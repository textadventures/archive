{
  "Topic": {
    "TopicId": "429",
    "ForumId": "3",
    "Title": "Why so many bad Quest games?",
    "LastUpdated": "2004-07-14T20:00:15+01:00",
    "ReplyCount": 27
  },
  "Posts": [
    {
      "PostId": "2836",
      "UserId": 0,
      "Username": "davidw",
      "UserAvatar": null,
      "UserGravatar": "5d9c9199ac213c3e7284cd76a2262c4a",
      "EditableText": "Seriously. I just downloaded the latest two \"games\" (it's almost insulting to proper games to call them that) on the Quest games page and two seconds after starting, I'm shuddering at how dire they are.\n\nWhy do people even bother uploading such trash? Surely not even the writers can like these games.",
      "EditableFormat": "bbcode",
      "HTML": "Seriously. I just downloaded the latest two \"games\" (it's almost insulting to proper games to call them that) on the Quest games page and two seconds after starting, I'm shuddering at how dire they are.<br/><br/>Why do people even bother uploading such trash? Surely not even the writers can like these games.",
      "PostDate": "2004-07-02T08:38:42+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2837",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "You should see the stuff that I reject!",
      "EditableFormat": "bbcode",
      "HTML": "You should see the stuff that I reject!",
      "PostDate": "2004-07-02T11:15:58+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2838",
      "UserId": 0,
      "Username": "davidw",
      "UserAvatar": null,
      "UserGravatar": "5d9c9199ac213c3e7284cd76a2262c4a",
      "EditableText": "You mean those are the ones that got through?  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: -->  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: -->  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: --> \n\nI don't think I'd survive an encounter with the rejected games.",
      "EditableFormat": "bbcode",
      "HTML": "You mean those are the ones that got through?  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: -->  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: -->  <!-- s:cry: --><img src=\"{SMILIES_PATH}/icon_cry.gif\" alt=\":cry:\" title=\"Crying or Very Sad\" /><!-- s:cry: --> <br/><br/>I don't think I'd survive an encounter with the rejected games.",
      "PostDate": "2004-07-02T12:36:03+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2842",
      "UserId": 0,
      "Username": "billchelonis",
      "UserAvatar": null,
      "UserGravatar": "c392dd292ff05b8f98616cbfecf7b77b",
      "EditableText": "I'm not sure what's the most popular adventure engine out there,  I'm guessing TADS but then again TADS (to my knowledge) does not have something like a GUI engine like the QDK. It's all text editor scripting. However there do seem to be more tads games than quest games, though tads probably also has been around longer. The other reason you might not see many quest games (on this site anyway) is some authors have not yet submitted them. I know of a few quest games floating around certain yahoo groups that are not on this site. Then again they are also not technically completed games either. \n\nThere is a dilemma in the TADS community where html TADS has not caught on yet or been updated to have all the commands of tads 3 (or something like that anyhow). So because of that (and some bugs I just don't like about tads) I've held off writing code in that and have been trying to write up something in quest. I'll eventually submit my game here, but it has a long way to go before I get all the kinks worked out in the code, and already the source code is over half a megabyte in size. \n\nI'm trying something like a recreation of the old Hewlett Packard mainframe game \"Mystery Mansion\" (from the mid '70's). It's going to take time to write up all those routines though (put rope over wall, open door, forward, backward, turn left, turn right, open drapes, turn on light, dig hole with shovel, question butler, use phone, etc.) Since no library exists with these types of commands already in place I have to write everything from scratch, and it's a bit time consuming. I'm sure other quest authors are encountering these same sorts of problems. If there was a big library available we could get these games out faster I think, but that will take time.",
      "EditableFormat": "bbcode",
      "HTML": "I'm not sure what's the most popular adventure engine out there,  I'm guessing TADS but then again TADS (to my knowledge) does not have something like a GUI engine like the QDK. It's all text editor scripting. However there do seem to be more tads games than quest games, though tads probably also has been around longer. The other reason you might not see many quest games (on this site anyway) is some authors have not yet submitted them. I know of a few quest games floating around certain yahoo groups that are not on this site. Then again they are also not technically completed games either. <br/><br/>There is a dilemma in the TADS community where html TADS has not caught on yet or been updated to have all the commands of tads 3 (or something like that anyhow). So because of that (and some bugs I just don't like about tads) I've held off writing code in that and have been trying to write up something in quest. I'll eventually submit my game here, but it has a long way to go before I get all the kinks worked out in the code, and already the source code is over half a megabyte in size. <br/><br/>I'm trying something like a recreation of the old Hewlett Packard mainframe game \"Mystery Mansion\" (from the mid '70's). It's going to take time to write up all those routines though (put rope over wall, open door, forward, backward, turn left, turn right, open drapes, turn on light, dig hole with shovel, question butler, use phone, etc.) Since no library exists with these types of commands already in place I have to write everything from scratch, and it's a bit time consuming. I'm sure other quest authors are encountering these same sorts of problems. If there was a big library available we could get these games out faster I think, but that will take time.",
      "PostDate": "2004-07-04T08:47:46+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2843",
      "UserId": 0,
      "Username": "007bond",
      "UserAvatar": null,
      "UserGravatar": "4c2673a2d8666a97b5c1082c5cf2e0e5",
      "EditableText": "I quite agree.  Without a big library especially devoted to these commands, we have to create them ourselves.  If someone like MaDbRiT could write another library devoted to commands like the ones stated in Billchelonis described, things would be a whole lot easier and I'm sure that a lot more Quest games would come out sooner.  What would be even easier is if Alex implemented some of these commands into Quest.\n\nI've also started using ADRIFT over the past few weeks and that has built in commands for standing, sitting and lying on objects, turning objects on and off, closing and opening objects, locking objects, using an object as a shield or weapon in a battle engine, as well as commands that exist in MaDbRiT's TypeLib, like reading an object and using an object as a container.  Plus it has a character implementation so that objects are separate from characters.\n\nIf Alex could implement some of these features in Quest, or MaDbRiT could write a library for some of these commands, I think a lot more Quest games will appear a lot sooner rather than later.",
      "EditableFormat": "bbcode",
      "HTML": "I quite agree.  Without a big library especially devoted to these commands, we have to create them ourselves.  If someone like MaDbRiT could write another library devoted to commands like the ones stated in Billchelonis described, things would be a whole lot easier and I'm sure that a lot more Quest games would come out sooner.  What would be even easier is if Alex implemented some of these commands into Quest.<br/><br/>I've also started using ADRIFT over the past few weeks and that has built in commands for standing, sitting and lying on objects, turning objects on and off, closing and opening objects, locking objects, using an object as a shield or weapon in a battle engine, as well as commands that exist in MaDbRiT's TypeLib, like reading an object and using an object as a container.  Plus it has a character implementation so that objects are separate from characters.<br/><br/>If Alex could implement some of these features in Quest, or MaDbRiT could write a library for some of these commands, I think a lot more Quest games will appear a lot sooner rather than later.",
      "PostDate": "2004-07-05T01:03:08+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2846",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "[quote:29lviuud]\nI've also started using ADRIFT over the past few weeks and that has built in commands for standing, sitting and lying on objects, turning objects on and off, closing and opening objects, locking objects, using an object as a shield or weapon in a battle engine, as well as commands that exist in MaDbRiT's TypeLib, like reading an object and using an object as a container. Plus it has a character implementation so that objects are separate from characters. \n[/quote:29lviuud]\n\nThe ADRIFT object set is I think modelled on, (maybe even uses) a TADS adventure 'library', which is why it has those TADS like features. Strangely enough objects and characters were discrete and different in QUEST too until reasonably recently (Q3? Alex can correct me if I'm wrong). Because you can now use types in Quest now it really doesn't matter anyway. I implement a character type 'TLT_Actor' in my old typelib.qlb and this is effectively the same as having the two still seperate.\n\n[quote:29lviuud]\nIf Alex could implement some of these features in Quest, or MaDbRiT could write a library for some of these commands, I think a lot more Quest games will appear a lot sooner rather than later.[/quote:29lviuud]\n\nI'd hope you were right on the last point - With the addition of the words 'good quality'.\n\nLibraries of re-usable code are actually quite tricky to do well. Not in the coding sense (although they can get hairy!) but from the point of view of making them both broad ranging enough to be flexible an useful in many cases, yet precise enough to require minimal work from the end user to implement and able to deal with lots of possible variations.  This is something of a balancing act to get right. \n\nI don't think putting more hard coded functionality into Quest is a good idea at all, it makes things much more difficult to override when you want non-standard behaviour.  As a matter of interest Mike Roberts (TADS author) has deliberately moved pretty much all of the hard coded interaction out of the TADS engine in TADS 3.0 and put it into a bigger, user customisable library.  This makes TADS 3.0 more flexible than any previous version - a 'Good Thing'.  If Mike Roberts and the assembled wisdom of all those TADS experts think that transferring interaction out of the engine and into a library is the way to go, I'd certainly give that weight of opinion the utmost respect. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) -->\n\nMy own 'Typelib 2' (which WILL get released eventually) does add a lot more commands to Quest, but basically most are aimed at making the 'TLT_Actor' appear more lifelike. Things like \"tell Fred to pick up the booby trap\", \"Ask Fred about the widget\", \"Fred, put on the diving suit\" are dealt with by having implemented a quite complex \"TLT_Topic\" type (something that can be asked/told about), extending the clothing types to work with NPC's and altering almost everything else in the library so that a player may instruct a NPC to do something he might otherwise do himself.  These make for very complicated 'types' as you might imagine.\n\nI am planning to add 'chair', 'bed' &amp; 'vehicle' types to Typelib (sometime) and therefore 'sit on / lie on / stand on / ride in/on commands to suit.  A 'battle engine' is an altogether different thing - I think that would best be done as an entirely separate library to be included only in games that feature combat, rather than as part of a general extension library such as 'Typelib 2'. \n\nWhat I've not done is implement very many easy to do types.  'TLT_Readable' is a good example of a type I *have* implemented which is (relatively speaking) pretty simple.  Typelib already provides an openable/closeable' type, I think it would be trivial to add 'locked/unlocked' to that type - but should I do that as part of the library or allow that to be left to the library's end user?\n\nIt might be advantageous add to the library a bunch of simple 'stub commands'.  By this I mean code up some minimal default responses to user input like 'eat the apple'.  Rather than go the whole hog and code an  edible type (which isn't actually very hard, but that's another story!) the command would simply test the object (apple in this case) to see if it has an 'eat' action. If the test fails the library would respond with a 'You/He/She can't eat things like that.' otherwise it would call the 'eat' action it found.  \n\nThis makes 'eat (whatever)' understood as a legal command, but doesn't provide any real functionality - which is why I call it a 'stub command'.\n\nObviously if the end user now adds an 'eat' action to the apple object, this would be run in response to 'eat apple'. Thus an action might be written to increase the players strength or kill him if it is poisoned, destroy the apple and so on.\n\nAdding lots of commands of this type would be very easy to do - but the result wouldn't be so easy to use - requiring the author to manually write actions (there would be no QDK interface for the stub command) rather than just tick boxes and provide messages the way a fully implemented 'edible type' allows.\n\nSo therein lies the library designer's quandry - does one add loads of these 'stub commands', or just keep the library for fully implemented types only?\n\nIt'll be interesting to canvas opinion / discuss this one further <!-- s;-) --><img src=\"{SMILIES_PATH}/icon_e_wink.gif\" alt=\";-)\" title=\"Wink\" /><!-- s;-) -->\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p><br/>I've also started using ADRIFT over the past few weeks and that has built in commands for standing, sitting and lying on objects, turning objects on and off, closing and opening objects, locking objects, using an object as a shield or weapon in a battle engine, as well as commands that exist in MaDbRiT's TypeLib, like reading an object and using an object as a container. Plus it has a character implementation so that objects are separate from characters. <br/></p></blockquote><br/><br/>The ADRIFT object set is I think modelled on, (maybe even uses) a TADS adventure 'library', which is why it has those TADS like features. Strangely enough objects and characters were discrete and different in QUEST too until reasonably recently (Q3? Alex can correct me if I'm wrong). Because you can now use types in Quest now it really doesn't matter anyway. I implement a character type 'TLT_Actor' in my old typelib.qlb and this is effectively the same as having the two still seperate.<br/><br/><blockquote><p><br/>If Alex could implement some of these features in Quest, or MaDbRiT could write a library for some of these commands, I think a lot more Quest games will appear a lot sooner rather than later.</p></blockquote><br/><br/>I'd hope you were right on the last point - With the addition of the words 'good quality'.<br/><br/>Libraries of re-usable code are actually quite tricky to do well. Not in the coding sense (although they can get hairy!) but from the point of view of making them both broad ranging enough to be flexible an useful in many cases, yet precise enough to require minimal work from the end user to implement and able to deal with lots of possible variations.  This is something of a balancing act to get right. <br/><br/>I don't think putting more hard coded functionality into Quest is a good idea at all, it makes things much more difficult to override when you want non-standard behaviour.  As a matter of interest Mike Roberts (TADS author) has deliberately moved pretty much all of the hard coded interaction out of the TADS engine in TADS 3.0 and put it into a bigger, user customisable library.  This makes TADS 3.0 more flexible than any previous version - a 'Good Thing'.  If Mike Roberts and the assembled wisdom of all those TADS experts think that transferring interaction out of the engine and into a library is the way to go, I'd certainly give that weight of opinion the utmost respect. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) --><br/><br/>My own 'Typelib 2' (which WILL get released eventually) does add a lot more commands to Quest, but basically most are aimed at making the 'TLT_Actor' appear more lifelike. Things like \"tell Fred to pick up the booby trap\", \"Ask Fred about the widget\", \"Fred, put on the diving suit\" are dealt with by having implemented a quite complex \"TLT_Topic\" type (something that can be asked/told about), extending the clothing types to work with NPC's and altering almost everything else in the library so that a player may instruct a NPC to do something he might otherwise do himself.  These make for very complicated 'types' as you might imagine.<br/><br/>I am planning to add 'chair', 'bed' &amp; 'vehicle' types to Typelib (sometime) and therefore 'sit on / lie on / stand on / ride in/on commands to suit.  A 'battle engine' is an altogether different thing - I think that would best be done as an entirely separate library to be included only in games that feature combat, rather than as part of a general extension library such as 'Typelib 2'. <br/><br/>What I've not done is implement very many easy to do types.  'TLT_Readable' is a good example of a type I *have* implemented which is (relatively speaking) pretty simple.  Typelib already provides an openable/closeable' type, I think it would be trivial to add 'locked/unlocked' to that type - but should I do that as part of the library or allow that to be left to the library's end user?<br/><br/>It might be advantageous add to the library a bunch of simple 'stub commands'.  By this I mean code up some minimal default responses to user input like 'eat the apple'.  Rather than go the whole hog and code an  edible type (which isn't actually very hard, but that's another story!) the command would simply test the object (apple in this case) to see if it has an 'eat' action. If the test fails the library would respond with a 'You/He/She can't eat things like that.' otherwise it would call the 'eat' action it found.  <br/><br/>This makes 'eat (whatever)' understood as a legal command, but doesn't provide any real functionality - which is why I call it a 'stub command'.<br/><br/>Obviously if the end user now adds an 'eat' action to the apple object, this would be run in response to 'eat apple'. Thus an action might be written to increase the players strength or kill him if it is poisoned, destroy the apple and so on.<br/><br/>Adding lots of commands of this type would be very easy to do - but the result wouldn't be so easy to use - requiring the author to manually write actions (there would be no QDK interface for the stub command) rather than just tick boxes and provide messages the way a fully implemented 'edible type' allows.<br/><br/>So therein lies the library designer's quandry - does one add loads of these 'stub commands', or just keep the library for fully implemented types only?<br/><br/>It'll be interesting to canvas opinion / discuss this one further <!-- s;-) --><img src=\"{SMILIES_PATH}/icon_e_wink.gif\" alt=\";-)\" title=\"Wink\" /><!-- s;-) --><br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-05T15:04:53+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2847",
      "UserId": 0,
      "Username": "davidw",
      "UserAvatar": null,
      "UserGravatar": "5d9c9199ac213c3e7284cd76a2262c4a",
      "EditableText": "I think one of the main failings with Quest right now is its, for want of a better word, fiddlyness. \n\nAdding custom commands is one of the things that every game needs because the commands that are covered are, frankly, not up to much. Yet rather than a simple one-click to add a custom command, I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and [i:choozyym]then[/i:choozyym] finally I can enter the command I want. Wouldn't it be easier to just have an icon in the main QDK interface that I could click on to add a command? It would certainly save time. The way things are now, adding custom commands is such a tedious and long drawn out process that most people don't seem to bother.\n\nIt's also very fiddly adding items and there seem to be one hell of a lot of unnecessary options here: prefix, suffix, detail, display type, not to mention the strange idea of lumping in characters and objects together. This way, every time I add a character to a game I have a make a point of making them \"not takeable\" or have it possible for the player to pick them up and carry them around as if they were normal objects. It might be a better idea to separate the two: have one area for objects and another for characters.\n\nI also think Quest needs to recognise a few more basic commands. When I wrote a game I was surprised to find the program didn't understand the \"wear\" command, one of the most commonly used commands in text adventures since the dawn of computers! I suppose I could create a custom one but, really, shouldn't Quest cover at least the basic commands and not leave the poor writer with the forbidding task of creating every command they're going to need in a game?\n\nThe way Quest is now, it has potential but its GUI isn't a patch on Adrift's and nor is it anywhere near as straightforward and easy to use. And if you're just going to hand code everything, it lacks the power of either Tads or Inform, which has pretty much left it behind in the text adventure market. Games might be getting written for it, but as they're all pretty much drivel that's no big deal.\n\n\nEDIT: another thing that really bugs me although no one else seems to have mentioned it so maybe it's just me. Too many pop up windows! Seriously, you edit a command and have to click your way through a dozen or more windows to get to the bit you want to change and then close down every one of the windows. Is there any need for so many windows? Why not just have one?",
      "EditableFormat": "bbcode",
      "HTML": "I think one of the main failings with Quest right now is its, for want of a better word, fiddlyness. <br/><br/>Adding custom commands is one of the things that every game needs because the commands that are covered are, frankly, not up to much. Yet rather than a simple one-click to add a custom command, I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and <span style=\"font-style:italic;\">then</span> finally I can enter the command I want. Wouldn't it be easier to just have an icon in the main QDK interface that I could click on to add a command? It would certainly save time. The way things are now, adding custom commands is such a tedious and long drawn out process that most people don't seem to bother.<br/><br/>It's also very fiddly adding items and there seem to be one hell of a lot of unnecessary options here: prefix, suffix, detail, display type, not to mention the strange idea of lumping in characters and objects together. This way, every time I add a character to a game I have a make a point of making them \"not takeable\" or have it possible for the player to pick them up and carry them around as if they were normal objects. It might be a better idea to separate the two: have one area for objects and another for characters.<br/><br/>I also think Quest needs to recognise a few more basic commands. When I wrote a game I was surprised to find the program didn't understand the \"wear\" command, one of the most commonly used commands in text adventures since the dawn of computers! I suppose I could create a custom one but, really, shouldn't Quest cover at least the basic commands and not leave the poor writer with the forbidding task of creating every command they're going to need in a game?<br/><br/>The way Quest is now, it has potential but its GUI isn't a patch on Adrift's and nor is it anywhere near as straightforward and easy to use. And if you're just going to hand code everything, it lacks the power of either Tads or Inform, which has pretty much left it behind in the text adventure market. Games might be getting written for it, but as they're all pretty much drivel that's no big deal.<br/><br/><br/>EDIT: another thing that really bugs me although no one else seems to have mentioned it so maybe it's just me. Too many pop up windows! Seriously, you edit a command and have to click your way through a dozen or more windows to get to the bit you want to change and then close down every one of the windows. Is there any need for so many windows? Why not just have one?",
      "PostDate": "2004-07-05T20:26:37+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2849",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "[quote:26bqyo2z]I think one of the main failings with Quest right now is its, for want of a better word, fiddlyness.\n[/quote:26bqyo2z]\n\nOoh, I [b:26bqyo2z]do[/b:26bqyo2z] like the word 'fiddlyness' (wish I had thought of it  <!-- s:D --><img src=\"{SMILIES_PATH}/icon_e_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D -->  ) and I do agree Q.D.K. does tend to appear to suffer that way, but it is hard to see how it could be improved without sacrificing control. \n\n[quote:26bqyo2z]\nAdding custom commands is one of the things that every game needs because the commands that are covered are, frankly, not up to much. Yet rather than a simple one-click to add a custom command, I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and then finally I can enter the command I want. Wouldn't it be easier to just have an icon in the main QDK interface that I could click on to add a command? It would certainly save time. The way things are now, adding custom commands is such a tedious and long drawn out process that most people don't seem to bother. \n[/quote:26bqyo2z]\n\nI agree the inbuilt command set is kind of minimal, but as I said in my previous post, I think that is a [b:26bqyo2z]Good Thing[/b:26bqyo2z]. TADS &amp; INFORM get their power from the add in libraries of commands &amp; objects which means we can change things when we want, hard coding too much restricts flexibility.  I must admit I agree that the custom commands are kind of 'buried' in the QDK interface a bit too deeply for my liking though.\n\n[quote:26bqyo2z]\nIt's also very fiddly adding items and there seem to be one hell of a lot of unnecessary options here: prefix, suffix, detail, display type, not to mention the strange idea of lumping in characters and objects together. This way, every time I add a character to a game I have a make a point of making them \"not takeable\" or have it possible for the player to pick them up and carry them around as if they were normal objects. It might be a better idea to separate the two: have one area for objects and another for characters. [/quote:26bqyo2z]\n\nUnnecessary? as they are [i:26bqyo2z]options[/i:26bqyo2z] surely you can safely ignore those you don't want - at least the options are there when and if you need them.  Of course that means they clutter up the interface when you don't want them, I'm not at all sure you can avoid that.  This is one of those 'judgement calls' weighing up more options offered (i.e. flexibility) against simpler appearance (less flexibility).  I don't find that characters being objects is a problem at all, but then I use my own TLT_Actor type derived from the base object which makes setting up a simple actor a tick one check box in QDK exercise.\n\n[quote:26bqyo2z]\nI also think Quest needs to recognise a few more basic commands. When I wrote a game I was surprised to find the program didn't understand the \"wear\" command, one of the most commonly used commands in text adventures since the dawn of computers! I suppose I could create a custom one but, really, shouldn't Quest cover at least the basic commands and not leave the poor writer with the forbidding task of creating every command they're going to need in a game? \n[/quote:26bqyo2z]\n\nExactly the point I was trying to 'get at' in my original posting in this thread.  Yes, I agree Quest needs to have more ready made commands like wear, read, open &amp; close available to the user 'by default'.  However, at the risk of repeating myself, I don't think they should be hard coded into the Quest engine. I subscribe to the idea that these would be better (i.e. more flexibly) provided by way of a library or libraries.  This is how TADS, HUGO, INFORM, ALAN etc do it - these are the 'big players' of IF and I think that is significant. \n\nThis is why I've tried since Q2.01 (and continue to try) to produce libraries to add commands for Quest - so far I'm ploughing a lone furrow on this one unfortunately.  I've tended to go for a very 'full' treatment of objects and related commands with lots of user 'tailorability' in my libraries, but maybe I should provide more commands/objects but keep them simpler?  Without a lot of feedback I'm tending to write them to suit my own purposes as much as anything.\n\n[quote:26bqyo2z]\nThe way Quest is now, it has potential but its GUI isn't a patch on Adrift's and nor is it anywhere near as straightforward and easy to use. And if you're just going to hand code everything, it lacks the power of either Tads or Inform, which has pretty much left it behind in the text adventure market. Games might be getting written for it, but as they're all pretty much drivel that's no big deal. \n[/quote:26bqyo2z]\n\nI don't actually agree with you regarding ADRIFT's GUI, I find it (and ADRIFT generally) curiously awkward and restrictive in use.  I'm not 'knocking' ADRIFT here, it's a fine system for sure, this is merely my personal preference.  Just as I prefer the feel of TADS to Inform because it 'makes more sense' to my mindset although I recognise both are excellent and (basically) pretty evenly matched.\n\nPower wise, I think Quest is pitched somewhere between Adrift &amp; Inform/TADS, that means it is pretty sure to be more 'difficult' than ADRIFT and less 'difficult' than TADS - 'you pays your money and takes your choice' as they say...\n\n[quote:26bqyo2z]\nEDIT: another thing that really bugs me although no one else seems to have mentioned it so maybe it's just me. Too many pop up windows! Seriously, you edit a command and have to click your way through a dozen or more windows to get to the bit you want to change and then close down every one of the windows. Is there any need for so many windows? Why not just have one?\n[/quote:26bqyo2z]\n\nWhile there are lots of levels of pop up windows in Q.D.K. generally, I'm not sure that this is avoidable. If Alex dramatically increased the content at each 'level' it would make things look even more cluttered than they already are and things might not be so logically grouped.  A designer with 60 related options to present to the end user has to pick a method somewhere between having 1 'window' with all 60 options on it or 60 'windows' with 1 each.  Most people would consider either extreme very poor interface design, but deciding the way to 'split up' the options and over how many windows is very much a question of taste.  \nPersonally I too would prefer rather fewer levels of windows than at present and would not find the inevitable increase in 'options per page' too distressing - but ask a dozen programmers to design an interface and you'll get 12 different ideas on what's best. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) -->\n\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>I think one of the main failings with Quest right now is its, for want of a better word, fiddlyness.<br/></p></blockquote><br/><br/>Ooh, I <span style=\"font-weight:bold;\">do</span> like the word 'fiddlyness' (wish I had thought of it  <!-- s:D --><img src=\"{SMILIES_PATH}/icon_e_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D -->  ) and I do agree Q.D.K. does tend to appear to suffer that way, but it is hard to see how it could be improved without sacrificing control. <br/><br/><blockquote><p><br/>Adding custom commands is one of the things that every game needs because the commands that are covered are, frankly, not up to much. Yet rather than a simple one-click to add a custom command, I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and then finally I can enter the command I want. Wouldn't it be easier to just have an icon in the main QDK interface that I could click on to add a command? It would certainly save time. The way things are now, adding custom commands is such a tedious and long drawn out process that most people don't seem to bother. <br/></p></blockquote><br/><br/>I agree the inbuilt command set is kind of minimal, but as I said in my previous post, I think that is a <span style=\"font-weight:bold;\">Good Thing</span>. TADS &amp; INFORM get their power from the add in libraries of commands &amp; objects which means we can change things when we want, hard coding too much restricts flexibility.  I must admit I agree that the custom commands are kind of 'buried' in the QDK interface a bit too deeply for my liking though.<br/><br/><blockquote><p><br/>It's also very fiddly adding items and there seem to be one hell of a lot of unnecessary options here: prefix, suffix, detail, display type, not to mention the strange idea of lumping in characters and objects together. This way, every time I add a character to a game I have a make a point of making them \"not takeable\" or have it possible for the player to pick them up and carry them around as if they were normal objects. It might be a better idea to separate the two: have one area for objects and another for characters. </p></blockquote><br/><br/>Unnecessary? as they are <span style=\"font-style:italic;\">options</span> surely you can safely ignore those you don't want - at least the options are there when and if you need them.  Of course that means they clutter up the interface when you don't want them, I'm not at all sure you can avoid that.  This is one of those 'judgement calls' weighing up more options offered (i.e. flexibility) against simpler appearance (less flexibility).  I don't find that characters being objects is a problem at all, but then I use my own TLT_Actor type derived from the base object which makes setting up a simple actor a tick one check box in QDK exercise.<br/><br/><blockquote><p><br/>I also think Quest needs to recognise a few more basic commands. When I wrote a game I was surprised to find the program didn't understand the \"wear\" command, one of the most commonly used commands in text adventures since the dawn of computers! I suppose I could create a custom one but, really, shouldn't Quest cover at least the basic commands and not leave the poor writer with the forbidding task of creating every command they're going to need in a game? <br/></p></blockquote><br/><br/>Exactly the point I was trying to 'get at' in my original posting in this thread.  Yes, I agree Quest needs to have more ready made commands like wear, read, open &amp; close available to the user 'by default'.  However, at the risk of repeating myself, I don't think they should be hard coded into the Quest engine. I subscribe to the idea that these would be better (i.e. more flexibly) provided by way of a library or libraries.  This is how TADS, HUGO, INFORM, ALAN etc do it - these are the 'big players' of IF and I think that is significant. <br/><br/>This is why I've tried since Q2.01 (and continue to try) to produce libraries to add commands for Quest - so far I'm ploughing a lone furrow on this one unfortunately.  I've tended to go for a very 'full' treatment of objects and related commands with lots of user 'tailorability' in my libraries, but maybe I should provide more commands/objects but keep them simpler?  Without a lot of feedback I'm tending to write them to suit my own purposes as much as anything.<br/><br/><blockquote><p><br/>The way Quest is now, it has potential but its GUI isn't a patch on Adrift's and nor is it anywhere near as straightforward and easy to use. And if you're just going to hand code everything, it lacks the power of either Tads or Inform, which has pretty much left it behind in the text adventure market. Games might be getting written for it, but as they're all pretty much drivel that's no big deal. <br/></p></blockquote><br/><br/>I don't actually agree with you regarding ADRIFT's GUI, I find it (and ADRIFT generally) curiously awkward and restrictive in use.  I'm not 'knocking' ADRIFT here, it's a fine system for sure, this is merely my personal preference.  Just as I prefer the feel of TADS to Inform because it 'makes more sense' to my mindset although I recognise both are excellent and (basically) pretty evenly matched.<br/><br/>Power wise, I think Quest is pitched somewhere between Adrift &amp; Inform/TADS, that means it is pretty sure to be more 'difficult' than ADRIFT and less 'difficult' than TADS - 'you pays your money and takes your choice' as they say...<br/><br/><blockquote><p><br/>EDIT: another thing that really bugs me although no one else seems to have mentioned it so maybe it's just me. Too many pop up windows! Seriously, you edit a command and have to click your way through a dozen or more windows to get to the bit you want to change and then close down every one of the windows. Is there any need for so many windows? Why not just have one?<br/></p></blockquote><br/><br/>While there are lots of levels of pop up windows in Q.D.K. generally, I'm not sure that this is avoidable. If Alex dramatically increased the content at each 'level' it would make things look even more cluttered than they already are and things might not be so logically grouped.  A designer with 60 related options to present to the end user has to pick a method somewhere between having 1 'window' with all 60 options on it or 60 'windows' with 1 each.  Most people would consider either extreme very poor interface design, but deciding the way to 'split up' the options and over how many windows is very much a question of taste.  <br/>Personally I too would prefer rather fewer levels of windows than at present and would not find the inevitable increase in 'options per page' too distressing - but ask a dozen programmers to design an interface and you'll get 12 different ideas on what's best. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) --><br/><br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-06T14:07:57+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2851",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Well, the cluttered pop-up window thingy I have to also agree on... Many times have I been through 10 or more conditional pop-ups and then other pop-ups for text etc...\n\nMaybe have one \"node\" window for the comands/conditional statements within a function/whatever, have the user select where he wants to insert the conditional/action and then have the pop-up come up... That way it'll only go about 3 pop-up pages deep... Instead of the millions before.\n\nI also think maybe an open-source library would be good... Where someone monitors a main file, then people write in with additions to the command set and additions to the coices of the command set too...\nEach command would be given a \"default\" setting, with the ability to over-ride this default by a simple override property in the object (ie, OR_#commandname# = 1) and additional settings with be given a \"type\" number... Much like functions...\n\nIe (and thisis using a pretty wild mixture of laguages here!):\nFunction \"Math\" (OR, ORW, TYPE, NUM1, NUM2)\nif OR = 1 then {\n    execute \"ORW\"   * Obviously you'd put in some code and standardise a way to pass custom commands here...\n} elseif TYPE = 1 then {\n    return \"NUM1 * NUM2\"\n} elseif TYPE = 2 then {\n    return \"NUM1 / NUM2\"\n}\netc...\n\nNow I know it's just a rough idea/outline... But I think if a change was wanted a vote could be held by the coders and so a majority vote would win. It would be backwards compatible if you added settings onto the end and maybe a version number at the beginning. There'd be one guy taking submissions and writing it up, producing one copy... I think that would be definately good for the coders - and also allw some of use advanced coders the freedom of not writing a WHOLE library, but instead contribute parts... Therefore not becoming a major project or eating our free time.",
      "EditableFormat": "bbcode",
      "HTML": "Well, the cluttered pop-up window thingy I have to also agree on... Many times have I been through 10 or more conditional pop-ups and then other pop-ups for text etc...<br/><br/>Maybe have one \"node\" window for the comands/conditional statements within a function/whatever, have the user select where he wants to insert the conditional/action and then have the pop-up come up... That way it'll only go about 3 pop-up pages deep... Instead of the millions before.<br/><br/>I also think maybe an open-source library would be good... Where someone monitors a main file, then people write in with additions to the command set and additions to the coices of the command set too...<br/>Each command would be given a \"default\" setting, with the ability to over-ride this default by a simple override property in the object (ie, OR_#commandname# = 1) and additional settings with be given a \"type\" number... Much like functions...<br/><br/>Ie (and thisis using a pretty wild mixture of laguages here!):<br/>Function \"Math\" (OR, ORW, TYPE, NUM1, NUM2)<br/>if OR = 1 then {<br/>    execute \"ORW\"   * Obviously you'd put in some code and standardise a way to pass custom commands here...<br/>} elseif TYPE = 1 then {<br/>    return \"NUM1 * NUM2\"<br/>} elseif TYPE = 2 then {<br/>    return \"NUM1 / NUM2\"<br/>}<br/>etc...<br/><br/>Now I know it's just a rough idea/outline... But I think if a change was wanted a vote could be held by the coders and so a majority vote would win. It would be backwards compatible if you added settings onto the end and maybe a version number at the beginning. There'd be one guy taking submissions and writing it up, producing one copy... I think that would be definately good for the coders - and also allw some of use advanced coders the freedom of not writing a WHOLE library, but instead contribute parts... Therefore not becoming a major project or eating our free time.",
      "PostDate": "2004-07-06T20:19:01+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2852",
      "UserId": 0,
      "Username": "billchelonis",
      "UserAvatar": null,
      "UserGravatar": "c392dd292ff05b8f98616cbfecf7b77b",
      "EditableText": "As an example of the kind of library I mean, take NWN (Neverwinter Nights) Content Expansion Pack (CEP). Though a 3D role playing game, NWN has some nice code examples in their CEP library. In fact, I basically lifted the code from there on how to handle door objects in Quest by using various properties tags on each \"side\" of the door. Not sure how much more of the CEP I can snag and copy for use in a text adventure though, but the CEP library is fairly impressive for something basically the users came together with and put together. \n\nSome links regarding the NWN CEP:\nLibrary standards:\n<!-- m --><a class=\"postlink\" href=\"http://nwvault.ign.com/dm/resources/CommunityExpansionPack.shtml\">http://nwvault.ign.com/dm/resources/Com ... Pack.shtml</a><!-- m -->\n\nCommunity Expansion Pack:\n<!-- m --><a class=\"postlink\" href=\"http://nwn.bioware.com/players/cep.html\">http://nwn.bioware.com/players/cep.html</a><!-- m -->\n<!-- m --><a class=\"postlink\" href=\"http://www.nwncep.com/\">http://www.nwncep.com/</a><!-- m -->\n\nI think they even went so far as to include an optional patcher program to check for CEP updates. That would be a good idea if we built a community quest library so that everyone was able to have the same working version of the library, and be sure to always include backwards compatability for any deprecated commands so loading the newer library doesn't mess up a game designed with an older version. \n\n- Bill",
      "EditableFormat": "bbcode",
      "HTML": "As an example of the kind of library I mean, take NWN (Neverwinter Nights) Content Expansion Pack (CEP). Though a 3D role playing game, NWN has some nice code examples in their CEP library. In fact, I basically lifted the code from there on how to handle door objects in Quest by using various properties tags on each \"side\" of the door. Not sure how much more of the CEP I can snag and copy for use in a text adventure though, but the CEP library is fairly impressive for something basically the users came together with and put together. <br/><br/>Some links regarding the NWN CEP:<br/>Library standards:<br/><!-- m --><a class=\"postlink\" href=\"http://nwvault.ign.com/dm/resources/CommunityExpansionPack.shtml\">http://nwvault.ign.com/dm/resources/Com ... Pack.shtml</a><!-- m --><br/><br/>Community Expansion Pack:<br/><!-- m --><a class=\"postlink\" href=\"http://nwn.bioware.com/players/cep.html\">http://nwn.bioware.com/players/cep.html</a><!-- m --><br/><!-- m --><a class=\"postlink\" href=\"http://www.nwncep.com/\">http://www.nwncep.com/</a><!-- m --><br/><br/>I think they even went so far as to include an optional patcher program to check for CEP updates. That would be a good idea if we built a community quest library so that everyone was able to have the same working version of the library, and be sure to always include backwards compatability for any deprecated commands so loading the newer library doesn't mess up a game designed with an older version. <br/><br/>- Bill",
      "PostDate": "2004-07-07T04:22:40+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2854",
      "UserId": 0,
      "Username": "Farvardin",
      "UserAvatar": null,
      "UserGravatar": "b6ea46e28b64e5f7c68f80468607f022",
      "EditableText": "[quote:afs8qlir]\n I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and then finally [/quote:afs8qlir]\n\nI think QDK is good for the skeleton of the game. If you want to properly add such new commands, then you should edit with an ascii editor. It's very quick to do so.\n\n[code:afs8qlir]\n\tcommand &lt;take all&gt; msg &lt;You can't take all&#46;&gt;\n\tcommand &lt;x self; look myself; x myself; examine myself; examine self&gt; msg &lt;You are yourself, it's already much, few people could claim the same&#46;&gt;\n\tcommand &lt;hints&gt; displaytext &lt;hints&gt;\n\tcommand &lt;walkthrough; solution&gt; displaytext &lt;walkthrough&gt;\n\n\tcommand &lt;dirs&gt; &#123;\n\t\tif not &#40; #quest&#46;doorways&#46;out# =  &#41; then msg &lt;You can go out to #quest&#46;doorways&#46;out#&#46;&gt;\n\t\tif not &#40; #quest&#46;doorways&#46;dirs# =  &#41; then msg &lt;You can go #quest&#46;doorways&#46;dirs#&#46;&gt;\n\t\tif not &#40; #quest&#46;doorways&#46;places# =  &#41; then msg &lt;You can go to #quest&#46;doorways&#46;places#&#46;&gt;\n\t&#125;\n\tcommand &lt;objects&gt; &#123;\n\t\tif not &#40; #quest&#46;objects# =  &#41; then msg &lt;You can see in your surroundings &#58;|n#quest&#46;formatobjects#&#46;|n&gt;\n\t&#125;\n\tcommand &lt;give #@thing# to #@destinataire#&gt; &#123;\n\t\tif &#40; #destinataire# = Livolas &#41; then &#123;\n\t\t\tmsg &lt;Livolas thanks you for the #@thing#&#46;&gt;\n\t\tlose &lt;#@thing#&gt;\n\t\thide &lt;#@thing#&gt; \n\t\t&#125; else &lt;This person doesn't want this item now&#46;&gt;\n\t&#125;\n\tcommand &lt;put #@thing# in #@container#&gt; &#123;\n\t\tif property &lt;#container#; container&gt; then msg &lt;You put #quest&#46;error&#46;gender# #thing# in #container#&gt; else msg &lt;You can't put #quest&#46;error&#46;gender# #thing# in this&#46;&gt;\n\n[/code:afs8qlir]\n\nBut otherwise I totally agree with you. \n\nI think the two main reasons why there are so many \"bad\" Quest games, are those :\n\n- Many good author don't want to bother using a tool such as QDK (even if it's a good tool). And they expect also many built-in commands for the most actions. For example they don't want to have to code themselves the default reply for \"wear\".\n\n- Most of the good authors (look at rec.arts.int-fiction) are using linux / unix without problem, and probably most of their time. So they can't use Quest easily, and it's probably not a problem for them to run a system (Tads, Inform) that is more difficult to code, but which has more library, and more \"mature\" for them\n\nIt's a pity, but it's such. I hope it will change in the future, and new authors will release good games on Quest. \n\nBut they will need to have some libraries for helping them, probably. I posted in the past about this issue. I don't consider myself as a good author, but I began to write a game with Inform. It's good, but sometimes tricky to use. I found more flexibilities and ease with Quest. I want to port my Quest game into french, and think when it will be finished it will be above several quest games in the archives. It won't be a revolution or a wonderfull games, but I want it to be pleasant to play (and maybe to find someone for correcting my english in the final release, but my aim is for the french \"market\"). I tried to include many additional commands, only not to disappoint the player who want to test some words. So I'm working on this kind of library : (the commands without 'msg' are the ones that need to be finished)\n\n\n\n[code:afs8qlir]\n\tcommand &lt;blow in #@objects#&gt; msg &lt;Blowing in this doesn't make any interesting sound&#46;&gt;\n\tcommand &lt;borrow #@objects# from #@actor#&gt; msg &lt;You can't achieve it this way&#46;&gt;\n\tcommand &lt;buy #@object#&gt; msg &lt;#quest&#46;error&#46;article# is not for sale&gt;\n\tcommand\t&lt;bring&gt;\n\tcommand\t&lt;cancel&gt;\n\tcommand\t&lt;cast&gt;\n\tcommand\t&lt;carve, dig, pick&gt;\n\tcommand\t&lt;change&gt;\n\tcommand\t&lt;clean&gt;\n\tcommand\t&lt;climb&gt;\n\tcommand\t&lt;close&gt;\n\tcommand\t&lt;comb&gt;\n\tcommand\t&lt;complain&gt; msg &lt;Don't complain all the time !&gt;\n\tcommand\t&lt;cook&gt; msg &lt;Maybe it's not time to cook now ?&gt;\n\tcommand\t&lt;cough&gt; msg &lt;Reuf, reuf&gt;\n\tcommand\t&lt;count&gt;\n\tcommand &lt;commit suicide&gt; playerlose\n\tcommand &lt;cry&gt; msg &lt;You don't need to do that now&#46; Crying can't be made on command&#46;&gt;\n\tcommand &lt;cut #@quest&#46;objects#&gt; &#123;\n\t\tif property &lt;#quest&#46;objects#; breakable&gt; then &#123;\n\t\tmsg &lt;You torn #quest&#46;error&#46;gender# #quest&#46;objects# to pieces, and nothing usefull remains&#46;&gt;\n\t\tconceal &lt;#quest&#46;objects#&gt;\n\t\t&#125;\n\t\t&#125;\n\tcommand &lt;change #@quest&#46;objects#&gt; msg &lt;Change what ?&gt;\n\tcommand\t&lt;crawl&gt;\n\tcommand\t&lt;dance&gt; msg &lt;You dance a bit for your own pleasure&gt;\n\tcommand\t&lt;desire&gt;\n\tcommand\t&lt;detach&gt;\n\tcommand\t&lt;dive&gt;\n\tcommand\t&lt;dig&gt;\n\tcommand\t&lt;draw&gt;\n\tcommand\t&lt;dream&gt;\n\tcommand\t&lt;drive&gt;\n\tcommand &lt;drink #@quest&#46;objects#&gt; &#123;\n\t\tif property &lt;#quest&#46;objects#; drinkable&gt; then &#123;\n\t\tmsg &lt;You drink #quest&#46;error&#46;gender# #quest&#46;objects#&gt;\n\t\tconceal &lt;#quest&#46;objects#&gt;\n\t\t&#125; \n\t\telse msg &lt;#quest&#46;error&#46;gender# #quest&#46;objects# doesn't seem good to drink, you should forget this&#46;&gt;\n\t\t&#125;\n\tcommand &lt;eat #@quest&#46;objects#&gt; &#123;\n\t\tif property &lt;#quest&#46;objects#; edible&gt; then &#123;\n\t\tmsg &lt;You eat #quest&#46;error&#46;gender# #quest&#46;objects#&gt;\n\t\tconceal &lt;#quest&#46;objects#&gt;\n\t\t&#125; \n\t\telse &#123; \n\t\t\tmsg &lt;#quest&#46;error&#46;gender# #quest&#46;objects# doesn't appear appetizing, you shouldn't do this&#46;&gt;\n\t\t\t&#125;\n\t\t&#125;\n[/code:afs8qlir]",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p><br/> I need to click on Game -&gt; Properties -&gt; Global Settings -&gt; Edit Custom Player Commands -&gt; Add and then finally </p></blockquote><br/><br/>I think QDK is good for the skeleton of the game. If you want to properly add such new commands, then you should edit with an ascii editor. It's very quick to do so.<br/><br/><pre><code><br/>\tcommand &lt;take all&gt; msg &lt;You can't take all&#46;&gt;<br/>\tcommand &lt;x self; look myself; x myself; examine myself; examine self&gt; msg &lt;You are yourself, it's already much, few people could claim the same&#46;&gt;<br/>\tcommand &lt;hints&gt; displaytext &lt;hints&gt;<br/>\tcommand &lt;walkthrough; solution&gt; displaytext &lt;walkthrough&gt;<br/><br/>\tcommand &lt;dirs&gt; &#123;<br/>\t\tif not &#40; #quest&#46;doorways&#46;out# =  &#41; then msg &lt;You can go out to #quest&#46;doorways&#46;out#&#46;&gt;<br/>\t\tif not &#40; #quest&#46;doorways&#46;dirs# =  &#41; then msg &lt;You can go #quest&#46;doorways&#46;dirs#&#46;&gt;<br/>\t\tif not &#40; #quest&#46;doorways&#46;places# =  &#41; then msg &lt;You can go to #quest&#46;doorways&#46;places#&#46;&gt;<br/>\t&#125;<br/>\tcommand &lt;objects&gt; &#123;<br/>\t\tif not &#40; #quest&#46;objects# =  &#41; then msg &lt;You can see in your surroundings &#58;|n#quest&#46;formatobjects#&#46;|n&gt;<br/>\t&#125;<br/>\tcommand &lt;give #@thing# to #@destinataire#&gt; &#123;<br/>\t\tif &#40; #destinataire# = Livolas &#41; then &#123;<br/>\t\t\tmsg &lt;Livolas thanks you for the #@thing#&#46;&gt;<br/>\t\tlose &lt;#@thing#&gt;<br/>\t\thide &lt;#@thing#&gt; <br/>\t\t&#125; else &lt;This person doesn't want this item now&#46;&gt;<br/>\t&#125;<br/>\tcommand &lt;put #@thing# in #@container#&gt; &#123;<br/>\t\tif property &lt;#container#; container&gt; then msg &lt;You put #quest&#46;error&#46;gender# #thing# in #container#&gt; else msg &lt;You can't put #quest&#46;error&#46;gender# #thing# in this&#46;&gt;<br/><br/></code></pre><br/><br/>But otherwise I totally agree with you. <br/><br/>I think the two main reasons why there are so many \"bad\" Quest games, are those :<br/><br/>- Many good author don't want to bother using a tool such as QDK (even if it's a good tool). And they expect also many built-in commands for the most actions. For example they don't want to have to code themselves the default reply for \"wear\".<br/><br/>- Most of the good authors (look at rec.arts.int-fiction) are using linux / unix without problem, and probably most of their time. So they can't use Quest easily, and it's probably not a problem for them to run a system (Tads, Inform) that is more difficult to code, but which has more library, and more \"mature\" for them<br/><br/>It's a pity, but it's such. I hope it will change in the future, and new authors will release good games on Quest. <br/><br/>But they will need to have some libraries for helping them, probably. I posted in the past about this issue. I don't consider myself as a good author, but I began to write a game with Inform. It's good, but sometimes tricky to use. I found more flexibilities and ease with Quest. I want to port my Quest game into french, and think when it will be finished it will be above several quest games in the archives. It won't be a revolution or a wonderfull games, but I want it to be pleasant to play (and maybe to find someone for correcting my english in the final release, but my aim is for the french \"market\"). I tried to include many additional commands, only not to disappoint the player who want to test some words. So I'm working on this kind of library : (the commands without 'msg' are the ones that need to be finished)<br/><br/><br/><br/><pre><code><br/>\tcommand &lt;blow in #@objects#&gt; msg &lt;Blowing in this doesn't make any interesting sound&#46;&gt;<br/>\tcommand &lt;borrow #@objects# from #@actor#&gt; msg &lt;You can't achieve it this way&#46;&gt;<br/>\tcommand &lt;buy #@object#&gt; msg &lt;#quest&#46;error&#46;article# is not for sale&gt;<br/>\tcommand\t&lt;bring&gt;<br/>\tcommand\t&lt;cancel&gt;<br/>\tcommand\t&lt;cast&gt;<br/>\tcommand\t&lt;carve, dig, pick&gt;<br/>\tcommand\t&lt;change&gt;<br/>\tcommand\t&lt;clean&gt;<br/>\tcommand\t&lt;climb&gt;<br/>\tcommand\t&lt;close&gt;<br/>\tcommand\t&lt;comb&gt;<br/>\tcommand\t&lt;complain&gt; msg &lt;Don't complain all the time !&gt;<br/>\tcommand\t&lt;cook&gt; msg &lt;Maybe it's not time to cook now ?&gt;<br/>\tcommand\t&lt;cough&gt; msg &lt;Reuf, reuf&gt;<br/>\tcommand\t&lt;count&gt;<br/>\tcommand &lt;commit suicide&gt; playerlose<br/>\tcommand &lt;cry&gt; msg &lt;You don't need to do that now&#46; Crying can't be made on command&#46;&gt;<br/>\tcommand &lt;cut #@quest&#46;objects#&gt; &#123;<br/>\t\tif property &lt;#quest&#46;objects#; breakable&gt; then &#123;<br/>\t\tmsg &lt;You torn #quest&#46;error&#46;gender# #quest&#46;objects# to pieces, and nothing usefull remains&#46;&gt;<br/>\t\tconceal &lt;#quest&#46;objects#&gt;<br/>\t\t&#125;<br/>\t\t&#125;<br/>\tcommand &lt;change #@quest&#46;objects#&gt; msg &lt;Change what ?&gt;<br/>\tcommand\t&lt;crawl&gt;<br/>\tcommand\t&lt;dance&gt; msg &lt;You dance a bit for your own pleasure&gt;<br/>\tcommand\t&lt;desire&gt;<br/>\tcommand\t&lt;detach&gt;<br/>\tcommand\t&lt;dive&gt;<br/>\tcommand\t&lt;dig&gt;<br/>\tcommand\t&lt;draw&gt;<br/>\tcommand\t&lt;dream&gt;<br/>\tcommand\t&lt;drive&gt;<br/>\tcommand &lt;drink #@quest&#46;objects#&gt; &#123;<br/>\t\tif property &lt;#quest&#46;objects#; drinkable&gt; then &#123;<br/>\t\tmsg &lt;You drink #quest&#46;error&#46;gender# #quest&#46;objects#&gt;<br/>\t\tconceal &lt;#quest&#46;objects#&gt;<br/>\t\t&#125; <br/>\t\telse msg &lt;#quest&#46;error&#46;gender# #quest&#46;objects# doesn't seem good to drink, you should forget this&#46;&gt;<br/>\t\t&#125;<br/>\tcommand &lt;eat #@quest&#46;objects#&gt; &#123;<br/>\t\tif property &lt;#quest&#46;objects#; edible&gt; then &#123;<br/>\t\tmsg &lt;You eat #quest&#46;error&#46;gender# #quest&#46;objects#&gt;<br/>\t\tconceal &lt;#quest&#46;objects#&gt;<br/>\t\t&#125; <br/>\t\telse &#123; <br/>\t\t\tmsg &lt;#quest&#46;error&#46;gender# #quest&#46;objects# doesn't appear appetizing, you shouldn't do this&#46;&gt;<br/>\t\t\t&#125;<br/>\t\t&#125;<br/></code></pre>",
      "PostDate": "2004-07-07T23:10:55+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2857",
      "UserId": 0,
      "Username": "007bond",
      "UserAvatar": null,
      "UserGravatar": "4c2673a2d8666a97b5c1082c5cf2e0e5",
      "EditableText": "Another big problem is the fact that a lot of people don't like to hand-code, because it's sort of like programming.  Meaning that most people DON'T find it easy to add new properties and commands in a text editor",
      "EditableFormat": "bbcode",
      "HTML": "Another big problem is the fact that a lot of people don't like to hand-code, because it's sort of like programming.  Meaning that most people DON'T find it easy to add new properties and commands in a text editor",
      "PostDate": "2004-07-08T04:59:26+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2858",
      "UserId": 0,
      "Username": "davidw",
      "UserAvatar": null,
      "UserGravatar": "5d9c9199ac213c3e7284cd76a2262c4a",
      "EditableText": "[quote=&quot;007bond&quot;:3ki3f4et]Another big problem is the fact that a lot of people don't like to hand-code, because it's sort of like programming.  Meaning that most people DON'T find it easy to add new properties and commands in a text editor[/quote:3ki3f4et]\n\nExactly.\n\nThe thing that initially attracted me to Quest was the fact that it has a GUI. I don't know how to code and I don't have any great desire to learn so coding a game is out of the question for me. However, if I [i:3ki3f4et]was[/i:3ki3f4et] going to code something I wouldn't use Quest. I'd use Tads or Inform because they have a far better reputation than Quest, a better interface [i:3ki3f4et]and[/i:3ki3f4et] a massive resource of libraries. Sure, I'd still have to code the game itself but a lot of the tedious work would already be taken care of.\n\nQuest's selling point is its GUI which at the moment needs a serious reworking in order to attract people.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>007bond wrote:</cite>Another big problem is the fact that a lot of people don't like to hand-code, because it's sort of like programming.  Meaning that most people DON'T find it easy to add new properties and commands in a text editor</blockquote><br/><br/>Exactly.<br/><br/>The thing that initially attracted me to Quest was the fact that it has a GUI. I don't know how to code and I don't have any great desire to learn so coding a game is out of the question for me. However, if I <span style=\"font-style:italic;\">was</span> going to code something I wouldn't use Quest. I'd use Tads or Inform because they have a far better reputation than Quest, a better interface <span style=\"font-style:italic;\">and</span> a massive resource of libraries. Sure, I'd still have to code the game itself but a lot of the tedious work would already be taken care of.<br/><br/>Quest's selling point is its GUI which at the moment needs a serious reworking in order to attract people.",
      "PostDate": "2004-07-08T08:44:04+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2859",
      "UserId": 0,
      "Username": "Farvardin",
      "UserAvatar": null,
      "UserGravatar": "b6ea46e28b64e5f7c68f80468607f022",
      "EditableText": "I can understand what you mean, but believe me : even when coding \"by hand\", Quest is more pleasant than Inform, and I find it more natural to use (ASL I mean). Also the ASL habiliy to be run as an interpreted language, without the need to compile it, is very cleaver. It seems it's the only IF system that allows this.\n\nI think the QDK is very good for begining a game, and also for setting the first functions, procedures, commands, flags and so on.\nI don't like writing code from scratch. I never did it, even with Inform. \nBut the QDK is perfect :\n- for showing how the code is written (then you only have to copy, paste and modify)\n- for cleaning the code\nI find it conveniant to use\n\nWithout QDK I wouldn't have started writing a game in Quest, but now the hand-coding is quicker to use. The game is big too (almost 100 ko) so it's better to use a text editor. And I sometime still use the QDK for having a general overview of the game, and for cleaning the code.",
      "EditableFormat": "bbcode",
      "HTML": "I can understand what you mean, but believe me : even when coding \"by hand\", Quest is more pleasant than Inform, and I find it more natural to use (ASL I mean). Also the ASL habiliy to be run as an interpreted language, without the need to compile it, is very cleaver. It seems it's the only IF system that allows this.<br/><br/>I think the QDK is very good for begining a game, and also for setting the first functions, procedures, commands, flags and so on.<br/>I don't like writing code from scratch. I never did it, even with Inform. <br/>But the QDK is perfect :<br/>- for showing how the code is written (then you only have to copy, paste and modify)<br/>- for cleaning the code<br/>I find it conveniant to use<br/><br/>Without QDK I wouldn't have started writing a game in Quest, but now the hand-coding is quicker to use. The game is big too (almost 100 ko) so it's better to use a text editor. And I sometime still use the QDK for having a general overview of the game, and for cleaning the code.",
      "PostDate": "2004-07-08T11:52:55+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2860",
      "UserId": 0,
      "Username": "Farvardin",
      "UserAvatar": null,
      "UserGravatar": "b6ea46e28b64e5f7c68f80468607f022",
      "EditableText": "Talking about bad and good games, I've just seen that with the new games you mention, there are also  \"War of Hyrule Castle\" and \"Kenny's Christmas Presents\" (I hadn't checked the new games for a while), they are worth looking. There are still lacking some commands, but they look enjoyable to play.\n\nAbout good author using Quest, I remember now \"Chuck\" was here some time ago, he released a good game made with Suds (<!-- m --><a class=\"postlink\" href=\"http://www.ksu.edu/wwparent/story/nature/index.htm\">http://www.ksu.edu/wwparent/story/nature/index.htm</a><!-- m -->). He planned to make a game with Quest, I hope he's still working on this .",
      "EditableFormat": "bbcode",
      "HTML": "Talking about bad and good games, I've just seen that with the new games you mention, there are also  \"War of Hyrule Castle\" and \"Kenny's Christmas Presents\" (I hadn't checked the new games for a while), they are worth looking. There are still lacking some commands, but they look enjoyable to play.<br/><br/>About good author using Quest, I remember now \"Chuck\" was here some time ago, he released a good game made with Suds (<!-- m --><a class=\"postlink\" href=\"http://www.ksu.edu/wwparent/story/nature/index.htm\">http://www.ksu.edu/wwparent/story/nature/index.htm</a><!-- m -->). He planned to make a game with Quest, I hope he's still working on this .",
      "PostDate": "2004-07-08T18:21:43+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2864",
      "UserId": 0,
      "Username": "snakecharmer",
      "UserAvatar": null,
      "UserGravatar": "dfe0b6ef03deb65a5c9ea5e91e0ecb42",
      "EditableText": "I think libraries of objects that can be used from QDK with a few clicks and filling in a few parameters are a wonderful idea, making things that would seriously challenge my ability to code for myself plug and play simple to implement.  \n\nExpert coders probably don't need libraries at all, so I think the priority with libraries should be that they be as easy to use from QDK as possible.\n\nRegarding backwards compatability of libraries, while it certainly matters a lot with add ons to an existing game (such as the online RPG mentioned above) and would be convenient for the coders in Quest, I really don't think it is all that important.  \n\nI say this because in distributing a Quest game, I would imagine most people would prefer to release a compiled CAS file.  This being the case, (as I understand it) whichever generation of the library one had used to develop a game would be 'crunched' into one file along with the ASL file that required it, the two becoming one entirely self contained whole.  That means that the presence of another version of the library on a player's computer wouldn't matter at all.  \n\nThis also means a game doesn't have to be packed with instructions like \"you must have version 22b of MaDbRiT's typelib.qlb or later to run this game\"\n\nI guess I'm trying to say that as I don't think the end player should need a coding library for a game to run on her/his PC, so coder's libraries can exist in many forms, even incompatible ones, without causing problems. \n\nAs I said above though, I do recognise that it would [i:2xp6iama]convenient[/i:2xp6iama] for these coder's libs to be backward compatible, but if breaking that rule allows a big improvement in what the library can do, I'd prefer the improvements.  <!-- s:D --><img src=\"{SMILIES_PATH}/icon_e_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D --> \n\nOne can always continue to use the old library anyway.\n\nAli G",
      "EditableFormat": "bbcode",
      "HTML": "I think libraries of objects that can be used from QDK with a few clicks and filling in a few parameters are a wonderful idea, making things that would seriously challenge my ability to code for myself plug and play simple to implement.  <br/><br/>Expert coders probably don't need libraries at all, so I think the priority with libraries should be that they be as easy to use from QDK as possible.<br/><br/>Regarding backwards compatability of libraries, while it certainly matters a lot with add ons to an existing game (such as the online RPG mentioned above) and would be convenient for the coders in Quest, I really don't think it is all that important.  <br/><br/>I say this because in distributing a Quest game, I would imagine most people would prefer to release a compiled CAS file.  This being the case, (as I understand it) whichever generation of the library one had used to develop a game would be 'crunched' into one file along with the ASL file that required it, the two becoming one entirely self contained whole.  That means that the presence of another version of the library on a player's computer wouldn't matter at all.  <br/><br/>This also means a game doesn't have to be packed with instructions like \"you must have version 22b of MaDbRiT's typelib.qlb or later to run this game\"<br/><br/>I guess I'm trying to say that as I don't think the end player should need a coding library for a game to run on her/his PC, so coder's libraries can exist in many forms, even incompatible ones, without causing problems. <br/><br/>As I said above though, I do recognise that it would <span style=\"font-style:italic;\">convenient</span> for these coder's libs to be backward compatible, but if breaking that rule allows a big improvement in what the library can do, I'd prefer the improvements.  <!-- s:D --><img src=\"{SMILIES_PATH}/icon_e_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D --> <br/><br/>One can always continue to use the old library anyway.<br/><br/>Ali G",
      "PostDate": "2004-07-09T07:53:53+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2865",
      "UserId": 0,
      "Username": "007bond",
      "UserAvatar": null,
      "UserGravatar": "4c2673a2d8666a97b5c1082c5cf2e0e5",
      "EditableText": "Farvardin is right, Quest is about the only IF Creator that lets you edit the code straight from a text editor.  Fortunately for Alex though people prefer the GUI and end up buying Quest Pro",
      "EditableFormat": "bbcode",
      "HTML": "Farvardin is right, Quest is about the only IF Creator that lets you edit the code straight from a text editor.  Fortunately for Alex though people prefer the GUI and end up buying Quest Pro",
      "PostDate": "2004-07-09T09:41:53+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2866",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "[quote:2usij28p]Expert coders probably don't need libraries at all, so I think the priority with libraries should be that they be as easy to use from QDK as possible. [/quote:2usij28p]\n\nI think they DO need libraries, because even if they are \"expert coders\", they probably don't want to spend their time coding basic things. The most popular IF systems have dozens of advanced libraries available.\n\nFor the rest, you're right, in a compiled game, old libraries won't interfere with the news.\n\n[quote:2usij28p]Quest is about the only IF Creator that lets you edit the code straight from a text editor[/quote:2usij28p]\n\nyes, binary code for IF is not good (cf SUDS, ADRIFT (I think) etc.)\nMost of the time I prefer to code by hand, but even now I load my game in QDK for arranging a few things (doors and such)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>Expert coders probably don't need libraries at all, so I think the priority with libraries should be that they be as easy to use from QDK as possible. </p></blockquote><br/><br/>I think they DO need libraries, because even if they are \"expert coders\", they probably don't want to spend their time coding basic things. The most popular IF systems have dozens of advanced libraries available.<br/><br/>For the rest, you're right, in a compiled game, old libraries won't interfere with the news.<br/><br/><blockquote><p>Quest is about the only IF Creator that lets you edit the code straight from a text editor</p></blockquote><br/><br/>yes, binary code for IF is not good (cf SUDS, ADRIFT (I think) etc.)<br/>Most of the time I prefer to code by hand, but even now I load my game in QDK for arranging a few things (doors and such)",
      "PostDate": "2004-07-09T11:16:48+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2870",
      "UserId": 0,
      "Username": "MaDbRiT",
      "UserAvatar": null,
      "UserGravatar": "c3dda772bea28be252abe6e4a646a54a",
      "EditableText": "[quote:1grc4z4d]I think they DO need libraries, because even if they are \"expert coders\", they probably don't want to spend their time coding basic things.[/quote:1grc4z4d]\n\nI suspect that Snakecharmer was thinking of the all-encompassing 'typelib.qlb/q3EXT.qlb' type of library that provides very detailed objects for easy QDK use.  I know she has mentioned to me that while these probably suit the non manual coding author perfectly, they might be too rigid (despite my best intentions to make them not so) for those who code manually.\n\nIn other words, QDK users &amp; manual coders may well have different ideas of what a library should do, the QDK user wanting to tailor from loads of ready made options, the manual coder just wanting the bare bones to flesh out to meet his or her requirements.\n\nA good example is eating and drinking.  I could (maybe should) add edible and drinkable types to typelib for the QDK user.  As anyone who can code manually will realise, it is actually pretty trivial to code 'eat' and 'drink' commands for any object that requires them so adding objects to typelib to enable them would be regarded as not required by this group.\n\nOn the other hand 'lock' and 'unlock' aren't so easy to do, they require 'key' objects, they impact on 'open' and 'close' commands, they can relate to containers and doors - it would therefore be useful to all if a 'lockable' and 'key' types were included in Typelib (or something similar.)\n\nI've been through the ALAN library, and of the functionality it provides, came up with the following list of things Quest currently doesn't handle (I'm assuming my typelib_2 is loaded to provide containers, actors, conversation objects, clothes etc) and marked the list either 'trivial' or ' library' - \n\nattack: shoot: hit [with] - needs a discrete \"combat library\"\nverbose/brief: - Library\neat: drink  - trivial\nhint: - a seperate 'hint library maybe?\njump on: jump - trivial\nkiss -trivial\nknock [on]    - trivial\nlisten [to] - trivial\nlock: unlock [with] - Library \npush: pull - trivial\nsmell:  - trivial\nthrow [at] - trivial (mostly!)\ntouch [with] - trivial\nturn on, switch on &amp; off - mostly trivial\nsit on: lie on: stand on - library\n\nI think some other stuff NOT in ALAN ought to be added - like -\n\nvehicles - library\ndoors (between locations)- library\n\nBe interesting to see how other people view this.  I am planning to add 'doors' (and locks etc) 'bed and chair' items (sit/lie/stand) to typelib_2.  I don't plan to add vehicles (do that seperately) and a combat lib DEFINITELY needs to be done as a stand alone.\n\nAl MaDbRiT",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>I think they DO need libraries, because even if they are \"expert coders\", they probably don't want to spend their time coding basic things.</p></blockquote><br/><br/>I suspect that Snakecharmer was thinking of the all-encompassing 'typelib.qlb/q3EXT.qlb' type of library that provides very detailed objects for easy QDK use.  I know she has mentioned to me that while these probably suit the non manual coding author perfectly, they might be too rigid (despite my best intentions to make them not so) for those who code manually.<br/><br/>In other words, QDK users &amp; manual coders may well have different ideas of what a library should do, the QDK user wanting to tailor from loads of ready made options, the manual coder just wanting the bare bones to flesh out to meet his or her requirements.<br/><br/>A good example is eating and drinking.  I could (maybe should) add edible and drinkable types to typelib for the QDK user.  As anyone who can code manually will realise, it is actually pretty trivial to code 'eat' and 'drink' commands for any object that requires them so adding objects to typelib to enable them would be regarded as not required by this group.<br/><br/>On the other hand 'lock' and 'unlock' aren't so easy to do, they require 'key' objects, they impact on 'open' and 'close' commands, they can relate to containers and doors - it would therefore be useful to all if a 'lockable' and 'key' types were included in Typelib (or something similar.)<br/><br/>I've been through the ALAN library, and of the functionality it provides, came up with the following list of things Quest currently doesn't handle (I'm assuming my typelib_2 is loaded to provide containers, actors, conversation objects, clothes etc) and marked the list either 'trivial' or ' library' - <br/><br/>attack: shoot: hit [with] - needs a discrete \"combat library\"<br/>verbose/brief: - Library<br/>eat: drink  - trivial<br/>hint: - a seperate 'hint library maybe?<br/>jump on: jump - trivial<br/>kiss -trivial<br/>knock [on]    - trivial<br/>listen [to] - trivial<br/>lock: unlock [with] - Library <br/>push: pull - trivial<br/>smell:  - trivial<br/>throw [at] - trivial (mostly!)<br/>touch [with] - trivial<br/>turn on, switch on &amp; off - mostly trivial<br/>sit on: lie on: stand on - library<br/><br/>I think some other stuff NOT in ALAN ought to be added - like -<br/><br/>vehicles - library<br/>doors (between locations)- library<br/><br/>Be interesting to see how other people view this.  I am planning to add 'doors' (and locks etc) 'bed and chair' items (sit/lie/stand) to typelib_2.  I don't plan to add vehicles (do that seperately) and a combat lib DEFINITELY needs to be done as a stand alone.<br/><br/>Al MaDbRiT",
      "PostDate": "2004-07-11T09:36:44+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2874",
      "UserId": 0,
      "Username": "Alf",
      "UserAvatar": null,
      "UserGravatar": "df6fcdbeed91f46db8f5428ad267174e",
      "EditableText": "Hi, Al.  I like your ideas about doors, etc.  Pretty much any scenario required some sort of passage from one location to another.  Doors, keys, locks, and all the variances of each are part of any scenario I've ever seen, and any I can think of.  I know you can script these, but object properties sure makes it much easier!\n\nHow about different libs for different object groups?  A lib for living/biologic objects would include coding for properties of living things (alive, hungry, sleepy, size, weight, other stuff).  A lib for scenery (trees, lakes, rivers) that are interacted with but you generally can't take them with you.  If I define an object now like a lake, it shows up in the list of objects.  I would rather have it there, but not have to take it to get a drink.  I must add that, given your current lib, you know a LOT more about lib contents than I do.  Too, I guess there are different opinions as to having one large lib or several smaller one.\n\nYour thoughts?\n\nAlf\n\nPS - After writing this and reviewing it, I realized that a lot of my ideas come from programming with objects.  I keep forgetting that IF scripting conveys the same ideas to the player.  Rather than deleting the message, I thought I'd post it anyway and get other opinions.",
      "EditableFormat": "bbcode",
      "HTML": "Hi, Al.  I like your ideas about doors, etc.  Pretty much any scenario required some sort of passage from one location to another.  Doors, keys, locks, and all the variances of each are part of any scenario I've ever seen, and any I can think of.  I know you can script these, but object properties sure makes it much easier!<br/><br/>How about different libs for different object groups?  A lib for living/biologic objects would include coding for properties of living things (alive, hungry, sleepy, size, weight, other stuff).  A lib for scenery (trees, lakes, rivers) that are interacted with but you generally can't take them with you.  If I define an object now like a lake, it shows up in the list of objects.  I would rather have it there, but not have to take it to get a drink.  I must add that, given your current lib, you know a LOT more about lib contents than I do.  Too, I guess there are different opinions as to having one large lib or several smaller one.<br/><br/>Your thoughts?<br/><br/>Alf<br/><br/>PS - After writing this and reviewing it, I realized that a lot of my ideas come from programming with objects.  I keep forgetting that IF scripting conveys the same ideas to the player.  Rather than deleting the message, I thought I'd post it anyway and get other opinions.",
      "PostDate": "2004-07-12T13:29:20+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2875",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Alf wrote\n[quote:2egr3689]How about different libs for different object groups? A lib for living/biologic objects would include coding for properties of living things (alive, hungry, sleepy, size, weight, other stuff). A lib for scenery (trees, lakes, rivers) that are interacted with but you generally can't take them with you. If I define an object now like a lake, it shows up in the list of objects. I would rather have it there, but not have to take it to get a drink.[/quote:2egr3689]\n\nBreaking a lib into component modules that deal with specific areas is a Good Idea, it it how ALAN works and makes altering individual 'areas' that much easier.  The fact that Quest is pretty object oriented itself these days means that the logical division is indeed into groups of related objects.  However when writing typelib I realised that some things really can't be 'modularised' very well because there is so much crossover with objects (or more accurately, common commands relating to them) that seem unrelated actually vitally affecting each other - this is why typelib has become something of a monolithic monster.  \n\nThis isn't a problem with ALAN, because basically all the player commands and syntaxes are defined in the library and it is therefore very easy to override and re-use them object by object exactly as required.  Quest however has a lot of the standard commands 'built in' which makes them easier to use as they are, but means that overriding them for a specific class of objects is a rather trickier exercise.  \n\nIt's still possible to do Quest Libraries in a modular way, just not entirely practical a lot of the time <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) -->  Discrete functionality like vehicles and combat which probably don't have any overlap with the object types added  by typelib could certainly be done as separate libs.\n\nTypelib does have a 'scenery' object in it by the way,  I use it for the Swimming Pool in the demo piece where it allows you to examine etc the Pool object though that isn't actually 'listed' in the room.\n\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "Alf wrote<br/><blockquote><p>How about different libs for different object groups? A lib for living/biologic objects would include coding for properties of living things (alive, hungry, sleepy, size, weight, other stuff). A lib for scenery (trees, lakes, rivers) that are interacted with but you generally can't take them with you. If I define an object now like a lake, it shows up in the list of objects. I would rather have it there, but not have to take it to get a drink.</p></blockquote><br/><br/>Breaking a lib into component modules that deal with specific areas is a Good Idea, it it how ALAN works and makes altering individual 'areas' that much easier.  The fact that Quest is pretty object oriented itself these days means that the logical division is indeed into groups of related objects.  However when writing typelib I realised that some things really can't be 'modularised' very well because there is so much crossover with objects (or more accurately, common commands relating to them) that seem unrelated actually vitally affecting each other - this is why typelib has become something of a monolithic monster.  <br/><br/>This isn't a problem with ALAN, because basically all the player commands and syntaxes are defined in the library and it is therefore very easy to override and re-use them object by object exactly as required.  Quest however has a lot of the standard commands 'built in' which makes them easier to use as they are, but means that overriding them for a specific class of objects is a rather trickier exercise.  <br/><br/>It's still possible to do Quest Libraries in a modular way, just not entirely practical a lot of the time <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) -->  Discrete functionality like vehicles and combat which probably don't have any overlap with the object types added  by typelib could certainly be done as separate libs.<br/><br/>Typelib does have a 'scenery' object in it by the way,  I use it for the Swimming Pool in the demo piece where it allows you to examine etc the Pool object though that isn't actually 'listed' in the room.<br/><br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-12T14:12:29+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2876",
      "UserId": 0,
      "Username": "Alf",
      "UserAvatar": null,
      "UserGravatar": "df6fcdbeed91f46db8f5428ad267174e",
      "EditableText": "That's a good point about overriding the built-in behavior.  I noticed that in the integration of your lib with the Quest environment there was considerable contention between the two.  \n\nWould it be worth asking Alex to consider offering an override feature to the built-ins that would allow them to be replaced?  Then, if the user has a lib that would handle his particular task in a more specific fashion, it would supercede the default behavior.  For example: The Quest system would work just fine with a space themed adventure.  But, suppose that the user had available a lib that contained objects that were specifically space-oriented.  It could supercede the built-in finctionality of the generic object.  That may be an oversimplification.  But, it might be just as simple as showing all the built-in objects in a list, and letting the user select the one(s) that his lib replaces.  The default would then 'disappear'.  \n\nOr, maybe in the user lib there could be a way to put a \"replaces commandABC\" or \"replaces objectABC\" to tell the system not to process the default object or command AT ALL.\n\nYour opinion?\n\nAlf",
      "EditableFormat": "bbcode",
      "HTML": "That's a good point about overriding the built-in behavior.  I noticed that in the integration of your lib with the Quest environment there was considerable contention between the two.  <br/><br/>Would it be worth asking Alex to consider offering an override feature to the built-ins that would allow them to be replaced?  Then, if the user has a lib that would handle his particular task in a more specific fashion, it would supercede the default behavior.  For example: The Quest system would work just fine with a space themed adventure.  But, suppose that the user had available a lib that contained objects that were specifically space-oriented.  It could supercede the built-in finctionality of the generic object.  That may be an oversimplification.  But, it might be just as simple as showing all the built-in objects in a list, and letting the user select the one(s) that his lib replaces.  The default would then 'disappear'.  <br/><br/>Or, maybe in the user lib there could be a way to put a \"replaces commandABC\" or \"replaces objectABC\" to tell the system not to process the default object or command AT ALL.<br/><br/>Your opinion?<br/><br/>Alf",
      "PostDate": "2004-07-12T19:17:03+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2877",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hi Alf\n\n[quote:17qh25gr]That's a good point about overriding the built-in behavior. I noticed that in the integration of your lib with the Quest environment there was considerable contention between the two. [/quote:17qh25gr]\n\n[quote:17qh25gr]\nWould it be worth asking Alex to consider offering an override feature to the built-ins that would allow them to be replaced?\n[/quote:17qh25gr]\n\nThe overrides do exist, what complicates things is how integrated everything is. By way of example take a containable object from my llibrary.\n\nIt needs the default take behaviour as built in to allow it to be taken when sitting in a room - but obviously a DIFFERENT behaviour whan it is sitting in a container which is in the room, where \"take\" really becomes \"take from\".  Of course because it isn't listed in the room (and we wouldn't want it to be) the standard take can't find the object...\n\n\"LOOK\" is the same, a standard look command is fine if the object's in the room, but will fail if it is in a container which is in the room. This also affects 'examine' in the same way. The various GIVE options also have to be replaced as do the DROP options, then you have to add the put in and take out possibilities.   USE is also affected in the same way.\n\nBasically, for many of the 'types' in typelib I pretty much have to provide custom versions for all the standard built in commands that combine standard behaviour and custom behaviour as required. Because I still need the built in commands to work exactly as before for other objects that are NOT typelib types or I'd break QDK, this means I sometimes have to look for ways to make things work that might not be the most elegant or straightforward, but which dovetail nicely into the Quest/QDK model - something over which I have no control.\n\nThis isn't actually an insurmountable problem, so far I've been able to find a way to make every kind of object I've ever needed in Quest, which says a lot for how flexible the system is.  What I've found is that I have to produce very detailed objects for QDK to be much use and that it's very hard to write these without a lot of crossover.  Take the Clothing type, it also needs to be a containable, it introduces yet another variation on 'take' and 'drop' in addition to those required for ordinary containables and ordinary objects, being clothing it has other requirements (wearing in layers etc) all of which impact on ability of the player to 'drop/take' it - and so on and so on...\n\nTo be fair, Typeplib isn't as QDK friendly as it could now be, pre dating as it does a lot of testable conditions that would allow far more elegant solutions to be coded in a re-write.  However, as I see it, the basic situation remains that because it is inherent in the way QDK/Quest work, the ideal of completely modular self contained object libraries of any consequence is likely to be very difficult to achieve.    \n\nWhile that makes things a bit more difficult for the library writer, it tends to make things a lot easier for the QDK user,  so perhaps that is a good trade off.\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "Hi Alf<br/><br/><blockquote><p>That's a good point about overriding the built-in behavior. I noticed that in the integration of your lib with the Quest environment there was considerable contention between the two. </p></blockquote><br/><br/><blockquote><p><br/>Would it be worth asking Alex to consider offering an override feature to the built-ins that would allow them to be replaced?<br/></p></blockquote><br/><br/>The overrides do exist, what complicates things is how integrated everything is. By way of example take a containable object from my llibrary.<br/><br/>It needs the default take behaviour as built in to allow it to be taken when sitting in a room - but obviously a DIFFERENT behaviour whan it is sitting in a container which is in the room, where \"take\" really becomes \"take from\".  Of course because it isn't listed in the room (and we wouldn't want it to be) the standard take can't find the object...<br/><br/>\"LOOK\" is the same, a standard look command is fine if the object's in the room, but will fail if it is in a container which is in the room. This also affects 'examine' in the same way. The various GIVE options also have to be replaced as do the DROP options, then you have to add the put in and take out possibilities.   USE is also affected in the same way.<br/><br/>Basically, for many of the 'types' in typelib I pretty much have to provide custom versions for all the standard built in commands that combine standard behaviour and custom behaviour as required. Because I still need the built in commands to work exactly as before for other objects that are NOT typelib types or I'd break QDK, this means I sometimes have to look for ways to make things work that might not be the most elegant or straightforward, but which dovetail nicely into the Quest/QDK model - something over which I have no control.<br/><br/>This isn't actually an insurmountable problem, so far I've been able to find a way to make every kind of object I've ever needed in Quest, which says a lot for how flexible the system is.  What I've found is that I have to produce very detailed objects for QDK to be much use and that it's very hard to write these without a lot of crossover.  Take the Clothing type, it also needs to be a containable, it introduces yet another variation on 'take' and 'drop' in addition to those required for ordinary containables and ordinary objects, being clothing it has other requirements (wearing in layers etc) all of which impact on ability of the player to 'drop/take' it - and so on and so on...<br/><br/>To be fair, Typeplib isn't as QDK friendly as it could now be, pre dating as it does a lot of testable conditions that would allow far more elegant solutions to be coded in a re-write.  However, as I see it, the basic situation remains that because it is inherent in the way QDK/Quest work, the ideal of completely modular self contained object libraries of any consequence is likely to be very difficult to achieve.    <br/><br/>While that makes things a bit more difficult for the library writer, it tends to make things a lot easier for the QDK user,  so perhaps that is a good trade off.<br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-12T21:31:56+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2879",
      "UserId": 0,
      "Username": "Alf",
      "UserAvatar": null,
      "UserGravatar": "df6fcdbeed91f46db8f5428ad267174e",
      "EditableText": "I see your point.  I'm still looking at things from a pure object environment, where each object 's properties - including location - can be determined programmatically.  (Hmm, maybe that's THE answer, making everything into objects with properties <!-- s:lol: --><img src=\"{SMILIES_PATH}/icon_lol.gif\" alt=\":lol:\" title=\"Laughing\" /><!-- s:lol: --> ).\n\nThanks for the chat.  Always very interesting!\n\nAlf",
      "EditableFormat": "bbcode",
      "HTML": "I see your point.  I'm still looking at things from a pure object environment, where each object 's properties - including location - can be determined programmatically.  (Hmm, maybe that's THE answer, making everything into objects with properties <!-- s:lol: --><img src=\"{SMILIES_PATH}/icon_lol.gif\" alt=\":lol:\" title=\"Laughing\" /><!-- s:lol: --> ).<br/><br/>Thanks for the chat.  Always very interesting!<br/><br/>Alf",
      "PostDate": "2004-07-13T20:32:42+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2880",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Alf wrote\n\n[quote:3atmaukd]Hmm, maybe that's THE answer, making everything into objects with properties [/quote:3atmaukd]\n\nBelieve it or not, this was exactly my intention when I first started 'typelib' - the idea was that the end user would ignore QDK's default object panes and program his/her whole game using objects based on my 'types' - which is of course another way of saying using just objects instantiated from my 'classes'. \n\n(Look at typelib_2 and you'll see it does exactly what you are suggesting, typelib's objects have properties and 'actions' (a.k.a. methods) that attempt to put all functionality into the object itself as much as possible.)\n\nHad I been able to achieve my intention, it would have avoided a lot of the problems which centre around making the mix of my types and Quest's default objects co-exist.\n\nUnfortunately I quickly found that you can't actually enforce the use of the types I added. Although I provide a regular (optionally takeable) object type as part of typelib, QDK will always let people define objects that are NOT derived from one of my types and so I'm obliged to cater for all the possibilities that opens up.  \n\nThis is exactly why having all the default objects &amp; related commands defined in a library rather than internal to Quest appeals to me -  under those circumstances I could simply replace the default structure entirely rather than have to work around it.\n\nWhatever, nothing is perfect and I still really like Quest and will continue to try to find ways of adding easy to use functionality with libraries of code.  These libs might not always be easy to [i:3atmaukd]write[/i:3atmaukd], but that's rather less important - the whole point is that the intended end (QDK) user need never know what sort of hideously inelegant bodge is going on under the hood to provide those nice easy to use objects. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) -->\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "Alf wrote<br/><br/><blockquote><p>Hmm, maybe that's THE answer, making everything into objects with properties </p></blockquote><br/><br/>Believe it or not, this was exactly my intention when I first started 'typelib' - the idea was that the end user would ignore QDK's default object panes and program his/her whole game using objects based on my 'types' - which is of course another way of saying using just objects instantiated from my 'classes'. <br/><br/>(Look at typelib_2 and you'll see it does exactly what you are suggesting, typelib's objects have properties and 'actions' (a.k.a. methods) that attempt to put all functionality into the object itself as much as possible.)<br/><br/>Had I been able to achieve my intention, it would have avoided a lot of the problems which centre around making the mix of my types and Quest's default objects co-exist.<br/><br/>Unfortunately I quickly found that you can't actually enforce the use of the types I added. Although I provide a regular (optionally takeable) object type as part of typelib, QDK will always let people define objects that are NOT derived from one of my types and so I'm obliged to cater for all the possibilities that opens up.  <br/><br/>This is exactly why having all the default objects &amp; related commands defined in a library rather than internal to Quest appeals to me -  under those circumstances I could simply replace the default structure entirely rather than have to work around it.<br/><br/>Whatever, nothing is perfect and I still really like Quest and will continue to try to find ways of adding easy to use functionality with libraries of code.  These libs might not always be easy to <span style=\"font-style:italic;\">write</span>, but that's rather less important - the whole point is that the intended end (QDK) user need never know what sort of hideously inelegant bodge is going on under the hood to provide those nice easy to use objects. <!-- s:-) --><img src=\"{SMILIES_PATH}/icon_e_smile.gif\" alt=\":-)\" title=\"Smile\" /><!-- s:-) --><br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-13T21:08:04+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2881",
      "UserId": 0,
      "Username": "Alf",
      "UserAvatar": null,
      "UserGravatar": "df6fcdbeed91f46db8f5428ad267174e",
      "EditableText": "typelib_2?  I don't think I've seen it, have I???",
      "EditableFormat": "bbcode",
      "HTML": "typelib_2?  I don't think I've seen it, have I???",
      "PostDate": "2004-07-13T21:42:30+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2882",
      "UserId": 0,
      "Username": "Anonymous",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "[quote:f6m8v545]typelib_2? I don't think I've seen it, have I???[/quote:f6m8v545]\n\nErr,  no you haven't.   <!-- s:oops: --><img src=\"{SMILIES_PATH}/icon_redface.gif\" alt=\":oops:\" title=\"Embarrassed\" /><!-- s:oops: --> \n\nit's the successor to typelib which seems to have 'stalled' in pre beta release form due to: \n\na: My being unable to 'feature freeze' it - I keep adding things which push the whole thing back to 'development version only' status.  Entirely my fault, I know I ought to leave stuff out until \"typelib 3\" and get this version de-bugged,  but I am by nature a perpetual code-tweaker.\n\nb: My knowing that, with recent improvements in testable properties and actions being added to Quest (thanks for listening Alex!) I could do a lot of the stable working stuff brought forward from the original typelib a lot more elegantly now.  I know I ought to do it, but every time I look at those 3000+ lines of code I just shudder at the thought of pulling it all apart and re-writing it when it already works...\n\nc: Real Life getting in the way of important stuff like playing with Quest  <!-- s:lol: --><img src=\"{SMILIES_PATH}/icon_lol.gif\" alt=\":lol:\" title=\"Laughing\" /><!-- s:lol: --> \n\nFor the record, main differences in typelib_2 compared to typelib are:\n\nFar better NPC interaction.  NPC''s can wear the layered clothing, be instructed to do things that the player might otherwise do himself (take, drop, examine etc can all be directed to NPC's now)\n\ne.g.  \n[code:f6m8v545]&quot;Fred, put the widget in the fridge&quot;\n&quot;Ask Fred to examine the suspect parcel&quot;\n&quot;Fred, take off the Tutu&quot;[/code:f6m8v545]\n\nAll work as you would hope.  as you can imagine theres a lot more 'stuff' required code wise to make this happen.\n\nOther 'big improvement' (at least in my opinion) is the provision of a 'topic' type that allows an object, player or room to become a topic of conversation - easiest way to demonstrate this is with pseudo game output,  using \"TLT_topic\" the following is possible without writing any new actions or conditional tests:\n\n[code:f6m8v545]&gt;Ask Fred about the car\n&quot;Sorry, I know nothing about that&quot;\n\n&gt;Ask Sue about the car\n&quot;It's mine, a Porsche 911 - it's nice isn't it&#46;&quot;\n\n&gt;Tell Fred about the car\nYou tell Fred all you know&#46;\n\n&gt;Ask Fred about the car\n&quot;It belongs to Sue, I'm told its a Porsche&quot;\n\n&gt;ask Fred about Sue\n&quot;She's a nice girl, bit of a speed freak I'm told&#46;&quot;\n\n&gt;ask Sue about herself\n&quot;I'm a librarian, but I do have a thing about sports cars&quot;&#46;[/code:f6m8v545]\na few well placed 'If-Thens' and this \"conversation\" can be expanded  to make for pretty good almost realistic effects.  The thing to note is that Fred apparently 'learns' by what you tell him - and Sue describes herself differently than Fred describes her -  this is all inherent in the topic type.\n\nAl (MaDbRiT)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>typelib_2? I don't think I've seen it, have I???</p></blockquote><br/><br/>Err,  no you haven't.   <!-- s:oops: --><img src=\"{SMILIES_PATH}/icon_redface.gif\" alt=\":oops:\" title=\"Embarrassed\" /><!-- s:oops: --> <br/><br/>it's the successor to typelib which seems to have 'stalled' in pre beta release form due to: <br/><br/>a: My being unable to 'feature freeze' it - I keep adding things which push the whole thing back to 'development version only' status.  Entirely my fault, I know I ought to leave stuff out until \"typelib 3\" and get this version de-bugged,  but I am by nature a perpetual code-tweaker.<br/><br/>b: My knowing that, with recent improvements in testable properties and actions being added to Quest (thanks for listening Alex!) I could do a lot of the stable working stuff brought forward from the original typelib a lot more elegantly now.  I know I ought to do it, but every time I look at those 3000+ lines of code I just shudder at the thought of pulling it all apart and re-writing it when it already works...<br/><br/>c: Real Life getting in the way of important stuff like playing with Quest  <!-- s:lol: --><img src=\"{SMILIES_PATH}/icon_lol.gif\" alt=\":lol:\" title=\"Laughing\" /><!-- s:lol: --> <br/><br/>For the record, main differences in typelib_2 compared to typelib are:<br/><br/>Far better NPC interaction.  NPC''s can wear the layered clothing, be instructed to do things that the player might otherwise do himself (take, drop, examine etc can all be directed to NPC's now)<br/><br/>e.g.  <br/><pre><code>&quot;Fred, put the widget in the fridge&quot;<br/>&quot;Ask Fred to examine the suspect parcel&quot;<br/>&quot;Fred, take off the Tutu&quot;</code></pre><br/><br/>All work as you would hope.  as you can imagine theres a lot more 'stuff' required code wise to make this happen.<br/><br/>Other 'big improvement' (at least in my opinion) is the provision of a 'topic' type that allows an object, player or room to become a topic of conversation - easiest way to demonstrate this is with pseudo game output,  using \"TLT_topic\" the following is possible without writing any new actions or conditional tests:<br/><br/><pre><code>&gt;Ask Fred about the car<br/>&quot;Sorry, I know nothing about that&quot;<br/><br/>&gt;Ask Sue about the car<br/>&quot;It's mine, a Porsche 911 - it's nice isn't it&#46;&quot;<br/><br/>&gt;Tell Fred about the car<br/>You tell Fred all you know&#46;<br/><br/>&gt;Ask Fred about the car<br/>&quot;It belongs to Sue, I'm told its a Porsche&quot;<br/><br/>&gt;ask Fred about Sue<br/>&quot;She's a nice girl, bit of a speed freak I'm told&#46;&quot;<br/><br/>&gt;ask Sue about herself<br/>&quot;I'm a librarian, but I do have a thing about sports cars&quot;&#46;</code></pre><br/>a few well placed 'If-Thens' and this \"conversation\" can be expanded  to make for pretty good almost realistic effects.  The thing to note is that Fred apparently 'learns' by what you tell him - and Sue describes herself differently than Fred describes her -  this is all inherent in the topic type.<br/><br/>Al (MaDbRiT)",
      "PostDate": "2004-07-14T11:06:30+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "2883",
      "UserId": 0,
      "Username": "Alf",
      "UserAvatar": null,
      "UserGravatar": "df6fcdbeed91f46db8f5428ad267174e",
      "EditableText": "Wow, talk about some nice features!\n\nThe character interactions (in my opinion) add depth to an otherwise OK adventure.  Also, the NPC options make for a more realistic play.  So much more than the early IF games which made you feel more like a programmer than an adventurer.\n\nAlready, I'm thinking about the possibilities.  Walk into a room, and one of the NPCs come up to you and offer you something (drink, advice, etc.).  You head off to another location, and find the same NPC beat you there because they knew the short cut.\n\nAs I've said before, the best IF games do not need graphics.  They allow the avdenturer to bury themselves in the game.  Now, all we need are good IF game writers...\n\nI still wish there was some way to totally override a default object or behavior.  That keeps the user in step with the world you're creating.\n\nThanks, Al.  Keep me posted on the new lib!\n\nAlf",
      "EditableFormat": "bbcode",
      "HTML": "Wow, talk about some nice features!<br/><br/>The character interactions (in my opinion) add depth to an otherwise OK adventure.  Also, the NPC options make for a more realistic play.  So much more than the early IF games which made you feel more like a programmer than an adventurer.<br/><br/>Already, I'm thinking about the possibilities.  Walk into a room, and one of the NPCs come up to you and offer you something (drink, advice, etc.).  You head off to another location, and find the same NPC beat you there because they knew the short cut.<br/><br/>As I've said before, the best IF games do not need graphics.  They allow the avdenturer to bury themselves in the game.  Now, all we need are good IF game writers...<br/><br/>I still wish there was some way to totally override a default object or behavior.  That keeps the user in step with the world you're creating.<br/><br/>Thanks, Al.  Keep me posted on the new lib!<br/><br/>Alf",
      "PostDate": "2004-07-14T20:00:15+01:00",
      "LastEditDate": null
    }
  ]
}
