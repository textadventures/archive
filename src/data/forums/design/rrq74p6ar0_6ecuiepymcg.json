{
  "Topic": {
    "TopicId": "rrq74p6ar0_6ecuiepymcg",
    "ForumId": "20",
    "Title": "Parser function",
    "LastUpdated": "2020-12-10T20:00:12.6688375Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "09b15ef9-ce57-4f3c-ab71-2b76205aee0c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "A recent topic in the QuestJS/QuestKit/Quest6 forum got me thinking about parser design; and how regular expressions aren't quite flexible enough for some of the things we might want of them. It's something I'd thought about before; but I came to the conclusion that the system I'd like to see would be way too tough to implement in Quest simply due to the awkward string-processing functions.\r\n\r\nNow I'm thinking about it again. And I don't think this is Quest-specific; I'm pretty much talking about an arbitrary text adventure here.\r\n\r\nHow do you go about handling parameters for a command that the player could enter? I've got a system in mind now, and thought I'd share it in case anyone else has feedback. Is there anything that you'd want to do that my concept doesn't allow?\r\n\r\nLet's start with a simple command:\r\n```\r\n// \"TAKE #object#\"\r\ntake.pattern = [[\r\n  [\"get\", \"take\", \"pick up\"],\r\n  {\r\n    argument: 'objects',\r\n    multiple: true,\r\n    scope: GetVisibleNotHeld\r\n  }\r\n]];\r\n```\r\nSo that's an array containing an array (I'll explain that later). The first element is an array containing \"get\", \"take\", and \"pick up\" - different ways the player could refer to the command. The second is a dictionary (or whatever your language calls it) representing the value we want to capture.\r\nThe fields in this dictionary could include:\r\n* `argument` - the name by which this argument will be passed to the command's script\r\n* `multiple` - false by default. If true, the argument will be returned as an array\r\n* `exclusive` - if more than one parameter has the same 'argument' field, only match one of them. Default: same value as 'multiple'. If not exclusive and not multiple, the one with the highest priority will be returned.\r\n* `scope` - by default, all visible objects. Either an array of possible values, a regex, or a function which returns an array or regex. In this case I've used the name of a Quest function as a placeholder, as it's pretty obvious how that would work.\r\n* `scopes` - backup scopes. By default this is the array [scope, visible_objects, all_objects] if the scope contains objects. It's an array of arrays\r\n* `optional` - if true, this argument is optional. Allowing too many optional or multiple parameters may make the parser really slow\r\n* `priority` - If multiple commands match what the player typed, the one with the highest priority goes first. By default, the priority value is higher if the argument matches an object in its primary scope (so you can have commands with the same name but different scopes, and one will be chosen based on the objects entered). This can be a function, whose parameter is the matched object(s)\r\n* `disambiguate` - a function which can be called to choose between multiple matching objects. Its arguments will be a player-entered string, and a dictionary mapping aliases onto objects. This function can modify the dictionary.\r\n* `min`/`max` - minimum and maximum number of objects for a multiple parameter\r\n* `preposition` - This parameter may be preceded by a preposition. This can be a string, array, or dictionary (exactly as if it were another parameter). If the preposition doesn't have its optional field explicitly specified, it will be the inverse of the parent parameter's optional (this makes sense; trust me)\r\n* `reorder` - If true, allow this parameter to be moved later in the order if necessary to create a match. If the value is the name of another parameter, this one can't be moved past it. If this field is the same as the preposition, allow reordering only if the preposition is present.\r\n* `everything` - If the player enters \"all\" or \"everything\" for a multiple parameter, what should be taken? Default will be all objects in scope which have not been entered for another parameter (so \"put all in bag\" won't try to put the bag in itself). Setting this to false will make \"put all in bag\" include the bag as part of all. Setting it as a function will use that function instead of scope.\r\n* `pronoun` - will this parameter be remembered so the player can refer to it as \"he\", \"it\", etc in future commands?\r\n* `return` - value to be returned for this argument; if `undefined`, don't return anything. Default: the object matched\r\n\r\nSome of these may seem a bit weird. So here's some more examples:\r\n```\r\n// \"GIVE #objects# TO #npc#\"\r\n// \"GIVE TO #npc# #objects#\"\r\n// \"GIVE #npc# #objects#\"\r\ngiveto.pattern = [[\r\n  [\"give\", \"offer\"],\r\n  {\r\n    argument: 'npc',\r\n    scope: GetVisibleNPCs,\r\n    preposition: \"to\",\r\n    reorder: \"to\"\r\n  },\r\n  {\r\n    argument: 'objects',\r\n    scope: GetReachableInventory,\r\n    multiple: true\r\n  }\r\n]];\r\n\r\n// \"DROP #object#\"\r\n// \"DROP #object# IN #container#\"\r\n// \"PUT #object# IN #container#\"\r\n// \"PUT DOWN #object#\"\r\n// \"PUT #object# DOWN\"\r\n// \"TOSS AWAY #object#\"\r\n// \"TOSS #object# AWAY\"\r\ndrop.pattern = [[\r\n  {\r\n    argument: 'verb',\r\n    scope: [\"drop\", \"discard\", \"put\", \"throw\"]\r\n  },\r\n  {\r\n    scope: (matched) => ({put: ['down'], throw: ['away']}[matched['verb']] || /^(?!.*?)/),\r\n    reorder: true,\r\n    optional: true\r\n  },\r\n  {\r\n    argument: 'objects',\r\n    multiple: true,\r\n    scope: GetReachableInventory\r\n  },\r\n  {\r\n    argument: 'destination',\r\n    scope: GetReachableContainers,\r\n    preposition: /^(in|on)(to| to|)$/,\r\n    optional: true\r\n  }\r\n]];\r\n```\r\n\r\nYeah, I put too much thought into this. I think it's pretty basic, easy to understand the easy stuff. Then lets you add the weirder options if you need them.\r\n\r\nOh, the nested arrays.\r\n\r\nOK. What a pattern matches depends on its type:\r\n* A string: that exact string (case insensitive)\r\n* A regex: something that matches the regex\r\n* A plain object: As described above\r\n* A function: pass a string to the function; it returns a dictionary. If it has elements, it's a match\r\n* An array: Any one of the items in the array (each of which is a pattern like this)\r\n\r\nObviously, an array matching \"any of these items\", it would be meaningless to have another array inside it meaning the same thing.\r\nAn array within an array matches all of the items in the array, in order. (like the words in a longer command)\r\nAnd an array inside an array inside an array matches any one of its items again (like the `[\"get\", \"take\", \"pick up\"]` example)",
      "EditableFormat": "markdown",
      "HTML": "<p>A recent topic in the QuestJS/QuestKit/Quest6 forum got me thinking about parser design; and how regular expressions aren't quite flexible enough for some of the things we might want of them. It's something I'd thought about before; but I came to the conclusion that the system I'd like to see would be way too tough to implement in Quest simply due to the awkward string-processing functions.</p>\n<p>Now I'm thinking about it again. And I don't think this is Quest-specific; I'm pretty much talking about an arbitrary text adventure here.</p>\n<p>How do you go about handling parameters for a command that the player could enter? I've got a system in mind now, and thought I'd share it in case anyone else has feedback. Is there anything that you'd want to do that my concept doesn't allow?</p>\n<p>Let's start with a simple command:</p>\n<pre><code>// \"TAKE #object#\"\ntake.pattern = [[\n  [\"get\", \"take\", \"pick up\"],\n  {\n    argument: 'objects',\n    multiple: true,\n    scope: GetVisibleNotHeld\n  }\n]];\n</code></pre>\n<p>So that's an array containing an array (I'll explain that later). The first element is an array containing \"get\", \"take\", and \"pick up\" - different ways the player could refer to the command. The second is a dictionary (or whatever your language calls it) representing the value we want to capture.<br>\nThe fields in this dictionary could include:</p>\n<ul>\n<li><code>argument</code> - the name by which this argument will be passed to the command's script</li>\n<li><code>multiple</code> - false by default. If true, the argument will be returned as an array</li>\n<li><code>exclusive</code> - if more than one parameter has the same 'argument' field, only match one of them. Default: same value as 'multiple'. If not exclusive and not multiple, the one with the highest priority will be returned.</li>\n<li><code>scope</code> - by default, all visible objects. Either an array of possible values, a regex, or a function which returns an array or regex. In this case I've used the name of a Quest function as a placeholder, as it's pretty obvious how that would work.</li>\n<li><code>scopes</code> - backup scopes. By default this is the array [scope, visible_objects, all_objects] if the scope contains objects. It's an array of arrays</li>\n<li><code>optional</code> - if true, this argument is optional. Allowing too many optional or multiple parameters may make the parser really slow</li>\n<li><code>priority</code> - If multiple commands match what the player typed, the one with the highest priority goes first. By default, the priority value is higher if the argument matches an object in its primary scope (so you can have commands with the same name but different scopes, and one will be chosen based on the objects entered). This can be a function, whose parameter is the matched object(s)</li>\n<li><code>disambiguate</code> - a function which can be called to choose between multiple matching objects. Its arguments will be a player-entered string, and a dictionary mapping aliases onto objects. This function can modify the dictionary.</li>\n<li><code>min</code>/<code>max</code> - minimum and maximum number of objects for a multiple parameter</li>\n<li><code>preposition</code> - This parameter may be preceded by a preposition. This can be a string, array, or dictionary (exactly as if it were another parameter). If the preposition doesn't have its optional field explicitly specified, it will be the inverse of the parent parameter's optional (this makes sense; trust me)</li>\n<li><code>reorder</code> - If true, allow this parameter to be moved later in the order if necessary to create a match. If the value is the name of another parameter, this one can't be moved past it. If this field is the same as the preposition, allow reordering only if the preposition is present.</li>\n<li><code>everything</code> - If the player enters \"all\" or \"everything\" for a multiple parameter, what should be taken? Default will be all objects in scope which have not been entered for another parameter (so \"put all in bag\" won't try to put the bag in itself). Setting this to false will make \"put all in bag\" include the bag as part of all. Setting it as a function will use that function instead of scope.</li>\n<li><code>pronoun</code> - will this parameter be remembered so the player can refer to it as \"he\", \"it\", etc in future commands?</li>\n<li><code>return</code> - value to be returned for this argument; if <code>undefined</code>, don't return anything. Default: the object matched</li>\n</ul>\n<p>Some of these may seem a bit weird. So here's some more examples:</p>\n<pre><code>// \"GIVE #objects# TO #npc#\"\n// \"GIVE TO #npc# #objects#\"\n// \"GIVE #npc# #objects#\"\ngiveto.pattern = [[\n  [\"give\", \"offer\"],\n  {\n    argument: 'npc',\n    scope: GetVisibleNPCs,\n    preposition: \"to\",\n    reorder: \"to\"\n  },\n  {\n    argument: 'objects',\n    scope: GetReachableInventory,\n    multiple: true\n  }\n]];\n\n// \"DROP #object#\"\n// \"DROP #object# IN #container#\"\n// \"PUT #object# IN #container#\"\n// \"PUT DOWN #object#\"\n// \"PUT #object# DOWN\"\n// \"TOSS AWAY #object#\"\n// \"TOSS #object# AWAY\"\ndrop.pattern = [[\n  {\n    argument: 'verb',\n    scope: [\"drop\", \"discard\", \"put\", \"throw\"]\n  },\n  {\n    scope: (matched) =&gt; ({put: ['down'], throw: ['away']}[matched['verb']] || /^(?!.*?)/),\n    reorder: true,\n    optional: true\n  },\n  {\n    argument: 'objects',\n    multiple: true,\n    scope: GetReachableInventory\n  },\n  {\n    argument: 'destination',\n    scope: GetReachableContainers,\n    preposition: /^(in|on)(to| to|)$/,\n    optional: true\n  }\n]];\n</code></pre>\n<p>Yeah, I put too much thought into this. I think it's pretty basic, easy to understand the easy stuff. Then lets you add the weirder options if you need them.</p>\n<p>Oh, the nested arrays.</p>\n<p>OK. What a pattern matches depends on its type:</p>\n<ul>\n<li>A string: that exact string (case insensitive)</li>\n<li>A regex: something that matches the regex</li>\n<li>A plain object: As described above</li>\n<li>A function: pass a string to the function; it returns a dictionary. If it has elements, it's a match</li>\n<li>An array: Any one of the items in the array (each of which is a pattern like this)</li>\n</ul>\n<p>Obviously, an array matching \"any of these items\", it would be meaningless to have another array inside it meaning the same thing.<br>\nAn array within an array matches all of the items in the array, in order. (like the words in a longer command)<br>\nAnd an array inside an array inside an array matches any one of its items again (like the <code>[\"get\", \"take\", \"pick up\"]</code> example)</p>\n\n",
      "PostDate": "2020-12-10T20:00:12.6688375Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "375ee32d-cfb7-4b43-94ac-d3c0a02e7535",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Got to admit, Quest 6 parser is pretty much a development of the Quest 5 parser, and I have since become away there are other ways to do it.\r\n\r\nWith regards to the fields, reorder makes a lot of sense; might also be useful for translating to other languages with different word order. Not so sure about min/max, preposition or disambiguate....\r\n\r\nWhen you say:\r\n\r\n> OK. What a pattern matches depends on its type:\r\n\r\nAre you matching the specific object or the whole command? I assume the former? But then how do you match to a plain object, other than by string or regex?\r\n\r\nCan you give an example of when a function might be used? I appreciate this is the ultimate in flexible, but I am not seeing when it would actually be used.",
      "EditableFormat": "markdown",
      "HTML": "<p>Got to admit, Quest 6 parser is pretty much a development of the Quest 5 parser, and I have since become away there are other ways to do it.</p>\n<p>With regards to the fields, reorder makes a lot of sense; might also be useful for translating to other languages with different word order. Not so sure about min/max, preposition or disambiguate....</p>\n<p>When you say:</p>\n<blockquote>\n<p>OK. What a pattern matches depends on its type:</p>\n</blockquote>\n<p>Are you matching the specific object or the whole command? I assume the former? But then how do you match to a plain object, other than by string or regex?</p>\n<p>Can you give an example of when a function might be used? I appreciate this is the ultimate in flexible, but I am not seeing when it would actually be used.</p>\n\n",
      "PostDate": "2020-12-11T14:38:15.030877Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "a7669401-d9ac-4c70-bb5b-ba7b5dea8f69",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Not so sure about min/max, preposition or disambiguate....\r\n\r\nNot sure about min/max; but experience on the forum suggests that someone is going to ask for them.\r\n\r\n`preposition` I added because it seems the easiest way to do some commands; notably the \"give to\" example. The preposition \"to\" indicates which object you're trying to give things to if it isn't the first. (Theoretically, `reorder` could try every possible guess until the scope matches, which would probably work. But allowing words like \"to\", \"with\", \"for\" to be used as hints to the parser for which object goes into which argument gives quite a lot of flexibility.\r\n\r\n`disambiguate`  I wouldn't have thought of, but it's basically an easy hook. There have been quite a few posts on the Quest forum about how to change the behaviour of disambiguation responses. Including \"if objects A and B both match what the player typed, assume they mean A\", or \"prefer whole words\" or \"prefer no unmatched words\"\r\n\r\nOne example I can think of might be directions. If a command expects the user to enter a compass direction, typing \"sout\" almost certainly means \"south\", not \"southwest\", even if both are options.\r\n\r\n> Are you matching the specific object or the whole command?\r\n\r\nA pattern matches a whole string. So simple patterns like `\"wait\"` or `/^i(nv(entory)?)?$/` match the command.\r\n\r\nIf there's an array at the outer level, an array will try to match each of its members against the whole command. Such as `[\"rest\", \"sleep\"]`.\r\n\r\nIf there's an array inside an odd number of nested arrays, it will attempt to match its first member against the beginning of the command, and its remaining members successively against what remains of the string.\r\nI can't find an easy way to describe this, but it should look pretty intuitive if you look at the examples.\r\n\r\n> But then how do you match to a plain object, other than by string or regex?\r\n\r\nDon't think I understand the question. A plain object in the JS sense? A plain object in the pattern can match a string, a regex, an object from a list, or whatever else is in it's `scope` field. It just lets you specify other options like assigning the result to a named variable or similar.\r\n\r\n(I should have said 'dictionary' rather than 'plain object' because I was trying to describe the structure in a language-agnostic way, and JS terminology 'object' could be confused with an in-game object, but I hope you know what I meant)\r\n\r\n> Can you give an example of when a function might be used?\r\n\r\nI can't think of one. That's basically an option for people who want to rewrite part of the parser to work in a different way without completely starting over. If it's implemented in JS or Perl (or most modern languages with flexible types), this will be trivial to implement, and basically allows the user to do \"anything the developer didn't think of\".\r\n\r\nI was already thinking that most of the fields could have a function reference, so the  user's code can dynamically change the pattern at runtime.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Not so sure about min/max, preposition or disambiguate....</p>\n</blockquote>\n<p>Not sure about min/max; but experience on the forum suggests that someone is going to ask for them.</p>\n<p><code>preposition</code> I added because it seems the easiest way to do some commands; notably the \"give to\" example. The preposition \"to\" indicates which object you're trying to give things to if it isn't the first. (Theoretically, <code>reorder</code> could try every possible guess until the scope matches, which would probably work. But allowing words like \"to\", \"with\", \"for\" to be used as hints to the parser for which object goes into which argument gives quite a lot of flexibility.</p>\n<p><code>disambiguate</code>  I wouldn't have thought of, but it's basically an easy hook. There have been quite a few posts on the Quest forum about how to change the behaviour of disambiguation responses. Including \"if objects A and B both match what the player typed, assume they mean A\", or \"prefer whole words\" or \"prefer no unmatched words\"</p>\n<p>One example I can think of might be directions. If a command expects the user to enter a compass direction, typing \"sout\" almost certainly means \"south\", not \"southwest\", even if both are options.</p>\n<blockquote>\n<p>Are you matching the specific object or the whole command?</p>\n</blockquote>\n<p>A pattern matches a whole string. So simple patterns like <code>\"wait\"</code> or <code>/^i(nv(entory)?)?$/</code> match the command.</p>\n<p>If there's an array at the outer level, an array will try to match each of its members against the whole command. Such as <code>[\"rest\", \"sleep\"]</code>.</p>\n<p>If there's an array inside an odd number of nested arrays, it will attempt to match its first member against the beginning of the command, and its remaining members successively against what remains of the string.<br>\nI can't find an easy way to describe this, but it should look pretty intuitive if you look at the examples.</p>\n<blockquote>\n<p>But then how do you match to a plain object, other than by string or regex?</p>\n</blockquote>\n<p>Don't think I understand the question. A plain object in the JS sense? A plain object in the pattern can match a string, a regex, an object from a list, or whatever else is in it's <code>scope</code> field. It just lets you specify other options like assigning the result to a named variable or similar.</p>\n<p>(I should have said 'dictionary' rather than 'plain object' because I was trying to describe the structure in a language-agnostic way, and JS terminology 'object' could be confused with an in-game object, but I hope you know what I meant)</p>\n<blockquote>\n<p>Can you give an example of when a function might be used?</p>\n</blockquote>\n<p>I can't think of one. That's basically an option for people who want to rewrite part of the parser to work in a different way without completely starting over. If it's implemented in JS or Perl (or most modern languages with flexible types), this will be trivial to implement, and basically allows the user to do \"anything the developer didn't think of\".</p>\n<p>I was already thinking that most of the fields could have a function reference, so the  user's code can dynamically change the pattern at runtime.</p>\n\n",
      "PostDate": "2020-12-11T15:27:23.5503642Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
