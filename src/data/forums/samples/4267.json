{
  "Topic": {
    "TopicId": "4267",
    "ForumId": "18",
    "Title": "Unit Test Library",
    "LastUpdated": "2014-04-07T20:07:49+01:00",
    "ReplyCount": 2
  },
  "Posts": [
    {
      "PostId": "28363",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I have worked for a new company for a few months now, and I've been indoctrinated into &quot;Test Driven Development&quot; and the use of test frameworks to unit test code, to make sure it doesn't rot or develop inexplicable bugs. In my Quest work, I began to crave something similar - so I wrote one. It's not very full-featured (only three types of assertions at the moment), but it does provide a general framework you can hang tests off of. Even if you don't practice TDD, you might to be able to write automated tests for your code.\n\nThe attached zip has the simple TestLib.aslx file. There is a also a sample app included, which is from some code I've been working on. I was too lazy to try to strip it out or come up with a simpler version, so there's a bit of stuff in there (don't be scared!). But at least you can see and run some real-world tests. The main file to load is TestLib_Sample.aslx. The rest are libraries.\n\nThe idea behind this is to write automated unit tests - tests that exercise various aspects of the code. It's probably more useful when making libraries or utility functions, but I think it's also applicable to more game-wide testing - though I haven't gotten there myself yet.\n\nTo begin, you create a test suite. This is a Quest object that will contain the individual tests. Usually a test suite will test one aspect of the system (e.g. a single library, function or other area of functionality). The tests within a suite are typically related.\n\nExample:\n\n[code:148cqbb9]&lt;object name=&quot;Some_Tests&quot;&gt;\n\t&lt;setup type=&quot;script&quot;&gt;\n\t\t// Put code here to be run before each test&#46;\n\t&lt;/setup&gt;\n\t&lt;teardown type=&quot;script&quot;&gt;\n\t\t// Put code here to be run after each test&#46;\n\t&lt;/teardown&gt;\n\t&lt;object name=&quot;Test that something is true&quot;&gt;\n\t\t&lt;test type=&quot;script&quot;&gt;\n\t\t// Test code goes here\n\t\t&lt;/test&gt; \n\t&lt;/object&gt;\n\t&lt;object name=&quot;Test that something else is true&quot;&gt;\n\t\t&lt;test type=&quot;script&quot;&gt;\n\t\t// Test code goes here\n\t\t&lt;/test&gt; \n\t&lt;/object&gt;\n&lt;/object&gt;[/code:148cqbb9]\nThe overall object &quot;Some Tests&quot; defines the set of tests (or the &quot;test suite&quot;). You can optionally have &quot;setup&quot; and &quot;teardown&quot; scripts which are, respectively, run before and after each test. This is meant to hold code common to all tests.\n\nThe child objects are the tests themselves. Each has a &quot;test&quot; script which is run. To run the tests, execute:\n\n[code:148cqbb9]TestLib_RunTests(Some_Tests)[/code:148cqbb9]\nThere is also a command included in the library which allows you to type:\n\n[code:148cqbb9]runtests Some_Tests[/code:148cqbb9]\nat the Quest command prompt to run the tests. Note that, due to how Quest handles output, you will not see any output until the tests have finished running!\n\nWhat does a test look like? The usual approach to a test is to set up some conditions and then assert that some other conditions hold or don't hold. For example, here is a test from ResponseLib_Tests:\n\n[code:148cqbb9]&lt;object name=&quot;GetContextResponses returns an empty list when there are no responders with responses&quot;&gt;\n  &lt;test type=&quot;script&quot;&gt;\n    this&#46;list = ResponseLib_GetContextResponses(&quot;some topics&quot;)\n    TestAssertEq(this, &quot;ListCount(this&#46;list)&quot;, 0)\n  &lt;/test&gt;\n&lt;/object&gt;[/code:148cqbb9]\nThe setup for the test is to call GetContextResponders. Then the test asserts a condition, in this case that ListCount(this.list) = 0.\n\nTest output will look something like this:\n[quote:148cqbb9]&gt; runtests ResponseLib_Tests\nRunning tests for ResponseLib_Tests...\nYou are in an EmptyRoom.\nGetContextResponses returns an empty list when there are no responders with responses: success\nGetContextResponders returns the player: success\nGetContextResponders returns the player room: success\nGetContextResponders returns a responder in the player room: success\nGetContextResponses returns a response with no topic for any topic: success\nGetContextResponses returns all responses matching a specified topic: success\nGetContextResponses filters responses based on the group required topics: success\nGetContextResponses does notfilter responses based on the group non required topics: success\n===========================================\nTests run: 8\nPassed: 8\nFailed: 0[/quote:148cqbb9]\n\nWhen tests fail, they will tell you why - that's the reason the expressions are passed as strings. Passing tests are in green and failing tests are in red. At the bottom of each test suite run is the overall statistics - run, passed, and failed.\n\nThere are three current assertions you can use in tests:\n\n- [b:148cqbb9]TestAssert(context, expression)[/b:148cqbb9]: The expectation in this case is that the expression is true. It takes two parameters: the test (or test context) and the condition expression to test. A condition is passed as a string, which the test library then &quot;eval&quot;s. Any local variables in the test script are not accessible. So to make them visible, a context object of some kind is passed in, which becomes &quot;this&quot; when the condition is evaluated. I typically use the current test being run for the context since it's handy, but you can use what you like.\n\n- [b:148cqbb9]TestAssertEq(context, expression, value)[/b:148cqbb9]: The expectation is that the expression, when evaluated, equals the value passed. The expression is a string, and the value is some actual value to compare the result of the expression to. The context is handled as described for TestAssert.\n\n- [b:148cqbb9]TestAssertNotEq(context, expression, value)[/b:148cqbb9]: The expectation is that the expression, when evaluated, does not equal the value passed. The expression is a string, and the value is some actual value to compare the result of the expression to. The context is handled as described for TestAssert.\n\nThe sample code provides some comprehensive examples of the test library being used. There are two test suites provided, a partial one for the response library (not finished) and one for a &quot;response&quot; which allows one NPC to lead the PC or another NPC to a target room. The latter test suite shows some experimentation I was doing with Quest's ability to use full, spaced names to enhance the readability of the tests. For example, one test looks like this:\n\n[code:148cqbb9]    &lt;object name=&quot;LeadCharacterResponse keeps leader quiet while leading&quot;&gt;\n      &lt;test type=&quot;script&quot;&gt;\n        Move follower to leader\n        Leader acts\n        Clear Dialogue\n        Move follower to leader\n        Leader acts\n        Assert nobody spoke\n      &lt;/test&gt;\n    &lt;/object&gt;[/code:148cqbb9]\nwhere things like &quot;Move follower to leader&quot; and &quot;Leader acts&quot; are actual function names that hide the messy details.\n\nIf you decide to try this out, please let me know how it goes, especially if you would like to use it for something that doesn't seem to quite work. I think this could be expanded to where you could automate your entire game (seems doable in theory), but that would require having the test lib not use msg directly and then provide a hook whereby msg output could be captured and asserted against.",
      "EditableFormat": "bbcode",
      "HTML": "I have worked for a new company for a few months now, and I've been indoctrinated into &quot;Test Driven Development&quot; and the use of test frameworks to unit test code, to make sure it doesn't rot or develop inexplicable bugs. In my Quest work, I began to crave something similar - so I wrote one. It's not very full-featured (only three types of assertions at the moment), but it does provide a general framework you can hang tests off of. Even if you don't practice TDD, you might to be able to write automated tests for your code.<br/><br/>The attached zip has the simple TestLib.aslx file. There is a also a sample app included, which is from some code I've been working on. I was too lazy to try to strip it out or come up with a simpler version, so there's a bit of stuff in there (don't be scared!). But at least you can see and run some real-world tests. The main file to load is TestLib_Sample.aslx. The rest are libraries.<br/><br/>The idea behind this is to write automated unit tests - tests that exercise various aspects of the code. It's probably more useful when making libraries or utility functions, but I think it's also applicable to more game-wide testing - though I haven't gotten there myself yet.<br/><br/>To begin, you create a test suite. This is a Quest object that will contain the individual tests. Usually a test suite will test one aspect of the system (e.g. a single library, function or other area of functionality). The tests within a suite are typically related.<br/><br/>Example:<br/><br/><pre><code>&lt;object name=&quot;Some_Tests&quot;&gt;<br/>\t&lt;setup type=&quot;script&quot;&gt;<br/>\t\t// Put code here to be run before each test&#46;<br/>\t&lt;/setup&gt;<br/>\t&lt;teardown type=&quot;script&quot;&gt;<br/>\t\t// Put code here to be run after each test&#46;<br/>\t&lt;/teardown&gt;<br/>\t&lt;object name=&quot;Test that something is true&quot;&gt;<br/>\t\t&lt;test type=&quot;script&quot;&gt;<br/>\t\t// Test code goes here<br/>\t\t&lt;/test&gt; <br/>\t&lt;/object&gt;<br/>\t&lt;object name=&quot;Test that something else is true&quot;&gt;<br/>\t\t&lt;test type=&quot;script&quot;&gt;<br/>\t\t// Test code goes here<br/>\t\t&lt;/test&gt; <br/>\t&lt;/object&gt;<br/>&lt;/object&gt;</code></pre><br/>The overall object &quot;Some Tests&quot; defines the set of tests (or the &quot;test suite&quot;). You can optionally have &quot;setup&quot; and &quot;teardown&quot; scripts which are, respectively, run before and after each test. This is meant to hold code common to all tests.<br/><br/>The child objects are the tests themselves. Each has a &quot;test&quot; script which is run. To run the tests, execute:<br/><br/><pre><code>TestLib_RunTests(Some_Tests)</code></pre><br/>There is also a command included in the library which allows you to type:<br/><br/><pre><code>runtests Some_Tests</code></pre><br/>at the Quest command prompt to run the tests. Note that, due to how Quest handles output, you will not see any output until the tests have finished running!<br/><br/>What does a test look like? The usual approach to a test is to set up some conditions and then assert that some other conditions hold or don't hold. For example, here is a test from ResponseLib_Tests:<br/><br/><pre><code>&lt;object name=&quot;GetContextResponses returns an empty list when there are no responders with responses&quot;&gt;<br/>  &lt;test type=&quot;script&quot;&gt;<br/>    this&#46;list = ResponseLib_GetContextResponses(&quot;some topics&quot;)<br/>    TestAssertEq(this, &quot;ListCount(this&#46;list)&quot;, 0)<br/>  &lt;/test&gt;<br/>&lt;/object&gt;</code></pre><br/>The setup for the test is to call GetContextResponders. Then the test asserts a condition, in this case that ListCount(this.list) = 0.<br/><br/>Test output will look something like this:<br/><blockquote><p>&gt; runtests ResponseLib_Tests<br/>Running tests for ResponseLib_Tests...<br/>You are in an EmptyRoom.<br/>GetContextResponses returns an empty list when there are no responders with responses: success<br/>GetContextResponders returns the player: success<br/>GetContextResponders returns the player room: success<br/>GetContextResponders returns a responder in the player room: success<br/>GetContextResponses returns a response with no topic for any topic: success<br/>GetContextResponses returns all responses matching a specified topic: success<br/>GetContextResponses filters responses based on the group required topics: success<br/>GetContextResponses does notfilter responses based on the group non required topics: success<br/>===========================================<br/>Tests run: 8<br/>Passed: 8<br/>Failed: 0</p></blockquote><br/><br/>When tests fail, they will tell you why - that's the reason the expressions are passed as strings. Passing tests are in green and failing tests are in red. At the bottom of each test suite run is the overall statistics - run, passed, and failed.<br/><br/>There are three current assertions you can use in tests:<br/><br/>- <span style=\"font-weight:bold;\">TestAssert(context, expression)</span>: The expectation in this case is that the expression is true. It takes two parameters: the test (or test context) and the condition expression to test. A condition is passed as a string, which the test library then &quot;eval&quot;s. Any local variables in the test script are not accessible. So to make them visible, a context object of some kind is passed in, which becomes &quot;this&quot; when the condition is evaluated. I typically use the current test being run for the context since it's handy, but you can use what you like.<br/><br/>- <span style=\"font-weight:bold;\">TestAssertEq(context, expression, value)</span>: The expectation is that the expression, when evaluated, equals the value passed. The expression is a string, and the value is some actual value to compare the result of the expression to. The context is handled as described for TestAssert.<br/><br/>- <span style=\"font-weight:bold;\">TestAssertNotEq(context, expression, value)</span>: The expectation is that the expression, when evaluated, does not equal the value passed. The expression is a string, and the value is some actual value to compare the result of the expression to. The context is handled as described for TestAssert.<br/><br/>The sample code provides some comprehensive examples of the test library being used. There are two test suites provided, a partial one for the response library (not finished) and one for a &quot;response&quot; which allows one NPC to lead the PC or another NPC to a target room. The latter test suite shows some experimentation I was doing with Quest's ability to use full, spaced names to enhance the readability of the tests. For example, one test looks like this:<br/><br/><pre><code>    &lt;object name=&quot;LeadCharacterResponse keeps leader quiet while leading&quot;&gt;<br/>      &lt;test type=&quot;script&quot;&gt;<br/>        Move follower to leader<br/>        Leader acts<br/>        Clear Dialogue<br/>        Move follower to leader<br/>        Leader acts<br/>        Assert nobody spoke<br/>      &lt;/test&gt;<br/>    &lt;/object&gt;</code></pre><br/>where things like &quot;Move follower to leader&quot; and &quot;Leader acts&quot; are actual function names that hide the messy details.<br/><br/>If you decide to try this out, please let me know how it goes, especially if you would like to use it for something that doesn't seem to quite work. I think this could be expanded to where you could automate your entire game (seems doable in theory), but that would require having the test lib not use msg directly and then provide a hook whereby msg output could be captured and asserted against.<div><a href=\"/attachment/876\">TestLib.zip</a></div>",
      "PostDate": "2014-04-05T13:34:14+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "28365",
      "UserId": 0,
      "Username": "george",
      "UserAvatar": null,
      "UserGravatar": "dc6fe8e6172303d85249a13c9a49c1ff",
      "EditableText": "Really cool Jay, I'll definitely check this out. Have you ever looked at the skein in the inform 7 IDE? I wonder if an (improved) version could work with Quest.",
      "EditableFormat": "bbcode",
      "HTML": "Really cool Jay, I'll definitely check this out. Have you ever looked at the skein in the inform 7 IDE? I wonder if an (improved) version could work with Quest.",
      "PostDate": "2014-04-07T06:09:34+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "28367",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I've seen it briefly in the first chapter of the docs, but I haven't tried it or have any in-depth knowledge. (I've made two aborted tries at Inform. They say the third time's the charm... Part of it is the documentation that comes with it. Perhaps I should look for some tutorials instead.)\n\nI'd be interested in trying to develop anything that can make games better or easier to develop. I'll put that on my list. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "I've seen it briefly in the first chapter of the docs, but I haven't tried it or have any in-depth knowledge. (I've made two aborted tries at Inform. They say the third time's the charm... Part of it is the documentation that comes with it. Perhaps I should look for some tutorials instead.)<br/><br/>I'd be interested in trying to develop anything that can make games better or easier to develop. I'll put that on my list. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2014-04-07T20:07:49+01:00",
      "LastEditDate": null
    }
  ]
}
