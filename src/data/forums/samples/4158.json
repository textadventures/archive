{
  "Topic": {
    "TopicId": "4158",
    "ForumId": "18",
    "Title": "More Intuitive String Matching For Objects",
    "LastUpdated": "2014-01-25T02:12:52+00:00",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "27653",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "I started to find it annoying in some cases where I referred to an object and a disambiguation menu was presented even though I was obviously referring to object1 and not object2.\n\ne.g.\nobject 1 is a rusty key\nobject 2 is a piano, and one of the alternate names is &quot;piano keys&quot;.\n\nWith the current code, Quest gives equal weighting to both so if you type &quot;examine key&quot; it will ask you if you mean the rusty key or the piano.\n\nI edited the in built functions ResolveNameInternal and CompareNames so now preference is given to an object if any of its names contain a [u:2w5umb3k]whole word[/u:2w5umb3k] that matches the input.\n\nBelow is a copy of each of the modified functions. The parameter &quot;semifullmatches&quot; must also be added to the CompareNames function.\n\n[b:2w5umb3k]ResolveNameInternal[/b:2w5umb3k]\n[code:2w5umb3k]fullmatches = NewObjectList()\npartialmatches = NewObjectList()\nsemifullmatches = NewObjectList()\ngame&#46;pov&#46;currentcommandmultiobjectpending = false\nif (objtype = &quot;object&quot;) {\n  scope = ScopeVisible()\n}\nelse if (objtype = &quot;exit&quot;) {\n  scope = ScopeExits()\n}\nvalue = Trim(value)\nforeach (obj, scope) {\n  name = LCase(GetDisplayAlias(obj))\n  CompareNames (name, value, obj, fullmatches, partialmatches, semifullmatches)\n  if (obj&#46;alt &lt;&gt; null) {\n    foreach (altname, obj&#46;alt) {\n      CompareNames (LCase(altname), value, obj, fullmatches, partialmatches, semifullmatches)\n    }\n  }\n}\nif (game&#46;lastobjects &lt;&gt; null) {\n  foreach (obj, game&#46;lastobjects) {\n    CompareNames (LCase(obj&#46;article), value, obj, fullmatches, partialmatches, semifullmatches)\n    CompareNames (LCase(obj&#46;gender), value, obj, fullmatches, partialmatches, semifullmatches)\n  }\n}\nif (ListCount(fullmatches) = 1) {\n  return (ListItem(fullmatches, 0))\n}\nelse if (ListCount(fullmatches) = 0 and ListCount(semifullmatches) = 1) {\n  return (ListItem(semifullmatches, 0))\n}\nelse if (ListCount(fullmatches) = 0 and ListCount(semifullmatches) = 0 and ListCount(partialmatches) = 1) {\n  return (ListItem(partialmatches, 0))\n}\nelse if (ListCount(fullmatches) + ListCount(partialmatches) + ListCount(semifullmatches) = 0) {\n  return (null)\n}\nelse {\n  menu = NewStringDictionary()\n  GenerateMenuChoices (menu, fullmatches)\n  GenerateMenuChoices (menu, semifullmatches)\n  GenerateMenuChoices (menu, partialmatches)\n  if (LengthOf(variable) &gt; 0) {\n    // single object command, so after showing the menu, add the object to game&#46;pov&#46;currentcommandresolvedelements\n    game&#46;pov&#46;currentcommandpendingvariable = variable\n    ShowMenu (DynamicTemplate(&quot;DisambiguateMenu&quot;, value), menu, true) {\n      varname = game&#46;pov&#46;currentcommandpendingvariable\n      game&#46;pov&#46;currentcommandpendingvariable = null\n      if (result &lt;&gt; null) {\n        AddToResolvedNames (varname, GetObject(result))\n      }\n    }\n  }\n  else {\n    // multi-object command, so after showing the menu, add the object to the list\n    game&#46;pov&#46;currentcommandmultiobjectpending = true\n    ShowMenu (DynamicTemplate(&quot;DisambiguateMenu&quot;, value), menu, true) {\n      if (result &lt;&gt; null) {\n        list add (game&#46;pov&#46;currentcommandpendingobjectlist, GetObject(result))\n        ResolveNextNameListItem\n      }\n    }\n  }\n  return (null)\n}[/code:2w5umb3k]\n\n[b:2w5umb3k]CompareNames[/b:2w5umb3k]\n[code:2w5umb3k]if (name = value) {\n  if (not ListContains(fullmatches, obj)) {\n    list add (fullmatches, obj)\n  }\n}\nelse {\n  if (StartsWith(name, value)) {\n    if (LengthOf(value) = (Instr(name, &quot; &quot;) - 1)) {\n      if (not ListContains(semifullmatches, obj)) {\n        list add (semifullmatches, obj)\n      }\n    }\n    else {\n      if ((not ListContains(partialmatches, obj)) and (not ListContains(semifullmatches, obj))) {\n        list add (partialmatches, obj)\n      }\n    }\n  }\n  else if (Instr(name, &quot; &quot; + value + &quot; &quot;) &gt; 0) {\n    if (not ListContains(semifullmatches, obj)) {\n      list add (semifullmatches, obj)\n    }\n  }\n  else {\n    // check if input matches the start of any word in the name\n    if (Instr(name, &quot; &quot; + value) &gt; 0) {\n      if (LengthOf(name) - Instr(name, &quot; &quot; + value) = LengthOf(value)) {\n        if (not ListContains(semifullmatches, obj)) {\n          list add (semifullmatches, obj)\n        }\n      }\n      else {\n        if ((not ListContains(partialmatches, obj)) and (not ListContains(semifullmatches, obj))) {\n          list add (partialmatches, obj)\n        }\n      }\n    }\n  }\n}[/code:2w5umb3k]\n\nIf anyone finds any problems in these please let me know.\n\nEdited to prevent certain objects from appearing twice in disambiguation menu.",
      "EditableFormat": "bbcode",
      "HTML": "I started to find it annoying in some cases where I referred to an object and a disambiguation menu was presented even though I was obviously referring to object1 and not object2.<br/><br/>e.g.<br/>object 1 is a rusty key<br/>object 2 is a piano, and one of the alternate names is &quot;piano keys&quot;.<br/><br/>With the current code, Quest gives equal weighting to both so if you type &quot;examine key&quot; it will ask you if you mean the rusty key or the piano.<br/><br/>I edited the in built functions ResolveNameInternal and CompareNames so now preference is given to an object if any of its names contain a <span style=\"text-decoration:underline;\">whole word</span> that matches the input.<br/><br/>Below is a copy of each of the modified functions. The parameter &quot;semifullmatches&quot; must also be added to the CompareNames function.<br/><br/><span style=\"font-weight:bold;\">ResolveNameInternal</span><br/><pre><code>fullmatches = NewObjectList()<br/>partialmatches = NewObjectList()<br/>semifullmatches = NewObjectList()<br/>game&#46;pov&#46;currentcommandmultiobjectpending = false<br/>if (objtype = &quot;object&quot;) {<br/>  scope = ScopeVisible()<br/>}<br/>else if (objtype = &quot;exit&quot;) {<br/>  scope = ScopeExits()<br/>}<br/>value = Trim(value)<br/>foreach (obj, scope) {<br/>  name = LCase(GetDisplayAlias(obj))<br/>  CompareNames (name, value, obj, fullmatches, partialmatches, semifullmatches)<br/>  if (obj&#46;alt &lt;&gt; null) {<br/>    foreach (altname, obj&#46;alt) {<br/>      CompareNames (LCase(altname), value, obj, fullmatches, partialmatches, semifullmatches)<br/>    }<br/>  }<br/>}<br/>if (game&#46;lastobjects &lt;&gt; null) {<br/>  foreach (obj, game&#46;lastobjects) {<br/>    CompareNames (LCase(obj&#46;article), value, obj, fullmatches, partialmatches, semifullmatches)<br/>    CompareNames (LCase(obj&#46;gender), value, obj, fullmatches, partialmatches, semifullmatches)<br/>  }<br/>}<br/>if (ListCount(fullmatches) = 1) {<br/>  return (ListItem(fullmatches, 0))<br/>}<br/>else if (ListCount(fullmatches) = 0 and ListCount(semifullmatches) = 1) {<br/>  return (ListItem(semifullmatches, 0))<br/>}<br/>else if (ListCount(fullmatches) = 0 and ListCount(semifullmatches) = 0 and ListCount(partialmatches) = 1) {<br/>  return (ListItem(partialmatches, 0))<br/>}<br/>else if (ListCount(fullmatches) + ListCount(partialmatches) + ListCount(semifullmatches) = 0) {<br/>  return (null)<br/>}<br/>else {<br/>  menu = NewStringDictionary()<br/>  GenerateMenuChoices (menu, fullmatches)<br/>  GenerateMenuChoices (menu, semifullmatches)<br/>  GenerateMenuChoices (menu, partialmatches)<br/>  if (LengthOf(variable) &gt; 0) {<br/>    // single object command, so after showing the menu, add the object to game&#46;pov&#46;currentcommandresolvedelements<br/>    game&#46;pov&#46;currentcommandpendingvariable = variable<br/>    ShowMenu (DynamicTemplate(&quot;DisambiguateMenu&quot;, value), menu, true) {<br/>      varname = game&#46;pov&#46;currentcommandpendingvariable<br/>      game&#46;pov&#46;currentcommandpendingvariable = null<br/>      if (result &lt;&gt; null) {<br/>        AddToResolvedNames (varname, GetObject(result))<br/>      }<br/>    }<br/>  }<br/>  else {<br/>    // multi-object command, so after showing the menu, add the object to the list<br/>    game&#46;pov&#46;currentcommandmultiobjectpending = true<br/>    ShowMenu (DynamicTemplate(&quot;DisambiguateMenu&quot;, value), menu, true) {<br/>      if (result &lt;&gt; null) {<br/>        list add (game&#46;pov&#46;currentcommandpendingobjectlist, GetObject(result))<br/>        ResolveNextNameListItem<br/>      }<br/>    }<br/>  }<br/>  return (null)<br/>}</code></pre><br/><br/><span style=\"font-weight:bold;\">CompareNames</span><br/><pre><code>if (name = value) {<br/>  if (not ListContains(fullmatches, obj)) {<br/>    list add (fullmatches, obj)<br/>  }<br/>}<br/>else {<br/>  if (StartsWith(name, value)) {<br/>    if (LengthOf(value) = (Instr(name, &quot; &quot;) - 1)) {<br/>      if (not ListContains(semifullmatches, obj)) {<br/>        list add (semifullmatches, obj)<br/>      }<br/>    }<br/>    else {<br/>      if ((not ListContains(partialmatches, obj)) and (not ListContains(semifullmatches, obj))) {<br/>        list add (partialmatches, obj)<br/>      }<br/>    }<br/>  }<br/>  else if (Instr(name, &quot; &quot; + value + &quot; &quot;) &gt; 0) {<br/>    if (not ListContains(semifullmatches, obj)) {<br/>      list add (semifullmatches, obj)<br/>    }<br/>  }<br/>  else {<br/>    // check if input matches the start of any word in the name<br/>    if (Instr(name, &quot; &quot; + value) &gt; 0) {<br/>      if (LengthOf(name) - Instr(name, &quot; &quot; + value) = LengthOf(value)) {<br/>        if (not ListContains(semifullmatches, obj)) {<br/>          list add (semifullmatches, obj)<br/>        }<br/>      }<br/>      else {<br/>        if ((not ListContains(partialmatches, obj)) and (not ListContains(semifullmatches, obj))) {<br/>          list add (partialmatches, obj)<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</code></pre><br/><br/>If anyone finds any problems in these please let me know.<br/><br/>Edited to prevent certain objects from appearing twice in disambiguation menu.",
      "PostDate": "2014-01-25T02:12:52+00:00",
      "LastEditDate": null
    }
  ]
}
