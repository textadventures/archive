{
  "Topic": {
    "TopicId": "3988",
    "ForumId": "10",
    "Title": "Scenes",
    "LastUpdated": "2013-10-30T07:06:34+00:00",
    "ReplyCount": 2
  },
  "Posts": [
    {
      "PostId": "26767",
      "UserId": 0,
      "Username": "george",
      "UserAvatar": null,
      "UserGravatar": "dc6fe8e6172303d85249a13c9a49c1ff",
      "EditableText": "What would be the Quest equivalent of scene code? By scene code I mean:\n\n* an attribute that tells you what scene you're in. I suppose a game.scene attribute?\n* Individual scenes that hold scripts active during that scene. I guess make Scene objects, and then based on the game.scene attribute select the appropriate object's scripts?\n* enter_scene and exit_scene scripts that you run -- maybe put these on the Scene object?\n\nI'm basing most of this on Inform 7's scenes -- to quote its manual, \n\n[quote:1gvqjtjc]As we have seen, Inform divides up space into individual places called &quot;rooms&quot;, and allows us to group rooms together into &quot;regions&quot; if we find that convenient. And Inform also divides time up, into individual turns. These too we can group together: the equivalent of a region is a &quot;scene&quot;.\n\nTo put this another way, if we think of the interactive fiction as a stage play, then up to now it has simply contained endless dialogue and stage directions - there has been no convenient way to divide up its running time into dramatic episodes, in the same way that a playwright might make Act II take place in the same drawing-room as Act I, but (let us say) six months later, after many things have changed. The script contains cues for one scene to end and another to begin: when those cues are reached, the stage hands rearrange props, actors reposition themselves and so on.\n\nInform also allows us to create scenes, with cues for them to start and end, and some stage machinery (so to speak) making it easy to move the action on. But interactive fiction is interactive, so the metaphor of the theatre only goes so far. We can have several different scenes going on at once - perhaps with the relevant events taking place in different rooms, which the player is free to walk between. And the player may make a choice which changes the story-line, causing scenes to happen which otherwise would not have happened, and so on. Scenes can even be &quot;recurring&quot;, that is, can repeat themselves.\n\nSo organising the story-line into scenes is not simply a matter of making a list (Scene 1, then Scene 2, then Scene 3, finis). It is more like a chart in which one scene can lead in several possible ways to others - a sort of map of time, which as we shall see Inform displays in its &quot;Scenes&quot; index.[/quote:1gvqjtjc]",
      "EditableFormat": "bbcode",
      "HTML": "What would be the Quest equivalent of scene code? By scene code I mean:<br/><br/>* an attribute that tells you what scene you're in. I suppose a game.scene attribute?<br/>* Individual scenes that hold scripts active during that scene. I guess make Scene objects, and then based on the game.scene attribute select the appropriate object's scripts?<br/>* enter_scene and exit_scene scripts that you run -- maybe put these on the Scene object?<br/><br/>I'm basing most of this on Inform 7's scenes -- to quote its manual, <br/><br/><blockquote><p>As we have seen, Inform divides up space into individual places called &quot;rooms&quot;, and allows us to group rooms together into &quot;regions&quot; if we find that convenient. And Inform also divides time up, into individual turns. These too we can group together: the equivalent of a region is a &quot;scene&quot;.<br/><br/>To put this another way, if we think of the interactive fiction as a stage play, then up to now it has simply contained endless dialogue and stage directions - there has been no convenient way to divide up its running time into dramatic episodes, in the same way that a playwright might make Act II take place in the same drawing-room as Act I, but (let us say) six months later, after many things have changed. The script contains cues for one scene to end and another to begin: when those cues are reached, the stage hands rearrange props, actors reposition themselves and so on.<br/><br/>Inform also allows us to create scenes, with cues for them to start and end, and some stage machinery (so to speak) making it easy to move the action on. But interactive fiction is interactive, so the metaphor of the theatre only goes so far. We can have several different scenes going on at once - perhaps with the relevant events taking place in different rooms, which the player is free to walk between. And the player may make a choice which changes the story-line, causing scenes to happen which otherwise would not have happened, and so on. Scenes can even be &quot;recurring&quot;, that is, can repeat themselves.<br/><br/>So organising the story-line into scenes is not simply a matter of making a list (Scene 1, then Scene 2, then Scene 3, finis). It is more like a chart in which one scene can lead in several possible ways to others - a sort of map of time, which as we shall see Inform displays in its &quot;Scenes&quot; index.</p></blockquote>",
      "PostDate": "2013-10-30T05:35:30+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "26769",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "I think you've hit the mark already. Like you say, create an attribute on the game to control the scenes (game.scene) and then use if scripts within a room for the objects that will change between scenes.\n\nI don't quite understand what you mean about needing to create a scene object. If a scene is merely the definition between two separate time frames within the same physical space, then using if scripts with game.scene would be sufficient. If you're talking about a set of turn scripts to be activated, you could just trigger them all at the same time the scene changes, perhaps with a changescript added alongside the game.scene attribute, to add/remove/alter objects as necessary. This way you can change attributes that cannot be set to a script.\n\nThe enter_scene could be done with the &quot;before/after entering room&quot; scripts, again use if (game.scene = 2) {} and you should be fine.\n\nThe truth is there are so many ways you could do it, the most effective would depend on exactly what you need to achieve. If it's a big time jump then grouping all the changes together like this is the way to go. My own game is open world in the sense that most areas are accessible from the start, but things necessarily have to change as you complete certain tasks. To achieve that I have &quot;stage&quot; (basically synonymous with &quot;scene&quot; here&quot;) set as an attribute for many objects and characters. As something is achieved, the stage attribute is pushed forward on all relevant objects while others remain at the same stage. It all depends on the context of your game.",
      "EditableFormat": "bbcode",
      "HTML": "I think you've hit the mark already. Like you say, create an attribute on the game to control the scenes (game.scene) and then use if scripts within a room for the objects that will change between scenes.<br/><br/>I don't quite understand what you mean about needing to create a scene object. If a scene is merely the definition between two separate time frames within the same physical space, then using if scripts with game.scene would be sufficient. If you're talking about a set of turn scripts to be activated, you could just trigger them all at the same time the scene changes, perhaps with a changescript added alongside the game.scene attribute, to add/remove/alter objects as necessary. This way you can change attributes that cannot be set to a script.<br/><br/>The enter_scene could be done with the &quot;before/after entering room&quot; scripts, again use if (game.scene = 2) {} and you should be fine.<br/><br/>The truth is there are so many ways you could do it, the most effective would depend on exactly what you need to achieve. If it's a big time jump then grouping all the changes together like this is the way to go. My own game is open world in the sense that most areas are accessible from the start, but things necessarily have to change as you complete certain tasks. To achieve that I have &quot;stage&quot; (basically synonymous with &quot;scene&quot; here&quot;) set as an attribute for many objects and characters. As something is achieved, the stage attribute is pushed forward on all relevant objects while others remain at the same stage. It all depends on the context of your game.",
      "PostDate": "2013-10-30T06:15:39+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "26771",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm probably not that clear about this code design logic stuff, and I'm sure you both already know this (and it's probably not related at all to the topic), but you can do this stuff in quest:\n\nmake &quot;data objects&quot;, which you can use to organize and easily find and use them wherever you want\n\nrooms can be used solely (as a &quot;room group&quot;) to hold a collection of rooms:\n\n(there can be more sub and~or super layers, of course)\n\n&quot;earth&quot; Room Type Object (no game play usage at all)\n-&gt; &quot;africa&quot; Room Type Object\n-&gt; &quot;asia&quot; Room Type Object\n-&gt; &quot;europe&quot; Room Type Object\n-&gt; &quot;north_america&quot; Room Type Object\n-&gt; &quot;south_america&quot; Room Type Object\n\n&quot;mars&quot; Room Type Object (no game play usage at all)\n-&gt; &quot;blah&quot; Room Type Object\n-&gt; &quot;blah etc&quot;\n\n&lt;object name=&quot;boolean_data_object&quot;&gt;\n-&gt; blah booleans\n&lt;/object&gt;\n\n&lt;object name=&quot;string_data_object&quot;&gt;\n-&gt; blah string\n&lt;/object&gt;\n\n&lt;object name=&quot;integer_data_object&quot;&gt;\n-&gt; blah integer\n&lt;/object&gt;\n\netc etc etc\n\n------------------\n\nalso, I think you can use Room_and_or_an_Object type too, for what you want to achieve, I think.\n\n--------------\n\nRooms, Objects, and~or Room+Objects can surely be used to create~be these &quot;scenes&quot;, I would think...\n\n&lt;object name=&quot;global_events_or_scenes_object&quot;&gt;\n-&gt; blah events~scenes\n&lt;/object&gt;",
      "EditableFormat": "bbcode",
      "HTML": "I'm probably not that clear about this code design logic stuff, and I'm sure you both already know this (and it's probably not related at all to the topic), but you can do this stuff in quest:<br/><br/>make &quot;data objects&quot;, which you can use to organize and easily find and use them wherever you want<br/><br/>rooms can be used solely (as a &quot;room group&quot;) to hold a collection of rooms:<br/><br/>(there can be more sub and~or super layers, of course)<br/><br/>&quot;earth&quot; Room Type Object (no game play usage at all)<br/>-&gt; &quot;africa&quot; Room Type Object<br/>-&gt; &quot;asia&quot; Room Type Object<br/>-&gt; &quot;europe&quot; Room Type Object<br/>-&gt; &quot;north_america&quot; Room Type Object<br/>-&gt; &quot;south_america&quot; Room Type Object<br/><br/>&quot;mars&quot; Room Type Object (no game play usage at all)<br/>-&gt; &quot;blah&quot; Room Type Object<br/>-&gt; &quot;blah etc&quot;<br/><br/>&lt;object name=&quot;boolean_data_object&quot;&gt;<br/>-&gt; blah booleans<br/>&lt;/object&gt;<br/><br/>&lt;object name=&quot;string_data_object&quot;&gt;<br/>-&gt; blah string<br/>&lt;/object&gt;<br/><br/>&lt;object name=&quot;integer_data_object&quot;&gt;<br/>-&gt; blah integer<br/>&lt;/object&gt;<br/><br/>etc etc etc<br/><br/>------------------<br/><br/>also, I think you can use Room_and_or_an_Object type too, for what you want to achieve, I think.<br/><br/>--------------<br/><br/>Rooms, Objects, and~or Room+Objects can surely be used to create~be these &quot;scenes&quot;, I would think...<br/><br/>&lt;object name=&quot;global_events_or_scenes_object&quot;&gt;<br/>-&gt; blah events~scenes<br/>&lt;/object&gt;",
      "PostDate": "2013-10-30T07:06:34+00:00",
      "LastEditDate": null
    }
  ]
}
