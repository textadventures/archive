{
  "Topic": {
    "TopicId": "3232",
    "ForumId": "10",
    "Title": "Quest Scripting Language Features...",
    "LastUpdated": "2012-10-26T05:00:51+01:00",
    "ReplyCount": 19
  },
  "Posts": [
    {
      "PostId": "21547",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "I know few like to hear my complain, so I try not to do it. However having used more grown up languages for so long I find quest's code features... or rather the lack there of... a little frustrating. Which is my only real qualm with the system (the rest I can more or less program around generally speaking).\n\nSo I thought adding a few minor features would make a programmers life a great deal less painful, I might even add them myself if I decide to get messy (and assuming said core is programmed in any sane way).\n\nThe short list (in order of importance)\n[list:2y6sqjmz]\n[*:2y6sqjmz]continue and break statements[/*:m:2y6sqjmz]\n[*:2y6sqjmz]&amp;&amp; and || short circuiting[/*:m:2y6sqjmz]\n[*:2y6sqjmz]+= -= /= *=[/*:m:2y6sqjmz]\n[*:2y6sqjmz]++ -- prefix and postfix operators (I could live without these)[/*:m:2y6sqjmz][/list:u:2y6sqjmz]\n\nI have written a few compilers, a few of which compiled to full blown bytecode rather then just IL. So I can provide some implementation details.\n\nThe Detailed List\n[code:2y6sqjmz]\nbreak and continue statements\n\nboth break and continue work on the innermost loop structure\nthey work by pushing start/end loop targets to the stack,\nif we encounter a break we pop both and use the end statement\nif we encounter a continue we peek at the start statement\n[/code:2y6sqjmz]\n[code:2y6sqjmz]\n&amp;&amp; and || short circuiting\n\nEXAMPLE\n&quot;if(a &amp;&amp; b)&quot; in this case, if a is false, b will not be tested and the if will be exited\n&quot;if(a || b)&quot; in this case, if a is true, b will not be tested and the if will be exited\n\n\nStack Machine Bytecode of how this works&#46;&#46;&#46;&#46; (for an &amp;&amp; statement)\n-----------------------------------------\nload_var a\t;expression 1 code goes here\nif_zero_goto label1\nload_var b\t;expression 2 code goes here\nif_zero_goto label1\n;; once we get here, both values are true\nload_const 1\ngoto label2\n_label1&#58;\nload_const 0\n_label2&#58;\n;we load constants to the stack for further expression handling\n\n\nStack Machine Bytecode of how this works&#46;&#46;&#46;&#46; (for an || statement)\n-----------------------------------------\nload_var a\t;expression 1 code goes here\nif_not_zero_goto label1\nload_var b\t;expression 2 code goes here\nif_not_zero_goto label1\n;; once we get here, both values are true\nload_const 0\ngoto label2\n_label1&#58;\nload_const 1\n_label2&#58;\n;we load constants to the stack for further expression handling\n[/code:2y6sqjmz]\n[code:2y6sqjmz]\n+= -= /= *=\n\nWe just expand these to slightly simpler expressions\n+=\nlvalue = lvalue + (expression)\n\n-= \nlvalue = lvalue - (expression)\n\n/=\nlvalue = lvalue / (expression)\n\n*=\nlvalue = lvalue * (expression)\n[/code:2y6sqjmz]",
      "EditableFormat": "bbcode",
      "HTML": "I know few like to hear my complain, so I try not to do it. However having used more grown up languages for so long I find quest's code features... or rather the lack there of... a little frustrating. Which is my only real qualm with the system (the rest I can more or less program around generally speaking).<br/><br/>So I thought adding a few minor features would make a programmers life a great deal less painful, I might even add them myself if I decide to get messy (and assuming said core is programmed in any sane way).<br/><br/>The short list (in order of importance)<br/>[list]<br/>[*]continue and break statements[/*:m]<br/>[*]&amp;&amp; and || short circuiting[/*:m]<br/>[*]+= -= /= *=[/*:m]<br/>[*]++ -- prefix and postfix operators (I could live without these)[/*:m][/list:u]<br/><br/>I have written a few compilers, a few of which compiled to full blown bytecode rather then just IL. So I can provide some implementation details.<br/><br/>The Detailed List<br/><pre><code><br/>break and continue statements<br/><br/>both break and continue work on the innermost loop structure<br/>they work by pushing start/end loop targets to the stack,<br/>if we encounter a break we pop both and use the end statement<br/>if we encounter a continue we peek at the start statement<br/></code></pre><br/><pre><code><br/>&amp;&amp; and || short circuiting<br/><br/>EXAMPLE<br/>&quot;if(a &amp;&amp; b)&quot; in this case, if a is false, b will not be tested and the if will be exited<br/>&quot;if(a || b)&quot; in this case, if a is true, b will not be tested and the if will be exited<br/><br/><br/>Stack Machine Bytecode of how this works&#46;&#46;&#46;&#46; (for an &amp;&amp; statement)<br/>-----------------------------------------<br/>load_var a\t;expression 1 code goes here<br/>if_zero_goto label1<br/>load_var b\t;expression 2 code goes here<br/>if_zero_goto label1<br/>;; once we get here, both values are true<br/>load_const 1<br/>goto label2<br/>_label1&#58;<br/>load_const 0<br/>_label2&#58;<br/>;we load constants to the stack for further expression handling<br/><br/><br/>Stack Machine Bytecode of how this works&#46;&#46;&#46;&#46; (for an || statement)<br/>-----------------------------------------<br/>load_var a\t;expression 1 code goes here<br/>if_not_zero_goto label1<br/>load_var b\t;expression 2 code goes here<br/>if_not_zero_goto label1<br/>;; once we get here, both values are true<br/>load_const 0<br/>goto label2<br/>_label1&#58;<br/>load_const 1<br/>_label2&#58;<br/>;we load constants to the stack for further expression handling<br/></code></pre><br/><pre><code><br/>+= -= /= *=<br/><br/>We just expand these to slightly simpler expressions<br/>+=<br/>lvalue = lvalue + (expression)<br/><br/>-= <br/>lvalue = lvalue - (expression)<br/><br/>/=<br/>lvalue = lvalue / (expression)<br/><br/>*=<br/>lvalue = lvalue * (expression)<br/></code></pre>",
      "PostDate": "2012-10-12T07:54:54+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21548",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "All reasonable requests - I'm happy for you to implement them and send me a pull request if you like <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nI think implementing short-circuiting will require updating FLEE, which Quest uses to parse expressions. Quest uses my fork here: <!-- m --><a class=\"postlink\" href=\"https://bitbucket.org/alexwarren/flee\">https://bitbucket.org/alexwarren/flee</a><!-- m -->\n\nImplementing things like += and ++ shouldn't be too difficult, but bear in mind they will need to be supported in the Script Editor too.",
      "EditableFormat": "bbcode",
      "HTML": "All reasonable requests - I'm happy for you to implement them and send me a pull request if you like <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>I think implementing short-circuiting will require updating FLEE, which Quest uses to parse expressions. Quest uses my fork here: <!-- m --><a class=\"postlink\" href=\"https://bitbucket.org/alexwarren/flee\">https://bitbucket.org/alexwarren/flee</a><!-- m --><br/><br/>Implementing things like += and ++ shouldn't be too difficult, but bear in mind they will need to be supported in the Script Editor too.",
      "PostDate": "2012-10-12T11:11:07+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21549",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Alright i'll see what I can do in my free time.\n\nI don't think I have heard of flee. Generally mostly use Antlr these days.\n\nAnyway, one questions before I touch any expressions\n\nHow do you handle boolean operations?",
      "EditableFormat": "bbcode",
      "HTML": "Alright i'll see what I can do in my free time.<br/><br/>I don't think I have heard of flee. Generally mostly use Antlr these days.<br/><br/>Anyway, one questions before I touch any expressions<br/><br/>How do you handle boolean operations?",
      "PostDate": "2012-10-12T12:25:54+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21550",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "Not sure I really understand the question, but Quest doesn't do anything special - every expression is handed to FLEE to parse, and Quest provides variable and function values when asked for them. So the answer is probably &quot;whatever FLEE does&quot;.",
      "EditableFormat": "bbcode",
      "HTML": "Not sure I really understand the question, but Quest doesn't do anything special - every expression is handed to FLEE to parse, and Quest provides variable and function values when asked for them. So the answer is probably &quot;whatever FLEE does&quot;.",
      "PostDate": "2012-10-12T17:28:35+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21553",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "[color=#800000:2d3739w4][size=200:2d3739w4]EDITED[/size:2d3739w4]\nI missed a lot due to how tired I was. I have rewritten this a bit to fix my mistakes.[/color:2d3739w4]\nThis concerns the addition of short-circuiting AND and OR.\n\nHah, well. Seems Flee is all vbscript. That syntax makes me head desk (I have only used vb for like 2 months back when vb6 was still about).\n\nThis is going to be fun.™\n\n[size=200:2d3739w4][b:2d3739w4]----[/b:2d3739w4][/size:2d3739w4]\n\nOkay.. at first glace it looks like Flee does support short circuiting out of the box, it just (apparently) isn't being used. I happen to know short circuiting doesn't work, [b:2d3739w4][i:2d3739w4]or at least it didn't for me[/i:2d3739w4][/b:2d3739w4]. But my tests of Quest Short Circuiting behavior were far from extensive.\n\n[size=200:2d3739w4][b:2d3739w4]----[/b:2d3739w4][/size:2d3739w4]\n\nI get an error of &quot;Cannot convert type 'Int32' to expression result of 'Boolean'&quot; when I test things in quest, which is interesting. I am guessing this is a problem in flee rather then Quest.\n\nHowever under most circumstances flee uses the bitwise 'and' rather then the Boolean'and' in expressions. It does however sometimes seem to be using Boolean and when the two sides are Boolean.\n\nThe differences between Bitwise 'and' and Boolean 'and'.\n[code:2d3739w4]\nc = 2 &amp; 1\nc is 0, since the bitwise and of 10b and 01b is 0\n\nc = 2 &amp;&amp; 1\nc is 1, since neither value equals zero, which is what boolean (logical) and does\n[/code:2d3739w4]\n\nLet me see if I can force flee to just use the logical stuff. Since most people who write Quest code probably do not use the bitwise functionality anyway.\n\n[size=200:2d3739w4][b:2d3739w4]----[/b:2d3739w4][/size:2d3739w4]\n\nFlee design is interesting. But it could be better. Anyway as you can see in [u:2d3739w4]ExpressionElements.LogicalBitwise.AndOr.vb[/u:2d3739w4] line 50 to 62, the method Emit. It does indeed use both logical and bitwise and.\n\nI modified this method to only use only the logical versions and when set to numeric mode it does indeed seem to operate as expected (however missing variables still cause it to crash :/)\n\nHowever there is a small bug in the AND routine, when evaluating something like &quot;2 and 123&quot; it will return 123, rather then 1. It is still technically a legal boolean true value, but I expect it is due to optimizations in the code, as flee only expects the Boolean type here. The OR works as expected however.\n\n[size=150:2d3739w4][b:2d3739w4]In conclusion[/b:2d3739w4][/size:2d3739w4]\nFlee has the capacity for logical 'and' and 'or'. We just have to somehow coax it to use it. So yes, it will likely require a modification of Flee to do.\nThe three options I see are as follows.\n\n[list=1:2d3739w4]\n[*:2d3739w4]We disable the ability for flee to use bitwise 'and' and bitwise 'or'. However this is a bit short sighted considering it has the capacity for it.[/*:m:2d3739w4]\n[*:2d3739w4]We give bitwise 'and and bitwise 'or' their own tokens in flee and set 'and' and 'or' tokens to be used only for the logical functions. However this may involve a great deal of work (depending on how they did it).[/*:m:2d3739w4]\n[*:2d3739w4]We completely replace flee with something else. While this has long term benefits, the short term requirement is considerable. I don't recommend doing unless you really think it worth the time. Creating just an expression parser is pretty easy though, so it might not be to bad.[/*:m:2d3739w4][/list:o:2d3739w4]\n\nEither way I also think we need to enable Flee to be able to convert a numeric result to a boolean result. That is if the number is into zero it is true, if it is zero, then it is false.",
      "EditableFormat": "bbcode",
      "HTML": "<span style=\"color:#800000\"><span style=\"font-size:200\">EDITED</span><br/>I missed a lot due to how tired I was. I have rewritten this a bit to fix my mistakes.</span><br/>This concerns the addition of short-circuiting AND and OR.<br/><br/>Hah, well. Seems Flee is all vbscript. That syntax makes me head desk (I have only used vb for like 2 months back when vb6 was still about).<br/><br/>This is going to be fun.™<br/><br/><span style=\"font-size:200\"><span style=\"font-weight:bold;\">----</span></span><br/><br/>Okay.. at first glace it looks like Flee does support short circuiting out of the box, it just (apparently) isn't being used. I happen to know short circuiting doesn't work, <span style=\"font-weight:bold;\"><span style=\"font-style:italic;\">or at least it didn't for me</span></span>. But my tests of Quest Short Circuiting behavior were far from extensive.<br/><br/><span style=\"font-size:200\"><span style=\"font-weight:bold;\">----</span></span><br/><br/>I get an error of &quot;Cannot convert type 'Int32' to expression result of 'Boolean'&quot; when I test things in quest, which is interesting. I am guessing this is a problem in flee rather then Quest.<br/><br/>However under most circumstances flee uses the bitwise 'and' rather then the Boolean'and' in expressions. It does however sometimes seem to be using Boolean and when the two sides are Boolean.<br/><br/>The differences between Bitwise 'and' and Boolean 'and'.<br/><pre><code><br/>c = 2 &amp; 1<br/>c is 0, since the bitwise and of 10b and 01b is 0<br/><br/>c = 2 &amp;&amp; 1<br/>c is 1, since neither value equals zero, which is what boolean (logical) and does<br/></code></pre><br/><br/>Let me see if I can force flee to just use the logical stuff. Since most people who write Quest code probably do not use the bitwise functionality anyway.<br/><br/><span style=\"font-size:200\"><span style=\"font-weight:bold;\">----</span></span><br/><br/>Flee design is interesting. But it could be better. Anyway as you can see in <span style=\"text-decoration:underline;\">ExpressionElements.LogicalBitwise.AndOr.vb</span> line 50 to 62, the method Emit. It does indeed use both logical and bitwise and.<br/><br/>I modified this method to only use only the logical versions and when set to numeric mode it does indeed seem to operate as expected (however missing variables still cause it to crash :/)<br/><br/>However there is a small bug in the AND routine, when evaluating something like &quot;2 and 123&quot; it will return 123, rather then 1. It is still technically a legal boolean true value, but I expect it is due to optimizations in the code, as flee only expects the Boolean type here. The OR works as expected however.<br/><br/><span style=\"font-size:150\"><span style=\"font-weight:bold;\">In conclusion</span></span><br/>Flee has the capacity for logical 'and' and 'or'. We just have to somehow coax it to use it. So yes, it will likely require a modification of Flee to do.<br/>The three options I see are as follows.<br/><br/>[list=1]<br/>[*]We disable the ability for flee to use bitwise 'and' and bitwise 'or'. However this is a bit short sighted considering it has the capacity for it.[/*:m]<br/>[*]We give bitwise 'and and bitwise 'or' their own tokens in flee and set 'and' and 'or' tokens to be used only for the logical functions. However this may involve a great deal of work (depending on how they did it).[/*:m]<br/>[*]We completely replace flee with something else. While this has long term benefits, the short term requirement is considerable. I don't recommend doing unless you really think it worth the time. Creating just an expression parser is pretty easy though, so it might not be to bad.[/*:m][/list:o]<br/><br/>Either way I also think we need to enable Flee to be able to convert a numeric result to a boolean result. That is if the number is into zero it is true, if it is zero, then it is false.",
      "PostDate": "2012-10-12T19:38:09+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21560",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Flee is not that well designed. Changing or adding anything requires making changes in a dozen places throughout the code. That, the strange customized version of Grammatica it requires, it being in Visual Basic convinced me it might be worth seeing if an alternative exists.\n\nOne does, better yet, it is almost a drop-in replacement. It is NCalc. It is made in Antlr, C# and has much cleaner code (just don't look in Numbers.cs but that can be fixed if we use .Net +4.0).\n\nJust letting you know, it might be worth a glance. I know replacing a major component of any grown program is a time consuming problem, I plan to do a lot of the work and testing myself. In the free time I can spare anyway. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nI wanted to get it working before I did any show and tell though. But I am mentioning it so if you object I don't spend to much of my non work days on it to find it out it's a no go.",
      "EditableFormat": "bbcode",
      "HTML": "Flee is not that well designed. Changing or adding anything requires making changes in a dozen places throughout the code. That, the strange customized version of Grammatica it requires, it being in Visual Basic convinced me it might be worth seeing if an alternative exists.<br/><br/>One does, better yet, it is almost a drop-in replacement. It is NCalc. It is made in Antlr, C# and has much cleaner code (just don't look in Numbers.cs but that can be fixed if we use .Net +4.0).<br/><br/>Just letting you know, it might be worth a glance. I know replacing a major component of any grown program is a time consuming problem, I plan to do a lot of the work and testing myself. In the free time I can spare anyway. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>I wanted to get it working before I did any show and tell though. But I am mentioning it so if you object I don't spend to much of my non work days on it to find it out it's a no go.",
      "PostDate": "2012-10-14T23:29:56+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21561",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Here is a sample of a heavily modified NCalc\n\n<!-- m --><a class=\"postlink\" href=\"http://www.mediafire.com/?pv1svxo2tf2fagv\">http://www.mediafire.com/?pv1svxo2tf2fagv</a><!-- m -->\n\nI rewrote the grammar (since that is very easy with antlr) to make it more Quest friendly.\n\nI added assignment code, since NCalc didn't have any. It wasn't too difficult.\n\nIt supports = += -= /= %= *= |= &amp;= ^= &lt;&lt;= and &gt;&gt;= as far as assignment goes and it can do it inline.\n\nMeaning this is a valid expression.\n\nb = 4 - (a += 2)\n\nI haven't hooked up the assignment to its parameter storage yet, since I was considering removing that entirely and just have a handler. so whoever is running it gets the request for the variable or told a variable has been assigned.\n\n[b:230zzqh7][u:230zzqh7]Other changes vs Flee[/u:230zzqh7][/b:230zzqh7]\n\nequality has changed from '=' to '=='\n'^' has been reassigned from raising to a power to Bitwise Excusive Or (XOR)\n\n'and' is no longer shared between bitwise and logical use\n'&amp;' is now used for Bitwise And\n\n'or' is no longer shared between bitwise and logical use\n'|' is now used for Bitwise Or\n\nIt has the capacity for short circuiting on Logical And and Logical Or\n\nYou gain '~' Bitwise Not as well as '!' for Logical Not ('not' is still valid for Logical Not)\n\nRaising to a power is not implemented (but if you want it, it is easy enough to add).\n\n\nThere was an interesting problem, since I wanted to originally make it identical to current Flee syntax, however there was a flaw.\nIt cannot tell the difference between variable = 10 and variable = 10. To be fair, neither can I. So I don't really blame it much. However assignment and equality checking require separate tokens for this reason. Since it only handles expressions, it cannot guess from context.\n\nOnce I realize that would pretty much break all Quest code in existence, I decided a few more minor changes wouldn't hurt to badly. However could increase compatibility by changing ^ back to power and changing the bitwise xor to 'xor'.\n\n\nEdit: I'll work more on this maybe Wednesday, see about hammering it into quest and updating all of the required parts of WorldModel to get it to work.",
      "EditableFormat": "bbcode",
      "HTML": "Here is a sample of a heavily modified NCalc<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.mediafire.com/?pv1svxo2tf2fagv\">http://www.mediafire.com/?pv1svxo2tf2fagv</a><!-- m --><br/><br/>I rewrote the grammar (since that is very easy with antlr) to make it more Quest friendly.<br/><br/>I added assignment code, since NCalc didn't have any. It wasn't too difficult.<br/><br/>It supports = += -= /= %= *= |= &amp;= ^= &lt;&lt;= and &gt;&gt;= as far as assignment goes and it can do it inline.<br/><br/>Meaning this is a valid expression.<br/><br/>b = 4 - (a += 2)<br/><br/>I haven't hooked up the assignment to its parameter storage yet, since I was considering removing that entirely and just have a handler. so whoever is running it gets the request for the variable or told a variable has been assigned.<br/><br/><span style=\"font-weight:bold;\"><span style=\"text-decoration:underline;\">Other changes vs Flee</span></span><br/><br/>equality has changed from '=' to '=='<br/>'^' has been reassigned from raising to a power to Bitwise Excusive Or (XOR)<br/><br/>'and' is no longer shared between bitwise and logical use<br/>'&amp;' is now used for Bitwise And<br/><br/>'or' is no longer shared between bitwise and logical use<br/>'|' is now used for Bitwise Or<br/><br/>It has the capacity for short circuiting on Logical And and Logical Or<br/><br/>You gain '~' Bitwise Not as well as '!' for Logical Not ('not' is still valid for Logical Not)<br/><br/>Raising to a power is not implemented (but if you want it, it is easy enough to add).<br/><br/><br/>There was an interesting problem, since I wanted to originally make it identical to current Flee syntax, however there was a flaw.<br/>It cannot tell the difference between variable = 10 and variable = 10. To be fair, neither can I. So I don't really blame it much. However assignment and equality checking require separate tokens for this reason. Since it only handles expressions, it cannot guess from context.<br/><br/>Once I realize that would pretty much break all Quest code in existence, I decided a few more minor changes wouldn't hurt to badly. However could increase compatibility by changing ^ back to power and changing the bitwise xor to 'xor'.<br/><br/><br/>Edit: I'll work more on this maybe Wednesday, see about hammering it into quest and updating all of the required parts of WorldModel to get it to work.",
      "PostDate": "2012-10-15T05:31:59+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21562",
      "UserId": 0,
      "Username": "The Pixie",
      "UserAvatar": null,
      "UserGravatar": "cfa37e927f96177bcf6053ae8f108f77",
      "EditableText": "I like the sound of this. += etc. would be a great addition to Quest, and I would prefer == for equality as it would be the same as every other langiage I use, and I would feel more confident return (a == b) was returning a boolean, rather than b.\n\nI would want to have some operator for raising to the power; it occasionally useful.\n\nWhether others would consider the change in syntax I do not know. Would a translation program be possible? It would mean maintaining two versions of libraries. Would it be possible to update flee to use both the new and old syntax as a first step?",
      "EditableFormat": "bbcode",
      "HTML": "I like the sound of this. += etc. would be a great addition to Quest, and I would prefer == for equality as it would be the same as every other langiage I use, and I would feel more confident return (a == b) was returning a boolean, rather than b.<br/><br/>I would want to have some operator for raising to the power; it occasionally useful.<br/><br/>Whether others would consider the change in syntax I do not know. Would a translation program be possible? It would mean maintaining two versions of libraries. Would it be possible to update flee to use both the new and old syntax as a first step?",
      "PostDate": "2012-10-15T08:27:44+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21563",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "[quote=&quot;The Pixie&quot;:2dz90jf9]I like the sound of this. += etc. would be a great addition to Quest, and I would prefer == for equality as it would be the same as every other langiage I use, and I would feel more confident return (a == b) was returning a boolean, rather than b.[/quote:2dz90jf9]\nI prefer '==' as well.\n\n[quote=&quot;The Pixie&quot;:2dz90jf9]I would want to have some operator for raising to the power; it occasionally useful.[/quote:2dz90jf9]\nWhat do you think of [b:2dz90jf9]b = 2 pow 4[/b:2dz90jf9] syntax wise? \nThe only other ways I see it done are [b:2dz90jf9]b = 2 ** 4[/b:2dz90jf9] and [b:2dz90jf9]b = 2 ^^ 4[/b:2dz90jf9], and of course [b:2dz90jf9]b = 2 ^ 4[/b:2dz90jf9].\n\nIn my humble opinion symbol based causes less confusion in the code, but ultimately not my decision. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\n[quote=&quot;The Pixie&quot;:2dz90jf9]Would a translation program be possible? It would mean maintaining two versions of libraries.[/quote:2dz90jf9]\nA translation program would mean we wouldn't need to maintain two different libraries. The alternate choice would just to keep Flee around for older games. This would be the most compatible choice obviously, but adds a level of complexity. Luckily, we would never have to touch Flee again.\n\nA translation program between the two formats wouldn't be inherently difficult. I will see about adding it to my queue of things to do. Since I am the one suggesting this, probably will be the one who ends up writing it.\n\n[code:2dz90jf9]\nBasic rules for updating (subject to tweaking of course)&#58;\nchange every = to == unless it is by itself on a line and the lvalue is an identifier\nchange every and outside of an if statement into an '&amp;'\nchange every or outside of an if statement into an '|'\nchange every ^ to whatever syntax we choose\nchange every xor to ^\n[/code:2dz90jf9]\n\n[quote=&quot;The Pixie&quot;:2dz90jf9]Would it be possible to update flee to use both the new and old syntax as a first step?[/quote:2dz90jf9]\nShort answer. No.\n\nMedium answer. It would probably be easier to update NCalc to guess at '=' and '='.\n\nLong answer. I really don't want to. [i:2dz90jf9]I already tried[/i:2dz90jf9], in fact [i:2dz90jf9]it was the first thing I tried[/i:2dz90jf9]. Before I even knew NCalc existed. Any change requires a dozen changes in other places, and the errors added up very quickly. That was just trying to separate the bitwise and logical 'and' and 'or' from each other.  That is to say, Flee is a maintenance nightmare.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>The Pixie wrote:</cite>I like the sound of this. += etc. would be a great addition to Quest, and I would prefer == for equality as it would be the same as every other langiage I use, and I would feel more confident return (a == b) was returning a boolean, rather than b.</blockquote><br/>I prefer '==' as well.<br/><br/><blockquote><cite>The Pixie wrote:</cite>I would want to have some operator for raising to the power; it occasionally useful.</blockquote><br/>What do you think of <span style=\"font-weight:bold;\">b = 2 pow 4</span> syntax wise? <br/>The only other ways I see it done are <span style=\"font-weight:bold;\">b = 2 ** 4</span> and <span style=\"font-weight:bold;\">b = 2 ^^ 4</span>, and of course <span style=\"font-weight:bold;\">b = 2 ^ 4</span>.<br/><br/>In my humble opinion symbol based causes less confusion in the code, but ultimately not my decision. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/><blockquote><cite>The Pixie wrote:</cite>Would a translation program be possible? It would mean maintaining two versions of libraries.</blockquote><br/>A translation program would mean we wouldn't need to maintain two different libraries. The alternate choice would just to keep Flee around for older games. This would be the most compatible choice obviously, but adds a level of complexity. Luckily, we would never have to touch Flee again.<br/><br/>A translation program between the two formats wouldn't be inherently difficult. I will see about adding it to my queue of things to do. Since I am the one suggesting this, probably will be the one who ends up writing it.<br/><br/><pre><code><br/>Basic rules for updating (subject to tweaking of course)&#58;<br/>change every = to == unless it is by itself on a line and the lvalue is an identifier<br/>change every and outside of an if statement into an '&amp;'<br/>change every or outside of an if statement into an '|'<br/>change every ^ to whatever syntax we choose<br/>change every xor to ^<br/></code></pre><br/><br/><blockquote><cite>The Pixie wrote:</cite>Would it be possible to update flee to use both the new and old syntax as a first step?</blockquote><br/>Short answer. No.<br/><br/>Medium answer. It would probably be easier to update NCalc to guess at '=' and '='.<br/><br/>Long answer. I really don't want to. <span style=\"font-style:italic;\">I already tried</span>, in fact <span style=\"font-style:italic;\">it was the first thing I tried</span>. Before I even knew NCalc existed. Any change requires a dozen changes in other places, and the errors added up very quickly. That was just trying to separate the bitwise and logical 'and' and 'or' from each other.  That is to say, Flee is a maintenance nightmare.",
      "PostDate": "2012-10-15T09:27:27+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21565",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "Just a few thoughts...\n\nI would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.\n\nIn any case I would like to keep FLEE for older game versions. We should use a factory to create Expression objects, then games with WorldModelVersion &lt;= v530 (for example) could use FLEE and newer games can use the new expression evaluator. (This would be a change for v5.4 or later as v5.3 is big enough as it is)\n\nWe do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.\n\nDoes NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.\n\nIt would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.",
      "EditableFormat": "bbcode",
      "HTML": "Just a few thoughts...<br/><br/>I would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.<br/><br/>In any case I would like to keep FLEE for older game versions. We should use a factory to create Expression objects, then games with WorldModelVersion &lt;= v530 (for example) could use FLEE and newer games can use the new expression evaluator. (This would be a change for v5.4 or later as v5.3 is big enough as it is)<br/><br/>We do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.<br/><br/>Does NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.<br/><br/>It would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.",
      "PostDate": "2012-10-15T12:21:25+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21572",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "[quote=&quot;Alex&quot;:ijq74ke3]I would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.[/quote:ijq74ke3]\n\nI would like a version that has a more advanced syntax, such as a library writer wants to be able to do b = 6 * ( a-= 4) or something. Not sure if a hidden toggle would be viable. Such as a scripting attribute on the asl tag. It would mean it would open the platform to more serious programmers who wouldn't want to be burdened by the restrictions of a simpler syntax.\n\nJust means in you would do less script translation for them or their libraries.\n\n(P.S. I am such a user.)\n\n[quote=&quot;Alex&quot;:ijq74ke3]In any case I would like to keep FLEE for older game versions. We should use a factory to create Expression objects, then games with WorldModelVersion &lt;= v530 (for example) could use FLEE and newer games can use the new expression evaluator. (This would be a change for v5.4 or later as v5.3 is big enough as it is)[/quote:ijq74ke3]\n\nWell keeping FLEE for older games would be the most compatible.\n\n[quote=&quot;Alex&quot;:ijq74ke3]We do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.[/quote:ijq74ke3]\n\nIt is only rare for beginners. It can save a great deal of effort in some routines. See the first point.\n\nAs for spaces in identifiers. NCalc might be able to be modified to allow that natively, since it only handles the expressions. Since spaces are only whitespace, if it sees (identifier) (some amount of spaces) (identifier) it would know it is all one identifier. However identifiers starting or ending with spaces would be right out.\n\nHave I mentioned modifying the grammar is easy?\n\n[quote=&quot;Alex&quot;:ijq74ke3]Does NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.[/quote:ijq74ke3]\nNCalc has no idea what dot notation is. Adding it however is not a problem and actually easily done. It could even be done in the parser. Could have it directly ask Quest.. &quot;What is 'player' 'parent' 'name'&quot;. or it could just pass the 'player.parent.name' variable request directly to quest.\n\nI not sure I want to use the internal variable storage of NCalc, since it isn't very accessible, and could just pass all variable read and write requests to Quest to handle.\n\n[quote=&quot;Alex&quot;:ijq74ke3]It would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.[/quote:ijq74ke3]\n\nWell it depends if you currently cache the bytecode results from FLEE, or if FLEE does it automatically. NCalc has a built in cache system for post parsed expressions, but doesn't use IL, but rather tree evaluation. This would only likely effect repeat evaluation, since the slowest part of any expression evaluator is its parsing. Antlr isn't known for it's speed, but it is likely as fast as any other LL parser (Grammatica).\n\nIf IL is a required part of it (like for say, the Web Player scripting, which couldn't handle parsing trees very easily), adding it to NCalc is very easy, as it already tree walks.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Alex wrote:</cite>I would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.</blockquote><br/><br/>I would like a version that has a more advanced syntax, such as a library writer wants to be able to do b = 6 * ( a-= 4) or something. Not sure if a hidden toggle would be viable. Such as a scripting attribute on the asl tag. It would mean it would open the platform to more serious programmers who wouldn't want to be burdened by the restrictions of a simpler syntax.<br/><br/>Just means in you would do less script translation for them or their libraries.<br/><br/>(P.S. I am such a user.)<br/><br/><blockquote><cite>Alex wrote:</cite>In any case I would like to keep FLEE for older game versions. We should use a factory to create Expression objects, then games with WorldModelVersion &lt;= v530 (for example) could use FLEE and newer games can use the new expression evaluator. (This would be a change for v5.4 or later as v5.3 is big enough as it is)</blockquote><br/><br/>Well keeping FLEE for older games would be the most compatible.<br/><br/><blockquote><cite>Alex wrote:</cite>We do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.</blockquote><br/><br/>It is only rare for beginners. It can save a great deal of effort in some routines. See the first point.<br/><br/>As for spaces in identifiers. NCalc might be able to be modified to allow that natively, since it only handles the expressions. Since spaces are only whitespace, if it sees (identifier) (some amount of spaces) (identifier) it would know it is all one identifier. However identifiers starting or ending with spaces would be right out.<br/><br/>Have I mentioned modifying the grammar is easy?<br/><br/><blockquote><cite>Alex wrote:</cite>Does NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.</blockquote><br/>NCalc has no idea what dot notation is. Adding it however is not a problem and actually easily done. It could even be done in the parser. Could have it directly ask Quest.. &quot;What is 'player' 'parent' 'name'&quot;. or it could just pass the 'player.parent.name' variable request directly to quest.<br/><br/>I not sure I want to use the internal variable storage of NCalc, since it isn't very accessible, and could just pass all variable read and write requests to Quest to handle.<br/><br/><blockquote><cite>Alex wrote:</cite>It would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.</blockquote><br/><br/>Well it depends if you currently cache the bytecode results from FLEE, or if FLEE does it automatically. NCalc has a built in cache system for post parsed expressions, but doesn't use IL, but rather tree evaluation. This would only likely effect repeat evaluation, since the slowest part of any expression evaluator is its parsing. Antlr isn't known for it's speed, but it is likely as fast as any other LL parser (Grammatica).<br/><br/>If IL is a required part of it (like for say, the Web Player scripting, which couldn't handle parsing trees very easily), adding it to NCalc is very easy, as it already tree walks.",
      "PostDate": "2012-10-16T00:22:47+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21575",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "[quote=&quot;Chase&quot;:18e3fn6z][quote=&quot;Alex&quot;:18e3fn6z]I would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.[/quote:18e3fn6z]\n\nI would like a version that has a more advanced syntax, such as a library writer wants to be able to do b = 6 * ( a-= 4) or something. Not sure if a hidden toggle would be viable. Such as a scripting attribute on the asl tag. It would mean it would open the platform to more serious programmers who wouldn't want to be burdened by the restrictions of a simpler syntax.\n[/quote:18e3fn6z]\n\nI suppose what I really mean is that the new syntax should add to, rather than change, the existing expression syntax. It will be confusing if people have to change &quot;=&quot; to &quot;==&quot; with a new version for example.\n\nI can see the argument for adding an attribute to the asl tag, but I think this will cause confusion - there would have to be two different versions for each code sample that somebody posted to the forum, for example.\n\n[quote:18e3fn6z]\n[quote=&quot;Alex&quot;:18e3fn6z]We do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.[/quote:18e3fn6z]\n\nIt is only rare for beginners. It can save a great deal of effort in some routines. See the first point.\n[/quote:18e3fn6z]\n\nI can see that using -= and += in an expression can be useful, and this could be added while retaining full compatibility with existing expressions. So I'd be fine with that.\n\nI don't see the point of using single-equals for assignment within an expression though, so I think we can keep using single-equals for equality.\n\n[quote:18e3fn6z]\nAs for spaces in identifiers. NCalc might be able to be modified to allow that natively, since it only handles the expressions. Since spaces are only whitespace, if it sees (identifier) (some amount of spaces) (identifier) it would know it is all one identifier. However identifiers starting or ending with spaces would be right out.\n[/quote:18e3fn6z]\n\nSounds good. The only thing to watch out for are operators such as &quot;and&quot; and &quot;or&quot;. Quest joins words together as part of a single identifier, except where one of the words is one of these keywords. Not sure how easy it would be for NCalc to take that into account. It also means we have to be careful about adding new operators - although I think something like &quot;pow&quot; is unlikely to cause problems. But we should prefer symbols as far as possible.\n\n[quote:18e3fn6z]\n[quote=&quot;Alex&quot;:18e3fn6z]Does NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.[/quote:18e3fn6z]\nNCalc has no idea what dot notation is. Adding it however is not a problem and actually easily done. It could even be done in the parser. Could have it directly ask Quest.. &quot;What is 'player' 'parent' 'name'&quot;. or it could just pass the 'player.parent.name' variable request directly to quest.\n[/quote:18e3fn6z]\n\nExcellent - there's currently a workaround to make this work with FLEE, so anything that makes the code simpler (at least for newer games) is great.\n\n[quote:18e3fn6z]\n[quote=&quot;Alex&quot;:18e3fn6z]It would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.[/quote:18e3fn6z]\n\nWell it depends if you currently cache the bytecode results from FLEE, or if FLEE does it automatically. NCalc has a built in cache system for post parsed expressions, but doesn't use IL, but rather tree evaluation. This would only likely effect repeat evaluation, since the slowest part of any expression evaluator is its parsing. Antlr isn't known for it's speed, but it is likely as fast as any other LL parser (Grammatica).\n\nIf IL is a required part of it (like for say, the Web Player scripting, which couldn't handle parsing trees very easily), adding it to NCalc is very easy, as it already tree walks.[/quote:18e3fn6z]\n\nWe compile with FLEE the first time an expression is evaluated, and recompile if any of the types in the expression have changed. This applies to both desktop and WebPlayer as the back-end is exactly the same (web-based games run on the server - only UI stuff happens on the client).\n\nI guess we will only really know once there is an NCalc version of the code, then some performance profiling can be done.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Chase wrote:</cite><blockquote><p><b>&quot;Alex&quot;</b></p><p>I would like to keep the syntax as similar as possible, otherwise there will be problems when people upgrade their games from an older version of Quest.</blockquote><br/><br/>I would like a version that has a more advanced syntax, such as a library writer wants to be able to do b = 6 * ( a-= 4) or something. Not sure if a hidden toggle would be viable. Such as a scripting attribute on the asl tag. It would mean it would open the platform to more serious programmers who wouldn't want to be burdened by the restrictions of a simpler syntax.<br/></p></blockquote><br/><br/>I suppose what I really mean is that the new syntax should add to, rather than change, the existing expression syntax. It will be confusing if people have to change &quot;=&quot; to &quot;==&quot; with a new version for example.<br/><br/>I can see the argument for adding an attribute to the asl tag, but I think this will cause confusion - there would have to be two different versions for each code sample that somebody posted to the forum, for example.<br/><br/><blockquote><p><br/><blockquote><cite>Alex wrote:</cite>We do some amount of pre-processing of expressions anyway, which enables us to handle things like spaces in object names. This means even if the expression evaluator requires double-equals, we can keep the Quest syntax using single-equals, and simply convert internally when the expression is loaded. I prefer single-equals for Quest as the language is designed to be easy for beginners, and it seems rare that one would want to use assignment in the middle of an expression.</blockquote><br/><br/>It is only rare for beginners. It can save a great deal of effort in some routines. See the first point.<br/></p></blockquote><br/><br/>I can see that using -= and += in an expression can be useful, and this could be added while retaining full compatibility with existing expressions. So I'd be fine with that.<br/><br/>I don't see the point of using single-equals for assignment within an expression though, so I think we can keep using single-equals for equality.<br/><br/><blockquote><p><br/>As for spaces in identifiers. NCalc might be able to be modified to allow that natively, since it only handles the expressions. Since spaces are only whitespace, if it sees (identifier) (some amount of spaces) (identifier) it would know it is all one identifier. However identifiers starting or ending with spaces would be right out.<br/></p></blockquote><br/><br/>Sounds good. The only thing to watch out for are operators such as &quot;and&quot; and &quot;or&quot;. Quest joins words together as part of a single identifier, except where one of the words is one of these keywords. Not sure how easy it would be for NCalc to take that into account. It also means we have to be careful about adding new operators - although I think something like &quot;pow&quot; is unlikely to cause problems. But we should prefer symbols as far as possible.<br/><br/><blockquote><p><br/><blockquote><cite>Alex wrote:</cite>Does NCalc give us control over object dot notation? That has always been a bit of a pain with FLEE and the current workaround is a bit cumbersome.</blockquote><br/>NCalc has no idea what dot notation is. Adding it however is not a problem and actually easily done. It could even be done in the parser. Could have it directly ask Quest.. &quot;What is 'player' 'parent' 'name'&quot;. or it could just pass the 'player.parent.name' variable request directly to quest.<br/></p></blockquote><br/><br/>Excellent - there's currently a workaround to make this work with FLEE, so anything that makes the code simpler (at least for newer games) is great.<br/><br/><blockquote><p><br/><blockquote><cite>Alex wrote:</cite>It would be worthwhile doing a performance comparison, as of course the expression evaluator is used very heavily.</blockquote><br/><br/>Well it depends if you currently cache the bytecode results from FLEE, or if FLEE does it automatically. NCalc has a built in cache system for post parsed expressions, but doesn't use IL, but rather tree evaluation. This would only likely effect repeat evaluation, since the slowest part of any expression evaluator is its parsing. Antlr isn't known for it's speed, but it is likely as fast as any other LL parser (Grammatica).<br/><br/>If IL is a required part of it (like for say, the Web Player scripting, which couldn't handle parsing trees very easily), adding it to NCalc is very easy, as it already tree walks.</p></blockquote><br/><br/>We compile with FLEE the first time an expression is evaluated, and recompile if any of the types in the expression have changed. This applies to both desktop and WebPlayer as the back-end is exactly the same (web-based games run on the server - only UI stuff happens on the client).<br/><br/>I guess we will only really know once there is an NCalc version of the code, then some performance profiling can be done.",
      "PostDate": "2012-10-16T12:47:27+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21576",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "[quote=&quot;Alex&quot;:3872r75v]\nI suppose what I really mean is that the new syntax should add to, rather than change, the existing expression syntax. It will be confusing if people have to change &quot;=&quot; to &quot;==&quot; with a new version for example. I can see the argument for adding an attribute to the asl tag, but I think this will cause confusion - there would have to be two different versions for each code sample that somebody posted to the forum, for example.\n\nI can see that using -= and += in an expression can be useful, and this could be added while retaining full compatibility with existing expressions. So I'd be fine with that. I don't see the point of using single-equals for assignment within an expression though, so I think we can keep using single-equals for equality.[/quote:3872r75v]\n\nOkay okay, I relent. I guess I can deal with = double duty. Which I can think of a few cases where just '=' inside can be used. I guess having it out makes the code easier to read.\n\n[quote=&quot;Alex&quot;:3872r75v]Sounds good. The only thing to watch out for are operators such as &quot;and&quot; and &quot;or&quot;. Quest joins words together as part of a single identifier, except where one of the words is one of these keywords. Not sure how easy it would be for NCalc to take that into account. It also means we have to be careful about adding new operators - although I think something like &quot;pow&quot; is unlikely to cause problems. But we should prefer symbols as far as possible.[/quote:3872r75v]\n\nAnd and Or are only a problem if they are by themselves, surrounded by spaces. &quot;man named andy&quot; would by okay, as would 'more powerful axe', even 'this andor that' would be okey-dokey by the parser. In fact, even &quot;this and_or that&quot;. What would not be okay would be something like &quot;he or she&quot; or &quot;them and me&quot;. Get what I mean?\n\nAlternatively, we could just surround the entire variable in some kind of bracket before sending it to the expression parser, so that &quot;them and me&quot; becomes &quot;[them and me]&quot; and I can configure the parser not to give a hoot. Means you could even have &quot;1 % 2 and 3 + 78 = 43&quot; as a variable name and it would be okay with that (though I have no idea how you would work that into the asl side).\n\n[quote=&quot;Alex&quot;:3872r75v]\nWe compile with FLEE the first time an expression is evaluated, and recompile if any of the types in the expression have changed. This applies to both desktop and WebPlayer as the back-end is exactly the same (web-based games run on the server - only UI stuff happens on the client).[/quote:3872r75v]\n\nIn theory, with in NCalc you would not have to recompile the tree if the type changes. If I configure the IL right, not even if we go the IL route.\n\n[quote=&quot;Alex&quot;:3872r75v]I guess we will only really know once there is an NCalc version of the code, then some performance profiling can be done.[/quote:3872r75v]\n\nYeah sorry, gotta eat, so gotta work (for money). I'll see what I can hammer out tomorrow.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Alex wrote:</cite><br/>I suppose what I really mean is that the new syntax should add to, rather than change, the existing expression syntax. It will be confusing if people have to change &quot;=&quot; to &quot;==&quot; with a new version for example. I can see the argument for adding an attribute to the asl tag, but I think this will cause confusion - there would have to be two different versions for each code sample that somebody posted to the forum, for example.<br/><br/>I can see that using -= and += in an expression can be useful, and this could be added while retaining full compatibility with existing expressions. So I'd be fine with that. I don't see the point of using single-equals for assignment within an expression though, so I think we can keep using single-equals for equality.</blockquote><br/><br/>Okay okay, I relent. I guess I can deal with = double duty. Which I can think of a few cases where just '=' inside can be used. I guess having it out makes the code easier to read.<br/><br/><blockquote><cite>Alex wrote:</cite>Sounds good. The only thing to watch out for are operators such as &quot;and&quot; and &quot;or&quot;. Quest joins words together as part of a single identifier, except where one of the words is one of these keywords. Not sure how easy it would be for NCalc to take that into account. It also means we have to be careful about adding new operators - although I think something like &quot;pow&quot; is unlikely to cause problems. But we should prefer symbols as far as possible.</blockquote><br/><br/>And and Or are only a problem if they are by themselves, surrounded by spaces. &quot;man named andy&quot; would by okay, as would 'more powerful axe', even 'this andor that' would be okey-dokey by the parser. In fact, even &quot;this and_or that&quot;. What would not be okay would be something like &quot;he or she&quot; or &quot;them and me&quot;. Get what I mean?<br/><br/>Alternatively, we could just surround the entire variable in some kind of bracket before sending it to the expression parser, so that &quot;them and me&quot; becomes &quot;[them and me]&quot; and I can configure the parser not to give a hoot. Means you could even have &quot;1 % 2 and 3 + 78 = 43&quot; as a variable name and it would be okay with that (though I have no idea how you would work that into the asl side).<br/><br/><blockquote><cite>Alex wrote:</cite><br/>We compile with FLEE the first time an expression is evaluated, and recompile if any of the types in the expression have changed. This applies to both desktop and WebPlayer as the back-end is exactly the same (web-based games run on the server - only UI stuff happens on the client).</blockquote><br/><br/>In theory, with in NCalc you would not have to recompile the tree if the type changes. If I configure the IL right, not even if we go the IL route.<br/><br/><blockquote><cite>Alex wrote:</cite>I guess we will only really know once there is an NCalc version of the code, then some performance profiling can be done.</blockquote><br/><br/>Yeah sorry, gotta eat, so gotta work (for money). I'll see what I can hammer out tomorrow.",
      "PostDate": "2012-10-16T16:11:22+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21582",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "I decided to go with the [ and ] method, and reserving normal identifiers only for functions. This simplifies problems with spaces and even starting or ending variables with spaces.\n\nCurrent Prototype Output\n[code:3dcmlb7i]\n&#91;a&#93; = 4 =&gt; 4\n2 * (3 + 5) =&gt; 16\n2 * (2*(2*(2+1))) =&gt; 24\n10 % 3 =&gt; 1\nfalse or not (false and true) =&gt; True\n3 &gt; 2 and 1 &lt;= (3-2) =&gt; True\n3 % 2 != 10 % 3 =&gt; 1\n3 and 4 =&gt; True\n&#91;age&#93; =&gt; 14\n&#91; no really and     what be or age? &#93; =&gt; 24\n&#91;age&#93; &gt;= 18 =&gt; False\nif( &#91;age&#93; &gt;= 18, 'majeur', 'mineur') =&gt; mineur\nif( &#91;age&#93;+6 &gt;= 18, 'majeur', 'mineur') =&gt; majeur\n[/code:3dcmlb7i]\n\nI went with the [ and ] method. Since it was something that NCalc had originally anyway and it makes sense here. It also simplifies the identifier lexer code by a great deal. The only illegal character within a variable name is now ']', which I am sure we could come up with a simple way to fix if needed. This would need to be retweaked if you wanted to add say [expression] based arrays.\n\nI do not honestly expect Quest to be able to support the full range of characters NClac variables can have. Since quest code does not have [ and ] delimiting, and uses dot notation. But [_@#$a-zA-Z0-9]([ ]*[_@#$a-zA-Z0-9]+)* is realistic.\n\nFunction names follow the old rules, that is to say function names are limited to being [_a-zA-Z][_a-zA-Z0-9]*\n\nCurrently the only bug currently is:\n[code:3dcmlb7i]3 % 2 != 10 % 3 =&gt; 1[/code:3dcmlb7i]\nWhich I need to look into.\n\n\nCurrent built in functions are\n[code:3dcmlb7i]\nAbs\nAcos\nAsin\nAtan\nCeiling\nCos\nExp\nFloor\nIEEERemainder\nLog\nLog10\nPow\nRound\nSign\nSin\nSqrt\nTan\nTruncate\nMax\nMin\nif\nin\n[/code:3dcmlb7i]\n\nThese can be however easily renamed, removed, added to or altered.",
      "EditableFormat": "bbcode",
      "HTML": "I decided to go with the [ and ] method, and reserving normal identifiers only for functions. This simplifies problems with spaces and even starting or ending variables with spaces.<br/><br/>Current Prototype Output<br/><pre><code><br/>&#91;a&#93; = 4 =&gt; 4<br/>2 * (3 + 5) =&gt; 16<br/>2 * (2*(2*(2+1))) =&gt; 24<br/>10 % 3 =&gt; 1<br/>false or not (false and true) =&gt; True<br/>3 &gt; 2 and 1 &lt;= (3-2) =&gt; True<br/>3 % 2 != 10 % 3 =&gt; 1<br/>3 and 4 =&gt; True<br/>&#91;age&#93; =&gt; 14<br/>&#91; no really and     what be or age? &#93; =&gt; 24<br/>&#91;age&#93; &gt;= 18 =&gt; False<br/>if( &#91;age&#93; &gt;= 18, 'majeur', 'mineur') =&gt; mineur<br/>if( &#91;age&#93;+6 &gt;= 18, 'majeur', 'mineur') =&gt; majeur<br/></code></pre><br/><br/>I went with the [ and ] method. Since it was something that NCalc had originally anyway and it makes sense here. It also simplifies the identifier lexer code by a great deal. The only illegal character within a variable name is now ']', which I am sure we could come up with a simple way to fix if needed. This would need to be retweaked if you wanted to add say [expression] based arrays.<br/><br/>I do not honestly expect Quest to be able to support the full range of characters NClac variables can have. Since quest code does not have [ and ] delimiting, and uses dot notation. But [_@#$a-zA-Z0-9]([ ]*[_@#$a-zA-Z0-9]+)* is realistic.<br/><br/>Function names follow the old rules, that is to say function names are limited to being [_a-zA-Z][_a-zA-Z0-9]*<br/><br/>Currently the only bug currently is:<br/><pre><code>3 % 2 != 10 % 3 =&gt; 1</code></pre><br/>Which I need to look into.<br/><br/><br/>Current built in functions are<br/><pre><code><br/>Abs<br/>Acos<br/>Asin<br/>Atan<br/>Ceiling<br/>Cos<br/>Exp<br/>Floor<br/>IEEERemainder<br/>Log<br/>Log10<br/>Pow<br/>Round<br/>Sign<br/>Sin<br/>Sqrt<br/>Tan<br/>Truncate<br/>Max<br/>Min<br/>if<br/>in<br/></code></pre><br/><br/>These can be however easily renamed, removed, added to or altered.",
      "PostDate": "2012-10-17T20:59:26+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21584",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "I completely forgot Quest syntax, so that != wasn't working because Quest doesn't have a symbol for !=. Not Equals is only &lt;&gt;.\n\n[code:2eesx8na]\n3 % 2 =&gt; 1\n10 % 3 =&gt; 1\n3 % 2 == 10 % 3 =&gt; True\n3 % 2 &lt;&gt; 10 % 3 =&gt; False\n[/code:2eesx8na]\n\nIt didn't complain at all, so I am wondering it that is a good thing or a bad thing.\n\nI am not sure how it handles it currently, so reverting it might require some diving into exactly why it ignores the errors. I know in the Java version of Antlr parsers and lexers, errors are thrown, so it either C# or something NCalc does.",
      "EditableFormat": "bbcode",
      "HTML": "I completely forgot Quest syntax, so that != wasn't working because Quest doesn't have a symbol for !=. Not Equals is only &lt;&gt;.<br/><br/><pre><code><br/>3 % 2 =&gt; 1<br/>10 % 3 =&gt; 1<br/>3 % 2 == 10 % 3 =&gt; True<br/>3 % 2 &lt;&gt; 10 % 3 =&gt; False<br/></code></pre><br/><br/>It didn't complain at all, so I am wondering it that is a good thing or a bad thing.<br/><br/>I am not sure how it handles it currently, so reverting it might require some diving into exactly why it ignores the errors. I know in the Java version of Antlr parsers and lexers, errors are thrown, so it either C# or something NCalc does.",
      "PostDate": "2012-10-17T21:50:52+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21586",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Well I got it to compile with NCalc, however that means nothing what so ever, since I don't correctly handle Expression&lt;T&gt; yet. Since I don't use C# I am not sure how to dynamically convert obj to T if obj is not already T.\n\nI honestly have no idea what all the type gobbly gook is for, so I likely gummed things up there.\n\nInside Expression&lt;T&gt;\n[code:1q8jghmz]\npublic T Execute(Context c)\n{\n\tNCalc&#46;Expression expr = new NCalc&#46;Expression(m_expression);\n\texpr&#46;EvaluateFunction += m_scriptContext&#46;EvaluateFunctionHandler;\n\texpr&#46;EvaluateVariable += m_scriptContext&#46;EvaluateVariableHandler;\n\n\tobject obj = expr&#46;Evaluate();\n\n\t//this will likely not work, but lets do it anyway\n\treturn (T)obj;\n}\n[/code:1q8jghmz]\n\nInside ExpressionGeneric\n[code:1q8jghmz]\npublic object Execute(Context c)\n{\n\tNCalc&#46;Expression expr = new NCalc&#46;Expression(m_expression);\n\texpr&#46;EvaluateFunction += m_scriptContext&#46;EvaluateFunctionHandler;\n\texpr&#46;EvaluateVariable += m_scriptContext&#46;EvaluateVariableHandler;\n\t//seems sane enough\n\treturn expr&#46;Evaluate();\n}\n[/code:1q8jghmz]\n\nInside ScriptContext\n[code:1q8jghmz]\n/**\n * Connector for NCalc function calls&#46;\n */\nprivate void FunctionHandler(string name, FunctionArgs args)\n{\n\tElement proc = m_worldModel&#46;Procedure(name);\n\tParameters parameters = new Parameters();\n\n\tint cnt = 0;\n\n\t// TO DO&#58; Check number of parameters matches\n\tforeach (object val in args&#46;EvaluateParameters())\n\t\tparameters&#46;Add((string)proc&#46;Fields&#91;FieldDefinitions&#46;ParamNames&#93;&#91;cnt++&#93;, val);\n\n\targs&#46;Result = m_worldModel&#46;RunProcedure(name, parameters, true);\n}\n\n/**\n * Connector for NCalc variable calls&#46;\n */\nprivate void VariableHandler(string name, VariableArgs args)\n{\n\tif (args&#46;IsAssignment)\n\t{\n\t\t//This will probably not work, but not sure how quest handles this yet\n\t\tm_context&#46;Parameters&#91;name&#93; = args&#46;Result;\n\t}\n\telse\n\t{\n\t\targs&#46;Result = ResolveVariable(name);\n\t}\n}\n[/code:1q8jghmz]\n\n\nIf you want to try it yourself, here is the newest version of my (heavily) modified NCalc.\n\n[url=http&#58;//www&#46;mediafire&#46;com/?e7ej9dovt8l6tu1:1q8jghmz]DOWNLOAD NCALC + SRC[/url:1q8jghmz]\n\n\nI am actually not sure how to go about testing to be honest. Not to mention modify it to do the required = to == conversion.",
      "EditableFormat": "bbcode",
      "HTML": "Well I got it to compile with NCalc, however that means nothing what so ever, since I don't correctly handle Expression&lt;T&gt; yet. Since I don't use C# I am not sure how to dynamically convert obj to T if obj is not already T.<br/><br/>I honestly have no idea what all the type gobbly gook is for, so I likely gummed things up there.<br/><br/>Inside Expression&lt;T&gt;<br/><pre><code><br/>public T Execute(Context c)<br/>{<br/>\tNCalc&#46;Expression expr = new NCalc&#46;Expression(m_expression);<br/>\texpr&#46;EvaluateFunction += m_scriptContext&#46;EvaluateFunctionHandler;<br/>\texpr&#46;EvaluateVariable += m_scriptContext&#46;EvaluateVariableHandler;<br/><br/>\tobject obj = expr&#46;Evaluate();<br/><br/>\t//this will likely not work, but lets do it anyway<br/>\treturn (T)obj;<br/>}<br/></code></pre><br/><br/>Inside ExpressionGeneric<br/><pre><code><br/>public object Execute(Context c)<br/>{<br/>\tNCalc&#46;Expression expr = new NCalc&#46;Expression(m_expression);<br/>\texpr&#46;EvaluateFunction += m_scriptContext&#46;EvaluateFunctionHandler;<br/>\texpr&#46;EvaluateVariable += m_scriptContext&#46;EvaluateVariableHandler;<br/>\t//seems sane enough<br/>\treturn expr&#46;Evaluate();<br/>}<br/></code></pre><br/><br/>Inside ScriptContext<br/><pre><code><br/>/**<br/> * Connector for NCalc function calls&#46;<br/> */<br/>private void FunctionHandler(string name, FunctionArgs args)<br/>{<br/>\tElement proc = m_worldModel&#46;Procedure(name);<br/>\tParameters parameters = new Parameters();<br/><br/>\tint cnt = 0;<br/><br/>\t// TO DO&#58; Check number of parameters matches<br/>\tforeach (object val in args&#46;EvaluateParameters())<br/>\t\tparameters&#46;Add((string)proc&#46;Fields&#91;FieldDefinitions&#46;ParamNames&#93;&#91;cnt++&#93;, val);<br/><br/>\targs&#46;Result = m_worldModel&#46;RunProcedure(name, parameters, true);<br/>}<br/><br/>/**<br/> * Connector for NCalc variable calls&#46;<br/> */<br/>private void VariableHandler(string name, VariableArgs args)<br/>{<br/>\tif (args&#46;IsAssignment)<br/>\t{<br/>\t\t//This will probably not work, but not sure how quest handles this yet<br/>\t\tm_context&#46;Parameters&#91;name&#93; = args&#46;Result;<br/>\t}<br/>\telse<br/>\t{<br/>\t\targs&#46;Result = ResolveVariable(name);<br/>\t}<br/>}<br/></code></pre><br/><br/><br/>If you want to try it yourself, here is the newest version of my (heavily) modified NCalc.<br/><br/><a href=\"http&#58;//www&#46;mediafire&#46;com/?e7ej9dovt8l6tu1\" rel=\"nofollow\">DOWNLOAD NCALC + SRC</a><br/><br/><br/>I am actually not sure how to go about testing to be honest. Not to mention modify it to do the required = to == conversion.",
      "PostDate": "2012-10-18T06:32:12+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21611",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Seems the [ and ] method isn't going to pan out, since it would require some work on the Quest side of things to get it to work. Right now I have it working with variables without spaces. But variables with spaces are being annoying.\n\nIn theory I could fix this by changing the identifier rule from a lexer to a parser rule. So until I have that working I don't want to hack on Quest to much more.\n\n\nCurrent rule definition is:\n[code:2zwubs99]\nfragment IdentFragment\n\t&#58; Letter (Letter | Digit)*\n\t;\n\nIdent\n\t&#58; IdentFragment+ ('&#46;' IdentFragment+)*\n\t;\n[/code:2zwubs99]",
      "EditableFormat": "bbcode",
      "HTML": "Seems the [ and ] method isn't going to pan out, since it would require some work on the Quest side of things to get it to work. Right now I have it working with variables without spaces. But variables with spaces are being annoying.<br/><br/>In theory I could fix this by changing the identifier rule from a lexer to a parser rule. So until I have that working I don't want to hack on Quest to much more.<br/><br/><br/>Current rule definition is:<br/><pre><code><br/>fragment IdentFragment<br/>\t&#58; Letter (Letter | Digit)*<br/>\t;<br/><br/>Ident<br/>\t&#58; IdentFragment+ ('&#46;' IdentFragment+)*<br/>\t;<br/></code></pre>",
      "PostDate": "2012-10-21T01:21:01+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21651",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "After watching <!-- m --><a class=\"postlink\" href=\"http://www.youtube.com/watch?v=taaEzHI9xyY\">http://www.youtube.com/watch?v=taaEzHI9xyY</a><!-- m --> which I recommend watching it if you are a programmer.\n\nI have decided to stop working on this as long as = is == and =. While this video is mostly about how a programmer can do better, I think we can allow the programmer to do better by making the language better.\n\nForms that can hide defects are considered defective.",
      "EditableFormat": "bbcode",
      "HTML": "After watching <!-- m --><a class=\"postlink\" href=\"http://www.youtube.com/watch?v=taaEzHI9xyY\">http://www.youtube.com/watch?v=taaEzHI9xyY</a><!-- m --> which I recommend watching it if you are a programmer.<br/><br/>I have decided to stop working on this as long as = is == and =. While this video is mostly about how a programmer can do better, I think we can allow the programmer to do better by making the language better.<br/><br/>Forms that can hide defects are considered defective.",
      "PostDate": "2012-10-23T07:05:37+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21668",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "What do you mean? Which bit of that video is relevant here...?",
      "EditableFormat": "bbcode",
      "HTML": "What do you mean? Which bit of that video is relevant here...?",
      "PostDate": "2012-10-25T19:25:25+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21671",
      "UserId": 0,
      "Username": "Chase",
      "UserAvatar": null,
      "UserGravatar": "29abae483578a869d52119c66622fd41",
      "EditableText": "Did you watch it?\n\nWell aside, = having two different uses based on context is more confusing then just having = and == having their own uses.\n\nMost of the entire reason I started working on NCalc was to get rid of that issue.\n\nSince you want to continue using flee anyway for older code, I don't see any real benefit to keeping the older style. You can still use what I have, and I will even post up the quest code modifications I have done.\n\nBut I don't really want to continue working on something that doesn't really do what I wanted it to do.",
      "EditableFormat": "bbcode",
      "HTML": "Did you watch it?<br/><br/>Well aside, = having two different uses based on context is more confusing then just having = and == having their own uses.<br/><br/>Most of the entire reason I started working on NCalc was to get rid of that issue.<br/><br/>Since you want to continue using flee anyway for older code, I don't see any real benefit to keeping the older style. You can still use what I have, and I will even post up the quest code modifications I have done.<br/><br/>But I don't really want to continue working on something that doesn't really do what I wanted it to do.",
      "PostDate": "2012-10-26T05:00:51+01:00",
      "LastEditDate": null
    }
  ]
}
