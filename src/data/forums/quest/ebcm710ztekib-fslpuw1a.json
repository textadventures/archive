{
  "Topic": {
    "TopicId": "ebcm710ztekib-fslpuw1a",
    "ForumId": "10",
    "Title": "Overriding core commands and verbs.",
    "LastUpdated": "2020-01-27T10:28:33.2724663Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "de2e0742-3beb-45d3-b106-4b08b28f6fc7",
      "UserId": 450907,
      "Username": "queste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b00b2ee33e6a23b1a02b67a5333569b4?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "In my project the player can die, but instead of ending the game the player effectively becomes a ghost. He can walk around, look at things but cannot, for example, take things or smell things.\r\n\r\nWith core commands (i.e take) I can copy them to my project and add a check to the script. \r\n\r\nWith core verbs (i.e smell) I can copy them and make the script editable, in attributes and add a check there.\r\n\r\nMy question is: Is this the best way to achieve what I want or is there an easier way of overriding commands and verbs under certain conditions.\r\n\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>In my project the player can die, but instead of ending the game the player effectively becomes a ghost. He can walk around, look at things but cannot, for example, take things or smell things.</p>\n<p>With core commands (i.e take) I can copy them to my project and add a check to the script.</p>\n<p>With core verbs (i.e smell) I can copy them and make the script editable, in attributes and add a check there.</p>\n<p>My question is: Is this the best way to achieve what I want or is there an easier way of overriding commands and verbs under certain conditions.</p>\n\n",
      "PostDate": "2020-01-27T10:28:33.2724663Z",
      "LastEditDate": "2020-01-27T11:40:21.3114594Z",
      "link": null
    },
    {
      "PostId": "812a1acd-83cb-40cc-996b-6ef58f0ec37b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That seems like a fairly common way to do it. There are two other options that come to mind; which one is easiest will depend on your use cases.\r\n\r\n1. Commands that are in a room override global commands, but only apply when the player is in that room. So you could create a separate set of ghost commands for when the player is dead, and put them in an unreachable room somewhere (like a holding area)\r\nWhen the player dies, you would move those commands to be global (`cmd.parent = null`), and either move the standard commands to the holding area, or destroy them.\r\n\r\n2. You could give some commands an extra script attribute for its behaviour when the player is dead; call it `ghost_script`. Then when the player dies: <pre><code>foreach (cmd, AllCommands()) {<br/>  if (HasScript (cmd, \"ghost_script\")) {<br/>    cmd.script = cmd.ghost_script<br/>  }<br/>}</code></pre>\r\n\r\n3. If you're just disabling commands:<pre><code>foreach (cmdname, Split(\"take;put;push;open;close;kick;use;eat\")) {<br/>  cmd = GetObject(cmdname)<br/>  cmd.script => {<br/>    msg (\"You can't do that, you're dead.\")<br/>  }<br/>}</code></pre>\r\n\r\nWhich one works best for you will likely depend on how many commands are involved, and how much change you want to make to them.\r\n\r\nIf you can come back to life after being a ghost, you could save the original behaviour in a separate script attribute.\r\nFor example, when the player dies you could run:\r\n```\r\nforeach (cmdname, Split(\"take;put;push;open;close;kick;use;eat\")) {\r\n  cmd = GetObject(cmdname)\r\n  cmd.alive_script = cmd.script\r\n  cmd.script => {\r\n    msg (\"You can't do that, you're dead.\")\r\n  }\r\n}\r\n```\r\nand when they come back to life:\r\n```\r\nforeach (cmd, AllCommands()) {\r\n  if (HasScript (cmd, \"alive_script\")) {\r\n    cmd.script = cmd.alive_script\r\n  }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>That seems like a fairly common way to do it. There are two other options that come to mind; which one is easiest will depend on your use cases.</p>\n<ol>\n<li>\n<p>Commands that are in a room override global commands, but only apply when the player is in that room. So you could create a separate set of ghost commands for when the player is dead, and put them in an unreachable room somewhere (like a holding area)<br>\nWhen the player dies, you would move those commands to be global (<code>cmd.parent = null</code>), and either move the standard commands to the holding area, or destroy them.</p>\n</li>\n<li>\n<p>You could give some commands an extra script attribute for its behaviour when the player is dead; call it <code>ghost_script</code>. Then when the player dies: </p><pre><code>foreach (cmd, AllCommands()) {<br>  if (HasScript (cmd, \"ghost_script\")) {<br>    cmd.script = cmd.ghost_script<br>  }<br>}</code></pre><p></p>\n</li>\n<li>\n<p>If you're just disabling commands:</p><pre><code>foreach (cmdname, Split(\"take;put;push;open;close;kick;use;eat\")) {<br>  cmd = GetObject(cmdname)<br>  cmd.script =&gt; {<br>    msg (\"You can't do that, you're dead.\")<br>  }<br>}</code></pre><p></p>\n</li>\n</ol>\n<p>Which one works best for you will likely depend on how many commands are involved, and how much change you want to make to them.</p>\n<p>If you can come back to life after being a ghost, you could save the original behaviour in a separate script attribute.<br>\nFor example, when the player dies you could run:</p>\n<pre><code>foreach (cmdname, Split(\"take;put;push;open;close;kick;use;eat\")) {\n  cmd = GetObject(cmdname)\n  cmd.alive_script = cmd.script\n  cmd.script =&gt; {\n    msg (\"You can't do that, you're dead.\")\n  }\n}\n</code></pre>\n<p>and when they come back to life:</p>\n<pre><code>foreach (cmd, AllCommands()) {\n  if (HasScript (cmd, \"alive_script\")) {\n    cmd.script = cmd.alive_script\n  }\n}\n</code></pre>\n\n",
      "PostDate": "2020-01-27T10:47:53.5052059Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "39d7b636-2f60-4870-9c60-22b20dee0dc1",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It's also worth noting that verbs are also commands: they just all have the same script (which is inherited from the `defaultverb` type), which just checks if the target object has a script for that verb, and runs it. So the above method with `Split(\"list of command names\")` works fine with verbs. This could end up being a lot quicker than including a check on every object that has a verb.\r\n\r\nIf you're doing more fancy things - for example, a ghost might be able to see some kind of spiritual aura around an object as well as looking at it normally, you could add something like:\r\n```\r\nlookat.alive_script = lookat.script\r\nlookat.script => {\r\n  do (this, \"alive_script\", game.pov.currentcommandresolvedelements)\r\n  if (HasScript (object, \"ghostlook\")) {\r\n    do (object, \"ghostlook\")\r\n  }\r\n  else if (HasString (object, \"ghostlook\")) {\r\n    msg (object.ghostlook)\r\n  }\r\n}\r\n```\r\nBy using `do (this, \"alive_script\", game.pov.currentcommandresolvedelements)` you can execute extra functions before (or after) the command's default behaviour, such as displaying an extra description. And because it uses the same `alive_script` attribute as the script above, it will work like magic with the \"coming back to life\" script above.",
      "EditableFormat": "markdown",
      "HTML": "<p>It's also worth noting that verbs are also commands: they just all have the same script (which is inherited from the <code>defaultverb</code> type), which just checks if the target object has a script for that verb, and runs it. So the above method with <code>Split(\"list of command names\")</code> works fine with verbs. This could end up being a lot quicker than including a check on every object that has a verb.</p>\n<p>If you're doing more fancy things - for example, a ghost might be able to see some kind of spiritual aura around an object as well as looking at it normally, you could add something like:</p>\n<pre><code>lookat.alive_script = lookat.script\nlookat.script =&gt; {\n  do (this, \"alive_script\", game.pov.currentcommandresolvedelements)\n  if (HasScript (object, \"ghostlook\")) {\n    do (object, \"ghostlook\")\n  }\n  else if (HasString (object, \"ghostlook\")) {\n    msg (object.ghostlook)\n  }\n}\n</code></pre>\n<p>By using <code>do (this, \"alive_script\", game.pov.currentcommandresolvedelements)</code> you can execute extra functions before (or after) the command's default behaviour, such as displaying an extra description. And because it uses the same <code>alive_script</code> attribute as the script above, it will work like magic with the \"coming back to life\" script above.</p>\n\n",
      "PostDate": "2020-01-27T10:58:50.3713301Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0f1592c7-7e2e-417b-8b9f-9063104362da",
      "UserId": 450907,
      "Username": "queste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b00b2ee33e6a23b1a02b67a5333569b4?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks mrangel, disabling commands is effectively what I'm doing so your third option looks like it will work best.\r\n\r\nThanks for the other examples.\r\n\r\ndo (this, \"alive_script\", game.pov.currentcommandresolvedelements)\r\n\r\nI can definitely make use  of this. thanks again.",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks mrangel, disabling commands is effectively what I'm doing so your third option looks like it will work best.</p>\n<p>Thanks for the other examples.</p>\n<p>do (this, \"alive_script\", game.pov.currentcommandresolvedelements)</p>\n<p>I can definitely make use  of this. thanks again.</p>\n\n",
      "PostDate": "2020-01-27T11:07:01.1005955Z",
      "LastEditDate": "2020-01-27T11:16:17.6499897Z",
      "link": null
    },
    {
      "PostId": "7d614dd2-4db1-4b37-933e-66c25eb20ea8",
      "UserId": 3327,
      "Username": "questste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/c43da520ee661d384ccd9600ba0e04dc?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Further to this:\r\n\r\nIs it possible to override all commands/verbs when dealing with a specific object. For example: a poisonous snake will kill you if you interact with it in any way.\r\n\r\nI could add a verb override for each verb in the objects verbs tab, commands are trickier. Is there an easy way using something similar to mrangel's solutions to my other query above?\r\n\r\nAnother possible solution would be a turnscript that actions before the players command is acted upon. Is this possible?",
      "EditableFormat": "markdown",
      "HTML": "<p>Further to this:</p>\n<p>Is it possible to override all commands/verbs when dealing with a specific object. For example: a poisonous snake will kill you if you interact with it in any way.</p>\n<p>I could add a verb override for each verb in the objects verbs tab, commands are trickier. Is there an easy way using something similar to mrangel's solutions to my other query above?</p>\n<p>Another possible solution would be a turnscript that actions before the players command is acted upon. Is this possible?</p>\n\n",
      "PostDate": "2020-02-20T14:37:01.1743443Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "64d20d44-4a06-427f-b673-bb3b8d21f2d9",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That sounds like it would be a useful feature to have; and should be relatively easy to implement in a way, if you don't mind editing one of the built-in functions. (In the desktop editor I believe you can copy the core functions so you can edit them). Off the top of my head:\r\n\r\n<details><summary>Click to see old code. The solution in my next post is better</summary>\r\n\r\n<pre><code>  &lt;function name=\"AddToResolvedNames\" parameters=\"var, result\">\r\n    if (TypeOf(result) = \"object\") {\r\n      if (result.type = \"object\") {\r\n        list add (game.pov.currentcommandresolvedobjects, result)\r\n<b style=\"border: 1px solid green; display: block\">        if (HasAttribute (result, \"limitcommands\")) {\r\n          if (not ListContains (result.limitcommands, game.pov.currentcommandpattern)) {\r\n            if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\r\n              dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\r\n            }\r\n            if (HasObject (result, \"defaultcommand\")) {\r\n              game.pov.currentcommandpattern = result.defaultcommand\r\n            }\r\n            else {\r\n              game.pov.currentcommandpattern = result\r\n            }\r\n            if (HasString (result, \"defaultcommandparameter\")) {\r\n              var = result.defaultcommandparameter\r\n            }\r\n          }\r\n        }</b>      }\r\n    }\r\n    else if (TypeOf(result) = \"objectlist\") {\r\n      foreach (obj, result) {\r\n        if (obj.type = \"object\") {\r\n          list add (game.pov.currentcommandresolvedobjects, obj)\r\n<b style=\"border: 1px solid green; display: block\">          if (HasAttribute (obj, \"limitcommands\")) {\r\n            if (not ListContains (obj.limitcommands, game.pov.currentcommandpattern)) {\r\n              if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\r\n                dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\r\n              }\r\n              if (HasObject (obj, \"defaultcommand\")) {\r\n                game.pov.currentcommandpattern = obj.defaultcommand\r\n              }\r\n              else {\r\n                game.pov.currentcommandpattern = obj\r\n              }\r\n              if (HasString (obj, \"defaultcommandparameter\")) {\r\n                var = obj.defaultcommandparameter\r\n              }\r\n            }\r\n          }</b>        }\r\n      }\r\n    }\r\n<b style=\"border: 1px solid green; display: block\">    if (DictionaryContains (game.pov.currentcommandresolvedelements, var)) {\r\n      dictionary remove (game.pov.currentcommandresolvedelements, var)\r\n    }</b>    dictionary add(game.pov.currentcommandresolvedelements, var, result)\r\n    ResolveNextName\r\n  &lt;/function></code></pre>\r\n\r\nWith that changed, you can then make a command or verb named something like \"annoy\", which will trigger an attack when used on the snake. If you don't want the player to have the option of deliberately annoying the snake, give the command the pattern (as a regular expression) `^$`.\r\n\r\nThen for the snake itself, set the attributes:\r\n\r\n* `snake.limitcommands` - an objectlist containing all the commands that the player can use normally (such as `lookat` or `charm`, for example)\r\n* `snake.defaultcommand` - the command which should be run instead of any command not on the limit list. In this case, `annoy`.\r\n* `snake.defaultcommandparameter` - the parameter which should be passed to the annoy command. This could be necessary because if the player types \"put snake in vase\", the snake will be in the variable `object1`; but if they type \"put sword in snake\", the snake will be in the variable `object2`. Setting `snake.defaultcommandparameter` to the string `\"object\"` means that the variable `object` will always refer to the snake.\r\n\r\n(usual disclaimer: code off the top of my head, not actually tested because I can't do this on the web editor)\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>That sounds like it would be a useful feature to have; and should be relatively easy to implement in a way, if you don't mind editing one of the built-in functions. (In the desktop editor I believe you can copy the core functions so you can edit them). Off the top of my head:</p>\n<details><summary>Click to see old code. The solution in my next post is better</summary>\n<pre><code>  &lt;function name=\"AddToResolvedNames\" parameters=\"var, result\"&gt;\n    if (TypeOf(result) = \"object\") {\n      if (result.type = \"object\") {\n        list add (game.pov.currentcommandresolvedobjects, result)\n<b style=\"border: 1px solid green; display: block\">        if (HasAttribute (result, \"limitcommands\")) {\n          if (not ListContains (result.limitcommands, game.pov.currentcommandpattern)) {\n            if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\n              dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\n            }\n            if (HasObject (result, \"defaultcommand\")) {\n              game.pov.currentcommandpattern = result.defaultcommand\n            }\n            else {\n              game.pov.currentcommandpattern = result\n            }\n            if (HasString (result, \"defaultcommandparameter\")) {\n              var = result.defaultcommandparameter\n            }\n          }\n        }</b>      }\n    }\n    else if (TypeOf(result) = \"objectlist\") {\n      foreach (obj, result) {\n        if (obj.type = \"object\") {\n          list add (game.pov.currentcommandresolvedobjects, obj)\n<b style=\"border: 1px solid green; display: block\">          if (HasAttribute (obj, \"limitcommands\")) {\n            if (not ListContains (obj.limitcommands, game.pov.currentcommandpattern)) {\n              if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\n                dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\n              }\n              if (HasObject (obj, \"defaultcommand\")) {\n                game.pov.currentcommandpattern = obj.defaultcommand\n              }\n              else {\n                game.pov.currentcommandpattern = obj\n              }\n              if (HasString (obj, \"defaultcommandparameter\")) {\n                var = obj.defaultcommandparameter\n              }\n            }\n          }</b>        }\n      }\n    }\n<b style=\"border: 1px solid green; display: block\">    if (DictionaryContains (game.pov.currentcommandresolvedelements, var)) {\n      dictionary remove (game.pov.currentcommandresolvedelements, var)\n    }</b>    dictionary add(game.pov.currentcommandresolvedelements, var, result)\n    ResolveNextName\n  &lt;/function&gt;</code></pre>\n<p>With that changed, you can then make a command or verb named something like \"annoy\", which will trigger an attack when used on the snake. If you don't want the player to have the option of deliberately annoying the snake, give the command the pattern (as a regular expression) <code>^$</code>.</p>\n<p>Then for the snake itself, set the attributes:</p>\n<ul>\n<li><code>snake.limitcommands</code> - an objectlist containing all the commands that the player can use normally (such as <code>lookat</code> or <code>charm</code>, for example)</li>\n<li><code>snake.defaultcommand</code> - the command which should be run instead of any command not on the limit list. In this case, <code>annoy</code>.</li>\n<li><code>snake.defaultcommandparameter</code> - the parameter which should be passed to the annoy command. This could be necessary because if the player types \"put snake in vase\", the snake will be in the variable <code>object1</code>; but if they type \"put sword in snake\", the snake will be in the variable <code>object2</code>. Setting <code>snake.defaultcommandparameter</code> to the string <code>\"object\"</code> means that the variable <code>object</code> will always refer to the snake.</li>\n</ul>\n<p>(usual disclaimer: code off the top of my head, not actually tested because I can't do this on the web editor)</p>\n</details>\n\n",
      "PostDate": "2020-02-20T16:10:47.6548656Z",
      "LastEditDate": "2020-02-21T14:38:05.8254458Z",
      "link": null
    },
    {
      "PostId": "2209569e-9df3-4c0b-bcc3-58f334172365",
      "UserId": 3327,
      "Username": "questste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/c43da520ee661d384ccd9600ba0e04dc?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks mrangel. I'm not exactly sure what is going on with your code and will take a bit of time to figure it out. One thing you have the limitcommands as an object list, that doesn't appear to be an option for an object attribute.\r\n\r\nThanks again, this gives me something to work with.",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks mrangel. I'm not exactly sure what is going on with your code and will take a bit of time to figure it out. One thing you have the limitcommands as an object list, that doesn't appear to be an option for an object attribute.</p>\n<p>Thanks again, this gives me something to work with.</p>\n\n",
      "PostDate": "2020-02-21T07:59:35.0967285Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2dec4b8d-c6fc-43be-9165-dc65bb7741e9",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "A better solution might be in the function `ResolveNextName`, look for this piece of code:\r\n<pre><code style=\"color:brown\">      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n        // This is the bit that actually runs the commands\r\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n      }</code></pre>\r\n\r\nAnd change to something like:\r\n<pre><code style=\"color:green\">      if (HasAttribute (game.pov, \"currentcommandresolvedobjects\")) {\r\n        if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\r\n          dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\r\n        }\r\n        foreach (obj, game.pov.currentcommandresolvedobjects) {\r\n          if (HasScript (obj, \"beforecommand\")) {\r\n            do (obj, \"beforecommand\", game.pov.currentcommandresolvedelements)\r\n          }\r\n        }\r\n      }\r\n      // check that 'beforecommand' scripts haven't cancelled the command\r\n      if (HasObject (game.pov, \"currentcommandpattern\")) {\r\n        if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n          // This is the bit that actually runs the commands\r\n          do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n        }\r\n      }</code></pre>\r\n\r\nThis would cause an object's `beforecommand` script attribute to be run before any command is used on it. This script can prevent the command from running by doing: `game.pov.currentcommandpattern = null` (or setting currentcommandpattern to a different command if you want to run something else instead).\r\n\r\nThis might be a better solution; checking through all the objects before running the command, rather than checking each as they're resolved.\r\n\r\nYour snake's `beforecommand` script could check the variable `command` against a list of commands such as `lookat` and `avoid` if you want those to work normally, and do something else otherwise.",
      "EditableFormat": "markdown",
      "HTML": "<p>A better solution might be in the function <code>ResolveNextName</code>, look for this piece of code:</p>\n<pre><code style=\"color: brown\">      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n        // This is the bit that actually runs the commands\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n      }</code></pre>\n<p>And change to something like:</p>\n<pre><code style=\"color: green\">      if (HasAttribute (game.pov, \"currentcommandresolvedobjects\")) {\n        if (not DictionaryContains (game.pov.currentcommandresolvedelements, \"command\")) {\n          dictionary add (game.pov.currentcommandresolvedelements, \"command\", game.pov.currentcommandpattern)\n        }\n        foreach (obj, game.pov.currentcommandresolvedobjects) {\n          if (HasScript (obj, \"beforecommand\")) {\n            do (obj, \"beforecommand\", game.pov.currentcommandresolvedelements)\n          }\n        }\n      }\n      // check that 'beforecommand' scripts haven't cancelled the command\n      if (HasObject (game.pov, \"currentcommandpattern\")) {\n        if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n          // This is the bit that actually runs the commands\n          do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n        }\n      }</code></pre>\n<p>This would cause an object's <code>beforecommand</code> script attribute to be run before any command is used on it. This script can prevent the command from running by doing: <code>game.pov.currentcommandpattern = null</code> (or setting currentcommandpattern to a different command if you want to run something else instead).</p>\n<p>This might be a better solution; checking through all the objects before running the command, rather than checking each as they're resolved.</p>\n<p>Your snake's <code>beforecommand</code> script could check the variable <code>command</code> against a list of commands such as <code>lookat</code> and <code>avoid</code> if you want those to work normally, and do something else otherwise.</p>\n\n",
      "PostDate": "2020-02-21T12:05:51.703094Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2197d242-e2c1-4cfb-a339-0a22308f7c07",
      "UserId": 3327,
      "Username": "questste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/c43da520ee661d384ccd9600ba0e04dc?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Brilliant. That new solution works. Thankyou.\r\n\r\nSimply adding the beforecommand attribute to my snake and adding this script\r\n\r\nif (not command=lookat) {\r\n  msg (\"You die.\")\r\n  game.pov.currentcommandpattern = null\r\n}\r\n\r\nallows all commands except examining to kill the player.",
      "EditableFormat": "markdown",
      "HTML": "<p>Brilliant. That new solution works. Thankyou.</p>\n<p>Simply adding the beforecommand attribute to my snake and adding this script</p>\n<p>if (not command=lookat) {<br>\nmsg (\"You die.\")<br>\ngame.pov.currentcommandpattern = null<br>\n}</p>\n<p>allows all commands except examining to kill the player.</p>\n\n",
      "PostDate": "2020-02-21T14:01:16.4121289Z",
      "LastEditDate": "2020-02-21T14:04:38.6054488Z",
      "link": null
    },
    {
      "PostId": "53a17ac3-0ca3-4ace-bbcf-3d263fcbdb42",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Great :)\r\n\r\nI'm not 100% sure if there's any more changes necessary to make it work with multiple commands such as \"take all\"; I've not properly looked into how those are implemented. I think it should work, but not certain.",
      "EditableFormat": "markdown",
      "HTML": "<p>Great :)</p>\n<p>I'm not 100% sure if there's any more changes necessary to make it work with multiple commands such as \"take all\"; I've not properly looked into how those are implemented. I think it should work, but not certain.</p>\n\n",
      "PostDate": "2020-02-21T14:36:18.5742165Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e2619a31-0948-4b13-ad66-5bbbc57c3089",
      "UserId": 3327,
      "Username": "questste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/c43da520ee661d384ccd9600ba0e04dc?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ahh yes, take all and drop all don't work 100%. With my script as above take all acts as if it's taking the snake only. Not too much of an issue for now if I change my script to exclude take and drop\r\n\r\nif (not command=lookat and not command=take and not command=drop) {\r\n  msg (\"You die.\")\r\n  game.pov.currentcommandpattern = null\r\n}\r\n\r\nIt's easy to override take and drop from the Inventory tab.\r\n\r\nAnd..\r\n\r\nBeing able to do something like:\r\n\r\nif (command = read) {\r\n  game.pov.currentcommandpattern = lookat\r\n}\r\n\r\nis really useful.",
      "EditableFormat": "markdown",
      "HTML": "<p>Ahh yes, take all and drop all don't work 100%. With my script as above take all acts as if it's taking the snake only. Not too much of an issue for now if I change my script to exclude take and drop</p>\n<p>if (not command=lookat and not command=take and not command=drop) {<br>\nmsg (\"You die.\")<br>\ngame.pov.currentcommandpattern = null<br>\n}</p>\n<p>It's easy to override take and drop from the Inventory tab.</p>\n<p>And..</p>\n<p>Being able to do something like:</p>\n<p>if (command = read) {<br>\ngame.pov.currentcommandpattern = lookat<br>\n}</p>\n<p>is really useful.</p>\n\n",
      "PostDate": "2020-02-21T14:55:15.3762523Z",
      "LastEditDate": "2020-02-21T16:00:09.7573839Z",
      "link": null
    },
    {
      "PostId": "c5a30de7-088e-479c-9731-244a2def6386",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "In the case of the snake, I think that the player tries to pick up all of the items at once and the snake bites them, which distracts them from picking up anything else.\r\n\r\nIf the bite isn't fatal, then you could allow them to pick up the rest of the objects by doing something like:\r\n```\r\nif (not command=lookat) {\r\n  msg (\"The snake jumps up and bites you.\")\r\n  removed = false\r\n  if (GetBoolean (command, \"allow_all\") or HasAttribute (command, \"multiple\")) {\r\n    if (IsDefined (\"object\")) {\r\n      if (TypeOf (object) = \"list\" or TypeOf (object) = \"objectlist\") {\r\n        if (ListContains (object, this)) {\r\n          list remove (object, this)\r\n          removed = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (not removed) {\r\n    game.pov.currentcommandpattern = null\r\n  }\r\n}\r\n```\r\n\r\nSo if the command has a list of objects to work on (like \"take x, y, and z\" or \"take all\"), it tries to remove the snake from the list and then execute the rest of the command normally. If it doesn't find the snake in the list, it cancels the command entirely.",
      "EditableFormat": "markdown",
      "HTML": "<p>In the case of the snake, I think that the player tries to pick up all of the items at once and the snake bites them, which distracts them from picking up anything else.</p>\n<p>If the bite isn't fatal, then you could allow them to pick up the rest of the objects by doing something like:</p>\n<pre><code>if (not command=lookat) {\n  msg (\"The snake jumps up and bites you.\")\n  removed = false\n  if (GetBoolean (command, \"allow_all\") or HasAttribute (command, \"multiple\")) {\n    if (IsDefined (\"object\")) {\n      if (TypeOf (object) = \"list\" or TypeOf (object) = \"objectlist\") {\n        if (ListContains (object, this)) {\n          list remove (object, this)\n          removed = true\n        }\n      }\n    }\n  }\n  if (not removed) {\n    game.pov.currentcommandpattern = null\n  }\n}\n</code></pre>\n<p>So if the command has a list of objects to work on (like \"take x, y, and z\" or \"take all\"), it tries to remove the snake from the list and then execute the rest of the command normally. If it doesn't find the snake in the list, it cancels the command entirely.</p>\n\n",
      "PostDate": "2020-02-21T16:37:45.3705483Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "18af2c8d-3635-4429-93da-b634469b8b94",
      "UserId": 3327,
      "Username": "questste",
      "AvatarUrl": "https://secure.gravatar.com/avatar/c43da520ee661d384ccd9600ba0e04dc?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks again.\r\n\r\nThe simplest option here for me would be to exclude the object from take all, it does seem unfair to cause the player major issues when entering a fairly common command.\r\n\r\nAnother option, and one that my project takes is to make the item scenery, then take all is taken care of.\r\n\r\nObviously any new commands that allow all would have to use something like the option above.",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks again.</p>\n<p>The simplest option here for me would be to exclude the object from take all, it does seem unfair to cause the player major issues when entering a fairly common command.</p>\n<p>Another option, and one that my project takes is to make the item scenery, then take all is taken care of.</p>\n<p>Obviously any new commands that allow all would have to use something like the option above.</p>\n\n",
      "PostDate": "2020-02-23T09:23:35.67699Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
