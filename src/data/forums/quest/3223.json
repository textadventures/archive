{
  "Topic": {
    "TopicId": "3223",
    "ForumId": "10",
    "Title": "Memory management, create and destroy",
    "LastUpdated": "2016-01-15T04:17:14+00:00",
    "ReplyCount": 11
  },
  "Posts": [
    {
      "PostId": "21481",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I have some questions that looking through the low-level source has not yet been able to answer - and I'd like to get the official word from someone who knows what the overall design is and how things are supposed to work.\n\nThe code I am writing could end up using lots of internal objects. While functions like NewObjectList and NewStringDictionary create anonymous entities, there is no such function for objects. The only ones I have found for generating objects are &quot;create&quot; (for basic, empty objects) and Clone (for duplicating existing objects). Both of these create named objects which exist in the master object list (I apologize for my terminology - I don't know the right words, so I'm just making it up as I go along.) This list is what's visible in the debugger under the Objects tab.\n\nI have two cases that I'd like to know the ramifications for in terms of memory usage and keeping Quest's internal data structures sane. Keep in mind that I understand about garabage collected objects (which both Javascript and C# have), but I fear there could possibly be complications with things like the undo stack...\n\n1) &quot;create&quot; - Let's say you do this:\n\n[code:3fpvtga7]create (&quot;o&quot;)[/code:3fpvtga7]\n\nand then you do it again:\n\n[code:3fpvtga7]create (&quot;o&quot;)[/code:3fpvtga7]\n\nThe initial object &quot;o&quot; wasn't explicitly destroyed, but it is clearly replaced. You can see this by assigning the first &quot;o&quot; to another variable and then manipulating members.\n\n[code:3fpvtga7]create (&quot;o&quot;)\no&#46;x = 1\nt = o\ncreate(&quot;o&quot;)\no&#46;x = 2\nmsg (&quot;o&#46;x = &quot; + o&#46;x + &quot;, t&#46;x = &quot; + t&#46;x)\n// yields o&#46;x = 2, t&#46;x = 1\n[/code:3fpvtga7]\n\nGiven my understanding of object references in general, etc, I would expect &quot;t&quot; to be separate from &quot;o&quot; above, and that indeed has proven to be the case. So that is handy, as object generation can simply use some standard name for every object creation and not end up polluting the &quot;master object list.&quot; My questions about that are:\n\na) Is this safe to do generally?\nb) When all references to the initial &quot;o&quot; go away (e.g. if &quot;t&quot; goes out of scope), will that &quot;o&quot; be garbage collected or will it be a leak?\n\nIf this is not safe to do, then I'm going to have to revisit some code I've written (like the path code).\n\n2) &quot;Clone&quot; - With Clone, you don't specify a name - the cloned object gets a numbered name variant of the original object (though I haven't tried cloning a clone to see what happens to the name).  If you keep Cloning objects, you will end up with all sorts of names in the master object list, and the objects won't go away, as they are still referenced there. So it seems that Cloned objects *must* be destroyed when it is desired that they no longer be used, to free up memory, etc. But I have wondered what happens in &quot;destroy&quot; and when it can be done. For example, if I do this (roughly):\n\n[code:3fpvtga7]\n  &lt;type name=&quot;foo&quot;&gt;\n  \t&lt;message&gt;Hello world!&lt;/message&gt;\n  &lt;/type&gt;\n  &lt;object name=&quot;prototype&quot;&gt;\n  \t&lt;inherit name=&quot;foo&quot;/&gt;\n  &lt;/object&gt;\n\n  o  = Clone(prototype)\n  destroy (o&#46;name)\n  msg(&quot;o&#46;message = &quot; + o&#46;message)[/code:3fpvtga7]\n\nI still get &quot;o.message = Hello World!&quot; as the object is still referenced by &quot;o&quot; and therefore existing (I hope!).\n\nHowever, after looking at the cs code, I varied the test like this :\n[code:3fpvtga7]&#46;&#46;&#46;\n  game&#46;o  = Clone(prototype)\n  destroy (game&#46;o&#46;name)\n  msg(&quot;o&#46;message = &quot; + game&#46;o&#46;message)[/code:3fpvtga7]\n\nand got &quot;Error running script&#058; Unknown object or variable 'message'&quot; as expected, because &quot;destroy&quot; walks all named object hierarchy and removes all references to a destroyed object before removing it from the master object list. \n\nSo given all that... is it safe, both from a memory management and &quot;undo stack&quot; point of view to do the former code, that is destroy a cloned object right away to remove the reference from the master list, but still retain, modify and use the disconnected object? I would think I'd at least want to null out the name attribute or something to avoid confusion. It would be more convenient to do it that way, as all the messy ownership issues could be handled at clone creation time (in fact, it could be wrapped up into a neat little function). But if it's not safe to do so, then I'll just switch to the idiom of calling &quot;destroy&quot; on all my objects when I'm done with them.\n\nI hope this all makes sense. I just want to be sure I'm doing the right thing with my objects. In my code, objects will be coming and going all the time (goals, paths, conversation topics, etc), so I need to get this right. And at least the answer will be posted here in the forum in case anyone else decides to travel down this same dark path...",
      "EditableFormat": "bbcode",
      "HTML": "I have some questions that looking through the low-level source has not yet been able to answer - and I'd like to get the official word from someone who knows what the overall design is and how things are supposed to work.<br/><br/>The code I am writing could end up using lots of internal objects. While functions like NewObjectList and NewStringDictionary create anonymous entities, there is no such function for objects. The only ones I have found for generating objects are &quot;create&quot; (for basic, empty objects) and Clone (for duplicating existing objects). Both of these create named objects which exist in the master object list (I apologize for my terminology - I don't know the right words, so I'm just making it up as I go along.) This list is what's visible in the debugger under the Objects tab.<br/><br/>I have two cases that I'd like to know the ramifications for in terms of memory usage and keeping Quest's internal data structures sane. Keep in mind that I understand about garabage collected objects (which both Javascript and C# have), but I fear there could possibly be complications with things like the undo stack...<br/><br/>1) &quot;create&quot; - Let's say you do this:<br/><br/><pre><code>create (&quot;o&quot;)</code></pre><br/><br/>and then you do it again:<br/><br/><pre><code>create (&quot;o&quot;)</code></pre><br/><br/>The initial object &quot;o&quot; wasn't explicitly destroyed, but it is clearly replaced. You can see this by assigning the first &quot;o&quot; to another variable and then manipulating members.<br/><br/><pre><code>create (&quot;o&quot;)<br/>o&#46;x = 1<br/>t = o<br/>create(&quot;o&quot;)<br/>o&#46;x = 2<br/>msg (&quot;o&#46;x = &quot; + o&#46;x + &quot;, t&#46;x = &quot; + t&#46;x)<br/>// yields o&#46;x = 2, t&#46;x = 1<br/></code></pre><br/><br/>Given my understanding of object references in general, etc, I would expect &quot;t&quot; to be separate from &quot;o&quot; above, and that indeed has proven to be the case. So that is handy, as object generation can simply use some standard name for every object creation and not end up polluting the &quot;master object list.&quot; My questions about that are:<br/><br/>a) Is this safe to do generally?<br/>b) When all references to the initial &quot;o&quot; go away (e.g. if &quot;t&quot; goes out of scope), will that &quot;o&quot; be garbage collected or will it be a leak?<br/><br/>If this is not safe to do, then I'm going to have to revisit some code I've written (like the path code).<br/><br/>2) &quot;Clone&quot; - With Clone, you don't specify a name - the cloned object gets a numbered name variant of the original object (though I haven't tried cloning a clone to see what happens to the name).  If you keep Cloning objects, you will end up with all sorts of names in the master object list, and the objects won't go away, as they are still referenced there. So it seems that Cloned objects *must* be destroyed when it is desired that they no longer be used, to free up memory, etc. But I have wondered what happens in &quot;destroy&quot; and when it can be done. For example, if I do this (roughly):<br/><br/><pre><code><br/>  &lt;type name=&quot;foo&quot;&gt;<br/>  \t&lt;message&gt;Hello world!&lt;/message&gt;<br/>  &lt;/type&gt;<br/>  &lt;object name=&quot;prototype&quot;&gt;<br/>  \t&lt;inherit name=&quot;foo&quot;/&gt;<br/>  &lt;/object&gt;<br/><br/>  o  = Clone(prototype)<br/>  destroy (o&#46;name)<br/>  msg(&quot;o&#46;message = &quot; + o&#46;message)</code></pre><br/><br/>I still get &quot;o.message = Hello World!&quot; as the object is still referenced by &quot;o&quot; and therefore existing (I hope!).<br/><br/>However, after looking at the cs code, I varied the test like this :<br/><pre><code>&#46;&#46;&#46;<br/>  game&#46;o  = Clone(prototype)<br/>  destroy (game&#46;o&#46;name)<br/>  msg(&quot;o&#46;message = &quot; + game&#46;o&#46;message)</code></pre><br/><br/>and got &quot;Error running script&#058; Unknown object or variable 'message'&quot; as expected, because &quot;destroy&quot; walks all named object hierarchy and removes all references to a destroyed object before removing it from the master object list. <br/><br/>So given all that... is it safe, both from a memory management and &quot;undo stack&quot; point of view to do the former code, that is destroy a cloned object right away to remove the reference from the master list, but still retain, modify and use the disconnected object? I would think I'd at least want to null out the name attribute or something to avoid confusion. It would be more convenient to do it that way, as all the messy ownership issues could be handled at clone creation time (in fact, it could be wrapped up into a neat little function). But if it's not safe to do so, then I'll just switch to the idiom of calling &quot;destroy&quot; on all my objects when I'm done with them.<br/><br/>I hope this all makes sense. I just want to be sure I'm doing the right thing with my objects. In my code, objects will be coming and going all the time (goals, paths, conversation topics, etc), so I need to get this right. And at least the answer will be posted here in the forum in case anyone else decides to travel down this same dark path...",
      "PostDate": "2012-09-29T01:12:58+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21482",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "And, of course, I left out a key part of my question: the objects I'm talking about here are internal objects only (data structures used in internal algorithms), not anything the player would see, touch, move, take or otherwise interact with. The latter type of objects *must* remain in the master object list; otherwise, they are not visible anywhere in the game world.\n\nIt's the internal ones I'm referring to, those &quot;behind the scenes&quot; objects that the user doesn't interact with directly but which scripts might want to create on the fly for their own personal data needs.",
      "EditableFormat": "bbcode",
      "HTML": "And, of course, I left out a key part of my question: the objects I'm talking about here are internal objects only (data structures used in internal algorithms), not anything the player would see, touch, move, take or otherwise interact with. The latter type of objects *must* remain in the master object list; otherwise, they are not visible anywhere in the game world.<br/><br/>It's the internal ones I'm referring to, those &quot;behind the scenes&quot; objects that the user doesn't interact with directly but which scripts might want to create on the fly for their own personal data needs.",
      "PostDate": "2012-09-29T10:59:58+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21512",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "1. This sounds like a bug to me. Quest should give you an error if you try to create an object with the same name as one that already exists. The old object may or may not stick around. It will certainly not get written out when you save the game, so you can't rely on it continuing to exist. You can probably still access it before a save if you had some other object attribute pointing to it. If there was ever an object attribute pointing to it, it won't be garbage collected because it would still have something pointing to it via the undo logger.\n\n2. Again not safe, as if the player saves to a .quest-save file the object won't be written out, so it won't be there on load.\n\nThis is basically why there is no such thing as an anonymous object - it needs to have a name to get written on save.\n\nIf you want to make use of lots of objects for storing data, I say go ahead - do some testing if you're worried about performance, but I can't see a problem with creating and destroying as many objects as you need. Destroying an object won't remove it from memory as it will still be in the undo stack. If anything can be regarded as actually purging destroyed objects, it's the process of saving and reloading a game.",
      "EditableFormat": "bbcode",
      "HTML": "1. This sounds like a bug to me. Quest should give you an error if you try to create an object with the same name as one that already exists. The old object may or may not stick around. It will certainly not get written out when you save the game, so you can't rely on it continuing to exist. You can probably still access it before a save if you had some other object attribute pointing to it. If there was ever an object attribute pointing to it, it won't be garbage collected because it would still have something pointing to it via the undo logger.<br/><br/>2. Again not safe, as if the player saves to a .quest-save file the object won't be written out, so it won't be there on load.<br/><br/>This is basically why there is no such thing as an anonymous object - it needs to have a name to get written on save.<br/><br/>If you want to make use of lots of objects for storing data, I say go ahead - do some testing if you're worried about performance, but I can't see a problem with creating and destroying as many objects as you need. Destroying an object won't remove it from memory as it will still be in the undo stack. If anything can be regarded as actually purging destroyed objects, it's the process of saving and reloading a game.",
      "PostDate": "2012-10-05T18:43:23+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21514",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Ok, this is starting to make more sense now - and the issues with saving are just the sort of thing I was worried about.\n\nI'll move to generating unique names for all my objects. It means I'm going to have to explicitly clean them up (which is painful - but we do it in other languages), but I already have some mechanisms in place for cloned objects, so I'll just expand them to the others as well. \n\nThanks much for the reply!",
      "EditableFormat": "bbcode",
      "HTML": "Ok, this is starting to make more sense now - and the issues with saving are just the sort of thing I was worried about.<br/><br/>I'll move to generating unique names for all my objects. It means I'm going to have to explicitly clean them up (which is painful - but we do it in other languages), but I already have some mechanisms in place for cloned objects, so I'll just expand them to the others as well. <br/><br/>Thanks much for the reply!",
      "PostDate": "2012-10-05T20:51:56+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "21539",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Just to round this thread out, I'm attaching what *I* have come to use based on the above. It's not a lot of code, but it's working well for me. It's a small &quot;Utils&quot; library with the following functions:\n\n1) o = Utils_CreateObject(&quot;basename&quot;)\n\nThis creates an internal object. The object visibility is set to false. The &quot;basename&quot; parameter is used to generate a unique name for the object. The created object names will be like &quot;basename0&quot;, &quot;basename1&quot;, etc. I originally didn't have that (using just a default base name), and it made it much more difficult to detect and resolve &quot;object leaks&quot;. Now by providing good base names for your objects, you'll be able to scan the object list in the debugger and know what things are much more easily.\n\nThe object is marked as needing to be destroyed. You should call Utils_DestroyObject(o) when you're done with it.\n\n2) o = Utils_CloneObject(prototype)\n\nThis creates an object as a clone of a prototype object. Note that the prototype parameter is a direct object reference, not an object name in quotes. The prototype is passed to Clone to generate a copy.\n\nIf the resulting object has a &quot;create&quot; script defined, then it will be executed on the new object after cloning.\n\nThe object is marked as needing to be destroyed. You should call Utils_DestroyObject(o) when you're done with it.\n\n3) Utils_DestroyObject(o)\n\nThis function destroys an object &quot;o&quot; if &quot;o&quot; has been created by either Utils_CreateObject or Utils_CloneObject. If it was not created by either of those functions (and so marked internally), then nothing will happen. This means, among other things, that you can pass any object to this function, and only those objects that should be destroyed will be. (There are ways to allow other objecs to be destroyed with this function. I have not found a need for that yet.)\n\nIf the object has a &quot;destroy&quot; script, then the script will be executed before the object is destroyed. This allows the object to clean up anything it needs to (e.g. other objects).\n\n4) Utils_DestroyObjectList(list)\n\nThis function is used to destroy a list of objects created by Utils_CreateObject and/or Utils_CloneObject. It simply removes each object from the list in turn and calls Utils_DestroyObject on it. You could, in theory, pass any object list into this. If the objects were not created Utils_CreateObject or Utils_CloneObject, they will just be removed from the list.\n\nUpon exit, the list is empty.\n\n5) Utils_CallBaseMethod(o, &quot;type&quot;, &quot;method&quot;, params)\n\nThis function invokes the specified base method on an object. This is useful if you have object type hierarchies and have overridden script attributes in derived types and want to still be able to call the overridden script. &quot;o&quot; is the object to invoke the method on. &quot;type&quot; specifies the base type that has the script to be invoked. Note that, as types can not be directly manipulated, there must exist a prototype object for the base type (just an empty object with an &quot;inherit&quot; element will do). &quot;method&quot; is the script to invoke. &quot;params&quot; are the parameters to pass. Pass [b:2qogtqdm]null[/b:2qogtqdm] for params if you have no parameters. Otherwise, params should be the standard parameters dictionary passed to a script.\n\nThis can especially be useful for cascading &quot;create&quot; and &quot;destroy&quot; calls up the type hierarchy. Actually it's useful for lots of things.\n\nConceptual notes: Mapping to standard object-oriented terminology, the prototype object is the equivalent of an instantiatable class. (You must still use types to implement derivation. But in order to Clone a type or call a base method on it, you must have a prototype object to be manipulated. If types in Quest are ever made visible like objects, then this requirement can go away.) The &quot;create&quot; script is akin to a constructor, and the &quot;destroy&quot; script is the equivalent of a destructor.\n\nImplementing a &quot;destroy&quot; method in a prototype is straightforward - just add it to the type or prototype object. If you use Utils_CreateObject to create an object that needs a destroy method, you can add it after creation. (I finally discovered about a week ago the elusive &quot;=&gt;&quot; operator to assign an inline script to an object. Very cool!)\n\nExample:\n\n[code:2qogtqdm]o = Utils_CreateObject(&quot;container&quot;)\no&#46;list = NewObjectList()\no&#46;destroy =&gt; { Utils_DestroyObjectList(this&#46;list) }\n\nitem = Utils_CreateObject(&quot;item&quot;)\nitem&#46;data = &quot;foo&quot;\nlist add(o&#46;list, item)\n\nitem = Utils_CreateObject(&quot;item&quot;)\nitem&#46;data = &quot;bar&quot;\nlist add(o&#46;list, item)\n\nUtils_DestroyObject(o)[/code:2qogtqdm]\n\nWith the &quot;destroy&quot; method added in as above, the two item objects will also be destroyed when the main object is destroyed.\n\nThat's about it. If anyone has any questions about this, needs more examples, encounters bugs, or comes up with suggestions, please let me know!",
      "EditableFormat": "bbcode",
      "HTML": "Just to round this thread out, I'm attaching what *I* have come to use based on the above. It's not a lot of code, but it's working well for me. It's a small &quot;Utils&quot; library with the following functions:<br/><br/>1) o = Utils_CreateObject(&quot;basename&quot;)<br/><br/>This creates an internal object. The object visibility is set to false. The &quot;basename&quot; parameter is used to generate a unique name for the object. The created object names will be like &quot;basename0&quot;, &quot;basename1&quot;, etc. I originally didn't have that (using just a default base name), and it made it much more difficult to detect and resolve &quot;object leaks&quot;. Now by providing good base names for your objects, you'll be able to scan the object list in the debugger and know what things are much more easily.<br/><br/>The object is marked as needing to be destroyed. You should call Utils_DestroyObject(o) when you're done with it.<br/><br/>2) o = Utils_CloneObject(prototype)<br/><br/>This creates an object as a clone of a prototype object. Note that the prototype parameter is a direct object reference, not an object name in quotes. The prototype is passed to Clone to generate a copy.<br/><br/>If the resulting object has a &quot;create&quot; script defined, then it will be executed on the new object after cloning.<br/><br/>The object is marked as needing to be destroyed. You should call Utils_DestroyObject(o) when you're done with it.<br/><br/>3) Utils_DestroyObject(o)<br/><br/>This function destroys an object &quot;o&quot; if &quot;o&quot; has been created by either Utils_CreateObject or Utils_CloneObject. If it was not created by either of those functions (and so marked internally), then nothing will happen. This means, among other things, that you can pass any object to this function, and only those objects that should be destroyed will be. (There are ways to allow other objecs to be destroyed with this function. I have not found a need for that yet.)<br/><br/>If the object has a &quot;destroy&quot; script, then the script will be executed before the object is destroyed. This allows the object to clean up anything it needs to (e.g. other objects).<br/><br/>4) Utils_DestroyObjectList(list)<br/><br/>This function is used to destroy a list of objects created by Utils_CreateObject and/or Utils_CloneObject. It simply removes each object from the list in turn and calls Utils_DestroyObject on it. You could, in theory, pass any object list into this. If the objects were not created Utils_CreateObject or Utils_CloneObject, they will just be removed from the list.<br/><br/>Upon exit, the list is empty.<br/><br/>5) Utils_CallBaseMethod(o, &quot;type&quot;, &quot;method&quot;, params)<br/><br/>This function invokes the specified base method on an object. This is useful if you have object type hierarchies and have overridden script attributes in derived types and want to still be able to call the overridden script. &quot;o&quot; is the object to invoke the method on. &quot;type&quot; specifies the base type that has the script to be invoked. Note that, as types can not be directly manipulated, there must exist a prototype object for the base type (just an empty object with an &quot;inherit&quot; element will do). &quot;method&quot; is the script to invoke. &quot;params&quot; are the parameters to pass. Pass <span style=\"font-weight:bold;\">null</span> for params if you have no parameters. Otherwise, params should be the standard parameters dictionary passed to a script.<br/><br/>This can especially be useful for cascading &quot;create&quot; and &quot;destroy&quot; calls up the type hierarchy. Actually it's useful for lots of things.<br/><br/>Conceptual notes: Mapping to standard object-oriented terminology, the prototype object is the equivalent of an instantiatable class. (You must still use types to implement derivation. But in order to Clone a type or call a base method on it, you must have a prototype object to be manipulated. If types in Quest are ever made visible like objects, then this requirement can go away.) The &quot;create&quot; script is akin to a constructor, and the &quot;destroy&quot; script is the equivalent of a destructor.<br/><br/>Implementing a &quot;destroy&quot; method in a prototype is straightforward - just add it to the type or prototype object. If you use Utils_CreateObject to create an object that needs a destroy method, you can add it after creation. (I finally discovered about a week ago the elusive &quot;=&gt;&quot; operator to assign an inline script to an object. Very cool!)<br/><br/>Example:<br/><br/><pre><code>o = Utils_CreateObject(&quot;container&quot;)<br/>o&#46;list = NewObjectList()<br/>o&#46;destroy =&gt; { Utils_DestroyObjectList(this&#46;list) }<br/><br/>item = Utils_CreateObject(&quot;item&quot;)<br/>item&#46;data = &quot;foo&quot;<br/>list add(o&#46;list, item)<br/><br/>item = Utils_CreateObject(&quot;item&quot;)<br/>item&#46;data = &quot;bar&quot;<br/>list add(o&#46;list, item)<br/><br/>Utils_DestroyObject(o)</code></pre><br/><br/>With the &quot;destroy&quot; method added in as above, the two item objects will also be destroyed when the main object is destroyed.<br/><br/>That's about it. If anyone has any questions about this, needs more examples, encounters bugs, or comes up with suggestions, please let me know!<div><a href=\"/attachment/389\">Utils.aslx</a></div>",
      "PostDate": "2012-10-10T14:11:47+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "40422",
      "UserId": 0,
      "Username": "Quantus",
      "UserAvatar": null,
      "UserGravatar": "35a21115ef82667ce2865ae6db5011e6",
      "EditableText": "I'm having an issue with cloned object removal.  I have figured out a way to Move the object into a Void Room.  This works to get rid of the object, but it causes other issues.  So what should I do if I want to:\n\nSpawn five clones of Monster and move to current room.\nSet a monster verb called Slay.\nClick Slay will slay the Monster(Remove object cloned monster).\n\nI know that having the pre created monster with verb Slay will cause each clones Slay verb to only Remove object named Monster.  I can't pre create a verb that will detect the name of the cloned monster. \n\nI think your post here maybe my answer, but it's way over my head right now.  I'll try it out though and see if I can comprehend it.",
      "EditableFormat": "bbcode",
      "HTML": "I'm having an issue with cloned object removal.  I have figured out a way to Move the object into a Void Room.  This works to get rid of the object, but it causes other issues.  So what should I do if I want to:<br/><br/>Spawn five clones of Monster and move to current room.<br/>Set a monster verb called Slay.<br/>Click Slay will slay the Monster(Remove object cloned monster).<br/><br/>I know that having the pre created monster with verb Slay will cause each clones Slay verb to only Remove object named Monster.  I can't pre create a verb that will detect the name of the cloned monster. <br/><br/>I think your post here maybe my answer, but it's way over my head right now.  I'll try it out though and see if I can comprehend it.",
      "PostDate": "2016-01-10T16:07:27+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40428",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The Slay verb should use the variable &quot;this&quot;, which refers to the current object/monster. That way, you don't have to know the name of the monster. (In other words, it's the only way to make the verb generic.)",
      "EditableFormat": "bbcode",
      "HTML": "The Slay verb should use the variable &quot;this&quot;, which refers to the current object/monster. That way, you don't have to know the name of the monster. (In other words, it's the only way to make the verb generic.)",
      "PostDate": "2016-01-10T17:50:05+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40452",
      "UserId": 0,
      "Username": "Quantus",
      "UserAvatar": null,
      "UserGravatar": "35a21115ef82667ce2865ae6db5011e6",
      "EditableText": "You sir are a genius.\n\nIt works perfectly.  Thank you!  So to remove a cloned object with a verb you just put Remove Object and type the word:  this\n\nI could have read that already, but I didn't understand it.  THE NAME OF THE VARIABLE IS: this\n\nA clone is able to be removed by clicking on the verb for that cloned object which contains the command to Remove Object.  You don't put the name of the object there, you put the variable name: this\n\nThe actual code looks like this:    \n\nRemoveObject (this)\n\nThanks again!",
      "EditableFormat": "bbcode",
      "HTML": "You sir are a genius.<br/><br/>It works perfectly.  Thank you!  So to remove a cloned object with a verb you just put Remove Object and type the word:  this<br/><br/>I could have read that already, but I didn't understand it.  THE NAME OF THE VARIABLE IS: this<br/><br/>A clone is able to be removed by clicking on the verb for that cloned object which contains the command to Remove Object.  You don't put the name of the object there, you put the variable name: this<br/><br/>The actual code looks like this:    <br/><br/>RemoveObject (this)<br/><br/>Thanks again!",
      "PostDate": "2016-01-11T01:11:52+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40483",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Glad it worked for you! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "Glad it worked for you! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-01-11T21:02:49+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40602",
      "UserId": 0,
      "Username": "Quantus",
      "UserAvatar": null,
      "UserGravatar": "35a21115ef82667ce2865ae6db5011e6",
      "EditableText": "Any idea what would cause this error:\n\nError running script&#058; Error compiling expression 'this': Unknown object or variable 'this'\n\n\nI'm still tinkering with the code, it works in most cases, but I'm getting this error sometimes.",
      "EditableFormat": "bbcode",
      "HTML": "Any idea what would cause this error:<br/><br/>Error running script&#058; Error compiling expression 'this': Unknown object or variable 'this'<br/><br/><br/>I'm still tinkering with the code, it works in most cases, but I'm getting this error sometimes.",
      "PostDate": "2016-01-14T05:23:21+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40604",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "A &quot;this&quot; variable only exists if you &quot;do&quot; a script, where you pass an object. If you &quot;invoke&quot; a script, it doesn't know what the object is, and there won't be a &quot;this&quot;. Not sure if that's it. If you have a persistent problem, reply where it's happening, so we can get some context.",
      "EditableFormat": "bbcode",
      "HTML": "A &quot;this&quot; variable only exists if you &quot;do&quot; a script, where you pass an object. If you &quot;invoke&quot; a script, it doesn't know what the object is, and there won't be a &quot;this&quot;. Not sure if that's it. If you have a persistent problem, reply where it's happening, so we can get some context.",
      "PostDate": "2016-01-14T09:07:56+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40637",
      "UserId": 0,
      "Username": "Quantus",
      "UserAvatar": null,
      "UserGravatar": "35a21115ef82667ce2865ae6db5011e6",
      "EditableText": "You helped again. Thanks!",
      "EditableFormat": "bbcode",
      "HTML": "You helped again. Thanks!",
      "PostDate": "2016-01-15T04:17:14+00:00",
      "LastEditDate": null
    }
  ]
}
