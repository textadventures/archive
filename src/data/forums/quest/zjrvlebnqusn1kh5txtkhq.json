{
  "Topic": {
    "TopicId": "zjrvlebnqusn1kh5txtkhq",
    "ForumId": "10",
    "Title": "Taking n items / Dropping n items",
    "LastUpdated": "2017-12-28T21:26:27.7737167Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "bd382990-0125-43c5-bcd2-83255144d179",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/Te0Y5FPb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm getting close here.\r\n\r\nIn fact, you can DROP n ITEMS or GET n ITEMS (and it usually works).\r\n\r\nNow, I'm working on the displayed list of objects in the room, but I just started on that, so it doesn't work right now (and may never work, I dunno).\r\n\r\nHere's what I have so far.\r\n\r\nNOTE:  It's loaded with debugging messages.\r\n\r\n\r\nEDITED 12/30/17 10:22 AM CST\r\n```\r\n<!--Saved by Quest 5.7.6404.15496-->\r\n<asl version=\"550\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Chips\">\r\n    <gameid>f2806bf4-e541-440d-8778-ea1dfdef45a7</gameid>\r\n    <version>0.0.2</version>\r\n    <firstpublished>2017</firstpublished>\r\n    <showmoney />\r\n    <start type=\"script\">\r\n    </start>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <enter type=\"script\">\r\n    </enter>\r\n    <beforeenter type=\"script\"><![CDATA[\r\n      i = 4\r\n      while (i>0) {\r\n        CloneObjectAndMoveHere (chip)\r\n        i = i - 1\r\n      }\r\n    ]]></beforeenter>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <object name=\"poker_chips\">\r\n        <inherit name=\"editor_object\" />\r\n        <visible type=\"boolean\">false</visible>\r\n        <alias>poker chip</alias>\r\n        <look><![CDATA[You have {poker_chips.count} chip{if poker_chips.count<>1:s}.]]></look>\r\n        <count type=\"int\">0</count>\r\n        <usedefaultprefix type=\"boolean\">false</usedefaultprefix>\r\n        <single type=\"object\">chip</single>\r\n        <drop type=\"script\"><![CDATA[\r\n          amount = poker_chips.count\r\n          while (poker_chips.count>0) {\r\n            i = ToString(poker_chips.count)\r\n            i = ToInt(i)\r\n            left = i - amount\r\n            // msg (\"To drop: \"+amount+\" out of \"+i+\", leaving \"+left+\".\")\r\n            // msg (object.single)\r\n            while (i>left) {\r\n              newObj = CloneObject (poker_chips.single)\r\n              MoveObjectHere (newObj)\r\n              newObj.prototype = poker_chips.single\r\n              i = i - 1\r\n            }\r\n            poker_chips.count = poker_chips.count - amount\r\n            msg (\"Done.\")\r\n            switch (poker_chips.count) {\r\n              case (1) {\r\n                poker_chips.alias = poker_chips.single.alias\r\n              }\r\n              case (0) {\r\n                MakeObjectInvisible (poker_chips)\r\n              }\r\n              default {\r\n                poker_chips.alias = ToWords(poker_chips.count)+\" \"+GetDisplayAlias(object.single)+\"s\"\r\n              }\r\n            }\r\n          }\r\n        ]]></drop>\r\n      </object>\r\n    </object>\r\n    <object name=\"baton\">\r\n      <inherit name=\"editor_object\" />\r\n      <take />\r\n      <look>This is only here to see if you can drop it.</look>\r\n    </object>\r\n  </object>\r\n  <object name=\"chip\">\r\n    <inherit name=\"editor_object\" />\r\n    <alias>poker chip</alias>\r\n    <look>A red poker chip, worth $1.</look>\r\n    <take type=\"script\"><![CDATA[\r\n      if (not poker_chips.visible) {\r\n        MakeObjectVisible (poker_chips)\r\n      }\r\n      poker_chips.count = poker_chips.count + 1\r\n      if (poker_chips.count>1) {\r\n        poker_chips.alias = ToWords(poker_chips.count)+\"\"+\" poker chips\"\r\n      }\r\n      RemoveObject (this)\r\n      msg (\"You pick it up.\")\r\n    ]]></take>\r\n    <multiple />\r\n  </object>\r\n  <command name=\"drop_n_objects\">\r\n    <pattern type=\"string\"><![CDATA[^drop (?<text>\\d+) (?<object>.*)$]]></pattern>\r\n    <script><![CDATA[\r\n      // msg (object)\r\n      // msg (text)\r\n      amount = ToInt(text)\r\n      if (HasAttribute(object,\"count\")) {\r\n        if (amount<=object.count) {\r\n          i = ToString(object.count)\r\n          i = ToInt(i)\r\n          left = i - amount\r\n          // msg (\"To drop: \"+amount+\" out of \"+i+\", leaving \"+left+\".\")\r\n          // msg (object.single)\r\n          while (i>left) {\r\n            newObj = CloneObject (object.single)\r\n            AddToInventory (newObj)\r\n            DoDrop (newObj, multiple)\r\n            newObj.prototype = object.single\r\n            i = i - 1\r\n          }\r\n          object.count = object.count - amount\r\n          msg (\"Done.\")\r\n          switch (object.count) {\r\n            case (1) {\r\n              object.alias = object.single.alias\r\n            }\r\n            case (0) {\r\n              msg (\"That was your last \"+GetDisplayAlias(object)+\".\")\r\n              MakeObjectInvisible (object)\r\n            }\r\n            default {\r\n              object.alias = ToWords(object.count)+\" \"+GetDisplayAlias(object.single)+\"s\"\r\n            }\r\n          }\r\n        }\r\n        else if (ToInt(text)>=object.count) {\r\n          msg (\"You don't have that many.\")\r\n        }\r\n      }\r\n      else {\r\n        foreach (obj, object) {\r\n          DoDrop (obj, multiple)\r\n        }\r\n      }\r\n    ]]></script>\r\n  </command>\r\n  <command name=\"take_n_objects\">\r\n    <pattern type=\"string\"><![CDATA[^get (?<text1>\\d+) ((?<text2>.*)s|(?<text2>.*))$]]></pattern>\r\n    <script><![CDATA[\r\n      if (IsInt(text1)) {\r\n        amount = ToInt(text1)\r\n      }\r\n      else {\r\n        error (\"Expected a number, but got \"+text1+\".\")\r\n      }\r\n      regex = \"(?<object>.+)\"\r\n      if (not IsRegexMatch(regex, text2)) {\r\n        error (\"Object not found.\")\r\n      }\r\n      dict = Populate(regex, text2)\r\n      object = GetObject(StringDictionaryItem(dict, \"object\"))\r\n      found = false\r\n      poss = NewObjectList()\r\n      foreach (obj, ScopeReachableNotHeld()) {\r\n        if (GetDisplayAlias(obj) = GetDisplayAlias(object)) {\r\n          if (HasAttribute(obj,\"multiple\")) {\r\n            found = true\r\n            msg (\"Found possible match: \"+obj)\r\n            list add (poss, obj)\r\n          }\r\n          else {\r\n            if (text1 = \"1\") {\r\n              DoTake (obj, multiple)\r\n              game.lastobjects = NewObjectList()\r\n              list add (game.lastobjects, obj)\r\n              // Using a return to exit this script\r\n              return (true)\r\n            }\r\n            else {\r\n              msg (\"You can't do that.\")\r\n              // Using a return to exit this script\r\n              return (false)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      held = false\r\n      if (not found) {\r\n        foreach (obj, ScopeInventory()) {\r\n          if (obj.alias = object) {\r\n            held = true\r\n            msg (\"You're already carrying \"+obj.article+\".\")\r\n            return (false)\r\n          }\r\n        }\r\n      }\r\n      if ((not found) and not held) {\r\n        msg (\"I can't see that.\")\r\n        return (false)\r\n      }\r\n      objects = NewObjectList()\r\n      msg (\"amount = \"+amount)\r\n      while (amount>0) {\r\n        amount = amount - 1\r\n        msg (\"amount = \"+amount)\r\n        object = poss[amount]\r\n        msg (\"MATCH: \"+object)\r\n        list add (objects, object)\r\n      }\r\n      foreach (obj, objects) {\r\n        // AddToInventory (obj)\r\n        DoTake (obj, multiple)\r\n      }\r\n      msg (text1)\r\n      msg (object)\r\n      msg (\"Done.\")\r\n    ]]></script>\r\n  </command>\r\n  <function name=\"ListDuplicates\" parameters=\"myList\" type=\"boolean\"><![CDATA[\r\n    Log (\"Called ListDuplicates\")\r\n    // I think this will only find ONE thing with duplicates, then stop. \\\r\n    // but this is currently untested.\r\n    i = 0\r\n    foreach (item, myList) {\r\n      Log (\"<hr/>item: \"+item)\r\n      newList = ListExclude(myList,\"\")\r\n      list remove (newList, item)\r\n      foreach (thing, newList) {\r\n        Log (\"thing: \"+thing)\r\n        if (item = thing) {\r\n          Log (\"Found one!\")\r\n          i = i + 1\r\n          Log (\"i = \"+i)\r\n        }\r\n      }\r\n      if (i>0) {\r\n        i = i + 1\r\n        // Log (myList)\r\n        Log (\"Found \"+i+\" \"+item+\"s.\")\r\n        return (true)\r\n      }\r\n    }\r\n    // Log (myList)\r\n    Log (\"Found \"+i)\r\n    return (false)\r\n  ]]></function>\r\n</asl>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm getting close here.</p>\n<p>In fact, you can DROP n ITEMS or GET n ITEMS (and it usually works).</p>\n<p>Now, I'm working on the displayed list of objects in the room, but I just started on that, so it doesn't work right now (and may never work, I dunno).</p>\n<p>Here's what I have so far.</p>\n<p>NOTE:  It's loaded with debugging messages.</p>\n<p>EDITED 12/30/17 10:22 AM CST</p>\n<pre><code>&lt;!--Saved by Quest 5.7.6404.15496--&gt;\n&lt;asl version=\"550\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Chips\"&gt;\n    &lt;gameid&gt;f2806bf4-e541-440d-8778-ea1dfdef45a7&lt;/gameid&gt;\n    &lt;version&gt;0.0.2&lt;/version&gt;\n    &lt;firstpublished&gt;2017&lt;/firstpublished&gt;\n    &lt;showmoney /&gt;\n    &lt;start type=\"script\"&gt;\n    &lt;/start&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;enter type=\"script\"&gt;\n    &lt;/enter&gt;\n    &lt;beforeenter type=\"script\"&gt;&lt;![CDATA[\n      i = 4\n      while (i&gt;0) {\n        CloneObjectAndMoveHere (chip)\n        i = i - 1\n      }\n    ]]&gt;&lt;/beforeenter&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;object name=\"poker_chips\"&gt;\n        &lt;inherit name=\"editor_object\" /&gt;\n        &lt;visible type=\"boolean\"&gt;false&lt;/visible&gt;\n        &lt;alias&gt;poker chip&lt;/alias&gt;\n        &lt;look&gt;&lt;![CDATA[You have {poker_chips.count} chip{if poker_chips.count&lt;&gt;1:s}.]]&gt;&lt;/look&gt;\n        &lt;count type=\"int\"&gt;0&lt;/count&gt;\n        &lt;usedefaultprefix type=\"boolean\"&gt;false&lt;/usedefaultprefix&gt;\n        &lt;single type=\"object\"&gt;chip&lt;/single&gt;\n        &lt;drop type=\"script\"&gt;&lt;![CDATA[\n          amount = poker_chips.count\n          while (poker_chips.count&gt;0) {\n            i = ToString(poker_chips.count)\n            i = ToInt(i)\n            left = i - amount\n            // msg (\"To drop: \"+amount+\" out of \"+i+\", leaving \"+left+\".\")\n            // msg (object.single)\n            while (i&gt;left) {\n              newObj = CloneObject (poker_chips.single)\n              MoveObjectHere (newObj)\n              newObj.prototype = poker_chips.single\n              i = i - 1\n            }\n            poker_chips.count = poker_chips.count - amount\n            msg (\"Done.\")\n            switch (poker_chips.count) {\n              case (1) {\n                poker_chips.alias = poker_chips.single.alias\n              }\n              case (0) {\n                MakeObjectInvisible (poker_chips)\n              }\n              default {\n                poker_chips.alias = ToWords(poker_chips.count)+\" \"+GetDisplayAlias(object.single)+\"s\"\n              }\n            }\n          }\n        ]]&gt;&lt;/drop&gt;\n      &lt;/object&gt;\n    &lt;/object&gt;\n    &lt;object name=\"baton\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;take /&gt;\n      &lt;look&gt;This is only here to see if you can drop it.&lt;/look&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"chip\"&gt;\n    &lt;inherit name=\"editor_object\" /&gt;\n    &lt;alias&gt;poker chip&lt;/alias&gt;\n    &lt;look&gt;A red poker chip, worth $1.&lt;/look&gt;\n    &lt;take type=\"script\"&gt;&lt;![CDATA[\n      if (not poker_chips.visible) {\n        MakeObjectVisible (poker_chips)\n      }\n      poker_chips.count = poker_chips.count + 1\n      if (poker_chips.count&gt;1) {\n        poker_chips.alias = ToWords(poker_chips.count)+\"\"+\" poker chips\"\n      }\n      RemoveObject (this)\n      msg (\"You pick it up.\")\n    ]]&gt;&lt;/take&gt;\n    &lt;multiple /&gt;\n  &lt;/object&gt;\n  &lt;command name=\"drop_n_objects\"&gt;\n    &lt;pattern type=\"string\"&gt;&lt;![CDATA[^drop (?&lt;text&gt;\\d+) (?&lt;object&gt;.*)$]]&gt;&lt;/pattern&gt;\n    &lt;script&gt;&lt;![CDATA[\n      // msg (object)\n      // msg (text)\n      amount = ToInt(text)\n      if (HasAttribute(object,\"count\")) {\n        if (amount&lt;=object.count) {\n          i = ToString(object.count)\n          i = ToInt(i)\n          left = i - amount\n          // msg (\"To drop: \"+amount+\" out of \"+i+\", leaving \"+left+\".\")\n          // msg (object.single)\n          while (i&gt;left) {\n            newObj = CloneObject (object.single)\n            AddToInventory (newObj)\n            DoDrop (newObj, multiple)\n            newObj.prototype = object.single\n            i = i - 1\n          }\n          object.count = object.count - amount\n          msg (\"Done.\")\n          switch (object.count) {\n            case (1) {\n              object.alias = object.single.alias\n            }\n            case (0) {\n              msg (\"That was your last \"+GetDisplayAlias(object)+\".\")\n              MakeObjectInvisible (object)\n            }\n            default {\n              object.alias = ToWords(object.count)+\" \"+GetDisplayAlias(object.single)+\"s\"\n            }\n          }\n        }\n        else if (ToInt(text)&gt;=object.count) {\n          msg (\"You don't have that many.\")\n        }\n      }\n      else {\n        foreach (obj, object) {\n          DoDrop (obj, multiple)\n        }\n      }\n    ]]&gt;&lt;/script&gt;\n  &lt;/command&gt;\n  &lt;command name=\"take_n_objects\"&gt;\n    &lt;pattern type=\"string\"&gt;&lt;![CDATA[^get (?&lt;text1&gt;\\d+) ((?&lt;text2&gt;.*)s|(?&lt;text2&gt;.*))$]]&gt;&lt;/pattern&gt;\n    &lt;script&gt;&lt;![CDATA[\n      if (IsInt(text1)) {\n        amount = ToInt(text1)\n      }\n      else {\n        error (\"Expected a number, but got \"+text1+\".\")\n      }\n      regex = \"(?&lt;object&gt;.+)\"\n      if (not IsRegexMatch(regex, text2)) {\n        error (\"Object not found.\")\n      }\n      dict = Populate(regex, text2)\n      object = GetObject(StringDictionaryItem(dict, \"object\"))\n      found = false\n      poss = NewObjectList()\n      foreach (obj, ScopeReachableNotHeld()) {\n        if (GetDisplayAlias(obj) = GetDisplayAlias(object)) {\n          if (HasAttribute(obj,\"multiple\")) {\n            found = true\n            msg (\"Found possible match: \"+obj)\n            list add (poss, obj)\n          }\n          else {\n            if (text1 = \"1\") {\n              DoTake (obj, multiple)\n              game.lastobjects = NewObjectList()\n              list add (game.lastobjects, obj)\n              // Using a return to exit this script\n              return (true)\n            }\n            else {\n              msg (\"You can't do that.\")\n              // Using a return to exit this script\n              return (false)\n            }\n          }\n        }\n      }\n      held = false\n      if (not found) {\n        foreach (obj, ScopeInventory()) {\n          if (obj.alias = object) {\n            held = true\n            msg (\"You're already carrying \"+obj.article+\".\")\n            return (false)\n          }\n        }\n      }\n      if ((not found) and not held) {\n        msg (\"I can't see that.\")\n        return (false)\n      }\n      objects = NewObjectList()\n      msg (\"amount = \"+amount)\n      while (amount&gt;0) {\n        amount = amount - 1\n        msg (\"amount = \"+amount)\n        object = poss[amount]\n        msg (\"MATCH: \"+object)\n        list add (objects, object)\n      }\n      foreach (obj, objects) {\n        // AddToInventory (obj)\n        DoTake (obj, multiple)\n      }\n      msg (text1)\n      msg (object)\n      msg (\"Done.\")\n    ]]&gt;&lt;/script&gt;\n  &lt;/command&gt;\n  &lt;function name=\"ListDuplicates\" parameters=\"myList\" type=\"boolean\"&gt;&lt;![CDATA[\n    Log (\"Called ListDuplicates\")\n    // I think this will only find ONE thing with duplicates, then stop. \\\n    // but this is currently untested.\n    i = 0\n    foreach (item, myList) {\n      Log (\"&lt;hr/&gt;item: \"+item)\n      newList = ListExclude(myList,\"\")\n      list remove (newList, item)\n      foreach (thing, newList) {\n        Log (\"thing: \"+thing)\n        if (item = thing) {\n          Log (\"Found one!\")\n          i = i + 1\n          Log (\"i = \"+i)\n        }\n      }\n      if (i&gt;0) {\n        i = i + 1\n        // Log (myList)\n        Log (\"Found \"+i+\" \"+item+\"s.\")\n        return (true)\n      }\n    }\n    // Log (myList)\n    Log (\"Found \"+i)\n    return (false)\n  ]]&gt;&lt;/function&gt;\n&lt;/asl&gt;\n</code></pre>\n\n",
      "PostDate": "2017-12-28T21:26:27.7737167Z",
      "LastEditDate": "2017-12-30T16:23:18.1535077Z",
      "link": null
    },
    {
      "PostId": "4869d845-7b1d-45f7-9187-e04df508b8d9",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "For GET you have this pattern:\r\n\r\n```\r\n^get (?<text1>\\d+) ((?<text2>.*)s|(?<text2>.*))$\r\n```\r\n\r\nWhy are you not matching to an object, as you do for the drop command? You are allowing for plurals, but that should be possible with this (though I have no tested it):\r\n\r\n```\r\n^get (?<text1>\\d+) (?<object>.*)s?$\r\n```\r\n\r\nIn fact, I would be tempted to include the plural as a synonym for each object, as often it is not as simple as adding an \"s\". Will there be many objects this will be relevant to?\r\n\r\nAlso, you check if `text1` is a number; it will be because it matched \\d+ (and I see you do not bother in the drop command).",
      "EditableFormat": "markdown",
      "HTML": "<p>For GET you have this pattern:</p>\n<pre><code>^get (?&lt;text1&gt;\\d+) ((?&lt;text2&gt;.*)s|(?&lt;text2&gt;.*))$\n</code></pre>\n<p>Why are you not matching to an object, as you do for the drop command? You are allowing for plurals, but that should be possible with this (though I have no tested it):</p>\n<pre><code>^get (?&lt;text1&gt;\\d+) (?&lt;object&gt;.*)s?$\n</code></pre>\n<p>In fact, I would be tempted to include the plural as a synonym for each object, as often it is not as simple as adding an \"s\". Will there be many objects this will be relevant to?</p>\n<p>Also, you check if <code>text1</code> is a number; it will be because it matched \\d+ (and I see you do not bother in the drop command).</p>\n\n",
      "PostDate": "2017-12-29T10:19:09.6399708Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "53e1c09d-9460-4624-9318-b13262c417ff",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/Te0Y5FPb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "If I match an object, it brings up the disambiguation menu.\r\n\r\n...but that would be solved if I included a plural as an ```alt```, I bet.  (Look at you go, Pixie!)\r\n\r\n---\r\nI didn't think of using regex at first, so I was checking if text1 was an integer in the first script and never changed it.  (Hehehe.)\r\n\r\n---\r\nI was considering making a reverse ToWords function, so the player could use GET TWO CHIPS or GET 2 CHIPS.\r\n\r\n---\r\n>often it is not as simple as adding an \"s\".\r\n\r\nYou speak the truth.\r\n\r\nThe plural of \"mouse\" is \"meese\", not \"meeses\" (which I hate to pieces).\r\n\r\n(That's a joke, kids.  It's \"mice\".  That was a reference to an old cartoon.)\r\n\r\nAnyway... I hadn't even thought of that, but you solved that when you suggested plurals as alternate names.\r\n\r\n---\r\nThanks, Pix!\r\n\r\nI'll post the revised version soon!",
      "EditableFormat": "markdown",
      "HTML": "<p>If I match an object, it brings up the disambiguation menu.</p>\n<p>...but that would be solved if I included a plural as an <code>alt</code>, I bet.  (Look at you go, Pixie!)</p>\n<hr>\n<p>I didn't think of using regex at first, so I was checking if text1 was an integer in the first script and never changed it.  (Hehehe.)</p>\n<hr>\n<p>I was considering making a reverse ToWords function, so the player could use GET TWO CHIPS or GET 2 CHIPS.</p>\n<hr>\n<blockquote>\n<p>often it is not as simple as adding an \"s\".</p>\n</blockquote>\n<p>You speak the truth.</p>\n<p>The plural of \"mouse\" is \"meese\", not \"meeses\" (which I hate to pieces).</p>\n<p>(That's a joke, kids.  It's \"mice\".  That was a reference to an old cartoon.)</p>\n<p>Anyway... I hadn't even thought of that, but you solved that when you suggested plurals as alternate names.</p>\n<hr>\n<p>Thanks, Pix!</p>\n<p>I'll post the revised version soon!</p>\n\n",
      "PostDate": "2017-12-29T10:35:07.9476738Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ac6135ad-b2c8-4a07-8b01-dca00a99baeb",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/Te0Y5FPb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "NOTE\r\n\r\nMost of this is what I recall from something mrangel previously posted.\r\n\r\nSIDE-NOTE\r\n\r\nIt's *what I recall*, meaning it's most likely a sloppy version of what I'm misremembering.\r\n\r\nSo the awesome concept is mrangel's, but the bad scripting is mine. \r\n\r\n---\r\n (Just making sure the credit is properly given.)",
      "EditableFormat": "markdown",
      "HTML": "<p>NOTE</p>\n<p>Most of this is what I recall from something mrangel previously posted.</p>\n<p>SIDE-NOTE</p>\n<p>It's <em>what I recall</em>, meaning it's most likely a sloppy version of what I'm misremembering.</p>\n<p>So the awesome concept is mrangel's, but the bad scripting is mine.</p>\n<hr>\n<p>(Just making sure the credit is properly given.)</p>\n\n",
      "PostDate": "2017-12-29T10:39:40.1312507Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4767f2f0-d0e3-471c-9272-ff184f5191b5",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> I was considering making a reverse ToWords function, so the player could use GET TWO CHIPS or GET 2 CHIPS.\r\n\r\nThat would be good; some people are sure to type that. It may not be easy, though, as Quest will try to match GET RED BALLOON, and may not realise RED does not match a number until too late (i.e., it is already commited to that command). Hmm, I guess you could have the words in regex like this maybe (untested!):\r\n\r\n```\r\n^get (?<text1>(\\d+|one|two|three)) ((?<text2>.*)s|(?<text2>.*))$\r\n```\r\n\r\nI do some coding in Ruby on Rails, and Rails has a built in mechanism for making plurals, which is cool... until you do some odd, and it, for example, tries to pluralise meta-data as meta-datas.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I was considering making a reverse ToWords function, so the player could use GET TWO CHIPS or GET 2 CHIPS.</p>\n</blockquote>\n<p>That would be good; some people are sure to type that. It may not be easy, though, as Quest will try to match GET RED BALLOON, and may not realise RED does not match a number until too late (i.e., it is already commited to that command). Hmm, I guess you could have the words in regex like this maybe (untested!):</p>\n<pre><code>^get (?&lt;text1&gt;(\\d+|one|two|three)) ((?&lt;text2&gt;.*)s|(?&lt;text2&gt;.*))$\n</code></pre>\n<p>I do some coding in Ruby on Rails, and Rails has a built in mechanism for making plurals, which is cool... until you do some odd, and it, for example, tries to pluralise meta-data as meta-datas.</p>\n\n",
      "PostDate": "2017-12-29T10:49:29.4289878Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2f3ef7e3-38c6-4e84-a24a-6063892388e3",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/Te0Y5FPb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I added plurals as alt names, but it still brought up the disambiguation menu, which is what I'm trying to avoid here, of course.\r\n\r\nNow, I know that the disambiguation menu is my friend, so I'm not downing it.  I just want to let it rest when I want to pickup numerous chips in one TAKE.\r\n\r\nThe way I have it set up now, it does this.  It will **TAKE OBJECT** normally, or **TAKE ```n``` OBJECTS**, and the same goes for dropping objects.\r\n\r\nThe main problem (I think, since the alt names should resolve any issues with irregular plurals) is the ```(?<text2>.*)s```, which is sort of allowing a **text2** which ends in \"s\" to slide through before checking if ```text2``` matches an object after dropping the \"s\".\r\n\r\nDoesn't Quest already do that?\r\n\r\nWhen a **CHIP** is in the room, I can enter **GET CHI**, and Quest will assume I meant **CHIP**, unless there's a **CHICKEN** or **CHITLIN** or just some plain old **CHI** in the room.  (Hehehe.)\r\n\r\nSo, what's the difference in letting a word slip through as text then immediately checking it against the regex ```(?<object>.+)```?\r\n\r\nWell, first off, I was thinking backwards.\r\n\r\nQuest will match when you enter fewer characters, but you can't ADD any characters!  (Dur!)\r\n\r\n---\r\nAlso, I am now envisioning a scenario:\r\n\r\n**GET 2 BATONS**\r\n\r\nI didn't test that!  (Doh!)\r\n\r\n<samp>\r\n\r\n\\> get 2 batons\r\nFound possible match: Object: baton\r\namount = 2\r\namount = 1\r\nError running script: Error evaluating expression 'poss[amount]': Index was out of range. Must be non-negative and less than the size of the collection.Parameter name: index\r\n\r\n</samp>\r\n\r\n---\r\nDamn and blast!\r\n\r\nI'll try adding one more ```if``` to catch it.\r\n\r\n...and it worked.\r\n\r\nNow you can GET 1 BATON, even when the baton isn't set as a multiple.\r\n\r\nIf you try to get more than 1, it says, \"You can't do that.\"\r\n\r\n---\r\nIs this more dangerous, or less dangerous than the first script?\r\n\r\n```\r\n  <command name=\"take_n_objects\">\r\n    <pattern type=\"string\"><![CDATA[^get (?<text1>\\d+) ((?<text2>.*)s|(?<text2>.*))$]]></pattern>\r\n    <script><![CDATA[\r\n      if (IsInt(text1)) {\r\n        amount = ToInt(text1)\r\n      }\r\n      else {\r\n        error (\"Expected a number, but got \"+text1+\".\")\r\n      }\r\n      regex = \"(?<object>.+)\"\r\n      if (not IsRegexMatch(regex, text2)) {\r\n        error (\"Object not found.\")\r\n      }\r\n      dict = Populate(regex, text2)\r\n      object = GetObject(StringDictionaryItem(dict, \"object\"))\r\n      found = false\r\n      poss = NewObjectList()\r\n      foreach (obj, ScopeReachableNotHeld()) {\r\n        if (GetDisplayAlias(obj) = GetDisplayAlias(object)) {\r\n          if (HasAttribute(obj,\"multiple\")) {\r\n            found = true\r\n            msg (\"Found possible match: \"+obj)\r\n            list add (poss, obj)\r\n          }\r\n          else {\r\n            if (text1 = \"1\") {\r\n              DoTake (obj, multiple)\r\n              game.lastobjects = NewObjectList()\r\n              list add (game.lastobjects, obj)\r\n              // Using a return to exit this script\r\n              return (true)\r\n            }\r\n            else {\r\n              msg (\"You can't do that.\")\r\n              // Using a return to exit this script\r\n              return (false)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      held = false\r\n      if (not found) {\r\n        foreach (obj, ScopeInventory()) {\r\n          if (obj.alias = object) {\r\n            held = true\r\n            msg (\"You're already carrying \"+obj.article+\".\")\r\n            return (false)\r\n          }\r\n        }\r\n      }\r\n      if ((not found) and not held) {\r\n        msg (\"I can't see that.\")\r\n        return (false)\r\n      }\r\n      objects = NewObjectList()\r\n      msg (\"amount = \"+amount)\r\n      while (amount>0) {\r\n        amount = amount - 1\r\n        msg (\"amount = \"+amount)\r\n        object = poss[amount]\r\n        msg (\"MATCH: \"+object)\r\n        list add (objects, object)\r\n      }\r\n      foreach (obj, objects) {\r\n        // AddToInventory (obj)\r\n        DoTake (obj, multiple)\r\n      }\r\n      msg (text1)\r\n      msg (object)\r\n      msg (\"Done.\")\r\n    ]]></script>\r\n  </command>\r\n```\r\n\r\n---\r\nANSWER \r\n\r\nBoth scripts are flawed.\r\n\r\nI thought this would catch it if ```text2``` wasn't an object, but it doesn't:\r\n\r\n```\r\nregex = \"(?<object>.+)\"\r\nif (not IsRegexMatch(regex, text2)) {\r\n  error (\"Object not found.\")\r\n}\r\n```\r\nWhen there is no WIDGET, I can put **GET WIDGET** and it says, \"I can't see that,\" just as it should, but **GET 1 WIDGET** or **GET 2 WIDGETS** causes problems.\r\n\r\n---\r\nCurses!!!\r\n\r\nI'll try adding one more ```foreach(obj,ScopeReachableNotHeld())``` to catch it before giving up.",
      "EditableFormat": "markdown",
      "HTML": "<p>I added plurals as alt names, but it still brought up the disambiguation menu, which is what I'm trying to avoid here, of course.</p>\n<p>Now, I know that the disambiguation menu is my friend, so I'm not downing it.  I just want to let it rest when I want to pickup numerous chips in one TAKE.</p>\n<p>The way I have it set up now, it does this.  It will <strong>TAKE OBJECT</strong> normally, or <strong>TAKE <code>n</code> OBJECTS</strong>, and the same goes for dropping objects.</p>\n<p>The main problem (I think, since the alt names should resolve any issues with irregular plurals) is the <code>(?&lt;text2&gt;.*)s</code>, which is sort of allowing a <strong>text2</strong> which ends in \"s\" to slide through before checking if <code>text2</code> matches an object after dropping the \"s\".</p>\n<p>Doesn't Quest already do that?</p>\n<p>When a <strong>CHIP</strong> is in the room, I can enter <strong>GET CHI</strong>, and Quest will assume I meant <strong>CHIP</strong>, unless there's a <strong>CHICKEN</strong> or <strong>CHITLIN</strong> or just some plain old <strong>CHI</strong> in the room.  (Hehehe.)</p>\n<p>So, what's the difference in letting a word slip through as text then immediately checking it against the regex <code>(?&lt;object&gt;.+)</code>?</p>\n<p>Well, first off, I was thinking backwards.</p>\n<p>Quest will match when you enter fewer characters, but you can't ADD any characters!  (Dur!)</p>\n<hr>\n<p>Also, I am now envisioning a scenario:</p>\n<p><strong>GET 2 BATONS</strong></p>\n<p>I didn't test that!  (Doh!)</p>\n<samp>\n<p>&gt; get 2 batons<br>\nFound possible match: Object: baton<br>\namount = 2<br>\namount = 1<br>\nError running script: Error evaluating expression 'poss[amount]': Index was out of range. Must be non-negative and less than the size of the collection.Parameter name: index</p>\n</samp>\n<hr>\n<p>Damn and blast!</p>\n<p>I'll try adding one more <code>if</code> to catch it.</p>\n<p>...and it worked.</p>\n<p>Now you can GET 1 BATON, even when the baton isn't set as a multiple.</p>\n<p>If you try to get more than 1, it says, \"You can't do that.\"</p>\n<hr>\n<p>Is this more dangerous, or less dangerous than the first script?</p>\n<pre><code>  &lt;command name=\"take_n_objects\"&gt;\n    &lt;pattern type=\"string\"&gt;&lt;![CDATA[^get (?&lt;text1&gt;\\d+) ((?&lt;text2&gt;.*)s|(?&lt;text2&gt;.*))$]]&gt;&lt;/pattern&gt;\n    &lt;script&gt;&lt;![CDATA[\n      if (IsInt(text1)) {\n        amount = ToInt(text1)\n      }\n      else {\n        error (\"Expected a number, but got \"+text1+\".\")\n      }\n      regex = \"(?&lt;object&gt;.+)\"\n      if (not IsRegexMatch(regex, text2)) {\n        error (\"Object not found.\")\n      }\n      dict = Populate(regex, text2)\n      object = GetObject(StringDictionaryItem(dict, \"object\"))\n      found = false\n      poss = NewObjectList()\n      foreach (obj, ScopeReachableNotHeld()) {\n        if (GetDisplayAlias(obj) = GetDisplayAlias(object)) {\n          if (HasAttribute(obj,\"multiple\")) {\n            found = true\n            msg (\"Found possible match: \"+obj)\n            list add (poss, obj)\n          }\n          else {\n            if (text1 = \"1\") {\n              DoTake (obj, multiple)\n              game.lastobjects = NewObjectList()\n              list add (game.lastobjects, obj)\n              // Using a return to exit this script\n              return (true)\n            }\n            else {\n              msg (\"You can't do that.\")\n              // Using a return to exit this script\n              return (false)\n            }\n          }\n        }\n      }\n      held = false\n      if (not found) {\n        foreach (obj, ScopeInventory()) {\n          if (obj.alias = object) {\n            held = true\n            msg (\"You're already carrying \"+obj.article+\".\")\n            return (false)\n          }\n        }\n      }\n      if ((not found) and not held) {\n        msg (\"I can't see that.\")\n        return (false)\n      }\n      objects = NewObjectList()\n      msg (\"amount = \"+amount)\n      while (amount&gt;0) {\n        amount = amount - 1\n        msg (\"amount = \"+amount)\n        object = poss[amount]\n        msg (\"MATCH: \"+object)\n        list add (objects, object)\n      }\n      foreach (obj, objects) {\n        // AddToInventory (obj)\n        DoTake (obj, multiple)\n      }\n      msg (text1)\n      msg (object)\n      msg (\"Done.\")\n    ]]&gt;&lt;/script&gt;\n  &lt;/command&gt;\n</code></pre>\n<hr>\n<p>ANSWER</p>\n<p>Both scripts are flawed.</p>\n<p>I thought this would catch it if <code>text2</code> wasn't an object, but it doesn't:</p>\n<pre><code>regex = \"(?&lt;object&gt;.+)\"\nif (not IsRegexMatch(regex, text2)) {\n  error (\"Object not found.\")\n}\n</code></pre>\n<p>When there is no WIDGET, I can put <strong>GET WIDGET</strong> and it says, \"I can't see that,\" just as it should, but <strong>GET 1 WIDGET</strong> or <strong>GET 2 WIDGETS</strong> causes problems.</p>\n<hr>\n<p>Curses!!!</p>\n<p>I'll try adding one more <code>foreach(obj,ScopeReachableNotHeld())</code> to catch it before giving up.</p>\n\n",
      "PostDate": "2017-12-30T16:19:09.6537937Z",
      "LastEditDate": "2017-12-30T16:21:44.1521652Z",
      "link": null
    }
  ]
}
