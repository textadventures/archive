{
  "Topic": {
    "TopicId": "ptu53m6bteqmcswiqsmvsg",
    "ForumId": "10",
    "Title": "More messing about with ShowMenu",
    "LastUpdated": "2018-03-21T11:12:43.3482255Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "2b680bcf-3a5a-4cbb-82e0-3ce49642a7a2",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Here we are again, folks!\r\n\r\nHere's my attempt at overriding some of the core functions so that ShowMenu gives you more flexibility.\r\n\r\nSadly untested, due to not having a windows machine on which to run the desktop version of quest. So there may be typos in here. Would appreciate if anyone can tell me if this works; or wrap these functions in a library to make them easier to use.\r\n\r\nMain features:\r\n* Functions similar to ShowMenu that allow you to display a numbered list, a bullet list, a list of options on one line, or return a single option so you can include the menu options within a paragraph.\r\n* Option to hide the menu after making a selection, or just disable the links.\r\n* Callback for if the menu is cancelled (so in your dialogue menu, you could make the guy yell \"Hey, where are you going?\" if the player walks off)\r\n* Attributes on the game object to control which kind of menu ShowMenu shows. Default should look just like the default one.\r\n* Player can type one of the menu options.\r\n* Let the player choose an option by typing just one word, or the start of a word (in the same way as partially naming an object for a command); game attribute to determine if this catches the names of menu options that are also commands.\r\n\r\n<details>\r\n<summary>Attributes of the game object</summary>\r\n\r\n* `game.alwaysshowmenunumbers` - boolean. If true, menu options that aren't in a numbered list will have a number in parentheses displayed after them.\r\n* `game.showmenutype` - string. Can be `\"number\"`, `\"bullet\"`, `\"flat\"`, or some other string which will be used as a bullet when ShowMenu is called. (\"flat\" displays the menu as a single line using FormatList).\r\n* `game.hidemenus` - boolean. If set to false, choosing a menu option will remove the links, but won't actually vanish the menu.\r\n* `game.showmenutryharder` - boolean. If true, typing a word that appears in exactly one of the menu options will choose that option; or the start of a word (like when typing object names).\r\n* `game.showmenuunresolvedcommand` - boolean. As above, but this behaviour will be pushed into the unresolved command handler, so that it only happens if the word isn't also a command. This may cause bugs if you have a command which modifies `game.unresolvedcommandhandler` during play.\r\n</details>\r\n\r\n<details>\r\n<summary>Menu display functions</summary>\r\n\r\n* `StartShowMenu (caption)` - Starts a menu, and displays the caption.\r\n  * If you do this more than once in the same menu, subsequent ones will just print the caption.\r\n  * If you miss this out, it will be called as soon as you call AddMenuOption (sorry, that's ugly, as you might want to generate options before actually printing them. But I can't see a way around it)\r\n* `EndShowMenu (allowCancel, hideAfterMenu, callback)`\r\n  * Marks the end of the menu, and sets the callback.\r\n  * `hideAfterMenu` - boolean. If true, everything between StartShowMenu and EndShowMenu will be hidden once an option is chosen. If false, the links will be disabled but remain on screen.\r\n* `MenuCancelledCallback (script)`\r\n  * Set a script to be run if the menu is not called.\r\n  * Note that this is a **misleading function name**, as I couldn't think of a better one.\r\n  * In the case of a menu with `allowCancel` set to false, this will be run each time the player enters something that can't be parsed as a valid choice. If you call `ClearMenu` from within the callback, you also need to call `MenuCancelledCallback(null)`.\r\n  * The callback will get the parameters:\r\n    * `options` - a dictionary of options the player didn't choose from\r\n    * `input` - what the player actually entered\r\n    * `command` - if applicable, the command that was executed instead of choosing a menu option (note that in this case, the callback will be run _after_ the command)\r\n* `AddMenuOption (option, result, displayNumber)`\r\n  * **Returns** a string containing all the HTML for a clickable link menu option. You need to use `msg()` to pass this to the player.\r\n  * `option` - The option to display. Calls GetDisplayAlias() if it's an object, using `linkcolour` if set, and ToString() for any other type that isn't a string.\r\n  * `result` - The value that the 'result' variable will be set to in the callback.\r\n    * String - `result` in the callback will be the string\r\n    * Object - `result` in the callback will be the object's name\r\n    * Anything else - `result` in the callback will be `option`'s name if it's an object, and `option` otherwise\r\n  * `displayNumber` - boolean. If true, will allow the player to select the option by typing its number. Will display like \"Would you like Red (1), Blue (2), or Yellow (3)?\". If this is a format string instead, `!` will be replaced by the option, and `#` by the number.\r\n* `AddMenuNumberedList (options)`\r\n  * **Returns** the HTML for a numbered list, like the original ShowMenu displays. You can modify this string if you want before outputting it.\r\n  * `options` - I *think* this should handle an options list in any of the formats ShowMenu supports\r\n* `AddMenuBulletList (options, bullet)`\r\n  * **Returns** a bulleted list; as above, but without numbering the options\r\n  * If `game.alwaysshowmenunumbers` is set, will add bracketed numbers after each option\r\n  * `bullet` - string, to display before each option. If `\"\"`, will return a HTML `<ul>` element instead.\r\n* `AddMenuFlatList (options, lastjoiner)`\r\n  * **Returns** a list of options on a single line, generated using `FormatList`.\r\n  * `lastjoiner` - you probably want `\"[Or]\"` or `\"[And]\"` here.\r\n* `ShowMenu`\r\n  * Same parameters as the default one. This will call `StartShowMenu`, then either AddMenuNumberedList, AddMenuBulletList, or AddMenuFlatList (depending on the value of `game.showmenutype`), then EndShowMenu.\r\n  * I've attempted to ensure that if none of the game attributes mentioned above are set, this will behave exactly the same as the standard ShowMenu function.\r\n</details>\r\n\r\n<details>\r\n<summary>The code</summary>\r\n\r\n```\r\n<function name=\"StartShowMenu\" parameters=\"caption\">\r\n  if (not HasString(game, \"menuoutputsection\")) {\r\n    game.menuoutputsection = StartNewOutputSection()\r\n  }\r\n  msg (caption)\r\n  game.menuoptionskeys = NewStringList()\r\n  game.menudisplayedoptions = NewStringDictionary()\r\n  game.menucallback => {\r\n    error (\"Menu callback not set\")\r\n  }\r\n</function>\r\n\r\n<function name=\"MenuCancelledCallback\" parameters=\"callback\">\r\n  game.menucancelcallback = callback\r\n</function>\r\n\r\n<function name=\"AddMenuOption\" type=\"string\" parameters=\"option, result, displayNumber\">\r\n  <![CDATA[\r\n  if (not HasString(game, \"menuoutputsection\")) {\r\n    StartShowMenu(\"\")\r\n  }\r\n  if (TypeOf(option) = \"object\") {\r\n    optionText = GetDisplayAlias(option)\r\n    optionTag = option.name\r\n    if (HasString(option, \"linkcolour\") and GetUIOption(\"UseGameColours\") = \"true\") {\r\n      colour = option.linkcolour\r\n    }\r\n    else {\r\n      colour = GetLinkTextColour()\r\n    }\r\n    style = GetCurrentTextFormat(colour)\r\n  }\r\n  else if (TypeOf(option) = \"string\") {\r\n    optionText = option\r\n    optionTag = option\r\n    style = GetCurrentLinkTextFormat()\r\n  }\r\n  else {\r\n    optionText = ToString(option)\r\n    optionTag = optionText\r\n    style = \"\"\r\n  }\r\n  if (IsDefined(\"result\")) {\r\n    if (TypeOf(result) = \"string\") {\r\n      if (LengthOf(result) > 0) {\r\n        optionTag = result\r\n      }\r\n    }\r\n    else if (TypeOf(result) = \"object\") {\r\n      optionTag = result.name\r\n    }\r\n  }\r\n  result = \"<a class=\\\"cmdlink\\\" style=\\\"\" + style + \"\\\" onclick=\\\"ASLEvent('ShowMenuResponse','\" + EscapeQuotes(optionTag) + \"')\\\">\" + optionText + \"</a>\"\r\n  dictionary add (game.menudisplayedoptions, optionTag, optionText)\r\n  if (TypeOf(displayNumber) = \"string\") {\r\n    if (IndexOf (displayNumber, \"!\") > 0) {\r\n      result = Replace (displayNumber, \"!\", result)\r\n    }\r\n    else {\r\n      result = displayNumber + \" \" + result\r\n    }\r\n    if (IndexOf (result, \"#\") > 0) {\r\n      list add (game.menuoptionskeys, optionTag)\r\n      result = Replace (displaynumber, \"#\", ListCount(game.menuoptionskeys))\r\n    }\r\n  }\r\n  else if (Equal(displayNumber, true) or GetBoolean(game, \"alwaysshowmenunumbers\")) {\r\n    list add (game.menuoptionskeys, optionTag)\r\n    result = result + \" (\" + ListCount(game.menuoptionskeys) + \")\"\r\n  }\r\n  return (result)\r\n  ]]>\r\n</function>\r\n\r\n<function name=\"EndShowMenu\" parameters=\"allowCancel, hideAfterMenu, callback\">\r\n  if (not HasString(game, \"menuoutputsection\")) {\r\n    error(\"Menu not started\")\r\n  }\r\n  EndOutputSection (game.menuoutputsection)\r\n  game.menuallowcancel = allowCancel\r\n  game.menucallback = callback\r\n  game.menuhideafter = hideAfterMenu\r\n</function>\r\n\r\n<function name=\"AddMenuNumberedList\" parameters=\"options\">\r\n<![CDATA[\r\n  if (TypeOf(options) = \"object\") {\r\n    options = GetDirectChildren(options)\r\n  }\r\n  else if (TypeOf(options) = \"string\") {\r\n    options = Split(options)\r\n  }\r\n\r\n  result = NewStringList()\r\n  foreach (o, options) {\r\n    optionText = o\r\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\r\n      optionText = DictionaryItem(options, o)\r\n    }\r\n    list add (result, AddMenuOption(optionText, o, \"#. \"))\r\n  }\r\n  return (Join (result, \"<br/>\"))\r\n]]>\r\n</function>\r\n\r\n<function name=\"AddMenuBulletList\" parameters=\"options, bullet\">\r\n<![CDATA[\r\n  if (not TypeOf(bullet) = \"string\") {\r\n    bullet = \"\"\r\n  }\r\n  if (TypeOf(options) = \"object\") {\r\n    options = GetDirectChildren(options)\r\n  }\r\n  else if (TypeOf(options) = \"string\") {\r\n    options = Split(options)\r\n  }\r\n\r\n  result = NewStringList()\r\n  foreach (o, options) {\r\n    optionText = o\r\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\r\n      optionText = DictionaryItem(options, o)\r\n    }\r\n    list add (result, bullet + AddMenuOption(optionText, o, false))\r\n  }\r\n  if (bullet = \"\") {\r\n    return (\"<ul><li>\" + Join(result, \"</li>\\n<li>\") + \"</li></ul>\\n\")\r\n  }\r\n  else {\r\n    return (Join (result, \"<br/>\"))\r\n  }\r\n]]>\r\n</function>\r\n\r\n<function name=\"AddMenuFlatList\" parameters=\"options, lastjoiner\">\r\n<![CDATA[\r\n  if (TypeOf(options) = \"object\") {\r\n    options = GetDirectChildren(options)\r\n  }\r\n  else if (TypeOf(options) = \"string\") {\r\n    options = Split(options)\r\n  }\r\n\r\n  result = NewStringList()\r\n  foreach (o, options) {\r\n    optionText = o\r\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\r\n      optionText = DictionaryItem(options, o)\r\n    }\r\n    list add (result, \"· \" + AddMenuOption(optionText, o, false))\r\n  }\r\n  return (FormatList(result, \",\", lastjoiner, \"\"))\r\n]]>\r\n</function>\r\n\r\n<function name=\"ShowMenu\" parameters=\"caption, options, allowCancel, callback\">\r\n  StartShowMenu(caption)\r\n  type = \"number\"\r\n  if (Equal (game.alwaysshowmenunumbers, false)) {\r\n    type = \"bullet\"\r\n  }\r\n  if (HasString (game, \"showmenutype\")) {\r\n    type = LCase(game.showmenutype)\r\n  }\r\n  if (type = \"bullet\") {\r\n    msg (AddMenuBulletList(options), \"\")\r\n  }\r\n  else if (type = \"flat\") {\r\n    msg (AddMenuFlatList(options, \"[Or]\"))\r\n  }\r\n  else if (type = \"number\") {\r\n    msg (AddMenuNumberedList(options))\r\n  }\r\n  else {\r\n    msg (AddMenuBulletList(options), type)\r\n  }\r\n  if (not HasBoolean(game, \"hidemenus\")) {\r\n    game.hidemenus = true\r\n  }\r\n  EndShowMenu(allowCancel, game.hidemenus, callback)\r\n</function>\r\n\r\n<function name=\"HandleMenuTextResponse\" parameters=\"input\" type=\"boolean\">\r\n  <![CDATA[\r\n  handled = false\r\n  if (IsInt(input)) {\r\n    number = ToInt(input)\r\n    if (number > 0 and number <= ListCount(game.menuoptionskeys)) {\r\n      ShowMenuResponse(StringListItem(game.menuoptionskeys, number - 1))\r\n      return (true)\r\n    }\r\n  }\r\n  else if(HasAttribute(game, \"menudisplayedoptions\")) {\r\n    foreach (option, game.menudisplayedoptions) {\r\n      if (LCase(Trim(StringDictionaryItem(game.menudisplayedoptions, option))) = LCase(Trim(input))) {\r\n        ShowMenuResponse(option)\r\n        game.menucancelcallback = null\r\n        return (true)\r\n      }\r\n    }\r\n    if (GetBoolean(game, \"showmenutryharder\") or not GetBoolean(game, \"menuallowcancel\")) {\r\n      handled = HandleMenuTextHarder (game, input)\r\n      return (handled)\r\n    }\r\n    else if (GetBoolean(game, \"showmenuunresolvedcommand\")) {\r\n      if (HasScript(game, \"unresolvedcommandhandler\")) {\r\n        game.unresolvedcommandbackup = game.unresolvedcommandhandler\r\n      }\r\n      SetTurnTimeout(0) {\r\n        if (HasScript (showmenu_data_object, \"menucancelcallback\")) {\r\n          params = NewDictionary()\r\n          dictionary add (params, \"options\", showmenu_data_object.menudisplayedoptions)\r\n          dictionary add (params, \"input\", game.pov.currentcommand)\r\n          dictionary add (params, \"command\", game.pov.currentcommandpattern)\r\n          do (showmenu_data_object, \"menucancelcallback\", params)\r\n        }\r\n        ClearMenu()\r\n        if (HasScript(game, \"unresolvedcommandbackup\")) {\r\n          game.unresolvedcommandhandler = game.unresolvedcommandbackup\r\n          game.unresolvedcommandbackup = null\r\n        }\r\n      }\r\n      game.unresolvedcommandhandler => {\r\n        handled = HandleMenuTextHarder (showmenu_data_object, command)\r\n        if (HasScript(game, \"unresolvedcommandbackup\")) {\r\n          game.unresolvedcommandhandler = game.unresolvedcommandbackup\r\n          game.unresolvedcommandbackup = null\r\n        }\r\n        if (not handled) {\r\n          if (HasScript(game, \"unresolvedcommandhandler\")) {\r\n            params = NewDictionary()\r\n            dictionary add(params, \"command\", command)\r\n            do (game, \"unresolvedcommandhandler\", params)\r\n          } else {\r\n            msg (Template(\"UnrecognisedCommand\"))\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return (false)\r\n  ]]>\r\n</function>\r\n\r\n<function name=\"HandleMenuTextHarder\" parameters=\"menu, input\">\r\n  possibilities = NewStringList()\r\n  options = menu.menudisplayedoptions\r\n  foreach (option, options) {\r\n    list add (possibilities, option)\r\n  }\r\n  foreach (word, Split(LCase(input), \" \")) {\r\n    stillpossible = NewStringList()\r\n    foreach (option, possibilities) {\r\n      words_in_option = Split(LCase(StringDictionaryItem(options, option)), \" \")\r\n      found = false\r\n      foreach (w, words_in_option) {\r\n        if (StartsWith(w, word)) {\r\n          found = true\r\n        }\r\n      }\r\n      if (found) {\r\n        list add (stillpossible, option)\r\n      }\r\n    }\r\n    possibilities = stillpossible\r\n  }\r\n  if (ListCount (possibilities) = 1) {\r\n    ShowMenuResponse(possibilities[0])\r\n    ClearMenu()\r\n    return (true)\r\n  }\r\n  else if (HasScript(menu, \"menucancelcallback\")) {\r\n    params = NewDictionary()\r\n    dictionary add (params, \"options\", options)\r\n    dictionary add (params, \"input\", input)\r\n    do (menu, \"menucancelcallback\", params)\r\n    if (GetBoolean(game, \"menuallowcancel\")) {\r\n      ClearMenu()\r\n    }\r\n  }\r\n  return (false)\r\n</function>\r\n  \r\n<function name=\"ClearMenu\">\r\n  if (HasString(game, \"menuoutputsection\")) {\r\n    if (GetBoolean(game, \"menuhideafter\")) {\r\n      HideOutputSection(game.menuoutputsection)\r\n    }\r\n    else {\r\n      JS.eval(\"name = '\"+game.menuoutputsection+\"';EndOutputSection(name);$('.' + name + ' .cmdlink').attr('onclick', '');\")\r\n    }\r\n    game.menuoutputsection = null\r\n  }\r\n\r\n  // If we're running an unresolved command script to check player input against menu options\r\n  // we need to move all the menu data into a new object\r\n  // to ensure that it doesn't screw up if the player entered a command that creates a new menu\r\n  //\r\n  // But destroy it the next time ClearMenu is called\r\n\r\n  if (not GetObject(\"showmenu_data_object\") = null) {\r\n    destroy (\"showmenu_data_object\")\r\n  }\r\n\r\n  foreach (attr, Split(\"menuoptionskeys;menudisplayedoptions;menuoutputsection;menucallback;menuallowcancel;menucancelcallback\")) {\r\n    if (HasAttribute(game, attr)) {\r\n      if (GetBoolean(game, \"showmenuunresolvedcommand\")) {\r\n        if (GetObject(\"showmenu_data_object\") = null) {\r\n          create (\"showmenu_data_object\")\r\n        }\r\n        set (showmenu_data_object, attr, GetAttribute(game, attr))\r\n      }\r\n      set (game, attr, null)\r\n    }\r\n  }\r\n</function>\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>Here we are again, folks!</p>\n<p>Here's my attempt at overriding some of the core functions so that ShowMenu gives you more flexibility.</p>\n<p>Sadly untested, due to not having a windows machine on which to run the desktop version of quest. So there may be typos in here. Would appreciate if anyone can tell me if this works; or wrap these functions in a library to make them easier to use.</p>\n<p>Main features:</p>\n<ul>\n<li>Functions similar to ShowMenu that allow you to display a numbered list, a bullet list, a list of options on one line, or return a single option so you can include the menu options within a paragraph.</li>\n<li>Option to hide the menu after making a selection, or just disable the links.</li>\n<li>Callback for if the menu is cancelled (so in your dialogue menu, you could make the guy yell \"Hey, where are you going?\" if the player walks off)</li>\n<li>Attributes on the game object to control which kind of menu ShowMenu shows. Default should look just like the default one.</li>\n<li>Player can type one of the menu options.</li>\n<li>Let the player choose an option by typing just one word, or the start of a word (in the same way as partially naming an object for a command); game attribute to determine if this catches the names of menu options that are also commands.</li>\n</ul>\n<details>\n<summary>Attributes of the game object</summary>\n<ul>\n<li><code>game.alwaysshowmenunumbers</code> - boolean. If true, menu options that aren't in a numbered list will have a number in parentheses displayed after them.</li>\n<li><code>game.showmenutype</code> - string. Can be <code>\"number\"</code>, <code>\"bullet\"</code>, <code>\"flat\"</code>, or some other string which will be used as a bullet when ShowMenu is called. (\"flat\" displays the menu as a single line using FormatList).</li>\n<li><code>game.hidemenus</code> - boolean. If set to false, choosing a menu option will remove the links, but won't actually vanish the menu.</li>\n<li><code>game.showmenutryharder</code> - boolean. If true, typing a word that appears in exactly one of the menu options will choose that option; or the start of a word (like when typing object names).</li>\n<li><code>game.showmenuunresolvedcommand</code> - boolean. As above, but this behaviour will be pushed into the unresolved command handler, so that it only happens if the word isn't also a command. This may cause bugs if you have a command which modifies <code>game.unresolvedcommandhandler</code> during play.</li>\n</ul>\n</details>\n<details>\n<summary>Menu display functions</summary>\n<ul>\n<li><code>StartShowMenu (caption)</code> - Starts a menu, and displays the caption.\n<ul>\n<li>If you do this more than once in the same menu, subsequent ones will just print the caption.</li>\n<li>If you miss this out, it will be called as soon as you call AddMenuOption (sorry, that's ugly, as you might want to generate options before actually printing them. But I can't see a way around it)</li>\n</ul>\n</li>\n<li><code>EndShowMenu (allowCancel, hideAfterMenu, callback)</code>\n<ul>\n<li>Marks the end of the menu, and sets the callback.</li>\n<li><code>hideAfterMenu</code> - boolean. If true, everything between StartShowMenu and EndShowMenu will be hidden once an option is chosen. If false, the links will be disabled but remain on screen.</li>\n</ul>\n</li>\n<li><code>MenuCancelledCallback (script)</code>\n<ul>\n<li>Set a script to be run if the menu is not called.</li>\n<li>Note that this is a <strong>misleading function name</strong>, as I couldn't think of a better one.</li>\n<li>In the case of a menu with <code>allowCancel</code> set to false, this will be run each time the player enters something that can't be parsed as a valid choice. If you call <code>ClearMenu</code> from within the callback, you also need to call <code>MenuCancelledCallback(null)</code>.</li>\n<li>The callback will get the parameters:\n<ul>\n<li><code>options</code> - a dictionary of options the player didn't choose from</li>\n<li><code>input</code> - what the player actually entered</li>\n<li><code>command</code> - if applicable, the command that was executed instead of choosing a menu option (note that in this case, the callback will be run <em>after</em> the command)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>AddMenuOption (option, result, displayNumber)</code>\n<ul>\n<li><strong>Returns</strong> a string containing all the HTML for a clickable link menu option. You need to use <code>msg()</code> to pass this to the player.</li>\n<li><code>option</code> - The option to display. Calls GetDisplayAlias() if it's an object, using <code>linkcolour</code> if set, and ToString() for any other type that isn't a string.</li>\n<li><code>result</code> - The value that the 'result' variable will be set to in the callback.\n<ul>\n<li>String - <code>result</code> in the callback will be the string</li>\n<li>Object - <code>result</code> in the callback will be the object's name</li>\n<li>Anything else - <code>result</code> in the callback will be <code>option</code>'s name if it's an object, and <code>option</code> otherwise</li>\n</ul>\n</li>\n<li><code>displayNumber</code> - boolean. If true, will allow the player to select the option by typing its number. Will display like \"Would you like Red (1), Blue (2), or Yellow (3)?\". If this is a format string instead, <code>!</code> will be replaced by the option, and <code>#</code> by the number.</li>\n</ul>\n</li>\n<li><code>AddMenuNumberedList (options)</code>\n<ul>\n<li><strong>Returns</strong> the HTML for a numbered list, like the original ShowMenu displays. You can modify this string if you want before outputting it.</li>\n<li><code>options</code> - I <em>think</em> this should handle an options list in any of the formats ShowMenu supports</li>\n</ul>\n</li>\n<li><code>AddMenuBulletList (options, bullet)</code>\n<ul>\n<li><strong>Returns</strong> a bulleted list; as above, but without numbering the options</li>\n<li>If <code>game.alwaysshowmenunumbers</code> is set, will add bracketed numbers after each option</li>\n<li><code>bullet</code> - string, to display before each option. If <code>\"\"</code>, will return a HTML <code>&lt;ul&gt;</code> element instead.</li>\n</ul>\n</li>\n<li><code>AddMenuFlatList (options, lastjoiner)</code>\n<ul>\n<li><strong>Returns</strong> a list of options on a single line, generated using <code>FormatList</code>.</li>\n<li><code>lastjoiner</code> - you probably want <code>\"[Or]\"</code> or <code>\"[And]\"</code> here.</li>\n</ul>\n</li>\n<li><code>ShowMenu</code>\n<ul>\n<li>Same parameters as the default one. This will call <code>StartShowMenu</code>, then either AddMenuNumberedList, AddMenuBulletList, or AddMenuFlatList (depending on the value of <code>game.showmenutype</code>), then EndShowMenu.</li>\n<li>I've attempted to ensure that if none of the game attributes mentioned above are set, this will behave exactly the same as the standard ShowMenu function.</li>\n</ul>\n</li>\n</ul>\n</details>\n<details>\n<summary>The code</summary>\n<pre><code>&lt;function name=\"StartShowMenu\" parameters=\"caption\"&gt;\n  if (not HasString(game, \"menuoutputsection\")) {\n    game.menuoutputsection = StartNewOutputSection()\n  }\n  msg (caption)\n  game.menuoptionskeys = NewStringList()\n  game.menudisplayedoptions = NewStringDictionary()\n  game.menucallback =&gt; {\n    error (\"Menu callback not set\")\n  }\n&lt;/function&gt;\n\n&lt;function name=\"MenuCancelledCallback\" parameters=\"callback\"&gt;\n  game.menucancelcallback = callback\n&lt;/function&gt;\n\n&lt;function name=\"AddMenuOption\" type=\"string\" parameters=\"option, result, displayNumber\"&gt;\n  &lt;![CDATA[\n  if (not HasString(game, \"menuoutputsection\")) {\n    StartShowMenu(\"\")\n  }\n  if (TypeOf(option) = \"object\") {\n    optionText = GetDisplayAlias(option)\n    optionTag = option.name\n    if (HasString(option, \"linkcolour\") and GetUIOption(\"UseGameColours\") = \"true\") {\n      colour = option.linkcolour\n    }\n    else {\n      colour = GetLinkTextColour()\n    }\n    style = GetCurrentTextFormat(colour)\n  }\n  else if (TypeOf(option) = \"string\") {\n    optionText = option\n    optionTag = option\n    style = GetCurrentLinkTextFormat()\n  }\n  else {\n    optionText = ToString(option)\n    optionTag = optionText\n    style = \"\"\n  }\n  if (IsDefined(\"result\")) {\n    if (TypeOf(result) = \"string\") {\n      if (LengthOf(result) &gt; 0) {\n        optionTag = result\n      }\n    }\n    else if (TypeOf(result) = \"object\") {\n      optionTag = result.name\n    }\n  }\n  result = \"&lt;a class=\\\"cmdlink\\\" style=\\\"\" + style + \"\\\" onclick=\\\"ASLEvent('ShowMenuResponse','\" + EscapeQuotes(optionTag) + \"')\\\"&gt;\" + optionText + \"&lt;/a&gt;\"\n  dictionary add (game.menudisplayedoptions, optionTag, optionText)\n  if (TypeOf(displayNumber) = \"string\") {\n    if (IndexOf (displayNumber, \"!\") &gt; 0) {\n      result = Replace (displayNumber, \"!\", result)\n    }\n    else {\n      result = displayNumber + \" \" + result\n    }\n    if (IndexOf (result, \"#\") &gt; 0) {\n      list add (game.menuoptionskeys, optionTag)\n      result = Replace (displaynumber, \"#\", ListCount(game.menuoptionskeys))\n    }\n  }\n  else if (Equal(displayNumber, true) or GetBoolean(game, \"alwaysshowmenunumbers\")) {\n    list add (game.menuoptionskeys, optionTag)\n    result = result + \" (\" + ListCount(game.menuoptionskeys) + \")\"\n  }\n  return (result)\n  ]]&gt;\n&lt;/function&gt;\n\n&lt;function name=\"EndShowMenu\" parameters=\"allowCancel, hideAfterMenu, callback\"&gt;\n  if (not HasString(game, \"menuoutputsection\")) {\n    error(\"Menu not started\")\n  }\n  EndOutputSection (game.menuoutputsection)\n  game.menuallowcancel = allowCancel\n  game.menucallback = callback\n  game.menuhideafter = hideAfterMenu\n&lt;/function&gt;\n\n&lt;function name=\"AddMenuNumberedList\" parameters=\"options\"&gt;\n&lt;![CDATA[\n  if (TypeOf(options) = \"object\") {\n    options = GetDirectChildren(options)\n  }\n  else if (TypeOf(options) = \"string\") {\n    options = Split(options)\n  }\n\n  result = NewStringList()\n  foreach (o, options) {\n    optionText = o\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\n      optionText = DictionaryItem(options, o)\n    }\n    list add (result, AddMenuOption(optionText, o, \"#. \"))\n  }\n  return (Join (result, \"&lt;br/&gt;\"))\n]]&gt;\n&lt;/function&gt;\n\n&lt;function name=\"AddMenuBulletList\" parameters=\"options, bullet\"&gt;\n&lt;![CDATA[\n  if (not TypeOf(bullet) = \"string\") {\n    bullet = \"\"\n  }\n  if (TypeOf(options) = \"object\") {\n    options = GetDirectChildren(options)\n  }\n  else if (TypeOf(options) = \"string\") {\n    options = Split(options)\n  }\n\n  result = NewStringList()\n  foreach (o, options) {\n    optionText = o\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\n      optionText = DictionaryItem(options, o)\n    }\n    list add (result, bullet + AddMenuOption(optionText, o, false))\n  }\n  if (bullet = \"\") {\n    return (\"&lt;ul&gt;&lt;li&gt;\" + Join(result, \"&lt;/li&gt;\\n&lt;li&gt;\") + \"&lt;/li&gt;&lt;/ul&gt;\\n\")\n  }\n  else {\n    return (Join (result, \"&lt;br/&gt;\"))\n  }\n]]&gt;\n&lt;/function&gt;\n\n&lt;function name=\"AddMenuFlatList\" parameters=\"options, lastjoiner\"&gt;\n&lt;![CDATA[\n  if (TypeOf(options) = \"object\") {\n    options = GetDirectChildren(options)\n  }\n  else if (TypeOf(options) = \"string\") {\n    options = Split(options)\n  }\n\n  result = NewStringList()\n  foreach (o, options) {\n    optionText = o\n    if (EndsWith(TypeOf(o), \"dictionary\")) {\n      optionText = DictionaryItem(options, o)\n    }\n    list add (result, \"· \" + AddMenuOption(optionText, o, false))\n  }\n  return (FormatList(result, \",\", lastjoiner, \"\"))\n]]&gt;\n&lt;/function&gt;\n\n&lt;function name=\"ShowMenu\" parameters=\"caption, options, allowCancel, callback\"&gt;\n  StartShowMenu(caption)\n  type = \"number\"\n  if (Equal (game.alwaysshowmenunumbers, false)) {\n    type = \"bullet\"\n  }\n  if (HasString (game, \"showmenutype\")) {\n    type = LCase(game.showmenutype)\n  }\n  if (type = \"bullet\") {\n    msg (AddMenuBulletList(options), \"\")\n  }\n  else if (type = \"flat\") {\n    msg (AddMenuFlatList(options, \"[Or]\"))\n  }\n  else if (type = \"number\") {\n    msg (AddMenuNumberedList(options))\n  }\n  else {\n    msg (AddMenuBulletList(options), type)\n  }\n  if (not HasBoolean(game, \"hidemenus\")) {\n    game.hidemenus = true\n  }\n  EndShowMenu(allowCancel, game.hidemenus, callback)\n&lt;/function&gt;\n\n&lt;function name=\"HandleMenuTextResponse\" parameters=\"input\" type=\"boolean\"&gt;\n  &lt;![CDATA[\n  handled = false\n  if (IsInt(input)) {\n    number = ToInt(input)\n    if (number &gt; 0 and number &lt;= ListCount(game.menuoptionskeys)) {\n      ShowMenuResponse(StringListItem(game.menuoptionskeys, number - 1))\n      return (true)\n    }\n  }\n  else if(HasAttribute(game, \"menudisplayedoptions\")) {\n    foreach (option, game.menudisplayedoptions) {\n      if (LCase(Trim(StringDictionaryItem(game.menudisplayedoptions, option))) = LCase(Trim(input))) {\n        ShowMenuResponse(option)\n        game.menucancelcallback = null\n        return (true)\n      }\n    }\n    if (GetBoolean(game, \"showmenutryharder\") or not GetBoolean(game, \"menuallowcancel\")) {\n      handled = HandleMenuTextHarder (game, input)\n      return (handled)\n    }\n    else if (GetBoolean(game, \"showmenuunresolvedcommand\")) {\n      if (HasScript(game, \"unresolvedcommandhandler\")) {\n        game.unresolvedcommandbackup = game.unresolvedcommandhandler\n      }\n      SetTurnTimeout(0) {\n        if (HasScript (showmenu_data_object, \"menucancelcallback\")) {\n          params = NewDictionary()\n          dictionary add (params, \"options\", showmenu_data_object.menudisplayedoptions)\n          dictionary add (params, \"input\", game.pov.currentcommand)\n          dictionary add (params, \"command\", game.pov.currentcommandpattern)\n          do (showmenu_data_object, \"menucancelcallback\", params)\n        }\n        ClearMenu()\n        if (HasScript(game, \"unresolvedcommandbackup\")) {\n          game.unresolvedcommandhandler = game.unresolvedcommandbackup\n          game.unresolvedcommandbackup = null\n        }\n      }\n      game.unresolvedcommandhandler =&gt; {\n        handled = HandleMenuTextHarder (showmenu_data_object, command)\n        if (HasScript(game, \"unresolvedcommandbackup\")) {\n          game.unresolvedcommandhandler = game.unresolvedcommandbackup\n          game.unresolvedcommandbackup = null\n        }\n        if (not handled) {\n          if (HasScript(game, \"unresolvedcommandhandler\")) {\n            params = NewDictionary()\n            dictionary add(params, \"command\", command)\n            do (game, \"unresolvedcommandhandler\", params)\n          } else {\n            msg (Template(\"UnrecognisedCommand\"))\n          }\n        }\n      }\n    }\n  }\n  return (false)\n  ]]&gt;\n&lt;/function&gt;\n\n&lt;function name=\"HandleMenuTextHarder\" parameters=\"menu, input\"&gt;\n  possibilities = NewStringList()\n  options = menu.menudisplayedoptions\n  foreach (option, options) {\n    list add (possibilities, option)\n  }\n  foreach (word, Split(LCase(input), \" \")) {\n    stillpossible = NewStringList()\n    foreach (option, possibilities) {\n      words_in_option = Split(LCase(StringDictionaryItem(options, option)), \" \")\n      found = false\n      foreach (w, words_in_option) {\n        if (StartsWith(w, word)) {\n          found = true\n        }\n      }\n      if (found) {\n        list add (stillpossible, option)\n      }\n    }\n    possibilities = stillpossible\n  }\n  if (ListCount (possibilities) = 1) {\n    ShowMenuResponse(possibilities[0])\n    ClearMenu()\n    return (true)\n  }\n  else if (HasScript(menu, \"menucancelcallback\")) {\n    params = NewDictionary()\n    dictionary add (params, \"options\", options)\n    dictionary add (params, \"input\", input)\n    do (menu, \"menucancelcallback\", params)\n    if (GetBoolean(game, \"menuallowcancel\")) {\n      ClearMenu()\n    }\n  }\n  return (false)\n&lt;/function&gt;\n  \n&lt;function name=\"ClearMenu\"&gt;\n  if (HasString(game, \"menuoutputsection\")) {\n    if (GetBoolean(game, \"menuhideafter\")) {\n      HideOutputSection(game.menuoutputsection)\n    }\n    else {\n      JS.eval(\"name = '\"+game.menuoutputsection+\"';EndOutputSection(name);$('.' + name + ' .cmdlink').attr('onclick', '');\")\n    }\n    game.menuoutputsection = null\n  }\n\n  // If we're running an unresolved command script to check player input against menu options\n  // we need to move all the menu data into a new object\n  // to ensure that it doesn't screw up if the player entered a command that creates a new menu\n  //\n  // But destroy it the next time ClearMenu is called\n\n  if (not GetObject(\"showmenu_data_object\") = null) {\n    destroy (\"showmenu_data_object\")\n  }\n\n  foreach (attr, Split(\"menuoptionskeys;menudisplayedoptions;menuoutputsection;menucallback;menuallowcancel;menucancelcallback\")) {\n    if (HasAttribute(game, attr)) {\n      if (GetBoolean(game, \"showmenuunresolvedcommand\")) {\n        if (GetObject(\"showmenu_data_object\") = null) {\n          create (\"showmenu_data_object\")\n        }\n        set (showmenu_data_object, attr, GetAttribute(game, attr))\n      }\n      set (game, attr, null)\n    }\n  }\n&lt;/function&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-03-21T11:12:43.3482255Z",
      "LastEditDate": "2018-03-21T11:13:35.7925698Z",
      "link": null
    },
    {
      "PostId": "4ca4b4c3-54d7-4832-b19a-6f06d4dc68fb",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I personally like using numbers for input (and like using typed-in input), as much as possible / whenever possible, as it's the least amount of typing possible, to help with arithritis, carpal tunnel syndrome, etc stuff, lol, and it's also easy and fast too.\r\n\r\nSo, I'm trying to create my own menu system using numbers for typed-in input (and thus menu coding), though I'm still fumbling my way through it, as I'm not quite at your level, mrangel, lol.\r\n\r\n-------\r\n\r\nanyways, awesome code/library thread/post, as I'll be studying it for help/ideas for my own menu system (crediting you of course as/if I use any of it: concrete code or concept/design ideas), hehe",
      "EditableFormat": "markdown",
      "HTML": "<p>I personally like using numbers for input (and like using typed-in input), as much as possible / whenever possible, as it's the least amount of typing possible, to help with arithritis, carpal tunnel syndrome, etc stuff, lol, and it's also easy and fast too.</p>\n<p>So, I'm trying to create my own menu system using numbers for typed-in input (and thus menu coding), though I'm still fumbling my way through it, as I'm not quite at your level, mrangel, lol.</p>\n<hr>\n<p>anyways, awesome code/library thread/post, as I'll be studying it for help/ideas for my own menu system (crediting you of course as/if I use any of it: concrete code or concept/design ideas), hehe</p>\n\n",
      "PostDate": "2018-03-21T11:45:33.112003Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "cf2cd637-55be-4bdd-906a-ae34adb6f892",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "ShowMenu allows you to type in the numbers, which is pretty neat.\r\nI just tweaked it so that it allows you to click the option *or* type the number *or* type the start of the option text.\r\n(as well as allowing some different stylistic choices)\r\n\r\nThis isn't very neat code, and I wouldn't be surprised if there's still errors in there.",
      "EditableFormat": "markdown",
      "HTML": "<p>ShowMenu allows you to type in the numbers, which is pretty neat.<br>\nI just tweaked it so that it allows you to click the option <em>or</em> type the number <em>or</em> type the start of the option text.<br>\n(as well as allowing some different stylistic choices)</p>\n<p>This isn't very neat code, and I wouldn't be surprised if there's still errors in there.</p>\n\n",
      "PostDate": "2018-03-21T11:51:25.2445686Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "79baded6-f4a2-432d-924c-1b049063df5c",
      "UserId": 304102,
      "Username": "Doctor Agon",
      "AvatarUrl": "http://i.imgur.com/Lzd3mOwb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Awesome coding as always, like the names of some of your attributes too.\r\n\r\nBeing a bit silly here, so please forgive me.\r\n\r\nalwaysshowmenunumbers - _always show me nun umbers - I do like the look of an umber on a nun too._\r\nshowmenutryharder - _show me nutry harder - Can't work out if that's a nut-tree or you're just boasting._\r\n\r\nSeriously though, good piece of coding.",
      "EditableFormat": "markdown",
      "HTML": "<p>Awesome coding as always, like the names of some of your attributes too.</p>\n<p>Being a bit silly here, so please forgive me.</p>\n<p>alwaysshowmenunumbers - <em>always show me nun umbers - I do like the look of an umber on a nun too.</em><br>\nshowmenutryharder - <em>show me nutry harder - Can't work out if that's a nut-tree or you're just boasting.</em></p>\n<p>Seriously though, good piece of coding.</p>\n\n",
      "PostDate": "2018-03-21T13:22:47.7327446Z",
      "LastEditDate": "2018-03-21T13:23:40.7778329Z",
      "link": null
    },
    {
      "PostId": "d837b178-724f-427c-bb85-aab9f779e157",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/1xu84dwb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Awesome :D I love this Mr.Angel, especially customizing different messages that can be printed if the player cancels the menu or something. So cool! It definitely would be great too to have the option of turning on or off the numbered lists. Man, I wish I was talented >.<\r\n\r\nAnonynn. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Awesome :D I love this Mr.Angel, especially customizing different messages that can be printed if the player cancels the menu or something. So cool! It definitely would be great too to have the option of turning on or off the numbered lists. Man, I wish I was talented &gt;.&lt;</p>\n<p>Anonynn.</p>\n\n",
      "PostDate": "2018-03-22T19:11:16.0477578Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
