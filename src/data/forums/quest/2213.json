{
  "Topic": {
    "TopicId": "2213",
    "ForumId": "10",
    "Title": "creating endless rooms/region",
    "LastUpdated": "2009-11-29T14:56:00+00:00",
    "ReplyCount": 7
  },
  "Posts": [
    {
      "PostId": "17131",
      "UserId": 0,
      "Username": "ender",
      "UserAvatar": null,
      "UserGravatar": "f0e4b65cada813dc0b9262de27725b82",
      "EditableText": "I'm fairly new to Quest. I've been using IF7 for a while but recently decided I wanted to try quest because of the ingame interface. I've purchased the pro version.\n\nI am building a game with a single building that is surrounded by a haunted forest. Rather than keeping the player from entering the forest or manually creating a huge number of rooms with the same description ... I thought there must be some way to programatically allow the player to enter the forest and just wander around from 'room to room' until they realize the forest is more or less endless and there is little point in wandering around in it.\n\nI thought of two solutions to this ... \n\n1. Some kind of loop where the player is really going back to the same room all the time ... but then the problem is how to keep track of the way back so they can return to the rest of the game.... \n\n2. automatically creating new rooms ... and I really don't understand quest well enough to really even know what problems will arise .. \n\nI've worked on it for several hours and have come to a dead end, so I decided to ask for help. \n\nSo my questions for the community are:\n\n1. Is either solution possible?\n\n2. If both solutions are possible, which would be the better?\n\n3. Is there a better solution than either of these?\n\n4. Any ideas about how I might go about implementing this? If you can just point me in the right direction I can probably go from there, I'm not asking someone to do the work for me ... also, I'm experienced with programming concepts and terms so feel free to throw them out ... \n\nThanks,\nE",
      "EditableFormat": "bbcode",
      "HTML": "I'm fairly new to Quest. I've been using IF7 for a while but recently decided I wanted to try quest because of the ingame interface. I've purchased the pro version.<br/><br/>I am building a game with a single building that is surrounded by a haunted forest. Rather than keeping the player from entering the forest or manually creating a huge number of rooms with the same description ... I thought there must be some way to programatically allow the player to enter the forest and just wander around from 'room to room' until they realize the forest is more or less endless and there is little point in wandering around in it.<br/><br/>I thought of two solutions to this ... <br/><br/>1. Some kind of loop where the player is really going back to the same room all the time ... but then the problem is how to keep track of the way back so they can return to the rest of the game.... <br/><br/>2. automatically creating new rooms ... and I really don't understand quest well enough to really even know what problems will arise .. <br/><br/>I've worked on it for several hours and have come to a dead end, so I decided to ask for help. <br/><br/>So my questions for the community are:<br/><br/>1. Is either solution possible?<br/><br/>2. If both solutions are possible, which would be the better?<br/><br/>3. Is there a better solution than either of these?<br/><br/>4. Any ideas about how I might go about implementing this? If you can just point me in the right direction I can probably go from there, I'm not asking someone to do the work for me ... also, I'm experienced with programming concepts and terms so feel free to throw them out ... <br/><br/>Thanks,<br/>",
      "PostDate": "2009-11-21T18:56:00+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17132",
      "UserId": 0,
      "Username": "Wonderjudge",
      "UserAvatar": null,
      "UserGravatar": "29fd1b3b35ac2ca468be63961f946852",
      "EditableText": "The best solution in my opinion would be the endlessly returning to the same room. If you want to make it so that the player can't just one click back out of the forest then I suggest assigning variables to keep track of the players location. ie\nevery time a player goes east incremement the variable east1 by one and every time he goes west decrement it until 0 then start incrementing the west1 variable.\nAs there are so many directions it would be complicated to do.\nThe only other problem with the one room thing is players dropping items. A dropped item would show up in the room no matter what the variables were set to. You could make it so that players can't drop item there however.\nWonderjudge.",
      "EditableFormat": "bbcode",
      "HTML": "The best solution in my opinion would be the endlessly returning to the same room. If you want to make it so that the player can't just one click back out of the forest then I suggest assigning variables to keep track of the players location. ie<br/>every time a player goes east incremement the variable east1 by one and every time he goes west decrement it until 0 then start incrementing the west1 variable.<br/>As there are so many directions it would be complicated to do.<br/>The only other problem with the one room thing is players dropping items. A dropped item would show up in the room no matter what the variables were set to. You could make it so that players can't drop item there however.<br/>Wonderjudge.",
      "PostDate": "2009-11-21T19:16:05+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17133",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "Here's a solution. It dynamically creates more and more forest as the player keeps exploring. The player can retrace their steps.\n\nOne downside is you have to retrace your steps exactly - that may or may not be what you're after. If you want the player to be able to go north, east, south then west and end up where they started, this solution will need refining somewhat.\n\n[code:9l4wreqx]\ndefine game &lt;Forest&gt;\n\tasl-version &lt;410&gt;\n\tstart &lt;house&gt;\n\tstartscript {\n\t\tset numeric &lt;counter; 0&gt;\n\t\tset string &lt;oldroom;&gt;\n\t}\n\tafterturn {\n\t\tif (#quest&#46;currentroom# &lt;&gt; #oldroom#) and property &lt;#quest&#46;currentroom#; isforest&gt; and not property &lt;#quest&#46;currentroom#; createdforest&gt; then do &lt;createforest(#quest&#46;currentroom#)&gt;\n\t\tset &lt;oldroom; #quest&#46;currentroom#&gt;\n\t}\nend define\n\ndefine room &lt;house&gt;\n\tsouth &lt;forest&gt;\t\nend define\n\ndefine room &lt;forest&gt;\n\tscript do &lt;createforest(forest)&gt;\n\tnorth &lt;house&gt;\nend define\n\ndefine procedure &lt;createforest&gt;\n\tset numeric &lt;start; %counter%&gt;\n\tfor &lt;i; 1; 4&gt; {\n\t\tcreate room &lt;forest%counter%&gt;\n\t\tinc &lt;counter&gt;\n\t}\n\t\n\tflag on &lt;create north&gt;\n\tflag on &lt;create south&gt;\n\tflag on &lt;create east&gt;\n\tflag on &lt;create west&gt;\n\t\n\tset string &lt;p; $parameter(1)$&gt;\n\tif ($findexit(#p#; north)$ &lt;&gt;) then flag off &lt;create north&gt;\n\tif ($findexit(#p#; south)$ &lt;&gt;) then flag off &lt;create south&gt;\n\tif ($findexit(#p#; east)$ &lt;&gt;) then flag off &lt;create east&gt;\n\tif ($findexit(#p#; west)$ &lt;&gt;) then flag off &lt;create west&gt;\n\t\n\tset string &lt;northplace; forest%start%&gt;\n\tset string &lt;southplace; forest{%start%+1}&gt;\n\tset string &lt;eastplace; forest{%start%+2}&gt;\n\tset string &lt;westplace; forest{%start%+3}&gt;\n\tif flag &lt;create north&gt; then {\n\t\tcreate exit north &lt;$parameter(1)$; #northplace#&gt;\n\t\tcreate exit south &lt;#northplace#; $parameter(1)$&gt;\n\t\tproperty &lt;#northplace#; isforest&gt;\n\t}\n\tif flag &lt;create south&gt; then {\n\t\tcreate exit south &lt;$parameter(1)$; #southplace#&gt;\n\t\tcreate exit north &lt;#southplace#; $parameter(1)$&gt;\n\t\tproperty &lt;#southplace#; isforest&gt;\n\t}\n\tif flag &lt;create east&gt; then {\n\t\tcreate exit east &lt;$parameter(1)$; #eastplace#&gt;\n\t\tcreate exit west &lt;#eastplace#; $parameter(1)$&gt;\n\t\tproperty &lt;#eastplace#; isforest&gt;\n\t}\n\tif flag &lt;create west&gt; then {\n\t\tcreate exit west &lt;$parameter(1)$; #westplace#&gt;\n\t\tcreate exit east &lt;#westplace#; $parameter(1)$&gt;\n\t\tproperty &lt;#westplace#; isforest&gt;\n\t}\n\tproperty &lt;$parameter(1)$; createdforest&gt;\nend define\n[/code:9l4wreqx]",
      "EditableFormat": "bbcode",
      "HTML": "Here's a solution. It dynamically creates more and more forest as the player keeps exploring. The player can retrace their steps.<br/><br/>One downside is you have to retrace your steps exactly - that may or may not be what you're after. If you want the player to be able to go north, east, south then west and end up where they started, this solution will need refining somewhat.<br/><br/><pre><code><br/>define game &lt;Forest&gt;<br/>\tasl-version &lt;410&gt;<br/>\tstart &lt;house&gt;<br/>\tstartscript {<br/>\t\tset numeric &lt;counter; 0&gt;<br/>\t\tset string &lt;oldroom;&gt;<br/>\t}<br/>\tafterturn {<br/>\t\tif (#quest&#46;currentroom# &lt;&gt; #oldroom#) and property &lt;#quest&#46;currentroom#; isforest&gt; and not property &lt;#quest&#46;currentroom#; createdforest&gt; then do &lt;createforest(#quest&#46;currentroom#)&gt;<br/>\t\tset &lt;oldroom; #quest&#46;currentroom#&gt;<br/>\t}<br/>end define<br/><br/>define room &lt;house&gt;<br/>\tsouth &lt;forest&gt;\t<br/>end define<br/><br/>define room &lt;forest&gt;<br/>\tscript do &lt;createforest(forest)&gt;<br/>\tnorth &lt;house&gt;<br/>end define<br/><br/>define procedure &lt;createforest&gt;<br/>\tset numeric &lt;start; %counter%&gt;<br/>\tfor &lt;i; 1; 4&gt; {<br/>\t\tcreate room &lt;forest%counter%&gt;<br/>\t\tinc &lt;counter&gt;<br/>\t}<br/>\t<br/>\tflag on &lt;create north&gt;<br/>\tflag on &lt;create south&gt;<br/>\tflag on &lt;create east&gt;<br/>\tflag on &lt;create west&gt;<br/>\t<br/>\tset string &lt;p; $parameter(1)$&gt;<br/>\tif ($findexit(#p#; north)$ &lt;&gt;) then flag off &lt;create north&gt;<br/>\tif ($findexit(#p#; south)$ &lt;&gt;) then flag off &lt;create south&gt;<br/>\tif ($findexit(#p#; east)$ &lt;&gt;) then flag off &lt;create east&gt;<br/>\tif ($findexit(#p#; west)$ &lt;&gt;) then flag off &lt;create west&gt;<br/>\t<br/>\tset string &lt;northplace; forest%start%&gt;<br/>\tset string &lt;southplace; forest{%start%+1}&gt;<br/>\tset string &lt;eastplace; forest{%start%+2}&gt;<br/>\tset string &lt;westplace; forest{%start%+3}&gt;<br/>\tif flag &lt;create north&gt; then {<br/>\t\tcreate exit north &lt;$parameter(1)$; #northplace#&gt;<br/>\t\tcreate exit south &lt;#northplace#; $parameter(1)$&gt;<br/>\t\tproperty &lt;#northplace#; isforest&gt;<br/>\t}<br/>\tif flag &lt;create south&gt; then {<br/>\t\tcreate exit south &lt;$parameter(1)$; #southplace#&gt;<br/>\t\tcreate exit north &lt;#southplace#; $parameter(1)$&gt;<br/>\t\tproperty &lt;#southplace#; isforest&gt;<br/>\t}<br/>\tif flag &lt;create east&gt; then {<br/>\t\tcreate exit east &lt;$parameter(1)$; #eastplace#&gt;<br/>\t\tcreate exit west &lt;#eastplace#; $parameter(1)$&gt;<br/>\t\tproperty &lt;#eastplace#; isforest&gt;<br/>\t}<br/>\tif flag &lt;create west&gt; then {<br/>\t\tcreate exit west &lt;$parameter(1)$; #westplace#&gt;<br/>\t\tcreate exit east &lt;#westplace#; $parameter(1)$&gt;<br/>\t\tproperty &lt;#westplace#; isforest&gt;<br/>\t}<br/>\tproperty &lt;$parameter(1)$; createdforest&gt;<br/>end define<br/></code></pre>",
      "PostDate": "2009-11-21T22:18:20+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17134",
      "UserId": 0,
      "Username": "ender",
      "UserAvatar": null,
      "UserGravatar": "f0e4b65cada813dc0b9262de27725b82",
      "EditableText": "Thank you both very much.\n\nI had also come up with Wonderjudges thought .... which is what I had been working on but the calculations were becoming so bulky that it seemed like there should be a more elegant solution ... I didn't even think of the possiblity of problems with dropping objects though. So that creates a big problem.\n\nAlex's solution sounds pretty good except the need to retrace the route exactly ... but that might work ... it is a haunted forest after all ... could say the forest closes in around them as they travel, forcing them to return retrace their steps... hmm... if I come up with a better solution I'll post it. \n\nThanks.",
      "EditableFormat": "bbcode",
      "HTML": "Thank you both very much.<br/><br/>I had also come up with Wonderjudges thought .... which is what I had been working on but the calculations were becoming so bulky that it seemed like there should be a more elegant solution ... I didn't even think of the possiblity of problems with dropping objects though. So that creates a big problem.<br/><br/>Alex's solution sounds pretty good except the need to retrace the route exactly ... but that might work ... it is a haunted forest after all ... could say the forest closes in around them as they travel, forcing them to return retrace their steps... hmm... if I come up with a better solution I'll post it. <br/><br/>Thanks.",
      "PostDate": "2009-11-21T23:56:17+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17135",
      "UserId": 0,
      "Username": "Freak",
      "UserAvatar": null,
      "UserGravatar": "325ed9ac125e00c9937be0d3aea0916d",
      "EditableText": "Implementing a large number of rooms with a single room (or rather, one room for the all the rooms, and one object cache) is a well-known Inform trick:\n- give every object a maze-location property\n- right before the player moves from a maze room:\n- - loop over all objects in the maze room\n- - - set that object's maze-location property appropriately\n- - - move it to the cache room\n-\n- right before the player moves to a maze room:\n- - loop over all objects in the cache room\n- - - if the object's maze-location property matches the destination\n- - - - move that object to the maze\n- - - - clear its maze-location property\n\n(See the middle part of Hunter in Darkness, for one example of this.)  Not sure how difficult this is to do in Quest.\n\nAlternately, if you really insist on dynamically creating rooms:\n- Create a class ForestRoom\n- - Every ForestRoom has properties coord_x and coord_y\n- - The west property is a routine   playerto &lt;$get_forest_room(this.coord_x-1, this.coord_y)$&gt;\n- - ( similar with the other exit routines )\n-\n- Create a function $get_forest_room(x,y)$\n- - Set variable #rv# to the string &lt;Forest_Room_%x%_%y%&gt;\n- - Check whether room #rv# exists.  If not:\n- - - Create a new ForestRoom with internal name = #rv#, coord_x = %x%, coord_y = %y%.\n- - return #rv#\n\n(Code is written in an Inform 6-ish way.  It shouldn't be too difficult to change it to Quest.)",
      "EditableFormat": "bbcode",
      "HTML": "Implementing a large number of rooms with a single room (or rather, one room for the all the rooms, and one object cache) is a well-known Inform trick:<br/>- give every object a maze-location property<br/>- right before the player moves from a maze room:<br/>- - loop over all objects in the maze room<br/>- - - set that object's maze-location property appropriately<br/>- - - move it to the cache room<br/>-<br/>- right before the player moves to a maze room:<br/>- - loop over all objects in the cache room<br/>- - - if the object's maze-location property matches the destination<br/>- - - - move that object to the maze<br/>- - - - clear its maze-location property<br/><br/>(See the middle part of Hunter in Darkness, for one example of this.)  Not sure how difficult this is to do in Quest.<br/><br/>Alternately, if you really insist on dynamically creating rooms:<br/>- Create a class ForestRoom<br/>- - Every ForestRoom has properties coord_x and coord_y<br/>- - The west property is a routine   playerto &lt;$get_forest_room(this.coord_x-1, this.coord_y)$&gt;<br/>- - ( similar with the other exit routines )<br/>-<br/>- Create a function $get_forest_room(x,y)$<br/>- - Set variable #rv# to the string &lt;Forest_Room_%x%_%y%&gt;<br/>- - Check whether room #rv# exists.  If not:<br/>- - - Create a new ForestRoom with internal name = #rv#, coord_x = %x%, coord_y = %y%.<br/>- - return #rv#<br/><br/>(Code is written in an Inform 6-ish way.  It shouldn't be too difficult to change it to Quest.)",
      "PostDate": "2009-11-22T01:20:46+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17136",
      "UserId": 0,
      "Username": "ender",
      "UserAvatar": null,
      "UserGravatar": "f0e4b65cada813dc0b9262de27725b82",
      "EditableText": "You read my mind a little bit ... after my last post I went back to it and decided to try to do it all in one room .... but using cordinates.... my inital building being 0,0 .... and then just increase, decrease the x/y as they go ... and so if they get to -1,0 and then head in the direction of 0,0 it takes them back to the building... and it worked well ... worried about people getting lost... thinking about creating a magic compass that always points back to the building ... not sure how hard it would be ... \n\nStill had problems with the objects ... but I think your cycling over the objects in the room would be good ... maybe give them a property called 'position' with their x,y cordinate and when I go back to that x,y cord bring them back into play ... might create lag though, because I would need to run the script on EVERY object in the game to check if it had the current rooms x,y cords.\n\nThe grid system could be nice, because I could assign rooms positions too ... so I could have 'easter egg' rooms hidden in the endless forest... not sure if I will do that, but its nice to have the possibility ... but I like to keep my room count low ... especially with similar rooms... \n\nSo all of this is really good stuff. Thanks everyone. You're ideas and experience have really helped.",
      "EditableFormat": "bbcode",
      "HTML": "You read my mind a little bit ... after my last post I went back to it and decided to try to do it all in one room .... but using cordinates.... my inital building being 0,0 .... and then just increase, decrease the x/y as they go ... and so if they get to -1,0 and then head in the direction of 0,0 it takes them back to the building... and it worked well ... worried about people getting lost... thinking about creating a magic compass that always points back to the building ... not sure how hard it would be ... <br/><br/>Still had problems with the objects ... but I think your cycling over the objects in the room would be good ... maybe give them a property called 'position' with their x,y cordinate and when I go back to that x,y cord bring them back into play ... might create lag though, because I would need to run the script on EVERY object in the game to check if it had the current rooms x,y cords.<br/><br/>The grid system could be nice, because I could assign rooms positions too ... so I could have 'easter egg' rooms hidden in the endless forest... not sure if I will do that, but its nice to have the possibility ... but I like to keep my room count low ... especially with similar rooms... <br/><br/>So all of this is really good stuff. Thanks everyone. You're ideas and experience have really helped.",
      "PostDate": "2009-11-22T02:21:50+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17137",
      "UserId": 0,
      "Username": "ender",
      "UserAvatar": null,
      "UserGravatar": "f0e4b65cada813dc0b9262de27725b82",
      "EditableText": "Okay. This is solved. Here is my solution... \n\nIt uses one room as an 'endless room'.\n\nThis code is pretty rough, so bear with me ... I did this in a seperate 'game' that was just for testing this function. I'm sure I'll refine it a lot before I put it in my finished game, but I wanted to post it as is because I'll probably forget later. \n\nI'm not including the full code of the module, just the relevant parts to make this work.\n\nThe basic idea is that you define an 'endless room' ... in this example its 'test2' .... and then you give two properties (x and y) to any room you want to NOT be part of the endless room ... I wrote a procedure that I put into all the exits in the endless room that does all the processing ... you also need to put it into any exit that are in another room that goes TO the endless room ... rooms without x, y coordinates are ignored. (this way you could create several rooms as the interior of a building without them having any impact on the 'endless room'... if you exit from a room without coordinates to the endless room, make sure you use a script to set the global x,y variables correctly otherwise the virtual positioning could be off.) The way it handles objects is to cycle through the list of objects in the room and assign them x and y properties of the current grid point and make them inaccessible as you leave... as you enter it checks the room for inaccessible objects with the current grid point assigned to them and makes them accessible. So objects aren't a problem.\n\nThe best feature (as far as I'm concerned) is that this system allows you distribute real rooms anywhere in your 'wilderness' grid just by assigning them grid coordinates and putting the procedure into any exit that goes back to the 'wilderness' ... this has a lot of potential for letting you do things like make spaces between towns without needing to create every single cell... the next step will be to add in barriers (i.e. once you reach grid point -64 you can't go any further west.... and get a message like &quot;There is the grand canyon in your way! you can't go further west!&quot;) and sub 'wilderness' ... for doing things like roads ... i.e. specifying another 'endless' room that covers multiple grid points ... maybe do that by giving it sequential x values like 64, 65, 66.... but thats for another time ... what I've got will solve my immediate issues... feel free to improve, use, and do whatever with it.... (if you make significant improvements or add new features, please send me a copy)\n\n[code:t41bn9w3]\n\ndefine room &lt;test2&gt;\n\tnorth do &lt;EndlessRoom(n)&gt;\n\tsouth do &lt;EndlessRoom(s)&gt;\n\teast do &lt;EndlessRoom(e)&gt;\n\twest do &lt;EndlessRoom(w)&gt;\nend define\n\ndefine procedure &lt;EndlessRoom&gt;\n\tfor each object in &lt;test2&gt; {\n\t\tif exists &lt;#quest&#46;thing#&gt; then {\n\t\t\tproperty &lt;#quest&#46;thing#; x=%x%&gt;\n\t\t\tproperty &lt;#quest&#46;thing#; y=%y%&gt;\n\t\t\thide &lt;#quest&#46;thing#&gt; } }\n\tselect case &lt;$parameter(1)$&gt; {\n\t\tcase &lt;n&gt; inc &lt;y; 1&gt;\n\t\tcase &lt;s&gt; dec &lt;y; 1&gt;\n\t\tcase &lt;e&gt; inc &lt;x; 1&gt;\n\t\tcase &lt;w&gt; dec &lt;x; 1&gt;\n\t\t}\n\tset &lt;roomtemp; &gt;\n\tfor each room in game if ( #(quest&#46;thing)&#58;y# = %y% ) and ( #(quest&#46;thing)&#58;x# = %x% ) then set string &lt;roomtemp; #quest&#46;thing#&gt;\n\tif ( #roomtemp# &lt;&gt;  ) then goto &lt;#roomtemp#&gt; else {\n\t\tfor each object in &lt;test2&gt; if ( #(quest&#46;thing)&#58;y# = %y% ) and ( #(quest&#46;thing)&#58;x# = %x% ) then show &lt;#quest&#46;thing#&gt;\n\t\tgoto &lt;test2&gt; }\nend define\n[/code:t41bn9w3]",
      "EditableFormat": "bbcode",
      "HTML": "Okay. This is solved. Here is my solution... <br/><br/>It uses one room as an 'endless room'.<br/><br/>This code is pretty rough, so bear with me ... I did this in a seperate 'game' that was just for testing this function. I'm sure I'll refine it a lot before I put it in my finished game, but I wanted to post it as is because I'll probably forget later. <br/><br/>I'm not including the full code of the module, just the relevant parts to make this work.<br/><br/>The basic idea is that you define an 'endless room' ... in this example its 'test2' .... and then you give two properties (x and y) to any room you want to NOT be part of the endless room ... I wrote a procedure that I put into all the exits in the endless room that does all the processing ... you also need to put it into any exit that are in another room that goes TO the endless room ... rooms without x, y coordinates are ignored. (this way you could create several rooms as the interior of a building without them having any impact on the 'endless room'... if you exit from a room without coordinates to the endless room, make sure you use a script to set the global x,y variables correctly otherwise the virtual positioning could be off.) The way it handles objects is to cycle through the list of objects in the room and assign them x and y properties of the current grid point and make them inaccessible as you leave... as you enter it checks the room for inaccessible objects with the current grid point assigned to them and makes them accessible. So objects aren't a problem.<br/><br/>The best feature (as far as I'm concerned) is that this system allows you distribute real rooms anywhere in your 'wilderness' grid just by assigning them grid coordinates and putting the procedure into any exit that goes back to the 'wilderness' ... this has a lot of potential for letting you do things like make spaces between towns without needing to create every single cell... the next step will be to add in barriers (i.e. once you reach grid point -64 you can't go any further west.... and get a message like &quot;There is the grand canyon in your way! you can't go further west!&quot;) and sub 'wilderness' ... for doing things like roads ... i.e. specifying another 'endless' room that covers multiple grid points ... maybe do that by giving it sequential x values like 64, 65, 66.... but thats for another time ... what I've got will solve my immediate issues... feel free to improve, use, and do whatever with it.... (if you make significant improvements or add new features, please send me a copy)<br/><br/><pre><code><br/><br/>define room &lt;test2&gt;<br/>\tnorth do &lt;EndlessRoom(n)&gt;<br/>\tsouth do &lt;EndlessRoom(s)&gt;<br/>\teast do &lt;EndlessRoom(e)&gt;<br/>\twest do &lt;EndlessRoom(w)&gt;<br/>end define<br/><br/>define procedure &lt;EndlessRoom&gt;<br/>\tfor each object in &lt;test2&gt; {<br/>\t\tif exists &lt;#quest&#46;thing#&gt; then {<br/>\t\t\tproperty &lt;#quest&#46;thing#; x=%x%&gt;<br/>\t\t\tproperty &lt;#quest&#46;thing#; y=%y%&gt;<br/>\t\t\thide &lt;#quest&#46;thing#&gt; } }<br/>\tselect case &lt;$parameter(1)$&gt; {<br/>\t\tcase &lt;n&gt; inc &lt;y; 1&gt;<br/>\t\tcase &lt;s&gt; dec &lt;y; 1&gt;<br/>\t\tcase &lt;e&gt; inc &lt;x; 1&gt;<br/>\t\tcase &lt;w&gt; dec &lt;x; 1&gt;<br/>\t\t}<br/>\tset &lt;roomtemp; &gt;<br/>\tfor each room in game if ( #(quest&#46;thing)&#58;y# = %y% ) and ( #(quest&#46;thing)&#58;x# = %x% ) then set string &lt;roomtemp; #quest&#46;thing#&gt;<br/>\tif ( #roomtemp# &lt;&gt;  ) then goto &lt;#roomtemp#&gt; else {<br/>\t\tfor each object in &lt;test2&gt; if ( #(quest&#46;thing)&#58;y# = %y% ) and ( #(quest&#46;thing)&#58;x# = %x% ) then show &lt;#quest&#46;thing#&gt;<br/>\t\tgoto &lt;test2&gt; }<br/>end define<br/></code></pre>",
      "PostDate": "2009-11-22T04:24:28+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "17154",
      "UserId": 0,
      "Username": "Wonderjudge",
      "UserAvatar": null,
      "UserGravatar": "29fd1b3b35ac2ca468be63961f946852",
      "EditableText": "I actually have implement this in a game I uploaded called the maze. The object thing is a little laggy on my computer but my computer is old. I also gave different room descriptions in some parts And I have directions. The maze is 300 different rooms all in one room. The directions you could go were tricky. I stored the directions in string variables.\nie. north1=ynynynynynynnnnyn..... etc when the player goes to the next room it checks Mid (ypos*15+xpos,1).\nIf it is a 'y' then it creates the exit if it is 'no' then it destroys it. I also put gates so if the direction check mid contains a different character. example red gate = 'r' . then it will show the exit but you can't get by it till you deal with the red gate.\nWonderjudge\n(aka Tim Hamilton)",
      "EditableFormat": "bbcode",
      "HTML": "I actually have implement this in a game I uploaded called the maze. The object thing is a little laggy on my computer but my computer is old. I also gave different room descriptions in some parts And I have directions. The maze is 300 different rooms all in one room. The directions you could go were tricky. I stored the directions in string variables.<br/>ie. north1=ynynynynynynnnnyn..... etc when the player goes to the next room it checks Mid (ypos*15+xpos,1).<br/>If it is a 'y' then it creates the exit if it is 'no' then it destroys it. I also put gates so if the direction check mid contains a different character. example red gate = 'r' . then it will show the exit but you can't get by it till you deal with the red gate.<br/>Wonderjudge<br/>(aka Tim Hamilton)",
      "PostDate": "2009-11-29T14:56:00+00:00",
      "LastEditDate": null
    }
  ]
}
