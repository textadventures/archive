{
  "Topic": {
    "TopicId": "yklhzfhhk0mj7hj8v_qxeq",
    "ForumId": "10",
    "Title": "Random thoughts about exits",
    "LastUpdated": "2019-12-11T11:47:07.2628728Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "71e46b2b-09ff-4b3b-92dc-100d5caa6c92",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I was looking yesterday at the code in `CoreGrid.aslx` (the map), and I ended up thinking that the way it's constructed is a bit strange. And that got me thinking that it's really odd that an exit can only have one direction. I mean, you can have an exit that goes northwest, but not an exit that goes northup. Similarly, the front door of a house may be both \"north\" and \"out\".\r\n\r\nRather than having to choose exactly one direction, wouldn't it make sense to allow them to be combined?\r\n\r\nI'm thinking that in `CoreEditorExit.aslx`, the code:\r\n<pre><code style=\"color: brown\">      &lt;control>\r\n        &lt;caption>[EditorExitType]&lt;/caption>\r\n        &lt;controltype>dropdowntypes&lt;/controltype>\r\n        &lt;types>*=[TypeExitNon];northwestdirection=[CompassNW];northdirection=[CompassN];northeastdirection=[CompassNE];westdirection=[CompassW];eastdirection=[CompassE];southwestdirection=[CompassSW];southdirection=[CompassS];southeastdirection=[CompassSE];updirection=[CompassUp];downdirection=[CompassDown];indirection=[CompassIn];outdirection=[CompassOut]&lt;/types>\r\n        &lt;width>150&lt;/width>\r\n      &lt;/control></code></pre>\r\n\r\nCould maybe replaced by:\r\n```\r\n      <control>\r\n        <caption>Compass Direction</caption>\r\n        <controltype>dropdowntypes</controltype>\r\n        <types>*=[TypeExitNon];northwestdirection=[CompassNW];northdirection=[CompassN];northeastdirection=[CompassNE];westdirection=[CompassW];eastdirection=[CompassE];southwestdirection=[CompassSW];southdirection=[CompassS];southeastdirection=[CompassSE]</types>\r\n        <width>150</width>\r\n      </control>\r\n\r\n      <control>\r\n        <caption>Vertical Direction</caption>\r\n        <controltype>dropdowntypes</controltype>\r\n        <types>*=Level;updirection=[CompassUp];downdirection=[CompassDown]</types>\r\n        <width>150</width>\r\n      </control>\r\n\r\n      <control>\r\n        <caption>Other Direction</caption>\r\n        <controltype>dropdowntypes</controltype>\r\n        <types>*=N/A;indirection=[CompassIn];outdirection=[CompassOut]</types>\r\n        <width>150</width>\r\n      </control>\r\n```\r\n\r\nThe directional exit types in `CoreTypes.aslx` could have their `alt` attribute changed from `type=\"simplestringlist\"` to `type=\"listextend\"`, so that a staircase leading both up and north can be activated by the player typing \"go north\" or \"go up\".\r\n\r\nThen the function in `CoreGrid.aslx` could become:\r\n```\r\n  <function name=\"Grid_CalculateMapCoordinates\" parameters=\"room, playerobject\">\r\n    <![CDATA[\r\n    if (room.parent <> null) {\r\n      if (room.grid_parent_offset_auto) {\r\n        room.grid_parent_offset_x = (room.parent.grid_width - room.grid_width) /2.0\r\n        room.grid_parent_offset_y = (room.parent.grid_length - room.grid_length) /2.0\r\n      }\r\n\r\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") - room.grid_parent_offset_x)\r\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") - room.grid_parent_offset_y)\r\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"z\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\"))\r\n\r\n      room.parent.grid_render = true\r\n\r\n      Grid_CalculateMapCoordinates (room.parent, playerobject)\r\n    }\r\n\r\n    foreach (exit, AllExits()) {\r\n      if (exit.parent = room and not GetBoolean(exit, \"lookonly\")) {\r\n        x_offset = exit.grid_offset_x\r\n        y_offset = exit.grid_offset_y\r\n        xdir = 0\r\n        ydir = 0\r\n\r\n        if (DoesInherit (exit, \"westdirection\") or DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"southwestdirection\")) {\r\n          x_length = -exit.grid_length\r\n          x_offset = x_offset - room.grid_width/2.0\r\n          xdir = -1\r\n        }\r\n        else if (DoesInherit (exit, \"eastdirection\") or DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"southeastdirection\")) {\r\n          x_length = exit.grid_length\r\n          x_offset = x_offset + room.grid_width/2.0\r\n          xdir = 1\r\n        }\r\n        else {\r\n          x_length = 0\r\n        }\r\n        if (HasInt (exit, \"x_length\")) {\r\n          x_length = exit.x_length\r\n        }\r\n\r\n        if (DoesInherit (exit, \"northdirection\") or DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"northeastdirection\")) {\r\n          y_length = -exit.grid_length\r\n          y_offset = y_offset - room.grid_length/2.0\r\n          ydir = -1\r\n        }\r\n        else if (DoesInherit (exit, \"southdirection\") or DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"southeastdirection\")) {\r\n          y_length = exit.grid_length\r\n          y_offset = y_offset + room.grid_length/2.0\r\n          ydir = 1\r\n        }\r\n        else {\r\n          y_length = 0\r\n        }\r\n        if (HasInt (exit, \"y_length\")) {\r\n          y_length = exit.y_length\r\n        }\r\n\r\n        if (DoesInherit (exit, \"updirection\")) {\r\n          z_length = exit.grid_length\r\n        }\r\n        if (DoesInherit (exit, \"downdirection\")) {\r\n          z_length = - exit.grid_length\r\n        }\r\n\r\n        if (HasObject (exit, \"to\")) {\r\n          dest = exit.to\r\n          dest_coords = Grid_GetPlayerCoordinatesForRoom(playerobject, dest)\r\n          if (HasScript (dest, \"overridegridcoords\")) {\r\n            do (dest, \"overridegridcoords\", QuickParams (\"from_room\", room, \"exit\", exit, \"coords\", dest_coords))\r\n          }\r\n          if (dest.grid_render and DictionaryContains (dest_coords, \"x\")) {\r\n            x_length = DictionaryItem (dest_coords, \"x\") - xdir*dest.grid_width/2.0 - Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") - x_offset\r\n          }\r\n          else {\r\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset + x_length + xdir*dest.grid_width/2.0)\r\n          }\r\n\r\n          if (dest.grid_render and DictionaryContains (dest_coords, \"y\")) {\r\n            y_length = DictionaryItem (dest_coords, \"y\") - xdir*dest.grid_length/2.0 - Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") - y_offset\r\n          }\r\n          else {\r\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset + y_length + ydir*dest.grid_length/2.0)\r\n          }\r\n\r\n          if (dest.grid_render and DictionaryContains (dest_coords, \"z\")) {\r\n            z_length = DictionaryItem (dest_coords, \"z\") -Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\")\r\n          }\r\n          else {\r\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"z\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\") + z_length\r\n          }\r\n          dest.grid_render = true\r\n        }\r\n\r\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset)\r\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset)\r\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset + x_length)\r\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset + y_length)\r\n        exit.grid_render = exit.visible and not (x_length = 0 and y_length = 0)\r\n      }\r\n    }\r\n```\r\n\r\nThis started as an idle thought off the top of my head, but I think it looks neater than the current system.\r\n\r\nAdvantages:\r\n* Script-only exits (no destination) still draw on the map, but the room they point to doesn't.\r\n* If you see an exit that points to an already-drawn room, the exit's start and end points will be changed to connect the existing boxes on the map, rather than messing up the display\r\n* You can have staircases, or doors that also have a direction, just by selecting multiple types in the GUI. No need to mess around with offsets\r\n\r\nDisadvantages:\r\n* Typing off the top of my head; probably contains errors\r\n* Change to existing behaviour (the map scribbling on itself if you have a loop of rooms where the distances don't add up) - could be annoying if you were using that behaviour for some reason\r\n* I can't think of a sane way to set the alias of an exit with multiple types (not sure how the engine handles multiple types trying to set the same attribute)\r\n* A room can have an `overridegridcoords` script attribute which manually sets some of its coordinates, which could make some more complex layouts (especially procedurally generated mazes) easier to code\r\n\r\nWhat do you think?",
      "EditableFormat": "markdown",
      "HTML": "<p>I was looking yesterday at the code in <code>CoreGrid.aslx</code> (the map), and I ended up thinking that the way it's constructed is a bit strange. And that got me thinking that it's really odd that an exit can only have one direction. I mean, you can have an exit that goes northwest, but not an exit that goes northup. Similarly, the front door of a house may be both \"north\" and \"out\".</p>\n<p>Rather than having to choose exactly one direction, wouldn't it make sense to allow them to be combined?</p>\n<p>I'm thinking that in <code>CoreEditorExit.aslx</code>, the code:</p>\n<pre><code style=\"color: brown\">      &lt;control&gt;\n        &lt;caption&gt;[EditorExitType]&lt;/caption&gt;\n        &lt;controltype&gt;dropdowntypes&lt;/controltype&gt;\n        &lt;types&gt;*=[TypeExitNon];northwestdirection=[CompassNW];northdirection=[CompassN];northeastdirection=[CompassNE];westdirection=[CompassW];eastdirection=[CompassE];southwestdirection=[CompassSW];southdirection=[CompassS];southeastdirection=[CompassSE];updirection=[CompassUp];downdirection=[CompassDown];indirection=[CompassIn];outdirection=[CompassOut]&lt;/types&gt;\n        &lt;width&gt;150&lt;/width&gt;\n      &lt;/control&gt;</code></pre>\n<p>Could maybe replaced by:</p>\n<pre><code>      &lt;control&gt;\n        &lt;caption&gt;Compass Direction&lt;/caption&gt;\n        &lt;controltype&gt;dropdowntypes&lt;/controltype&gt;\n        &lt;types&gt;*=[TypeExitNon];northwestdirection=[CompassNW];northdirection=[CompassN];northeastdirection=[CompassNE];westdirection=[CompassW];eastdirection=[CompassE];southwestdirection=[CompassSW];southdirection=[CompassS];southeastdirection=[CompassSE]&lt;/types&gt;\n        &lt;width&gt;150&lt;/width&gt;\n      &lt;/control&gt;\n\n      &lt;control&gt;\n        &lt;caption&gt;Vertical Direction&lt;/caption&gt;\n        &lt;controltype&gt;dropdowntypes&lt;/controltype&gt;\n        &lt;types&gt;*=Level;updirection=[CompassUp];downdirection=[CompassDown]&lt;/types&gt;\n        &lt;width&gt;150&lt;/width&gt;\n      &lt;/control&gt;\n\n      &lt;control&gt;\n        &lt;caption&gt;Other Direction&lt;/caption&gt;\n        &lt;controltype&gt;dropdowntypes&lt;/controltype&gt;\n        &lt;types&gt;*=N/A;indirection=[CompassIn];outdirection=[CompassOut]&lt;/types&gt;\n        &lt;width&gt;150&lt;/width&gt;\n      &lt;/control&gt;\n</code></pre>\n<p>The directional exit types in <code>CoreTypes.aslx</code> could have their <code>alt</code> attribute changed from <code>type=\"simplestringlist\"</code> to <code>type=\"listextend\"</code>, so that a staircase leading both up and north can be activated by the player typing \"go north\" or \"go up\".</p>\n<p>Then the function in <code>CoreGrid.aslx</code> could become:</p>\n<pre><code>  &lt;function name=\"Grid_CalculateMapCoordinates\" parameters=\"room, playerobject\"&gt;\n    &lt;![CDATA[\n    if (room.parent &lt;&gt; null) {\n      if (room.grid_parent_offset_auto) {\n        room.grid_parent_offset_x = (room.parent.grid_width - room.grid_width) /2.0\n        room.grid_parent_offset_y = (room.parent.grid_length - room.grid_length) /2.0\n      }\n\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") - room.grid_parent_offset_x)\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") - room.grid_parent_offset_y)\n      Grid_SetGridCoordinateForPlayer (playerobject, room.parent, \"z\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\"))\n\n      room.parent.grid_render = true\n\n      Grid_CalculateMapCoordinates (room.parent, playerobject)\n    }\n\n    foreach (exit, AllExits()) {\n      if (exit.parent = room and not GetBoolean(exit, \"lookonly\")) {\n        x_offset = exit.grid_offset_x\n        y_offset = exit.grid_offset_y\n        xdir = 0\n        ydir = 0\n\n        if (DoesInherit (exit, \"westdirection\") or DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"southwestdirection\")) {\n          x_length = -exit.grid_length\n          x_offset = x_offset - room.grid_width/2.0\n          xdir = -1\n        }\n        else if (DoesInherit (exit, \"eastdirection\") or DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"southeastdirection\")) {\n          x_length = exit.grid_length\n          x_offset = x_offset + room.grid_width/2.0\n          xdir = 1\n        }\n        else {\n          x_length = 0\n        }\n        if (HasInt (exit, \"x_length\")) {\n          x_length = exit.x_length\n        }\n\n        if (DoesInherit (exit, \"northdirection\") or DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"northeastdirection\")) {\n          y_length = -exit.grid_length\n          y_offset = y_offset - room.grid_length/2.0\n          ydir = -1\n        }\n        else if (DoesInherit (exit, \"southdirection\") or DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"southeastdirection\")) {\n          y_length = exit.grid_length\n          y_offset = y_offset + room.grid_length/2.0\n          ydir = 1\n        }\n        else {\n          y_length = 0\n        }\n        if (HasInt (exit, \"y_length\")) {\n          y_length = exit.y_length\n        }\n\n        if (DoesInherit (exit, \"updirection\")) {\n          z_length = exit.grid_length\n        }\n        if (DoesInherit (exit, \"downdirection\")) {\n          z_length = - exit.grid_length\n        }\n\n        if (HasObject (exit, \"to\")) {\n          dest = exit.to\n          dest_coords = Grid_GetPlayerCoordinatesForRoom(playerobject, dest)\n          if (HasScript (dest, \"overridegridcoords\")) {\n            do (dest, \"overridegridcoords\", QuickParams (\"from_room\", room, \"exit\", exit, \"coords\", dest_coords))\n          }\n          if (dest.grid_render and DictionaryContains (dest_coords, \"x\")) {\n            x_length = DictionaryItem (dest_coords, \"x\") - xdir*dest.grid_width/2.0 - Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") - x_offset\n          }\n          else {\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset + x_length + xdir*dest.grid_width/2.0)\n          }\n\n          if (dest.grid_render and DictionaryContains (dest_coords, \"y\")) {\n            y_length = DictionaryItem (dest_coords, \"y\") - xdir*dest.grid_length/2.0 - Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") - y_offset\n          }\n          else {\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset + y_length + ydir*dest.grid_length/2.0)\n          }\n\n          if (dest.grid_render and DictionaryContains (dest_coords, \"z\")) {\n            z_length = DictionaryItem (dest_coords, \"z\") -Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\")\n          }\n          else {\n            Grid_SetGridCoordinateForPlayer (playerobject, dest, \"z\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"z\") + z_length\n          }\n          dest.grid_render = true\n        }\n\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset)\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset)\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_x\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"x\") + x_offset + x_length)\n        Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_y\", Grid_GetGridCoordinateForPlayer(playerobject, room, \"y\") + y_offset + y_length)\n        exit.grid_render = exit.visible and not (x_length = 0 and y_length = 0)\n      }\n    }\n</code></pre>\n<p>This started as an idle thought off the top of my head, but I think it looks neater than the current system.</p>\n<p>Advantages:</p>\n<ul>\n<li>Script-only exits (no destination) still draw on the map, but the room they point to doesn't.</li>\n<li>If you see an exit that points to an already-drawn room, the exit's start and end points will be changed to connect the existing boxes on the map, rather than messing up the display</li>\n<li>You can have staircases, or doors that also have a direction, just by selecting multiple types in the GUI. No need to mess around with offsets</li>\n</ul>\n<p>Disadvantages:</p>\n<ul>\n<li>Typing off the top of my head; probably contains errors</li>\n<li>Change to existing behaviour (the map scribbling on itself if you have a loop of rooms where the distances don't add up) - could be annoying if you were using that behaviour for some reason</li>\n<li>I can't think of a sane way to set the alias of an exit with multiple types (not sure how the engine handles multiple types trying to set the same attribute)</li>\n<li>A room can have an <code>overridegridcoords</code> script attribute which manually sets some of its coordinates, which could make some more complex layouts (especially procedurally generated mazes) easier to code</li>\n</ul>\n<p>What do you think?</p>\n\n",
      "PostDate": "2019-12-11T11:47:07.2628728Z",
      "LastEditDate": "2019-12-11T12:06:39.2444631Z",
      "link": null
    }
  ]
}
