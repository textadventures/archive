{
  "Topic": {
    "TopicId": "jbrgvtw_reqa8tnotl2yjg",
    "ForumId": "10",
    "Title": "[SOLVED] Hide inactive map layers",
    "LastUpdated": "2021-04-27T01:09:57.5144683Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "42592523-69fe-4b0f-a055-d65de889d4d4",
      "UserId": 438905,
      "Username": "Honoriam",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b865620f96adee94a79fceb9f25fed3d?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "By default, the map shows inactive layers (i.e. the ones the player isn't on on the z-axis) as a faded but still present render. I'm trying to find a way to hide these inactive layers altogether without the game \"forgetting\" what rooms the player already explored when a layer is left and returned to. I did manage to find a way to do this by modifying the CoreGrid library's Grid_Redraw function to only draw rooms on the active layer (see below) and clearing/redrawing the grid whenever the player changes levels.\r\n\r\n```\r\n  <function name=\"Grid_Redraw\">\r\n    foreach (object, AllObjects()) {\r\n      if (Grid_GetRoomBooleanForPlayer(game.pov, object, \"grid_isdrawn\") and (Grid_GetGridCoordinateForPlayer (game.pov, player.parent, \"z\").toString() = DictionaryItem(Grid_GetPlayerCoordinatesForRoom (game.pov, object),\"z\").toString())) {\r\n        Grid_DrawRoom (object, true, game.pov)\r\n      }\r\n    }\r\n  </function>\r\n```\r\n(Also, here's the code I use to actually redraw the grid on layer changes, just in case there's something screwy here:)\r\n```\r\n          JS.Grid_ClearAllLayers()\r\n          Grid_Redraw()\r\n          Grid_DrawPlayerInRoom(player.parent)\r\n```\r\n\r\nHowever, this seems to degrade performance over time, which I assume is due to the constant redrawing. Would there be another, more elegant way to hide these inactive map layers?",
      "EditableFormat": "markdown",
      "HTML": "<p>By default, the map shows inactive layers (i.e. the ones the player isn't on on the z-axis) as a faded but still present render. I'm trying to find a way to hide these inactive layers altogether without the game \"forgetting\" what rooms the player already explored when a layer is left and returned to. I did manage to find a way to do this by modifying the CoreGrid library's Grid_Redraw function to only draw rooms on the active layer (see below) and clearing/redrawing the grid whenever the player changes levels.</p>\n<pre><code>  &lt;function name=\"Grid_Redraw\"&gt;\n    foreach (object, AllObjects()) {\n      if (Grid_GetRoomBooleanForPlayer(game.pov, object, \"grid_isdrawn\") and (Grid_GetGridCoordinateForPlayer (game.pov, player.parent, \"z\").toString() = DictionaryItem(Grid_GetPlayerCoordinatesForRoom (game.pov, object),\"z\").toString())) {\n        Grid_DrawRoom (object, true, game.pov)\n      }\n    }\n  &lt;/function&gt;\n</code></pre>\n<p>(Also, here's the code I use to actually redraw the grid on layer changes, just in case there's something screwy here:)</p>\n<pre><code>          JS.Grid_ClearAllLayers()\n          Grid_Redraw()\n          Grid_DrawPlayerInRoom(player.parent)\n</code></pre>\n<p>However, this seems to degrade performance over time, which I assume is due to the constant redrawing. Would there be another, more elegant way to hide these inactive map layers?</p>\n\n",
      "PostDate": "2021-04-27T01:09:57.5144683Z",
      "LastEditDate": "2021-04-27T10:38:22.8720652Z",
      "link": null
    },
    {
      "PostId": "679cbcce-d409-4e7d-bb1a-f63cde4e5582",
      "UserId": 438905,
      "Username": "Honoriam",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b865620f96adee94a79fceb9f25fed3d?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Many of these functions are defined in grid.js as well, and are underlying JS functions. I'm still not 100% how the architecture of Quest works, but I know that if I was able to change the activateLayer function, which is where opacity of inactive layers is defined (as a static value of 0.2), I'd be able to do what I want far more easily (essentially just by changing that static opacity to 0). I'm just not sure how to do this, or if it's even possible, given that overriding JS functions in Quest doesn't seem to be readily doable. Or am I missing something?\r\n\r\nHere's the function:\r\n```\r\nfunction activateLayer(index) {\r\n    showCustomLayer(false);\r\n    layers[getLayerIndex(index)].activate();\r\n    layers[getLayerIndex(index)].opacity = 1;\r\n    if (currentLayer != index) {\r\n        layers[getLayerIndex(currentLayer)].opacity = 0.2;\r\n        currentLayer = index;\r\n    }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Many of these functions are defined in grid.js as well, and are underlying JS functions. I'm still not 100% how the architecture of Quest works, but I know that if I was able to change the activateLayer function, which is where opacity of inactive layers is defined (as a static value of 0.2), I'd be able to do what I want far more easily (essentially just by changing that static opacity to 0). I'm just not sure how to do this, or if it's even possible, given that overriding JS functions in Quest doesn't seem to be readily doable. Or am I missing something?</p>\n<p>Here's the function:</p>\n<pre><code>function activateLayer(index) {\n    showCustomLayer(false);\n    layers[getLayerIndex(index)].activate();\n    layers[getLayerIndex(index)].opacity = 1;\n    if (currentLayer != index) {\n        layers[getLayerIndex(currentLayer)].opacity = 0.2;\n        currentLayer = index;\n    }\n}\n</code></pre>\n\n",
      "PostDate": "2021-04-27T02:39:33.046187Z",
      "LastEditDate": "2021-04-27T02:40:10.5774835Z",
      "link": null
    },
    {
      "PostId": "e72a054e-6e01-4691-ba83-7413376af60a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Overriding javascript functions in Quest is mostly easy, because javascript treats functions like any other property or variable.\r\n\r\nHowever, the grid functions are an exception. Many of them are protected inside a closure, meaning that they aren't accessible to the main code. Their status variables, things such as `currentLayer`, are also stored as local variables rather than properties, meaning that even if you could replace the function, there's no way to get access to those variables unless you can find a function containing an `eval` somewhere inside the closure.\r\n\r\nHowever, there are ways around this. The functions which are called from Quest are accessible, because they are properties of an interface object, `gridApi`. You can replace these functions, but your new versions can't use any of the local variables that they have access to.\r\n\r\nMy first guess would be to try replacing gridApi.drawPlayer, which will probably be called every time the player changes layer. It already calls activateLayer, so you can assume that any layers with opacity 0.2 aren't the current one. In this case, I prefer to check for fractional opacity, because comparisons of decimals may be subject to rounding errors.\r\n\r\nSo you'd end up with pseudocode that looks like:\r\n<pre><code>$(function () {<em style=\"font-family: initial; padding-left: 1cm\">// This is a javascript closure; it keeps our local variables local</em>\r\n  var original_drawplayer = gridApi.drawPlayer;<em style=\"font-family: initial; padding-left: 1cm\">// make a copy of the original function</em>\r\n\r\n  gridApi.drawPlayer = function(x, y, z, r, b, w, f) {<em style=\"font-family: initial; padding-left: 1cm\">// and define a replacement function</em>\r\n    original_drawplayer(x, y, z, r, b, w, f)<em style=\"font-family: initial; padding-left: 1cm\">// Call the original function</em>\r\n\r\n    foreach (layer in layers) {<em style=\"font-family: initial; padding-left: 1cm\">// Need to find the layers</em>\r\n      if (layer.opacity < 0.5) layer.opacity = 0;\r\n    }\r\n  };\r\n});</code></pre>\r\nThis code should do what you want, I think. But first we need to find the array of layers. The variable `layers` isn't accessible because it's a local variable - so we need to get it from somewhere else. Thankfully, Paperscript doesn't use a closure to hide its data, so we can access the array in there… it'll just take a little time to find it.\r\n\r\nOK, here we go… this seems to work:\r\n```\r\n$(function () {\r\n  var original_drawplayer = gridApi.drawPlayer;\r\n\r\n  gridApi.drawPlayer = function(x, y, z, r, b, w, f) {\r\n    original_drawplayer(x, y, z, r, b, w, f)\r\n\r\n    $.each(paper.project.layers, function () {\r\n      this.setVisible(this.getOpacity() > 0.5);\r\n    });\r\n  };\r\n});\r\n```\r\n\r\nTo include that from Quest, you could either put it in a javascript file (if you're using the desktop editor, which I'm not familiar with), or minify it so that you can include it in your UI Initialisation script (on the game's \"Advanced Scripts\" tab). A version suitable for including in Quest would be:\r\n```\r\nJS.eval(\"$(function(){var a=gridApi.drawPlayer;gridApi.drawPlayer=function(){a.apply(gridApi,arguments),$.each(paper.project.layers,function(){this.setVisible(.5<this.getOpacity())})}});\")\r\n```\r\n\r\nDoes that work for you? I haven't actually got a game with multiple map layers to test it on, so am writing code off the top of my head here. But it looks about right if I poke around with bits of the code in the JS console; so I'm moderately confident.",
      "EditableFormat": "markdown",
      "HTML": "<p>Overriding javascript functions in Quest is mostly easy, because javascript treats functions like any other property or variable.</p>\n<p>However, the grid functions are an exception. Many of them are protected inside a closure, meaning that they aren't accessible to the main code. Their status variables, things such as <code>currentLayer</code>, are also stored as local variables rather than properties, meaning that even if you could replace the function, there's no way to get access to those variables unless you can find a function containing an <code>eval</code> somewhere inside the closure.</p>\n<p>However, there are ways around this. The functions which are called from Quest are accessible, because they are properties of an interface object, <code>gridApi</code>. You can replace these functions, but your new versions can't use any of the local variables that they have access to.</p>\n<p>My first guess would be to try replacing gridApi.drawPlayer, which will probably be called every time the player changes layer. It already calls activateLayer, so you can assume that any layers with opacity 0.2 aren't the current one. In this case, I prefer to check for fractional opacity, because comparisons of decimals may be subject to rounding errors.</p>\n<p>So you'd end up with pseudocode that looks like:</p>\n<pre><code>$(function () {<em style=\"font-family: initial; padding-left: 1cm\">// This is a javascript closure; it keeps our local variables local</em>\n  var original_drawplayer = gridApi.drawPlayer;<em style=\"font-family: initial; padding-left: 1cm\">// make a copy of the original function</em>\n\n  gridApi.drawPlayer = function(x, y, z, r, b, w, f) {<em style=\"font-family: initial; padding-left: 1cm\">// and define a replacement function</em>\n    original_drawplayer(x, y, z, r, b, w, f)<em style=\"font-family: initial; padding-left: 1cm\">// Call the original function</em>\n\n    foreach (layer in layers) {<em style=\"font-family: initial; padding-left: 1cm\">// Need to find the layers</em>\n      if (layer.opacity &lt; 0.5) layer.opacity = 0;\n    }\n  };\n});</code></pre>\n<p>This code should do what you want, I think. But first we need to find the array of layers. The variable <code>layers</code> isn't accessible because it's a local variable - so we need to get it from somewhere else. Thankfully, Paperscript doesn't use a closure to hide its data, so we can access the array in there… it'll just take a little time to find it.</p>\n<p>OK, here we go… this seems to work:</p>\n<pre><code>$(function () {\n  var original_drawplayer = gridApi.drawPlayer;\n\n  gridApi.drawPlayer = function(x, y, z, r, b, w, f) {\n    original_drawplayer(x, y, z, r, b, w, f)\n\n    $.each(paper.project.layers, function () {\n      this.setVisible(this.getOpacity() &gt; 0.5);\n    });\n  };\n});\n</code></pre>\n<p>To include that from Quest, you could either put it in a javascript file (if you're using the desktop editor, which I'm not familiar with), or minify it so that you can include it in your UI Initialisation script (on the game's \"Advanced Scripts\" tab). A version suitable for including in Quest would be:</p>\n<pre><code>JS.eval(\"$(function(){var a=gridApi.drawPlayer;gridApi.drawPlayer=function(){a.apply(gridApi,arguments),$.each(paper.project.layers,function(){this.setVisible(.5&lt;this.getOpacity())})}});\")\n</code></pre>\n<p>Does that work for you? I haven't actually got a game with multiple map layers to test it on, so am writing code off the top of my head here. But it looks about right if I poke around with bits of the code in the JS console; so I'm moderately confident.</p>\n\n",
      "PostDate": "2021-04-27T09:32:38.114175Z",
      "LastEditDate": "2021-04-27T09:51:42.7651164Z",
      "link": null
    },
    {
      "PostId": "5211e202-96d7-4806-ad60-297a536baf69",
      "UserId": 438905,
      "Username": "Honoriam",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b865620f96adee94a79fceb9f25fed3d?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That works perfectly, thanks a ton! \r\nThanks as well for the very thorough explanation as to the approach to the problem, it's very helpful.",
      "EditableFormat": "markdown",
      "HTML": "<p>That works perfectly, thanks a ton!<br>\nThanks as well for the very thorough explanation as to the approach to the problem, it's very helpful.</p>\n\n",
      "PostDate": "2021-04-27T10:37:56.3090823Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
