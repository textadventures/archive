{
  "Topic": {
    "TopicId": "igcf62bri0ovenfu0aapwg",
    "ForumId": "10",
    "Title": "How to create infinite maze?",
    "LastUpdated": "2021-04-05T09:21:06.4639623Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "f32b1c55-e0c6-4dd6-a832-64a4d6b8df27",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/kAFDdmcb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Basically I make a 5x4 rooms.\r\nEach of the exits from one to another room is referred as walls, so they have 50% chance of appearing.\r\nThis gives us a random maze of a 5x4 rooms size.\r\n\r\nEach 5x4 rooms size have a X-coordinate and Y-coordinate named as game.x and game.y.\r\nSo there is an enter door at the bottom of the 5x4 dungeon, and an exit door at the top of the 5x4 dungeon.\r\nWhen the players moves to the exit door, game.y = game.y+1, then move the player to the enter door at the\r\nbottom of the 5x4 dungeon.\r\nSo far, everything works great and the game knows that the dungeon are different based on the xy coordinates.\r\n\r\nBut this is where I encounter a problem, how do I make the game remember that the object chair and walls exist\r\nin this specific room of this specific dungeon of xy coordinates? I could make that the object chair is visible when game.x=0 \r\nand game.y=1, but the chair are randomly generated, meaning I clone chair and move to player.parent which is the player's current location, but I cannot access to change the chair's attributes, meaning I cannot make the chair knows that it is in x=0, y=1, if the chair knows, it will be visible, otherwise, invisible.\r\n\r\nAnother failed solution is that whenever a player enters a room, create a Floor and a Chair, whenever there is a Floor in the\r\nroom, the generator will not create anything, this solves my problem of auto-generating, but when tested in real life, the game\r\ndoes not recognize the Floors, because when you clone an object, it will create Floor1 instead of Floor, because the game cannot handle objects with exactly same names.",
      "EditableFormat": "markdown",
      "HTML": "<p>Basically I make a 5x4 rooms.<br>\nEach of the exits from one to another room is referred as walls, so they have 50% chance of appearing.<br>\nThis gives us a random maze of a 5x4 rooms size.</p>\n<p>Each 5x4 rooms size have a X-coordinate and Y-coordinate named as game.x and game.y.<br>\nSo there is an enter door at the bottom of the 5x4 dungeon, and an exit door at the top of the 5x4 dungeon.<br>\nWhen the players moves to the exit door, game.y = game.y+1, then move the player to the enter door at the<br>\nbottom of the 5x4 dungeon.<br>\nSo far, everything works great and the game knows that the dungeon are different based on the xy coordinates.</p>\n<p>But this is where I encounter a problem, how do I make the game remember that the object chair and walls exist<br>\nin this specific room of this specific dungeon of xy coordinates? I could make that the object chair is visible when game.x=0<br>\nand game.y=1, but the chair are randomly generated, meaning I clone chair and move to player.parent which is the player's current location, but I cannot access to change the chair's attributes, meaning I cannot make the chair knows that it is in x=0, y=1, if the chair knows, it will be visible, otherwise, invisible.</p>\n<p>Another failed solution is that whenever a player enters a room, create a Floor and a Chair, whenever there is a Floor in the<br>\nroom, the generator will not create anything, this solves my problem of auto-generating, but when tested in real life, the game<br>\ndoes not recognize the Floors, because when you clone an object, it will create Floor1 instead of Floor, because the game cannot handle objects with exactly same names.</p>\n\n",
      "PostDate": "2021-04-05T09:21:06.4639623Z",
      "LastEditDate": "2021-04-06T15:08:25.4936665Z",
      "link": null
    },
    {
      "PostId": "2e7af71d-051a-4172-a62e-63be73711a5a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK, there's a lot to unpack here. I'm not  sure I understand your post completely, but I'll include as much detail as I think is needed. Sorry if you already have some of this, or it seems irrelevant.\r\n\r\nThere are two common ways to make an infinite maze, and you seem to have selected a kind of hybrid.\r\n\r\nThe most common way to do this is to have an inaccessible 'template' room somewhere. Whenever the player goes through an exit that doesn't lead anywhere, the template room is cloned and added to the map at that location. This means you don't need to keep track of what is in each room, because Quest does that for you.\r\nFor more variety, you could even have a variety of rooms to choose from, and clone a different one each time.\r\n\r\nAnother method for a random dungeon is to have a single room, and then modify its attributes and move objects in/out of it to represent the different things that might be found there based on the player's coordinates. So rather than moving the player to a new room, you have an exit which changes the appearance of the current room and then displays the new description. Kind of like in the theatre, changing the backdrop and props to represent travelling.\r\nThis is often an efficient method for modelling a large dungeon; but Quest doesn't make it easy. Remembering what was in each room so you can display it again next time can become quite complex. It's doable, but Quest's data structures aren't well-suited to the task.\r\n\r\nIf I understand you correctly, you are using this second method but with a block of 20 actual rooms. I can see that makes sense, but Quest might make it a little harder to work with compared to other engines.\r\n\r\n> I clone chair and move to player.parent which is the player's current location, but I cannot access to change the chair's attributes\r\n\r\nIn this case, you should be able to access the chair's attributes just fine. I would expect you to have something like:\r\n```\r\nthischair = CloneObjectAndMoveHere (Chair)\r\n```\r\nwhich creates an object (possibly named `Chair1` or `Chair4` or similar), and stores it in the variable `thischair`. You can then use `thischair` as if it were the object for the remainder of the script. For example, you could do:\r\n```\r\nthischair.x = game.x\r\nthischair.y = game.y\r\n```\r\nto give the newly created chair a couple of attributes indicating which dungeon it is in.\r\n\r\nYou could then set it up so that when the player moves to a different x/y, all the objects in their current location are then removed, and if the player is returning to coordinates they've visited before, the objects from those coordinates are restored.\r\nThere are three main ways you could go about this:\r\n\r\n1) Hide the objects that are in the wrong x/y coords.\r\n\r\nYou would loop over all the objects in the rooms, showing or hiding them depending if their x/y match the current location. For this example I'm assuming there is a room `DungeonContainer` which contains the 20 rooms; as this makes it easier to loop over them:\r\n```\r\nforeach (room, GetDirectChildren (DungeonContainer)) {\r\n  foreach (object, GetDirectChildren (room)) {\r\n    if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\r\n      object.visible = (object.x = game.x and object.y = game.y)\r\n    }\r\n  }\r\n}\r\n```\r\nThat will show all objects whose x and y match the current `game.x` and `game.y` and hide objects whose x and y are different. In this case it won't do anything with objects that don't have coordinates.\r\n\r\nIf you want it to work properly if the player picks up an object and drops it elsewhere, you would also need to make sure that objects they are carrying have the correct coordinates. Then the objects will behave correctly when dropped. After changing `game.x` and `game.y` but before showing and hiding objects, you would do something like:\r\n```\r\nforeach (object, ScopeInventory()) {\r\n  object.x = game.x\r\n  object.y = game.y\r\n}\r\n```\r\n\r\n2) Remove objects when the player changes coordinates; find them and bring them back when the player returns to those coordinates.\r\n\r\nThis method is a little more complex, as you also need to store which room the objects were in. However, it might be a better option if you already have invisible objects, so that the `visible` flag isn't serving two purposes.\r\n\r\nIn this case, you'd first want to remove objects from the current rooms, and store their location for future access:\r\n```\r\nforeach (room, GetDirectChildren (DungeonContainer)) {\r\n  foreach (object, GetDirectChildren (room)) {\r\n    if (not (object = game.pov or Contains (game.pov, object))) {\r\n      object.x = game.x\r\n      object.y = game.y\r\n      object.room = room\r\n      RemoveObject (object)\r\n    }\r\n  }\r\n}\r\n```\r\nnote that this doesn't delete the objects; it just removes them by moving them into non-player space. In this case I'm specifically testing for the player and their objects, so that they don't get whisked away.\r\n\r\nOnce we've removed those objects, you increase `game.y`, and then check if there are any objects waiting to be moved back. In this case we end up looping over all objects to find the ones we want. we might be able to make the code easier to read using `FilterByAttribute`, but we would be creating multiple temporary objectlists, which is slower and uses more memory.\r\n```\r\nforeach (object, AllObjects()) {\r\n  if (object.parent = null) {\r\n    if (Equal (object.x, game.x) and Equal (object.y, game.y)) {\r\n      object.parent = object.room\r\n    }\r\n  }\r\n}\r\n```\r\nand once all that is done, you can move the player to their new room, so the description will be displayed using the recently moved objects.\r\n\r\n3) Actually destroying unnecessary objects\r\n\r\nIn theory you could destroy any objects that are floating around; store the random numbers used to generate each room in some set of attributes, and use those numbers to clone the objects again when they're needed. But this is already a complex thing to do, and if your objects have any attributes it will become even harder.\r\n\r\n\r\n> whenever there is a Floor in the room, the generator will not create anything, this solves my problem of auto-generating, but when tested in real life, the game does not recognize the Floors, because when you clone an object, it will create Floor1 instead of Floor\r\n\r\nRather than testing if the object named `Floor` is here, you want to test if there is a clone of `Floor` here. The clone functions (`CloneObject`, `CloneObjectAndMove`, `CloneObjectAndMoveHere`, and `CloneObjectAndInitialise`) will all give an object a `prototype` attribute which can be used to find its clones.\r\n\r\nFor example, the expression `FilterByAttribute (AllObjects(), \"prototype\", Floor)` will give you an objectlist of all clones of `Floor`.\r\n\r\nIn this case, a more useful expression would be`FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)` which examines all objects in the current room to see if any of them are clones of `Floor`.\r\n\r\nYou could use this like:\r\n```\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\nif (ListCount (floorlist) = 0) {\r\n  // do whatever you wanted to do if there *isn't* a floor here\r\n}\r\nelse {\r\n  thisfloor = PickOneObject (floorlist)\r\n  // if you want to do anything when there is a floor here, you can do it here\r\n  // you can use the variable `floorlist` to access the floor object in this room\r\n  // or just remove the else clause if you don't need to do anything\r\n}\r\n```\r\n\r\nI think that should be everything you need in order to make this work.\r\nIs there anything I've missed?",
      "EditableFormat": "markdown",
      "HTML": "<p>OK, there's a lot to unpack here. I'm not  sure I understand your post completely, but I'll include as much detail as I think is needed. Sorry if you already have some of this, or it seems irrelevant.</p>\n<p>There are two common ways to make an infinite maze, and you seem to have selected a kind of hybrid.</p>\n<p>The most common way to do this is to have an inaccessible 'template' room somewhere. Whenever the player goes through an exit that doesn't lead anywhere, the template room is cloned and added to the map at that location. This means you don't need to keep track of what is in each room, because Quest does that for you.<br>\nFor more variety, you could even have a variety of rooms to choose from, and clone a different one each time.</p>\n<p>Another method for a random dungeon is to have a single room, and then modify its attributes and move objects in/out of it to represent the different things that might be found there based on the player's coordinates. So rather than moving the player to a new room, you have an exit which changes the appearance of the current room and then displays the new description. Kind of like in the theatre, changing the backdrop and props to represent travelling.<br>\nThis is often an efficient method for modelling a large dungeon; but Quest doesn't make it easy. Remembering what was in each room so you can display it again next time can become quite complex. It's doable, but Quest's data structures aren't well-suited to the task.</p>\n<p>If I understand you correctly, you are using this second method but with a block of 20 actual rooms. I can see that makes sense, but Quest might make it a little harder to work with compared to other engines.</p>\n<blockquote>\n<p>I clone chair and move to player.parent which is the player's current location, but I cannot access to change the chair's attributes</p>\n</blockquote>\n<p>In this case, you should be able to access the chair's attributes just fine. I would expect you to have something like:</p>\n<pre><code>thischair = CloneObjectAndMoveHere (Chair)\n</code></pre>\n<p>which creates an object (possibly named <code>Chair1</code> or <code>Chair4</code> or similar), and stores it in the variable <code>thischair</code>. You can then use <code>thischair</code> as if it were the object for the remainder of the script. For example, you could do:</p>\n<pre><code>thischair.x = game.x\nthischair.y = game.y\n</code></pre>\n<p>to give the newly created chair a couple of attributes indicating which dungeon it is in.</p>\n<p>You could then set it up so that when the player moves to a different x/y, all the objects in their current location are then removed, and if the player is returning to coordinates they've visited before, the objects from those coordinates are restored.<br>\nThere are three main ways you could go about this:</p>\n<ol>\n<li>Hide the objects that are in the wrong x/y coords.</li>\n</ol>\n<p>You would loop over all the objects in the rooms, showing or hiding them depending if their x/y match the current location. For this example I'm assuming there is a room <code>DungeonContainer</code> which contains the 20 rooms; as this makes it easier to loop over them:</p>\n<pre><code>foreach (room, GetDirectChildren (DungeonContainer)) {\n  foreach (object, GetDirectChildren (room)) {\n    if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\n      object.visible = (object.x = game.x and object.y = game.y)\n    }\n  }\n}\n</code></pre>\n<p>That will show all objects whose x and y match the current <code>game.x</code> and <code>game.y</code> and hide objects whose x and y are different. In this case it won't do anything with objects that don't have coordinates.</p>\n<p>If you want it to work properly if the player picks up an object and drops it elsewhere, you would also need to make sure that objects they are carrying have the correct coordinates. Then the objects will behave correctly when dropped. After changing <code>game.x</code> and <code>game.y</code> but before showing and hiding objects, you would do something like:</p>\n<pre><code>foreach (object, ScopeInventory()) {\n  object.x = game.x\n  object.y = game.y\n}\n</code></pre>\n<ol start=\"2\">\n<li>Remove objects when the player changes coordinates; find them and bring them back when the player returns to those coordinates.</li>\n</ol>\n<p>This method is a little more complex, as you also need to store which room the objects were in. However, it might be a better option if you already have invisible objects, so that the <code>visible</code> flag isn't serving two purposes.</p>\n<p>In this case, you'd first want to remove objects from the current rooms, and store their location for future access:</p>\n<pre><code>foreach (room, GetDirectChildren (DungeonContainer)) {\n  foreach (object, GetDirectChildren (room)) {\n    if (not (object = game.pov or Contains (game.pov, object))) {\n      object.x = game.x\n      object.y = game.y\n      object.room = room\n      RemoveObject (object)\n    }\n  }\n}\n</code></pre>\n<p>note that this doesn't delete the objects; it just removes them by moving them into non-player space. In this case I'm specifically testing for the player and their objects, so that they don't get whisked away.</p>\n<p>Once we've removed those objects, you increase <code>game.y</code>, and then check if there are any objects waiting to be moved back. In this case we end up looping over all objects to find the ones we want. we might be able to make the code easier to read using <code>FilterByAttribute</code>, but we would be creating multiple temporary objectlists, which is slower and uses more memory.</p>\n<pre><code>foreach (object, AllObjects()) {\n  if (object.parent = null) {\n    if (Equal (object.x, game.x) and Equal (object.y, game.y)) {\n      object.parent = object.room\n    }\n  }\n}\n</code></pre>\n<p>and once all that is done, you can move the player to their new room, so the description will be displayed using the recently moved objects.</p>\n<ol start=\"3\">\n<li>Actually destroying unnecessary objects</li>\n</ol>\n<p>In theory you could destroy any objects that are floating around; store the random numbers used to generate each room in some set of attributes, and use those numbers to clone the objects again when they're needed. But this is already a complex thing to do, and if your objects have any attributes it will become even harder.</p>\n<blockquote>\n<p>whenever there is a Floor in the room, the generator will not create anything, this solves my problem of auto-generating, but when tested in real life, the game does not recognize the Floors, because when you clone an object, it will create Floor1 instead of Floor</p>\n</blockquote>\n<p>Rather than testing if the object named <code>Floor</code> is here, you want to test if there is a clone of <code>Floor</code> here. The clone functions (<code>CloneObject</code>, <code>CloneObjectAndMove</code>, <code>CloneObjectAndMoveHere</code>, and <code>CloneObjectAndInitialise</code>) will all give an object a <code>prototype</code> attribute which can be used to find its clones.</p>\n<p>For example, the expression <code>FilterByAttribute (AllObjects(), \"prototype\", Floor)</code> will give you an objectlist of all clones of <code>Floor</code>.</p>\n<p>In this case, a more useful expression would be<code>FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)</code> which examines all objects in the current room to see if any of them are clones of <code>Floor</code>.</p>\n<p>You could use this like:</p>\n<pre><code>floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nif (ListCount (floorlist) = 0) {\n  // do whatever you wanted to do if there *isn't* a floor here\n}\nelse {\n  thisfloor = PickOneObject (floorlist)\n  // if you want to do anything when there is a floor here, you can do it here\n  // you can use the variable `floorlist` to access the floor object in this room\n  // or just remove the else clause if you don't need to do anything\n}\n</code></pre>\n<p>I think that should be everything you need in order to make this work.<br>\nIs there anything I've missed?</p>\n\n",
      "PostDate": "2021-04-05T14:36:10.6434206Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "db86f398-46ac-40d4-9374-cad0b703503e",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "mrangel have the correct solution for infinite maze, if his solution helps you, you can help him by checking out his books.\r\nhttp://textadventures.co.uk/forum/general/topic/qlnz6tgk2u6rufhzykrpxw/has-mrangel-ever-helped-you\r\n\r\nYou didn't missed anything, you even added more solutions for problems I have not predicted yet.\r\nI like to make easy games or apps to slowly learn about quest textadventure and coding, but it looks like I have stumbled upon a beast.\r\nIt would take me some time to code the above then I can reply you whether I am able to do it.\r\n\r\nThanks a lot!\r\n\r\nUpdate: \r\n<details>\r\nYour first common way is to clone room, I cannot find such an option in quest, it might be done in code view programming, and I googled out https://textadventures.co.uk/forum/quest/topic/muyzncmskuamclqqeiqw9w/cloning-a-room-contents\r\nwhich is too much for me to do, and I do not even know how to begin with programming \"Whenever the player goes through an exit that doesn't lead anywhere\", so I shall skip this method.\r\n\r\nYou second common method is to use single room, this is probably the easiest method for me to deal with, you pointed out a flaw with this method but this flaw does not applies to me, I am basically making rpg games, like randomly generating monsters with stats that are at a lower ratio to player's stats and then sceneries that does not do anything, but I get what you mean, if I decide to expand the game, It will be hard to memorize the map even if I draw a map in real life, because every room will have multiple objects for me to record down.\r\n\r\nYour formula below shockingly works and I do not know why :) (Do not bother to re-explain me, I am slow.)\r\n```\r\nthischair = CloneObjectAndMoveHere (Chair)\r\nthischair.x = game.x\r\nthischair.y = game.y\r\nforeach (room, GetDirectChildren (DungeonContainer)) {\r\n  foreach (object, GetDirectChildren (room)) {\r\n    if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\r\n      object.visible = (object.x = game.x and object.y = game.y)}}}\r\n```\r\n\r\n1. To explain why I made a 5x4 dungeon instead of a 1x1 dungeon, it is because I am making an infinite maze, within a 5x4 dungeon, I can predetermined open paths from the north, south, east and west doors to each other, usually in a + crossroads.\r\nFor a 1x1 dungeon, each north, south, east and west have 20% of becoming closed paths, it is unlikely to have fully closed paths and players gets stuck, but if the players do encounter such heavy unluckiness, the maze is not infinite anymore. \r\n\r\n2. But there is a better way to create an infinite maze with 1x1 dungeon, basically the start of xy coordinates = 1 to 5, rooms of 25 have open paths from the very start of maze, after that, further paths will have 20% of becoming closed paths. I do not know the maths, but perhaps there is 400% chance of open path on NSEW, the next path will have 320%, the next path will have 256%, actually we will probably have to write out such a dungeon to see whether it works.\r\n\r\n3. The last way to create an infinite maze with 1x1 dungeon is to spawn 3x3 closed rooms, however this type of map does not gives me the feeling of a narrow hedge maze, which is the feeling I am trying to replicate.",
      "EditableFormat": "markdown",
      "HTML": "<p>mrangel have the correct solution for infinite maze, if his solution helps you, you can help him by checking out his books.<br>\nhttp://textadventures.co.uk/forum/general/topic/qlnz6tgk2u6rufhzykrpxw/has-mrangel-ever-helped-you</p>\n<p>You didn't missed anything, you even added more solutions for problems I have not predicted yet.<br>\nI like to make easy games or apps to slowly learn about quest textadventure and coding, but it looks like I have stumbled upon a beast.<br>\nIt would take me some time to code the above then I can reply you whether I am able to do it.</p>\n<p>Thanks a lot!</p>\n<p>Update:</p>\n<details>\nYour first common way is to clone room, I cannot find such an option in quest, it might be done in code view programming, and I googled out https://textadventures.co.uk/forum/quest/topic/muyzncmskuamclqqeiqw9w/cloning-a-room-contents\nwhich is too much for me to do, and I do not even know how to begin with programming \"Whenever the player goes through an exit that doesn't lead anywhere\", so I shall skip this method.\n<p>You second common method is to use single room, this is probably the easiest method for me to deal with, you pointed out a flaw with this method but this flaw does not applies to me, I am basically making rpg games, like randomly generating monsters with stats that are at a lower ratio to player's stats and then sceneries that does not do anything, but I get what you mean, if I decide to expand the game, It will be hard to memorize the map even if I draw a map in real life, because every room will have multiple objects for me to record down.</p>\n<p>Your formula below shockingly works and I do not know why :) (Do not bother to re-explain me, I am slow.)</p>\n<pre><code>thischair = CloneObjectAndMoveHere (Chair)\nthischair.x = game.x\nthischair.y = game.y\nforeach (room, GetDirectChildren (DungeonContainer)) {\n  foreach (object, GetDirectChildren (room)) {\n    if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\n      object.visible = (object.x = game.x and object.y = game.y)}}}\n</code></pre>\n<ol>\n<li>\n<p>To explain why I made a 5x4 dungeon instead of a 1x1 dungeon, it is because I am making an infinite maze, within a 5x4 dungeon, I can predetermined open paths from the north, south, east and west doors to each other, usually in a + crossroads.<br>\nFor a 1x1 dungeon, each north, south, east and west have 20% of becoming closed paths, it is unlikely to have fully closed paths and players gets stuck, but if the players do encounter such heavy unluckiness, the maze is not infinite anymore.</p>\n</li>\n<li>\n<p>But there is a better way to create an infinite maze with 1x1 dungeon, basically the start of xy coordinates = 1 to 5, rooms of 25 have open paths from the very start of maze, after that, further paths will have 20% of becoming closed paths. I do not know the maths, but perhaps there is 400% chance of open path on NSEW, the next path will have 320%, the next path will have 256%, actually we will probably have to write out such a dungeon to see whether it works.</p>\n</li>\n<li>\n<p>The last way to create an infinite maze with 1x1 dungeon is to spawn 3x3 closed rooms, however this type of map does not gives me the feeling of a narrow hedge maze, which is the feeling I am trying to replicate.</p>\n</li>\n</ol>\n\n</details>",
      "PostDate": "2021-04-05T15:17:17.1137692Z",
      "LastEditDate": "2021-04-20T12:28:36.2385314Z",
      "link": null
    },
    {
      "PostId": "11323aed-c310-4d4e-9cb3-88a9513cc261",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/vjdH3t6b.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The \"single room and put stuff in there\" is how the original text adventures did it. (And the way I did it in Basic before finding Quest. Still find the idea of objects strange. And clones even stranger!)\r\nThe nice thing about programming is that 10 people can give to 20 ways to solve a problem, and in the end, you come up with number 21, that no one else even thought about.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>The \"single room and put stuff in there\" is how the original text adventures did it. (And the way I did it in Basic before finding Quest. Still find the idea of objects strange. And clones even stranger!)<br>\nThe nice thing about programming is that 10 people can give to 20 ways to solve a problem, and in the end, you come up with number 21, that no one else even thought about.</p>\n\n",
      "PostDate": "2021-04-06T04:01:22.822738Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e95d941d-814e-41e8-9680-8aafc6690b05",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Apparently the forum do not like me editing my old post for new updates.\r\n\r\nMe rephrasing MrAngel's solution to try to understand it:\r\n<details>\r\nthischair is confusing because it sounds like this(object) or chair(object), but it is just random word for a variable, meaning I can put x1 to replace thischair instead, which I tested and it still works.\r\nIf thischair is an object, it would not works, as it can only gains 1 set of x and y, however it is actually a variable, a variable is just a temporary value which disappears after the script has ended. MrAngel used a variable to link up CloneObjectAndMoveHere (Chair).xy = game.xy, because if you directly write my formula, the game do not accepts such equation.\r\nSo another way to simplify this is:\r\n```\r\nx1 = CloneObjectAndMoveHere (Chair)\r\nx1.x = game.x\r\nx1.y = game.y\r\n```\r\nNow for the next program: foreach\r\n```\r\nforeach (room, GetDirectChildren (DungeonContainer)) {\r\nforeach (object, GetDirectChildren (room)) {\r\nif (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\r\nobject.visible = (object.x = game.x and object.y = game.y)}}}\r\n```\r\nforeach means to run this same script multiple times.\r\n(room,) means to keep the result of the script to this variable.\r\n(, GetDirectChildren(DungeonContainer)) means to get all the room folders inside the parent folder (DungeonContainer).\r\n\r\nThe next line of code \r\n```\r\nforeach (object, GetDirectChildren (room))\r\n```\r\nis similar, run same script multiple times, to get all childrens of room folder which gives us all the objects, and the result is kept in the variable called object.\r\n\r\nThird line of code\r\n```\r\nif (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object))\r\n```\r\nWe retrieve the variable object from previous 2 lines of codes, and test whether they have attributes x or y, and whether they do not have point of view (game.pov), after much googling, game.pov seems to refer to all objects inside player's folder which is basically the player's inventory.\r\n```not Contains (game.pov, object)``` means excluding all the objects in the player's inventory, meaning the player's inventory is excluded from the above if code. I am thinking this ```not Contains (game.pov, object)``` is not important, because generally player's inventory are usually and already visible. The whole 4 lines of code is to make objects visible, but the code is excluding player's inventory when making objects visible, but like I said, player's inventory are usually visible.\r\n\r\nLastly\r\n```\r\nobject.visible = (object.x = game.x and object.y = game.y)}}}\r\n```\r\nobject.visible means to make all the objects in this variable \"object\" visible, the right hand side means make it visible only if the variable object have an x coordinate = to the current game x coordinate.\r\n\r\nThe code can be rewritten as below for easier understanding.\r\n```\r\nforeach (x2, GetDirectChildren (DungeonContainer)) {\r\nforeach (x3, GetDirectChildren (x2)) {\r\nif (HasInt (x3, \"x\") and HasInt (x3, \"y\") and not Contains (game.pov, x3)) {\r\nx3.visible = (x3.x = game.x and x3.y = game.y)}}}\r\n```\r\n\r\nOur next code is fairly simple\r\n```\r\nforeach (object, ScopeInventory()) {\r\n  object.x = game.x\r\n  object.y = game.y}\r\n```\r\nScopeInventory code returns an objectlist containing all the visible objects which the player has in their inventory.\r\nSo foreach code again, for each object in player's inventory, change the object xy coordinates to the new xy coordinates.\r\nThis code is used when player entering a map of different xy coordinates, so that when the player decides to drop an inventory, it will have the correct xy coordinates.\r\n_____________________________________________________________________________________\r\n\r\nFor MrAngel's solution 2, it is recommended to start on a new quest file, it would be useful to keep the old file for future referencing.\r\n~~~\r\nforeach (room, GetDirectChildren (DungeonContainer)) {\r\n  foreach (object, GetDirectChildren (room)) {\r\n    if (not (object = game.pov or Contains (game.pov, object))) {\r\n      object.x = game.x\r\n      object.y = game.y\r\n      object.room = room\r\n      RemoveObject (object) }}}\r\n~~~\r\nSo we input this code, we find out that our doors(object) disappeared, whenever our autogenerator creates new object like a Chair(object), the Chairs disappears too. So if you look at the code similar to MrAngel's first solution, it digs out all objects in the game except for the player and the player's inventory.\r\n```object = game.pov``` refers to the player.\r\n```Contains (game.pov, object)``` refers to the player's inventory.\r\n```RemoveObject (object)``` like MrAngel said, it moves the object away instead of destroying, I am guessing this code moves the object out of parents/rooms.\r\n```object.room = room``` refers to adding new attributes to all objects, the attribute is named room, this code is strange as it records the current room name, this is probably useless in 1x1 dungeon infinite maze, this might be for 4x5 dungeon infinite maze, but, in short, its utility is strange.\r\n\r\nI am skipping ```FilterByAttribute```\r\n\r\nThis next code do not seems to works.\r\n```\r\nforeach (object, AllObjects()) {\r\n  if (object.parent = null) {\r\n    if (Equal (object.x, game.x) and Equal (object.y, game.y)) {\r\n      object.parent = object.room}}}\r\n```\r\nIt basically takes out all objects and store them in variable object, \r\nFind all the objects have no parents/room, then amongst them,\r\nfind objects with same xy coordinates as the current map xy coordinates,\r\nFinally, change this object's parent into a room.\r\n\r\nWhy it does not works is because the doors appears but the autogenerated old Chairs reappear whenever the player\r\nenters a new map of different xy.\r\nWhile we do not have an answer for that, after rereading, we know that solution 2 is better than solution 1 because it does not\r\nrelies on visibility, but rather on rooms instead, therefore we could still introduce invisible objects in our game.\r\nBecause that is the main difference, our coding error lies in that area too, we are missing some lines of coding about rooms.\r\n______________________________________________________________\r\nFor MrAngel's solution 3, start a new quest file and keep the old file for future referencing.\r\n```\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\nif (ListCount (floorlist) = 0) {\r\n  // do whatever you wanted to do if there *isn't* a floor here\r\n}\r\nelse {\r\n  thisfloor = PickOneObject (floorlist)\r\n  // if you want to do anything when there is a floor here, you can do it here\r\n  // you can use the variable `floorlist` to access the floor object in this room\r\n  // or just remove the else clause if you don't need to do anything}\r\n```\r\nWe know that this code is about destroying, we will try to learn more tomorrow.\r\nFor this code, it is called FilterByAttribute, FilterByAttribute returns a new object list containing only the objects in the given list for which the named attribute has the given value.\r\n```\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\n```\r\nfloorlist is most likely a variable, FilterByAttribute gives us something,\r\n(GetDirectChildren (game.pov.parent) are the parents of the players which is the room player is at right now.\r\n\"prototype\" is an attribute, Floor is used here so we can find out about it.\r\nIn short, variable = Find(player's room, \"prototype\" attribute, value=Floor)\r\nSo to rephrase it again, Find prototype Floor in the player's room and gives us that value inside a variable, so like MrAngel said, the prototype means that this Floor is a clone, therefore this line of code is extremely important to all our future games and coding, because I am going to streamline my coding to autogeneration as autogeneration codes uses one set of code to play 100 to unlimited rooms, as compared to making 100 codes for 100 rooms, which I have tried in my previous games, I will give up and surrender!\r\n</details>\r\nThis infinite maze lesson is too hard and deep for me to understand, I will use whatever works based on any combination of MrAngel's solution rather than understand it, perhaps few years later, I will be back to try and understand it again.",
      "EditableFormat": "markdown",
      "HTML": "<p>Apparently the forum do not like me editing my old post for new updates.</p>\n<p>Me rephrasing MrAngel's solution to try to understand it:</p>\n<details>\nthischair is confusing because it sounds like this(object) or chair(object), but it is just random word for a variable, meaning I can put x1 to replace thischair instead, which I tested and it still works.\nIf thischair is an object, it would not works, as it can only gains 1 set of x and y, however it is actually a variable, a variable is just a temporary value which disappears after the script has ended. MrAngel used a variable to link up CloneObjectAndMoveHere (Chair).xy = game.xy, because if you directly write my formula, the game do not accepts such equation.\nSo another way to simplify this is:\n```\nx1 = CloneObjectAndMoveHere (Chair)\nx1.x = game.x\nx1.y = game.y\n```\nNow for the next program: foreach\n```\nforeach (room, GetDirectChildren (DungeonContainer)) {\nforeach (object, GetDirectChildren (room)) {\nif (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\nobject.visible = (object.x = game.x and object.y = game.y)}}}\n```\nforeach means to run this same script multiple times.\n(room,) means to keep the result of the script to this variable.\n(, GetDirectChildren(DungeonContainer)) means to get all the room folders inside the parent folder (DungeonContainer).\n<p>The next line of code</p>\n<pre><code>foreach (object, GetDirectChildren (room))\n</code></pre>\n<p>is similar, run same script multiple times, to get all childrens of room folder which gives us all the objects, and the result is kept in the variable called object.</p>\n<p>Third line of code</p>\n<pre><code>if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object))\n</code></pre>\n<p>We retrieve the variable object from previous 2 lines of codes, and test whether they have attributes x or y, and whether they do not have point of view (game.pov), after much googling, game.pov seems to refer to all objects inside player's folder which is basically the player's inventory.<br>\n<code>not Contains (game.pov, object)</code> means excluding all the objects in the player's inventory, meaning the player's inventory is excluded from the above if code. I am thinking this <code>not Contains (game.pov, object)</code> is not important, because generally player's inventory are usually and already visible. The whole 4 lines of code is to make objects visible, but the code is excluding player's inventory when making objects visible, but like I said, player's inventory are usually visible.</p>\n<p>Lastly</p>\n<pre><code>object.visible = (object.x = game.x and object.y = game.y)}}}\n</code></pre>\n<p>object.visible means to make all the objects in this variable \"object\" visible, the right hand side means make it visible only if the variable object have an x coordinate = to the current game x coordinate.</p>\n<p>The code can be rewritten as below for easier understanding.</p>\n<pre><code>foreach (x2, GetDirectChildren (DungeonContainer)) {\nforeach (x3, GetDirectChildren (x2)) {\nif (HasInt (x3, \"x\") and HasInt (x3, \"y\") and not Contains (game.pov, x3)) {\nx3.visible = (x3.x = game.x and x3.y = game.y)}}}\n</code></pre>\n<p>Our next code is fairly simple</p>\n<pre><code>foreach (object, ScopeInventory()) {\n  object.x = game.x\n  object.y = game.y}\n</code></pre>\n<p>ScopeInventory code returns an objectlist containing all the visible objects which the player has in their inventory.<br>\nSo foreach code again, for each object in player's inventory, change the object xy coordinates to the new xy coordinates.<br>\nThis code is used when player entering a map of different xy coordinates, so that when the player decides to drop an inventory, it will have the correct xy coordinates.</p>\n<hr>\n<p>For MrAngel's solution 2, it is recommended to start on a new quest file, it would be useful to keep the old file for future referencing.</p>\n<pre><code>foreach (room, GetDirectChildren (DungeonContainer)) {\n  foreach (object, GetDirectChildren (room)) {\n    if (not (object = game.pov or Contains (game.pov, object))) {\n      object.x = game.x\n      object.y = game.y\n      object.room = room\n      RemoveObject (object) }}}\n</code></pre>\n<p>So we input this code, we find out that our doors(object) disappeared, whenever our autogenerator creates new object like a Chair(object), the Chairs disappears too. So if you look at the code similar to MrAngel's first solution, it digs out all objects in the game except for the player and the player's inventory.<br>\n<code>object = game.pov</code> refers to the player.<br>\n<code>Contains (game.pov, object)</code> refers to the player's inventory.<br>\n<code>RemoveObject (object)</code> like MrAngel said, it moves the object away instead of destroying, I am guessing this code moves the object out of parents/rooms.<br>\n<code>object.room = room</code> refers to adding new attributes to all objects, the attribute is named room, this code is strange as it records the current room name, this is probably useless in 1x1 dungeon infinite maze, this might be for 4x5 dungeon infinite maze, but, in short, its utility is strange.</p>\n<p>I am skipping <code>FilterByAttribute</code></p>\n<p>This next code do not seems to works.</p>\n<pre><code>foreach (object, AllObjects()) {\n  if (object.parent = null) {\n    if (Equal (object.x, game.x) and Equal (object.y, game.y)) {\n      object.parent = object.room}}}\n</code></pre>\n<p>It basically takes out all objects and store them in variable object,<br>\nFind all the objects have no parents/room, then amongst them,<br>\nfind objects with same xy coordinates as the current map xy coordinates,<br>\nFinally, change this object's parent into a room.</p>\n<p>Why it does not works is because the doors appears but the autogenerated old Chairs reappear whenever the player<br>\nenters a new map of different xy.<br>\nWhile we do not have an answer for that, after rereading, we know that solution 2 is better than solution 1 because it does not<br>\nrelies on visibility, but rather on rooms instead, therefore we could still introduce invisible objects in our game.<br>\nBecause that is the main difference, our coding error lies in that area too, we are missing some lines of coding about rooms.</p>\n<hr>\n<p>For MrAngel's solution 3, start a new quest file and keep the old file for future referencing.</p>\n<pre><code>floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nif (ListCount (floorlist) = 0) {\n  // do whatever you wanted to do if there *isn't* a floor here\n}\nelse {\n  thisfloor = PickOneObject (floorlist)\n  // if you want to do anything when there is a floor here, you can do it here\n  // you can use the variable `floorlist` to access the floor object in this room\n  // or just remove the else clause if you don't need to do anything}\n</code></pre>\n<p>We know that this code is about destroying, we will try to learn more tomorrow.<br>\nFor this code, it is called FilterByAttribute, FilterByAttribute returns a new object list containing only the objects in the given list for which the named attribute has the given value.</p>\n<pre><code>floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\n</code></pre>\n<p>floorlist is most likely a variable, FilterByAttribute gives us something,<br>\n(GetDirectChildren (game.pov.parent) are the parents of the players which is the room player is at right now.<br>\n\"prototype\" is an attribute, Floor is used here so we can find out about it.<br>\nIn short, variable = Find(player's room, \"prototype\" attribute, value=Floor)<br>\nSo to rephrase it again, Find prototype Floor in the player's room and gives us that value inside a variable, so like MrAngel said, the prototype means that this Floor is a clone, therefore this line of code is extremely important to all our future games and coding, because I am going to streamline my coding to autogeneration as autogeneration codes uses one set of code to play 100 to unlimited rooms, as compared to making 100 codes for 100 rooms, which I have tried in my previous games, I will give up and surrender!</p>\n</details>\nThis infinite maze lesson is too hard and deep for me to understand, I will use whatever works based on any combination of MrAngel's solution rather than understand it, perhaps few years later, I will be back to try and understand it again.\n\n",
      "PostDate": "2021-04-06T04:43:43.0011673Z",
      "LastEditDate": "2021-04-20T12:31:14.1172882Z",
      "link": null
    },
    {
      "PostId": "48c80b16-5d66-4636-abed-4041fcfe0b9b",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/HiZKEtPb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Creating clones baffle me too... \r\nSo, why use them?\r\nThe player is only in 1 room at a time.\r\nwhy not place the \"one and only\" chair in the current room (if one is needed), when the player enters the room?\r\nYou could even randomize the chair's description each time. But, I see where the chair would keep changing colors if the player jumps back and forth between 2 rooms with the chair in it. In that case, add an attribute to the chair based on the room number (.X and .Y not needed.)\r\n4x5 rooms numbered this way:\r\n01, 02, 03, 04, 05\r\n06, 07, 08, 09, 10\r\n11, 12, 13, 15, 15\r\n16, 17, 18, 19, 20\r\nexit=room 03\r\nstart room=18\r\nI should be very easy to randomize the room contents like this:\r\n// random floors\r\n(pseudo code because I think in BASIC and must translate to Quest)\r\nfor a=0 t0 20\r\nx=rnd(6) ' 6 different floors\r\nfloor(a)=x ' make room#A.floor= random floor# X\r\nnext a ' \r\nNow you have the room floor descriptions set.\r\nFloor=\"5,2,4,1,3,2,5,5,2,3,4,2,1,3,6,6,1,3,2,3\"\r\nAnd do the same for the chair\r\n0=no chair, >0 = a chair of the random color\r\nNow, when the player enters the room, just read the floor(room#) to get the floor, \r\nand chair(room#) to place the chair, and the same for every other item you want to add.\r\nIf the player picks up the chair, change chair(room#)=0 (no chair)\r\nAltho, this would limit each room to only having 1 chair.\r\nThis isn't object programming, but it does work the same way, altho, if the chair IS an object, then would it count?\r\n\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Creating clones baffle me too...<br>\nSo, why use them?<br>\nThe player is only in 1 room at a time.<br>\nwhy not place the \"one and only\" chair in the current room (if one is needed), when the player enters the room?<br>\nYou could even randomize the chair's description each time. But, I see where the chair would keep changing colors if the player jumps back and forth between 2 rooms with the chair in it. In that case, add an attribute to the chair based on the room number (.X and .Y not needed.)<br>\n4x5 rooms numbered this way:<br>\n01, 02, 03, 04, 05<br>\n06, 07, 08, 09, 10<br>\n11, 12, 13, 15, 15<br>\n16, 17, 18, 19, 20<br>\nexit=room 03<br>\nstart room=18<br>\nI should be very easy to randomize the room contents like this:<br>\n// random floors<br>\n(pseudo code because I think in BASIC and must translate to Quest)<br>\nfor a=0 t0 20<br>\nx=rnd(6) ' 6 different floors<br>\nfloor(a)=x ' make room#A.floor= random floor# X<br>\nnext a '<br>\nNow you have the room floor descriptions set.<br>\nFloor=\"5,2,4,1,3,2,5,5,2,3,4,2,1,3,6,6,1,3,2,3\"<br>\nAnd do the same for the chair<br>\n0=no chair, &gt;0 = a chair of the random color<br>\nNow, when the player enters the room, just read the floor(room#) to get the floor,<br>\nand chair(room#) to place the chair, and the same for every other item you want to add.<br>\nIf the player picks up the chair, change chair(room#)=0 (no chair)<br>\nAltho, this would limit each room to only having 1 chair.<br>\nThis isn't object programming, but it does work the same way, altho, if the chair IS an object, then would it count?</p>\n\n",
      "PostDate": "2021-04-08T22:14:24.8793946Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "7ad83218-af85-4a5d-979a-7b5a8a6d8518",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "For DarkLizerd, creating clones might be required as I generally make rpg games, I have to create multiple enemies like AxeDwarf1 and AxeDwarf2, players have the option to retreat after battling halfway, meaning there is one dwarf with half hp, and the other with full hp. (If it matters, I am using autogeneration monsters, objects, everything, so cloning seems relevant even if I am no master of it.)\r\nI am going to take some time to read the rest of your code.\r\n\r\nGuys stop giving me additional code for Infinite Maze, LOL, I only know if else programming, anymore is stressing me out for now.\r\nI cannot even comprehend MrAngel's solution and I do not know BASIC code or any other programming language.",
      "EditableFormat": "markdown",
      "HTML": "<p>For DarkLizerd, creating clones might be required as I generally make rpg games, I have to create multiple enemies like AxeDwarf1 and AxeDwarf2, players have the option to retreat after battling halfway, meaning there is one dwarf with half hp, and the other with full hp. (If it matters, I am using autogeneration monsters, objects, everything, so cloning seems relevant even if I am no master of it.)<br>\nI am going to take some time to read the rest of your code.</p>\n<p>Guys stop giving me additional code for Infinite Maze, LOL, I only know if else programming, anymore is stressing me out for now.<br>\nI cannot even comprehend MrAngel's solution and I do not know BASIC code or any other programming language.</p>\n\n",
      "PostDate": "2021-04-09T05:11:23.2981429Z",
      "LastEditDate": "2021-04-09T05:38:44.6723157Z",
      "link": null
    },
    {
      "PostId": "f433f3b9-b693-43f8-9cb2-50aee558bc86",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/HiZKEtPb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Give me a few days and I can slap an example together. Right now, I'm getting my Dark Halloween re-working, and expanded.\r\n ",
      "EditableFormat": "markdown",
      "HTML": "<p>Give me a few days and I can slap an example together. Right now, I'm getting my Dark Halloween re-working, and expanded.</p>\n\n",
      "PostDate": "2021-04-10T22:39:28.5355521Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "63170ec5-e2e5-4246-9e6f-6d3c32fe55d9",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/HiZKEtPb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK, I looked over what you said at the start.\r\nWhat you are creating is a maze with no exit, it just goes on forever.\r\nAnd you are using a 5x4 grid to \"describe\" part of it.\r\nWhat happens when you \"exit\" the top of the maze and jump to the bottom, and start running over your old rooms?\r\nWhy not use a 10x10, and pre-generate the maze?\r\nAnd have a start and end point?\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>OK, I looked over what you said at the start.<br>\nWhat you are creating is a maze with no exit, it just goes on forever.<br>\nAnd you are using a 5x4 grid to \"describe\" part of it.<br>\nWhat happens when you \"exit\" the top of the maze and jump to the bottom, and start running over your old rooms?<br>\nWhy not use a 10x10, and pre-generate the maze?<br>\nAnd have a start and end point?</p>\n\n",
      "PostDate": "2021-04-22T14:16:10.401439Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5caed73f-d673-469b-b6bf-7ecf26288145",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "MrAngel, I need help, I used the following variation of your codes but the program only clones the Floor object once only, \r\nI am guessing line 6 FilterByAttribute have a mistake in which it detects Floor object in other rooms, that is why it will not clone any new Floor object, I need help to correct this.\r\n```\r\nforeach (object, GetDirectChildren (room)) {\r\n  if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\r\n    object.visible = (object.x = game.x and object.y = game.y)\r\n  }\r\n}\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\nif (ListCount (floorlist) = 0) {\r\n  // do whatever you wanted to do if there *isn't* a floor here\r\n  thisfloor = CloneObjectAndMoveHere (Floor)\r\n  thisfloor.x = game.x\r\n  thisfloor.y = game.y\r\n}\r\n```\r\nAdditional non-important notes : I am going for 1 room infinite maze, the player moves according to x and y.\r\nTo handle a maze-like structure, there is a 50% of spawning north, south, east, west roads (objects.), for example, if north road object is visible, the exit to North is visible too, else not. To make the maze makes sense, when creating a north road at x:1 y:1, I will have to spawn an additional south road and Floor at x:1 y:2.\r\n\r\nAfter trying three more times, once with game.x%2=0, exit visible,\r\nonce with game.x>3 and game.x<9 and game.y<0 and game.y<5, exit visible,\r\nlastly with pre put create object Floorcode4, find current player x and y in game, the next game.x-1 to game.x+1 have exits closed from game.y of -1 to +6.\r\nI think I should quit making infinite maze, bye bye XD!\r\nFaints in my bed.\r\n\r\n______________________________________\r\nUpdate 27 April 2021, MrAngel's new code\r\n```\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\nfloorlist = FilterByAttribute (floorlist, \"visible\", true)\r\n```\r\nInfinite maze finally seems to be working, still working hard on it to make a simple maze.",
      "EditableFormat": "markdown",
      "HTML": "<p>MrAngel, I need help, I used the following variation of your codes but the program only clones the Floor object once only,<br>\nI am guessing line 6 FilterByAttribute have a mistake in which it detects Floor object in other rooms, that is why it will not clone any new Floor object, I need help to correct this.</p>\n<pre><code>foreach (object, GetDirectChildren (room)) {\n  if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\n    object.visible = (object.x = game.x and object.y = game.y)\n  }\n}\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nif (ListCount (floorlist) = 0) {\n  // do whatever you wanted to do if there *isn't* a floor here\n  thisfloor = CloneObjectAndMoveHere (Floor)\n  thisfloor.x = game.x\n  thisfloor.y = game.y\n}\n</code></pre>\n<p>Additional non-important notes : I am going for 1 room infinite maze, the player moves according to x and y.<br>\nTo handle a maze-like structure, there is a 50% of spawning north, south, east, west roads (objects.), for example, if north road object is visible, the exit to North is visible too, else not. To make the maze makes sense, when creating a north road at x:1 y:1, I will have to spawn an additional south road and Floor at x:1 y:2.</p>\n<p>After trying three more times, once with game.x%2=0, exit visible,<br>\nonce with game.x&gt;3 and game.x&lt;9 and game.y&lt;0 and game.y&lt;5, exit visible,<br>\nlastly with pre put create object Floorcode4, find current player x and y in game, the next game.x-1 to game.x+1 have exits closed from game.y of -1 to +6.<br>\nI think I should quit making infinite maze, bye bye XD!<br>\nFaints in my bed.</p>\n<hr>\n<p>Update 27 April 2021, MrAngel's new code</p>\n<pre><code>floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nfloorlist = FilterByAttribute (floorlist, \"visible\", true)\n</code></pre>\n<p>Infinite maze finally seems to be working, still working hard on it to make a simple maze.</p>\n\n",
      "PostDate": "2021-04-22T14:48:00.7887865Z",
      "LastEditDate": "2021-04-26T16:12:26.1141351Z",
      "link": null
    },
    {
      "PostId": "21395f92-53f6-41e8-9d80-46b05336e498",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@DarkLizerd \r\nWell, this infinite maze is becoming sorta a nightmare.\r\nYes I need to create a maze with no exit, after making so many games, I realized creating rooms is troublesome, a chore, a mess, time-exhausting, hard to find the last room I was working on.\r\nI previously decided to use 5x4 grid because I can pre-do many walls and make it feel like the hedge maze just like in all the movies, also with 5x4 grid I can pre-do an open path to ensure there are actually exits, now this plan is currently abandoned.\r\n\r\nIn order to avoid \"exit\" the top of maze and jump to bottom and start running over old rooms, I used the game attribute x and y,\r\nfor example the top of maze have x:0 y:1, the original maze is x:0 y:0, this way, you can determine which objects to hide if their coordinates does not match, according to MrAngel's code it should be ```object.visible = (object.x = game.x and object.y = game.y)```\r\n\r\nIf I pre-generate the maze, have a start and end point, I am not improving myself, everytime I make a game, I must learn and create something new, and I feel that this infinite maze is a huge stepping stone to become a super good game creator.",
      "EditableFormat": "markdown",
      "HTML": "<p>@DarkLizerd<br>\nWell, this infinite maze is becoming sorta a nightmare.<br>\nYes I need to create a maze with no exit, after making so many games, I realized creating rooms is troublesome, a chore, a mess, time-exhausting, hard to find the last room I was working on.<br>\nI previously decided to use 5x4 grid because I can pre-do many walls and make it feel like the hedge maze just like in all the movies, also with 5x4 grid I can pre-do an open path to ensure there are actually exits, now this plan is currently abandoned.</p>\n<p>In order to avoid \"exit\" the top of maze and jump to bottom and start running over old rooms, I used the game attribute x and y,<br>\nfor example the top of maze have x:0 y:1, the original maze is x:0 y:0, this way, you can determine which objects to hide if their coordinates does not match, according to MrAngel's code it should be <code>object.visible = (object.x = game.x and object.y = game.y)</code></p>\n<p>If I pre-generate the maze, have a start and end point, I am not improving myself, everytime I make a game, I must learn and create something new, and I feel that this infinite maze is a huge stepping stone to become a super good game creator.</p>\n\n",
      "PostDate": "2021-04-22T14:59:56.1209912Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4310adcf-d17d-492a-8838-203c7956aac1",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> MrAngel, I need help, I used the following variation of your codes but the program only clones the Floor object once only,\r\nI am guessing line 6 FilterByAttribute have a mistake in which it detects Floor object in other rooms, that is why it will not clone any new Floor object, I need help to correct this.\r\n> \r\n>     foreach (object, GetDirectChildren (room)) {\r\n>       if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\r\n>         object.visible = (object.x = game.x and object.y = game.y)\r\n>       }\r\n>     }\r\n>     floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\n>     if (ListCount (floorlist) = 0) {\r\n>       // do whatever you wanted to do if there *isn't* a floor here\r\n>       thisfloor = CloneObjectAndMoveHere (Floor)\r\n>       thisfloor.x = game.x\r\n>       thisfloor.y = game.y\r\n>     }\r\n\r\nAh, I think I was a little careless with that one. In that case, it's checking whether there is a floor in that room, rather than checking if there's a *visible* floor in that room.\r\n\r\nThere's two methods to ignore floors in other versions of this room. The most efficient would be to filter the floor list to only the ones that are visible:\r\n```\r\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\r\nfloorlist = FilterByAttribute (floorlist, \"visible\", true)\r\n```\r\n\r\nOr slower (but the code might be easier to understand):\r\n```\r\nfloorlist = FilterByAttribute (ScopeVisibleNotHeld(), \"prototype\", Floor)\r\n```\r\n",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>MrAngel, I need help, I used the following variation of your codes but the program only clones the Floor object once only,<br>\nI am guessing line 6 FilterByAttribute have a mistake in which it detects Floor object in other rooms, that is why it will not clone any new Floor object, I need help to correct this.</p>\n<pre><code>foreach (object, GetDirectChildren (room)) {\n  if (HasInt (object, \"x\") and HasInt (object, \"y\") and not Contains (game.pov, object)) {\n    object.visible = (object.x = game.x and object.y = game.y)\n  }\n}\nfloorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nif (ListCount (floorlist) = 0) {\n  // do whatever you wanted to do if there *isn't* a floor here\n  thisfloor = CloneObjectAndMoveHere (Floor)\n  thisfloor.x = game.x\n  thisfloor.y = game.y\n}\n</code></pre>\n</blockquote>\n<p>Ah, I think I was a little careless with that one. In that case, it's checking whether there is a floor in that room, rather than checking if there's a <em>visible</em> floor in that room.</p>\n<p>There's two methods to ignore floors in other versions of this room. The most efficient would be to filter the floor list to only the ones that are visible:</p>\n<pre><code>floorlist = FilterByAttribute (GetDirectChildren (game.pov.parent), \"prototype\", Floor)\nfloorlist = FilterByAttribute (floorlist, \"visible\", true)\n</code></pre>\n<p>Or slower (but the code might be easier to understand):</p>\n<pre><code>floorlist = FilterByAttribute (ScopeVisibleNotHeld(), \"prototype\", Floor)\n</code></pre>\n\n",
      "PostDate": "2021-04-22T18:17:24.3200387Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "210c2f75-084c-4cdd-90e9-39bf753c95c8",
      "UserId": 31991,
      "Username": "daeun",
      "AvatarUrl": "https://i.imgur.com/cX50WTzb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Infinite Maze can now be played at\r\nhttps://textadventures.co.uk/games/view/wyxv0ib9jkopqyza1nhsww/infinite-maze-2021\r\n\r\nFree code at bottom.\r\nCopy and paste into Quest via [Tools, Code View] or [F9].\r\n\r\nI think I cannot post big amount of code in forum as I tried but it wasn't visible, \r\nthe code is now viewable at https://pastebin.com/9MLaacUX",
      "EditableFormat": "markdown",
      "HTML": "<p>Infinite Maze can now be played at<br>\nhttps://textadventures.co.uk/games/view/wyxv0ib9jkopqyza1nhsww/infinite-maze-2021</p>\n<p>Free code at bottom.<br>\nCopy and paste into Quest via [Tools, Code View] or [F9].</p>\n<p>I think I cannot post big amount of code in forum as I tried but it wasn't visible,<br>\nthe code is now viewable at https://pastebin.com/9MLaacUX</p>\n\n",
      "PostDate": "2021-04-26T18:39:36.3487722Z",
      "LastEditDate": "2021-04-27T04:17:05.7572089Z",
      "link": null
    }
  ]
}
