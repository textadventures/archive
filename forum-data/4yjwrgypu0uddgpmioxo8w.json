{
  "Topic": {
    "TopicId": "4yjwrgypu0uddgpmioxo8w",
    "ForumId": "24",
    "Title": "Hacking squiffy further…",
    "LastUpdated": "2021-02-06T01:33:18.420504Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "193fd896-7c2e-4019-9ddf-d24ebb2234ef",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I was playing around with something today, which would have been a lot easier if I could modify one of Squiffy's built-in functions, `setAttribute`.\r\nNow, I'd already written a script that would let me modify functions like `squiffy.ui.processText` or `squiffy.story.go` from within a game. But `setAttribute` is harder, because it's a local variable - it isn't in scope when user code is being executed. After a little poking around, I found a way to get it. This basically uses the fact that when a game is loaded, the code in the `_transition` attribute is passed to `eval` - and has access to any local variables that were in scope at the point where `squiffy.story.load` is defined. So I force the game to save and then load immediately on startup, so that I can use that `eval` to run my code.\r\n\r\nJust posting in case anyone else finds it useful (or can tell me a simpler way that I've missed\r\n\r\n(this javascript goes in the starting section; after it finishes it passes the player on to section \"firstsection\" which will contain the real start of the game)\r\n```\r\n    window.sq = squiffy;\r\n    var transition = function () {\r\n        console.log(\"Initialising...\");\r\n        var setfunc = setAttribute;\r\n        var processtextoriginal = squiffy.ui.processText;\r\n        squiffy.story.save = function () {\r\n            squiffy.set('_output', squiffy.ui.output.html() || \"  \");\r\n            squiffy.set('_transition', squiffy.get('_transitioncode'));\r\n        };\r\n        setAttribute = function (expr) {\r\n            var matches = /^(\\w*\\s*):=(.*)$/.exec(expr);\r\n            if (matches) {\r\n                console.log(\"Matches\");\r\n                console.log(matches);\r\n                expr = matches[1] + '=' + squiffy.ui.processText(matches[2]);\r\n            }\r\n            console.log(\"Evaluating set: \"+expr)\r\n            setfunc(expr);\r\n        };\r\n        squiffy.ui.processText = function (text) {\r\n            // insert modified text processor here\r\n            return (processtextoriginal(text));\r\n        };\r\n    }.toString();\r\n    squiffy.set('_transitioncode', transition);\r\n    squiffy.set('_transition', transition);\r\n    squiffy.set('_output', ' ');\r\n    squiffy.story.load();\r\n    squiffy.story.go(\"firstsection\");\r\n```\r\n\r\nIn this example, I'm tweaking it so that you can do things like:\r\n```\r\n@set someAttribute := This {anotherAttribute} will be substituted when the line is parsed\r\n```\r\nSo I can change anotherAttribute and someAttribute will still contain the old value :)\r\n\r\nI also tweaked the text processor so you can add arbitrary new commands to it (the same way I already did for Quest); but that's not really the point of this post.\r\nI just thought it might be interesting, in case anyone else wants to modify some of Squiffy's \"private\" internal functions in your games.",
      "EditableFormat": "markdown",
      "HTML": "<p>I was playing around with something today, which would have been a lot easier if I could modify one of Squiffy's built-in functions, <code>setAttribute</code>.<br>\nNow, I'd already written a script that would let me modify functions like <code>squiffy.ui.processText</code> or <code>squiffy.story.go</code> from within a game. But <code>setAttribute</code> is harder, because it's a local variable - it isn't in scope when user code is being executed. After a little poking around, I found a way to get it. This basically uses the fact that when a game is loaded, the code in the <code>_transition</code> attribute is passed to <code>eval</code> - and has access to any local variables that were in scope at the point where <code>squiffy.story.load</code> is defined. So I force the game to save and then load immediately on startup, so that I can use that <code>eval</code> to run my code.</p>\n<p>Just posting in case anyone else finds it useful (or can tell me a simpler way that I've missed</p>\n<p>(this javascript goes in the starting section; after it finishes it passes the player on to section \"firstsection\" which will contain the real start of the game)</p>\n<pre><code>    window.sq = squiffy;\n    var transition = function () {\n        console.log(\"Initialising...\");\n        var setfunc = setAttribute;\n        var processtextoriginal = squiffy.ui.processText;\n        squiffy.story.save = function () {\n            squiffy.set('_output', squiffy.ui.output.html() || \"  \");\n            squiffy.set('_transition', squiffy.get('_transitioncode'));\n        };\n        setAttribute = function (expr) {\n            var matches = /^(\\w*\\s*):=(.*)$/.exec(expr);\n            if (matches) {\n                console.log(\"Matches\");\n                console.log(matches);\n                expr = matches[1] + '=' + squiffy.ui.processText(matches[2]);\n            }\n            console.log(\"Evaluating set: \"+expr)\n            setfunc(expr);\n        };\n        squiffy.ui.processText = function (text) {\n            // insert modified text processor here\n            return (processtextoriginal(text));\n        };\n    }.toString();\n    squiffy.set('_transitioncode', transition);\n    squiffy.set('_transition', transition);\n    squiffy.set('_output', ' ');\n    squiffy.story.load();\n    squiffy.story.go(\"firstsection\");\n</code></pre>\n<p>In this example, I'm tweaking it so that you can do things like:</p>\n<pre><code>@set someAttribute := This {anotherAttribute} will be substituted when the line is parsed\n</code></pre>\n<p>So I can change anotherAttribute and someAttribute will still contain the old value :)</p>\n<p>I also tweaked the text processor so you can add arbitrary new commands to it (the same way I already did for Quest); but that's not really the point of this post.<br>\nI just thought it might be interesting, in case anyone else wants to modify some of Squiffy's \"private\" internal functions in your games.</p>\n\n",
      "PostDate": "2021-02-06T01:33:18.420504Z",
      "LastEditDate": "2021-02-07T11:14:19.3275699Z",
      "link": null
    },
    {
      "PostId": "85dce9ae-6127-4145-8083-d2af8ade7dfc",
      "UserId": 317941,
      "Username": "DaxAtDS9",
      "AvatarUrl": "http://i.imgur.com/qLCkdtBb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Didnt get what it may be good for. Do you have any example?",
      "EditableFormat": "markdown",
      "HTML": "<p>Didnt get what it may be good for. Do you have any example?</p>\n\n",
      "PostDate": "2021-02-07T05:43:19.9784411Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d8edb169-3f86-46cc-b760-f30d1257cfb3",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Didnt get what it may be good for. Do you have any example?\r\n\r\nThis is basically \"how to modify the built-in functions\". Like if you want to change how Squiffy works in some way to better fit your game; making functions that run every time you visit a new page, or adding new capabilities to the text processor, for example.\r\n\r\nThe system I was building it for looks something like this:\r\n```\r\n        squiffy.ui.processText = function (text, data = {}) {\r\n            if (!squiffy.ui.textProcessorFunctions) {return (processtextoriginal(text));}\r\n            var args, building = '';\r\n            var depth = 0;\r\n            var output = '';\r\n            var command = '';\r\n            $.each(text.split(/(?=[:{}])/), (i, token) => {\r\n                if (depth) {\r\n                    if (token.match(/^\\}/) && (depth == 1)) {\r\n                        args.push(building);\r\n                        building = '';\r\n                        var cmdname = args[0];\r\n                        if (squiffy.ui.textProcessorFunctions[cmdname]) {\r\n                            args.shift();\r\n                            output += squiffy.ui.textProcessorFunctions[cmdname].apply({command: command, data: data}, args) || '';\r\n                        } else {\r\n                            output += command + '}';\r\n                        }\r\n                        command = '';\r\n                        output += token.substr(1);\r\n                        depth = 0;\r\n                    } else if (token.match(/^:/) && (depth == 1)) {\r\n                        command += token;\r\n                        args.push(building);\r\n                        building = token.substr(1);\r\n                    } else {\r\n                        if (token.match(/^\\{/)) {depth++;}\r\n                        if (token.match(/^\\}/)) {depth--;}\r\n                        building += token;\r\n                        command += token;\r\n                    }\r\n                } else if(token.match(/^\\{/)) {\r\n                    building = token.substr(1);\r\n                    args = [];\r\n                    depth = 1;\r\n                    command = token;\r\n                } else {\r\n                    output += token;\r\n                }\r\n            });\r\n            if (command) {\r\n                output += command;\r\n            }\r\n            output = processtextoriginal(output);\r\n            return (output == text) ? text : squiffy.ui.processtext(output, data);\r\n        };\r\n```\r\n\r\nWhich is still just a framework to modify more stuff. Like a random function…\r\n```\r\n    squiffy.ui.textProcessorFunctions = {\r\n        random: function (...options) {\r\n            return options ? squiffy.ui.processText(options[Math.floor(Math.random() * options.length)], this.data) : '';\r\n        }\r\n    };\r\n```\r\n\r\nSo I can do something like:\r\n```\r\nYou walk through the garden and notice a pretty {random:red:green:yellow} flower.\r\n```\r\nor\r\n```\r\n@set cointoss := {random:heads:tails}\r\n```\r\n\r\n(this is all off the top of my head, I didn't finish writing it yet so I haven't tested all the stuff in this post)\r\n\r\n(and I know this has some real problems… like the fact that I can't access the `data` object, because the existing text processor doesn't expose it)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Didnt get what it may be good for. Do you have any example?</p>\n</blockquote>\n<p>This is basically \"how to modify the built-in functions\". Like if you want to change how Squiffy works in some way to better fit your game; making functions that run every time you visit a new page, or adding new capabilities to the text processor, for example.</p>\n<p>The system I was building it for looks something like this:</p>\n<pre><code>        squiffy.ui.processText = function (text, data = {}) {\n            if (!squiffy.ui.textProcessorFunctions) {return (processtextoriginal(text));}\n            var args, building = '';\n            var depth = 0;\n            var output = '';\n            var command = '';\n            $.each(text.split(/(?=[:{}])/), (i, token) =&gt; {\n                if (depth) {\n                    if (token.match(/^\\}/) &amp;&amp; (depth == 1)) {\n                        args.push(building);\n                        building = '';\n                        var cmdname = args[0];\n                        if (squiffy.ui.textProcessorFunctions[cmdname]) {\n                            args.shift();\n                            output += squiffy.ui.textProcessorFunctions[cmdname].apply({command: command, data: data}, args) || '';\n                        } else {\n                            output += command + '}';\n                        }\n                        command = '';\n                        output += token.substr(1);\n                        depth = 0;\n                    } else if (token.match(/^:/) &amp;&amp; (depth == 1)) {\n                        command += token;\n                        args.push(building);\n                        building = token.substr(1);\n                    } else {\n                        if (token.match(/^\\{/)) {depth++;}\n                        if (token.match(/^\\}/)) {depth--;}\n                        building += token;\n                        command += token;\n                    }\n                } else if(token.match(/^\\{/)) {\n                    building = token.substr(1);\n                    args = [];\n                    depth = 1;\n                    command = token;\n                } else {\n                    output += token;\n                }\n            });\n            if (command) {\n                output += command;\n            }\n            output = processtextoriginal(output);\n            return (output == text) ? text : squiffy.ui.processtext(output, data);\n        };\n</code></pre>\n<p>Which is still just a framework to modify more stuff. Like a random function…</p>\n<pre><code>    squiffy.ui.textProcessorFunctions = {\n        random: function (...options) {\n            return options ? squiffy.ui.processText(options[Math.floor(Math.random() * options.length)], this.data) : '';\n        }\n    };\n</code></pre>\n<p>So I can do something like:</p>\n<pre><code>You walk through the garden and notice a pretty {random:red:green:yellow} flower.\n</code></pre>\n<p>or</p>\n<pre><code>@set cointoss := {random:heads:tails}\n</code></pre>\n<p>(this is all off the top of my head, I didn't finish writing it yet so I haven't tested all the stuff in this post)</p>\n<p>(and I know this has some real problems… like the fact that I can't access the <code>data</code> object, because the existing text processor doesn't expose it)</p>\n\n",
      "PostDate": "2021-02-07T11:10:28.0931414Z",
      "LastEditDate": "2021-02-07T20:03:17.6477821Z",
      "link": null
    },
    {
      "PostId": "150f0cf6-76ed-4323-8326-0ad6c875ff59",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK… putting the pieces together now…\r\n\r\nThis is something like what I originally envisioned. I know it's a huge chunk of JS to put in the first section of a game, but I think it makes the text processor a lot more flexible. So you don't need as much javascript later on.\r\n```\r\n    window.sq = squiffy;\r\n    var transition = function () {\r\n        console.log(\"Initialising...\");\r\n        var setfunc = setAttribute;\r\n        var processtextoriginal = squiffy.ui.processText;\r\n        squiffy.story.save = function () {\r\n            squiffy.set('_output', squiffy.ui.output.html() || \"  \");\r\n            squiffy.set('_transition', squiffy.get('_transitioncode'));\r\n        };\r\n        setAttribute = function (expr) {\r\n            var matches = /^(\\w*\\s*):=(.*)$/.exec(expr);\r\n            if (matches) {\r\n                console.log(\"Matches\");\r\n                console.log(matches);\r\n                expr = matches[1] + '=' + squiffy.ui.processText(matches[2]);\r\n            }\r\n            console.log(\"Evaluating set: \"+expr)\r\n            setfunc(expr);\r\n        };\r\n\r\n        squiffy.ui.processText = function (text, data = {}) {\r\n            if (!squiffy.ui.textProcessorFunctions) {return (processtextoriginal(text));}\r\n            var args, building = '';\r\n            var depth = 0;\r\n            var output = '';\r\n            var command = '';\r\n            $.each(text.split(/(?=[:{}])/), (i, token) => {\r\n                if (depth) {\r\n                    if (token.match(/^\\}/) && (depth == 1)) {\r\n                        if (!args.length) {\r\n                            var cmd = building.match(/^(@)(?!replace)(.+)$/) || building.match(/^(\\w+)(?:\\s+(\\w+))?\\s*$/);\r\n                            if (cmd && cmd[0]) {args['command'] = cmd[0]}\r\n                            if (cmd && cmd[1]) {args['firstarg'] = cmd[1]}\r\n                        }\r\n                        args.push(building);\r\n                        building = '';\r\n                        args.stringform = command;\r\n                        args.toString = function() { return this.stringform; };\r\n                        if (squiffy.ui.textProcessorFunctions[args.cmd]) {\r\n                            output += squiffy.ui.textProcessorFunctions[cmdname].apply(args, args) || '';\r\n                        } else {\r\n                            output += command + '}';\r\n                        }\r\n                        command = '';\r\n                        output += token.substr(1);\r\n                        depth = 0;\r\n                    } else if (token.match(/^:/) && (depth == 1)) {\r\n                        command += token;\r\n                        args.push(building);\r\n                        building = token.substr(1);\r\n                    } else {\r\n                        if (token.match(/^\\{/)) {depth++;}\r\n                        if (token.match(/^\\}/)) {depth--;}\r\n                        building += token;\r\n                        command += token;\r\n                    }\r\n                } else if(token.match(/^\\{/)) {\r\n                    building = token.substr(1);\r\n                    args = [];\r\n                    depth = 1;\r\n                    command = token;\r\n                } else {\r\n                    output += token;\r\n                }\r\n            });\r\n            if (command) {\r\n                output += command;\r\n            }\r\n            return processtextoriginal(output);\r\n        };\r\n        squiffy.ui.textProcessorFunctions = {\r\n            random: function (command, ...options) {\r\n                var result = options ? squiffy.ui.processText(options[Math.floor(Math.random() * options.length)], this.data) : '';\r\n                if (this.firstarg) { squiffy.set(this.firstarg, result); }\r\n                return result;\r\n            },\r\n            // This lets you do things like {eval:$a + $b}\r\n            // or \"You give him $5, and have ${eval money:$money - 5} left.\"\r\n            // attributes are preceded with $ rather than @ because the expression is javascript,\r\n            // and JS variable names can't start with @\r\n            eval: function (command, args) {\r\n                var target, statement;\r\n                if (this.firstarg && !args.length) {\r\n                    statement = this.firstarg;\r\n                } else {\r\n                    target = this.firstarg;\r\n                    statement = args.join(':');\r\n                }\r\n                var attributes = [undefined];\r\n                var values = [];\r\n                var test;\r\n                $.each(statement.match(/(?<!\\w)\\$\\w+/g), (i, term) => {\r\n                    if (test = squiffy.get(term.substr(1))) {attributes.push(term); values.push(test);}\r\n                });\r\n                attributes.push(statement);\r\n                var result = (new (Function.prototype.bind.apply(Function, attributes))).apply(undefined, values);\r\n                if (target) { squiffy.set(target, result); }\r\n                return result;\r\n            },\r\n\r\n            // Would probably be better to copy the code for 'if', 'else', 'rotate', and so on here as well.\r\n\r\n        };\r\n    }.toString();\r\n    squiffy.set('_transitioncode', transition);\r\n    squiffy.set('_transition', transition);\r\n    squiffy.set('_output', ' ');\r\n    squiffy.story.load();\r\n    squiffy.story.go(\"firstsection\");\r\n```\r\n\r\nWith this in place, you could do something like:\r\n```\r\nThe NPC sneaks up and steals {eval stolen:Math.floor(Math.random() * $money)} gold pieces from your pocket, leaving you with only {eval money:$money - $stolen}! You promptly chase after him and demand your money back.\r\n\r\n\"I'm feeling generous,\" he says. \"If you can guess a coin toss, I'll give you your money back.\" Then he flips the coin.\r\n\r\n[[Heads!]](cointoss,guess=heads)\r\n[[Tails!]](cointoss,guess=tails)\r\n\r\n[[cointoss]]:\r\nYou shout out \"{guess}!\" just as the coin lands, showing its {random toss:heads:tails} side on top.\r\n\r\n{if guess=@toss:\"Well, you win. I'm a man of my word,\" he says, and hands your money back.{@money+@stolen}}{else:\"Tough luck, sucker.\"} Then he walks away without another word.\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>OK… putting the pieces together now…</p>\n<p>This is something like what I originally envisioned. I know it's a huge chunk of JS to put in the first section of a game, but I think it makes the text processor a lot more flexible. So you don't need as much javascript later on.</p>\n<pre><code>    window.sq = squiffy;\n    var transition = function () {\n        console.log(\"Initialising...\");\n        var setfunc = setAttribute;\n        var processtextoriginal = squiffy.ui.processText;\n        squiffy.story.save = function () {\n            squiffy.set('_output', squiffy.ui.output.html() || \"  \");\n            squiffy.set('_transition', squiffy.get('_transitioncode'));\n        };\n        setAttribute = function (expr) {\n            var matches = /^(\\w*\\s*):=(.*)$/.exec(expr);\n            if (matches) {\n                console.log(\"Matches\");\n                console.log(matches);\n                expr = matches[1] + '=' + squiffy.ui.processText(matches[2]);\n            }\n            console.log(\"Evaluating set: \"+expr)\n            setfunc(expr);\n        };\n\n        squiffy.ui.processText = function (text, data = {}) {\n            if (!squiffy.ui.textProcessorFunctions) {return (processtextoriginal(text));}\n            var args, building = '';\n            var depth = 0;\n            var output = '';\n            var command = '';\n            $.each(text.split(/(?=[:{}])/), (i, token) =&gt; {\n                if (depth) {\n                    if (token.match(/^\\}/) &amp;&amp; (depth == 1)) {\n                        if (!args.length) {\n                            var cmd = building.match(/^(@)(?!replace)(.+)$/) || building.match(/^(\\w+)(?:\\s+(\\w+))?\\s*$/);\n                            if (cmd &amp;&amp; cmd[0]) {args['command'] = cmd[0]}\n                            if (cmd &amp;&amp; cmd[1]) {args['firstarg'] = cmd[1]}\n                        }\n                        args.push(building);\n                        building = '';\n                        args.stringform = command;\n                        args.toString = function() { return this.stringform; };\n                        if (squiffy.ui.textProcessorFunctions[args.cmd]) {\n                            output += squiffy.ui.textProcessorFunctions[cmdname].apply(args, args) || '';\n                        } else {\n                            output += command + '}';\n                        }\n                        command = '';\n                        output += token.substr(1);\n                        depth = 0;\n                    } else if (token.match(/^:/) &amp;&amp; (depth == 1)) {\n                        command += token;\n                        args.push(building);\n                        building = token.substr(1);\n                    } else {\n                        if (token.match(/^\\{/)) {depth++;}\n                        if (token.match(/^\\}/)) {depth--;}\n                        building += token;\n                        command += token;\n                    }\n                } else if(token.match(/^\\{/)) {\n                    building = token.substr(1);\n                    args = [];\n                    depth = 1;\n                    command = token;\n                } else {\n                    output += token;\n                }\n            });\n            if (command) {\n                output += command;\n            }\n            return processtextoriginal(output);\n        };\n        squiffy.ui.textProcessorFunctions = {\n            random: function (command, ...options) {\n                var result = options ? squiffy.ui.processText(options[Math.floor(Math.random() * options.length)], this.data) : '';\n                if (this.firstarg) { squiffy.set(this.firstarg, result); }\n                return result;\n            },\n            // This lets you do things like {eval:$a + $b}\n            // or \"You give him $5, and have ${eval money:$money - 5} left.\"\n            // attributes are preceded with $ rather than @ because the expression is javascript,\n            // and JS variable names can't start with @\n            eval: function (command, args) {\n                var target, statement;\n                if (this.firstarg &amp;&amp; !args.length) {\n                    statement = this.firstarg;\n                } else {\n                    target = this.firstarg;\n                    statement = args.join(':');\n                }\n                var attributes = [undefined];\n                var values = [];\n                var test;\n                $.each(statement.match(/(?&lt;!\\w)\\$\\w+/g), (i, term) =&gt; {\n                    if (test = squiffy.get(term.substr(1))) {attributes.push(term); values.push(test);}\n                });\n                attributes.push(statement);\n                var result = (new (Function.prototype.bind.apply(Function, attributes))).apply(undefined, values);\n                if (target) { squiffy.set(target, result); }\n                return result;\n            },\n\n            // Would probably be better to copy the code for 'if', 'else', 'rotate', and so on here as well.\n\n        };\n    }.toString();\n    squiffy.set('_transitioncode', transition);\n    squiffy.set('_transition', transition);\n    squiffy.set('_output', ' ');\n    squiffy.story.load();\n    squiffy.story.go(\"firstsection\");\n</code></pre>\n<p>With this in place, you could do something like:</p>\n<pre><code>The NPC sneaks up and steals {eval stolen:Math.floor(Math.random() * $money)} gold pieces from your pocket, leaving you with only {eval money:$money - $stolen}! You promptly chase after him and demand your money back.\n\n\"I'm feeling generous,\" he says. \"If you can guess a coin toss, I'll give you your money back.\" Then he flips the coin.\n\n[[Heads!]](cointoss,guess=heads)\n[[Tails!]](cointoss,guess=tails)\n\n[[cointoss]]:\nYou shout out \"{guess}!\" just as the coin lands, showing its {random toss:heads:tails} side on top.\n\n{if guess=@toss:\"Well, you win. I'm a man of my word,\" he says, and hands your money back.{@money+@stolen}}{else:\"Tough luck, sucker.\"} Then he walks away without another word.\n</code></pre>\n\n",
      "PostDate": "2021-02-08T15:00:05.5700041Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "6ea3d500-66de-45af-bb9e-90bc62bcf650",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I may have to consider this for my game in development. Just released it - space flight and orbital mechanics. So much more to do...",
      "EditableFormat": "markdown",
      "HTML": "<p>I may have to consider this for my game in development. Just released it - space flight and orbital mechanics. So much more to do...</p>\n\n",
      "PostDate": "2021-02-08T17:55:11.8842147Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
