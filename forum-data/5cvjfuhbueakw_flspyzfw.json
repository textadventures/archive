{
  "Topic": {
    "TopicId": "5cvjfuhbueakw_flspyzfw",
    "ForumId": "10",
    "Title": "If I made a CombatLib",
    "LastUpdated": "2018-07-14T13:17:59.174537Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "dd071f59-0392-40b4-9aec-d6d09a898f56",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(finally got around to changing the title)\r\n\r\nA few times, I've looked at CombatLib when trying to help someone else on here; and it always seems a little awkward to me. I'm wondering if, because of the complexity combat can entail, it might be useful to build a CombatLib that's more tightly structured. Not to insult the original, it's a big project. But in places it feels like it was built for a specific game, and then extended in ways that don't quite fit.\r\n\r\nFor example, rather than giving every monster two very similar scripts `doattack` for when the player attacks it, and `attackplayer` for when it attacks either the player or another monster (which is a little confusing in itself), it might make more sense that a monster/player/spell/weapon/armour can have scripts `beginattack` and `receiveattack`. The former calculates damage (allowing for spells like the FF series \"demi\" which have special damage calculation methods) and the latter applies damage to the target (allowing for things such as elemental resistance and similar).\r\n\r\nI'm thinking that each attack would be calculated as a 'pipeline'. A temporary object is created to represent the attack, with properties including attack power, attack elements, attack accuracy, calculated damage, attack success (boolean), and success/failure/critical strings. This object would then be passed as a parameter to all the scripts in its path; including room/game \"beforeattack\" and \"afterattack\" scripts, and room/monster specific \"beforedeath\", \"makedead\" and \"afterdeath\" scripts.\r\n\r\nAn attack object would be useful, because any of the scripts on its path could modify it, making it easier for a game to deal with even relatively odd stuff (for example, I vaguely recall there being a 2nd ed D&D monster that can be harmed normally by other damage types, but will happily run on negative HP without dying until it's hit by a fire attack. The tri-stat Dark Side Of The Sun RPG has a ).\r\n\r\nCombatLib's method of dealing with attackdesc and similar is pretty neat. But I'd probably make it look more flexible. Rather than using a %, maybe replace variable names like \"{attacker}\", \"{target}\", \"{weapon}\" etc… \r\n\r\n(and that's another thought ... rather than ProcessText understanding a variable `game.text_processor_this`, why not have `game.text_processor_params` be a dictionary, like the one passed to `do` or `invoke`? Then combatlib could just pass the attackdesc to ProcessText, and have the attacker/target/damage/etc filled in automatically)",
      "EditableFormat": "markdown",
      "HTML": "<p>(finally got around to changing the title)</p>\n<p>A few times, I've looked at CombatLib when trying to help someone else on here; and it always seems a little awkward to me. I'm wondering if, because of the complexity combat can entail, it might be useful to build a CombatLib that's more tightly structured. Not to insult the original, it's a big project. But in places it feels like it was built for a specific game, and then extended in ways that don't quite fit.</p>\n<p>For example, rather than giving every monster two very similar scripts <code>doattack</code> for when the player attacks it, and <code>attackplayer</code> for when it attacks either the player or another monster (which is a little confusing in itself), it might make more sense that a monster/player/spell/weapon/armour can have scripts <code>beginattack</code> and <code>receiveattack</code>. The former calculates damage (allowing for spells like the FF series \"demi\" which have special damage calculation methods) and the latter applies damage to the target (allowing for things such as elemental resistance and similar).</p>\n<p>I'm thinking that each attack would be calculated as a 'pipeline'. A temporary object is created to represent the attack, with properties including attack power, attack elements, attack accuracy, calculated damage, attack success (boolean), and success/failure/critical strings. This object would then be passed as a parameter to all the scripts in its path; including room/game \"beforeattack\" and \"afterattack\" scripts, and room/monster specific \"beforedeath\", \"makedead\" and \"afterdeath\" scripts.</p>\n<p>An attack object would be useful, because any of the scripts on its path could modify it, making it easier for a game to deal with even relatively odd stuff (for example, I vaguely recall there being a 2nd ed D&amp;D monster that can be harmed normally by other damage types, but will happily run on negative HP without dying until it's hit by a fire attack. The tri-stat Dark Side Of The Sun RPG has a ).</p>\n<p>CombatLib's method of dealing with attackdesc and similar is pretty neat. But I'd probably make it look more flexible. Rather than using a %, maybe replace variable names like \"{attacker}\", \"{target}\", \"{weapon}\" etc…</p>\n<p>(and that's another thought ... rather than ProcessText understanding a variable <code>game.text_processor_this</code>, why not have <code>game.text_processor_params</code> be a dictionary, like the one passed to <code>do</code> or <code>invoke</code>? Then combatlib could just pass the attackdesc to ProcessText, and have the attacker/target/damage/etc filled in automatically)</p>\n\n",
      "PostDate": "2018-07-14T13:17:59.174537Z",
      "LastEditDate": "2018-09-01T10:11:47.6449281Z",
      "link": null
    },
    {
      "PostId": "875f2cf2-0237-4244-8c6c-17758164b710",
      "UserId": 367757,
      "Username": "ScriptingIsHard",
      "AvatarUrl": "https://secure.gravatar.com/avatar/aa8196a12464bf7c443488a22d853587?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I definitely lack the technical wherewithal to contribute, but I'm very interested in seeing how this develops and happy to help with testing. Just seeing how these things emerge is great for learning off.",
      "EditableFormat": "markdown",
      "HTML": "<p>I definitely lack the technical wherewithal to contribute, but I'm very interested in seeing how this develops and happy to help with testing. Just seeing how these things emerge is great for learning off.</p>\n\n",
      "PostDate": "2018-07-14T13:38:59.8165988Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d78fe78c-85e8-49b7-92db-91c7b508c163",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@ ScriptingIshard:\r\n\r\nif you want to just study some of the basics of combat coding/scripting, you can take a look at this old combat code I did back when I was learning this stuff for my own first time:\r\n\r\n(I used pertex' combat code as the structure for my combat coding, so the credit goes to him)\r\n\r\n(Pixie's combat library is much more extensive combat and handling, but if you want a more simple and study of some of the basics of combat coding, this combat code of mine is one good starting point if you're new to combat coding)\r\n\r\nhttps://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22485 (pertex' cleaned-up/fixed version link/download of it)\r\n\r\nhttps://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22483 (if you don't want to download pertex' fixed/cleaned-up version of my combat code file, here's my combat code, but it's got some errors and is very bad code with lots of unnecessary stuff and/or redundant stuff in it, so be warned, it'll be tough to follow due to its mistakes/errors and lots of unnecessary/redundant code in it)\r\n\r\nhttps://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22486 (key/legend for it... I've learned to never use abrevs ever again/since, lol. Sorry about all of the abrevs in this old combat code of mine)",
      "EditableFormat": "markdown",
      "HTML": "<p>@ ScriptingIshard:</p>\n<p>if you want to just study some of the basics of combat coding/scripting, you can take a look at this old combat code I did back when I was learning this stuff for my own first time:</p>\n<p>(I used pertex' combat code as the structure for my combat coding, so the credit goes to him)</p>\n<p>(Pixie's combat library is much more extensive combat and handling, but if you want a more simple and study of some of the basics of combat coding, this combat code of mine is one good starting point if you're new to combat coding)</p>\n<p>https://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22485 (pertex' cleaned-up/fixed version link/download of it)</p>\n<p>https://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22483 (if you don't want to download pertex' fixed/cleaned-up version of my combat code file, here's my combat code, but it's got some errors and is very bad code with lots of unnecessary stuff and/or redundant stuff in it, so be warned, it'll be tough to follow due to its mistakes/errors and lots of unnecessary/redundant code in it)</p>\n<p>https://textadventures.co.uk/forum/quest/topic/3348/noobie-hks-help-me-thread#22486 (key/legend for it... I've learned to never use abrevs ever again/since, lol. Sorry about all of the abrevs in this old combat code of mine)</p>\n\n",
      "PostDate": "2018-07-14T20:11:07.5159553Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8efd662e-949e-4251-a49f-bc1d933c6c6e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "My thought for structure is that there would be a standard set of scripts, run through in order.\r\nThese scripts may be attributes of several objects:\r\n* The game\r\n* The room containing the combat (or its parent rooms)\r\n* The attacker\r\n* The weapon/attack/spell\r\n* The target\r\n* The target's armour\r\n* Any effects/spells acting on the attacker or target\r\n\r\nFor the target, the target's armour, and any spells on the target, there would be an \"-ed\" suffix. So we'd run the attacker's \"beforeattack\" script, but the target's \"beforeattacked\".\r\nAny of these scripts can modify the attack object, altering damage, elements, or success/critical flags. Scripts, in order:\r\n1. beforeattack(ed)\r\n* Attacker's scripts:\r\n   2. beforemakeattack - a 'confuse' spell that can change your target might go here\r\n   3. makeattack - There would be a default script for this one, whose purpose is to calculate damage and set attackdesc and similar variables to sane values. This is where we do the dice rolls.\r\n   4. aftermakeattack - a poison which makes you inflict half damage might be put here, to modify the already-calculated damage values\r\n5. onattack(ed)\r\n6. if the attack has multiple targets, it's cloned and the following are run once for each target. So magic armour that automatically counters a spell attacking you would have an \"onattacked\" script, while a magic shield that prevents you being hit by fireballs would have a \"beforeresolveattack\" - only the former protects your allies too.\r\n* Target's scripts (Note that changing the attack's target at this point will start over):\r\n   7. beforeresolveattack - a spell like \"protection from fire\"might have a script here\r\n   8. resolveattack - Default script applies damage to the target, and apply effects if they're still alive\r\n   9. afterresolveattack\r\n10. afterattack(ed)success / afterattack(ed)failure / afterattack(ed)crit / afterattack(ed)kill\r\n11. print the attack's message, as relevant\r\n12. afterattack(ed)\r\n\r\nI know it seems a bit overcomplex, but I think it would be useful to have in a library. Because it would rarely be necessary to make a new script re-implementing the damage calculation script, you can just add scripts to be called at various points to add all the customisation you need. It's a system designed to be as extensible as it needs to be, where almost every spell, status effect, and magical item I can think of could be added quite easily.",
      "EditableFormat": "markdown",
      "HTML": "<p>My thought for structure is that there would be a standard set of scripts, run through in order.<br>\nThese scripts may be attributes of several objects:</p>\n<ul>\n<li>The game</li>\n<li>The room containing the combat (or its parent rooms)</li>\n<li>The attacker</li>\n<li>The weapon/attack/spell</li>\n<li>The target</li>\n<li>The target's armour</li>\n<li>Any effects/spells acting on the attacker or target</li>\n</ul>\n<p>For the target, the target's armour, and any spells on the target, there would be an \"-ed\" suffix. So we'd run the attacker's \"beforeattack\" script, but the target's \"beforeattacked\".<br>\nAny of these scripts can modify the attack object, altering damage, elements, or success/critical flags. Scripts, in order:</p>\n<ol>\n<li>beforeattack(ed)</li>\n</ol>\n<ul>\n<li>Attacker's scripts:\n<ol start=\"2\">\n<li>beforemakeattack - a 'confuse' spell that can change your target might go here</li>\n<li>makeattack - There would be a default script for this one, whose purpose is to calculate damage and set attackdesc and similar variables to sane values. This is where we do the dice rolls.</li>\n<li>aftermakeattack - a poison which makes you inflict half damage might be put here, to modify the already-calculated damage values</li>\n</ol>\n</li>\n</ul>\n<ol start=\"5\">\n<li>onattack(ed)</li>\n<li>if the attack has multiple targets, it's cloned and the following are run once for each target. So magic armour that automatically counters a spell attacking you would have an \"onattacked\" script, while a magic shield that prevents you being hit by fireballs would have a \"beforeresolveattack\" - only the former protects your allies too.</li>\n</ol>\n<ul>\n<li>Target's scripts (Note that changing the attack's target at this point will start over):\n<ol start=\"7\">\n<li>beforeresolveattack - a spell like \"protection from fire\"might have a script here</li>\n<li>resolveattack - Default script applies damage to the target, and apply effects if they're still alive</li>\n<li>afterresolveattack</li>\n</ol>\n</li>\n</ul>\n<ol start=\"10\">\n<li>afterattack(ed)success / afterattack(ed)failure / afterattack(ed)crit / afterattack(ed)kill</li>\n<li>print the attack's message, as relevant</li>\n<li>afterattack(ed)</li>\n</ol>\n<p>I know it seems a bit overcomplex, but I think it would be useful to have in a library. Because it would rarely be necessary to make a new script re-implementing the damage calculation script, you can just add scripts to be called at various points to add all the customisation you need. It's a system designed to be as extensible as it needs to be, where almost every spell, status effect, and magical item I can think of could be added quite easily.</p>\n\n",
      "PostDate": "2018-07-14T22:38:53.6312547Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5899a588-d7ad-4304-8e77-fcda357a0832",
      "UserId": 28419,
      "Username": "pascal.marchese",
      "AvatarUrl": "https://i.imgur.com/qjm4RcRb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Writing functions instead of scripts could be more clear and \"clean\", but you must pay attention of every possibility in which it could be called. So keeping this in mind is important to prevent bugs. I just did what you are saying with the code last summer, trying to \"customize\" the combat library with the Warhammer Fantasy Roleplay basic rules. So I changed the scripts to functions, callable from every pc or npc object. The result was non so bad, it was a big coding (for my little \"cat\" brain) ... :-) but the result was near to what you are suggesting!\r\nSo, have a nice coding and good work! If you want any help (if you need) let me know, I will be happy to contribute!",
      "EditableFormat": "markdown",
      "HTML": "<p>Writing functions instead of scripts could be more clear and \"clean\", but you must pay attention of every possibility in which it could be called. So keeping this in mind is important to prevent bugs. I just did what you are saying with the code last summer, trying to \"customize\" the combat library with the Warhammer Fantasy Roleplay basic rules. So I changed the scripts to functions, callable from every pc or npc object. The result was non so bad, it was a big coding (for my little \"cat\" brain) ... :-) but the result was near to what you are suggesting!<br>\nSo, have a nice coding and good work! If you want any help (if you need) let me know, I will be happy to contribute!</p>\n\n",
      "PostDate": "2018-07-16T20:15:36.499913Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "23dd8532-cd5c-4cad-8fbc-442c20fef8e8",
      "UserId": 28419,
      "Username": "pascal.marchese",
      "AvatarUrl": "https://i.imgur.com/qjm4RcRb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Also, I applied the Effective Initiative during an attack (see WFRP rules). This means that a \"creature with Initiative of 40 and 2 Attacks could not strike both before a creature with Initiative 35 and 5 Attacks. Otherwise, this seems implausible. \"\r\nSee what I am referring here (WFRP, Multiple Attacks) : http://wfrp1e.wikia.com/wiki/Combat\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Also, I applied the Effective Initiative during an attack (see WFRP rules). This means that a \"creature with Initiative of 40 and 2 Attacks could not strike both before a creature with Initiative 35 and 5 Attacks. Otherwise, this seems implausible. \"<br>\nSee what I am referring here (WFRP, Multiple Attacks) : http://wfrp1e.wikia.com/wiki/Combat</p>\n\n",
      "PostDate": "2018-07-16T20:29:34.5134696Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8b21f99f-8da4-41fa-953d-a226974142fa",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I said scripts for a reason. Functions have global scope.\r\n\r\nI'm looking at a function which contains only the core mechanics. Object scripts allow the code to be encapsulated, making it more organised, more stable, and easier to maintain.\r\n\r\nA weapon that follows different damage allocation rules? A shield spell that has a percentage chance of reflecting arrows back at the attacker? A magic ring that increases your weapon damage when fighting drunk? A cursed cathedral where non-blessed weapons do half damage? A monster that only dies if hit by fire damage?\r\n\r\nAnything like that needs to be accounted for as a special case in the combat code. If you put it in a function, then you either have an incredibly complex function with an awful lot of 'if' clauses checking dozens of attributes; or you give each spell/weapon/monster a script attribute containing its special-case code.\r\n\r\nEncapsulation is good; especially if the code might be reused in a future game. Any code applying to a particular weapon/spell/monster/location *belongs* in a script attribute. That is what they're for.\r\n\r\n(yes, I could use delegates instead. But in this case there is no benefit to doing so, and I've looked into the Quest code enough that I don't trust them not to introduce bizarre scope bugs in unintuitive edge cases)",
      "EditableFormat": "markdown",
      "HTML": "<p>I said scripts for a reason. Functions have global scope.</p>\n<p>I'm looking at a function which contains only the core mechanics. Object scripts allow the code to be encapsulated, making it more organised, more stable, and easier to maintain.</p>\n<p>A weapon that follows different damage allocation rules? A shield spell that has a percentage chance of reflecting arrows back at the attacker? A magic ring that increases your weapon damage when fighting drunk? A cursed cathedral where non-blessed weapons do half damage? A monster that only dies if hit by fire damage?</p>\n<p>Anything like that needs to be accounted for as a special case in the combat code. If you put it in a function, then you either have an incredibly complex function with an awful lot of 'if' clauses checking dozens of attributes; or you give each spell/weapon/monster a script attribute containing its special-case code.</p>\n<p>Encapsulation is good; especially if the code might be reused in a future game. Any code applying to a particular weapon/spell/monster/location <em>belongs</em> in a script attribute. That is what they're for.</p>\n<p>(yes, I could use delegates instead. But in this case there is no benefit to doing so, and I've looked into the Quest code enough that I don't trust them not to introduce bizarre scope bugs in unintuitive edge cases)</p>\n\n",
      "PostDate": "2018-07-16T20:58:48.511182Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9b6417cd-a139-42d8-8a6e-8d2a36466921",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Looking at this again, I thought I might try to make some actual code.\r\nI'm making a game now, just so I've got something to focus my efforts on in between writing prose. But figure I'll post the code here as well, so if you can see any problems with it, please let me know.\r\n\r\n(edited for silly error. Still needs a lot of work)\r\n\r\n<details>\r\n<summary>Old version of the code, preserved for the curious</summary>\r\n\r\n```\r\n<function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\">\r\n  object_name = \"current_attack\"\r\n  while (not GetObject(object_name) = null) {\r\n    object_name = object_name + \"_\"\r\n  }\r\n  create (object_name)\r\n  attack = GetObject (object_name)\r\n\r\n  if (attacker = null) attacker = game\r\n  if (weapon = null) weapon = attacker\r\n  if (spell = null) spell = weapon\r\n  attack.attacker = attacker\r\n  attack.weapon = weapon\r\n  attack.spell = spell\r\n  attack.valid = true\r\n  if (target = null) {\r\n    target = GetValidTargets (attack)\r\n    if (not GetBoolean (spell, \"attack_multiple\")) target = PickOneObject (target)\r\n  }\r\n  attack.target = target\r\n  attack.filters_attacker = NewObjectList()\r\n  if (not (spell = weapon or spell = attacker)) {\r\n    attack.filters_attacker = GetEffects (spell)\r\n  }\r\n  if (not weapon = attacker) {\r\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (weapon))\r\n  }\r\n  attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (attacker))\r\n  foreach (room, ListParents (attacker)) {\r\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (room))\r\n  }\r\n  list add (attack.filters_attacker, game)\r\n  list add (attack.filters_attacker, attack)\r\n  attack.filters_target = GetEffects (target)\r\n  foreach (room, ListParents (target)) {\r\n    attack.filters_target = ListCombine (attack.filters_target, GetEffects (room))\r\n  }\r\n  list add (attack.filters_target, game)\r\n  list add (attack.filters_target, attack)\r\n  params = QuickParams (\"attack\", attack)\r\n  foreach (obj, attack.filters_attacker) {\r\n    if (HasScript (obj, \"beforeattack\")) {\r\n      do (obj, \"beforeattack\", params)\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"beforeattacked\")) {\r\n        do (obj, \"beforeattacked\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_attacker) {\r\n      if (HasScript (obj, \"beforemakeattack\")) {\r\n        do (obj, \"beforemakeattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    done = false\r\n    foreach (obj, attack.filters_attacker) {\r\n      if (HasScript (obj, \"makeattack\")) {\r\n        do (obj, \"makeattack\", params)\r\n        done = true\r\n      }\r\n    }\r\n    if (not done) {\r\n      attack.attackroll = GetRandomInt(1, 12)\r\n      attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\r\n      if (HasString (spell, \"damageroll\")) {\r\n        attack.damage = eval (spell.damageroll, params)\r\n      }\r\n      if (HasInt (spell, \"damage\")) {\r\n        attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_attacker) {\r\n      if (HasScript (obj, \"aftermakeattack\")) {\r\n        do (obj, \"aftermakeattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_attacker) {\r\n      if (HasScript (obj, \"onattack\")) {\r\n        do (obj, \"onattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"onattacked\")) {\r\n        do (obj, \"onattacked\", params)\r\n      }\r\n    }\r\n  }\r\n  // code for splitting target lists should go here.\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"beforeresolveattack\")) {\r\n        do (obj, \"beforeresolveattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    done = false\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"resolveattack\")) {\r\n        do (obj, \"resolveattack\", params)\r\n        done = true\r\n      }\r\n    }\r\n    if (not done) {\r\n      attack.dodgeroll = GetRandomInt (1, 12)\r\n      attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") > attack.dodgeroll + GetInt (target, \"agility\"))\r\n      if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\r\n      if (attack.hit and attack.damage > 0) {\r\n        target.health = target.health - attack.damage\r\n        list add (attack.status, \"hit\")\r\n        if (target.health < 0) {\r\n          list add (attack.status, \"kill\")\r\n        }\r\n      }\r\n      else {\r\n        attack.damage = 0\r\n        list add (attack.status, \"miss\")\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"afterresolveattack\")) {\r\n        do (obj, \"afterresolveattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_attacker) {\r\n      foreach (status, attack.status) {\r\n        if (HasScript (obj, \"afterattack\"+status)) {\r\n          do (obj, \"afterattack\"+status, params)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      foreach (status, attack.status) {\r\n        if (HasScript (obj, \"afterattacked\"+status)) {\r\n          do (obj, \"afterattacked\"+status, params)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid and HasString (attack, \"message\")) {\r\n    if (ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target) or target = game.pov or attacker = game.pov) {\r\n      message = attack.message\r\n      game.text_processor_variables = GetAttackParams (attack)\r\n      while (not message = null) {\r\n        newmessage = ProcessText (message)\r\n        if (message = newmessage) {\r\n          msg (message)\r\n          message = null\r\n        }\r\n        else {\r\n          message = newmessage\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_attacker) {\r\n      if (HasScript (obj, \"afterattack\")) {\r\n        do (obj, \"afterattack\", params)\r\n      }\r\n    }\r\n  }\r\n  if (attack.valid) {\r\n    foreach (obj, attack.filters_target) {\r\n      if (HasScript (obj, \"afterattacked\")) {\r\n        do (obj, \"afterattacked\", params)\r\n      }\r\n    }\r\n  }\r\n  destroy (attack.name)\r\n</function>\r\n\r\n<function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\">\r\n  result = NewDictionary()\r\n  foreach (attr, GetAttributeNames (attack, true)) {\r\n    dictionary add (result, attr, GetAttribute (attack, attr))\r\n  }\r\n  if (not DictionaryContains (result, \"attack\")) {\r\n    dictionary add (result, \"attack\", attack)\r\n  }\r\n  return (result)\r\n</function>\r\n```\r\n</details>\r\nJust a first version off the top of my head",
      "EditableFormat": "markdown",
      "HTML": "<p>Looking at this again, I thought I might try to make some actual code.<br>\nI'm making a game now, just so I've got something to focus my efforts on in between writing prose. But figure I'll post the code here as well, so if you can see any problems with it, please let me know.</p>\n<p>(edited for silly error. Still needs a lot of work)</p>\n<details>\n<summary>Old version of the code, preserved for the curious</summary>\n<pre><code>&lt;function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\"&gt;\n  object_name = \"current_attack\"\n  while (not GetObject(object_name) = null) {\n    object_name = object_name + \"_\"\n  }\n  create (object_name)\n  attack = GetObject (object_name)\n\n  if (attacker = null) attacker = game\n  if (weapon = null) weapon = attacker\n  if (spell = null) spell = weapon\n  attack.attacker = attacker\n  attack.weapon = weapon\n  attack.spell = spell\n  attack.valid = true\n  if (target = null) {\n    target = GetValidTargets (attack)\n    if (not GetBoolean (spell, \"attack_multiple\")) target = PickOneObject (target)\n  }\n  attack.target = target\n  attack.filters_attacker = NewObjectList()\n  if (not (spell = weapon or spell = attacker)) {\n    attack.filters_attacker = GetEffects (spell)\n  }\n  if (not weapon = attacker) {\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (weapon))\n  }\n  attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (attacker))\n  foreach (room, ListParents (attacker)) {\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (room))\n  }\n  list add (attack.filters_attacker, game)\n  list add (attack.filters_attacker, attack)\n  attack.filters_target = GetEffects (target)\n  foreach (room, ListParents (target)) {\n    attack.filters_target = ListCombine (attack.filters_target, GetEffects (room))\n  }\n  list add (attack.filters_target, game)\n  list add (attack.filters_target, attack)\n  params = QuickParams (\"attack\", attack)\n  foreach (obj, attack.filters_attacker) {\n    if (HasScript (obj, \"beforeattack\")) {\n      do (obj, \"beforeattack\", params)\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"beforeattacked\")) {\n        do (obj, \"beforeattacked\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_attacker) {\n      if (HasScript (obj, \"beforemakeattack\")) {\n        do (obj, \"beforemakeattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    done = false\n    foreach (obj, attack.filters_attacker) {\n      if (HasScript (obj, \"makeattack\")) {\n        do (obj, \"makeattack\", params)\n        done = true\n      }\n    }\n    if (not done) {\n      attack.attackroll = GetRandomInt(1, 12)\n      attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\n      if (HasString (spell, \"damageroll\")) {\n        attack.damage = eval (spell.damageroll, params)\n      }\n      if (HasInt (spell, \"damage\")) {\n        attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_attacker) {\n      if (HasScript (obj, \"aftermakeattack\")) {\n        do (obj, \"aftermakeattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_attacker) {\n      if (HasScript (obj, \"onattack\")) {\n        do (obj, \"onattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"onattacked\")) {\n        do (obj, \"onattacked\", params)\n      }\n    }\n  }\n  // code for splitting target lists should go here.\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"beforeresolveattack\")) {\n        do (obj, \"beforeresolveattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    done = false\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"resolveattack\")) {\n        do (obj, \"resolveattack\", params)\n        done = true\n      }\n    }\n    if (not done) {\n      attack.dodgeroll = GetRandomInt (1, 12)\n      attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") &gt; attack.dodgeroll + GetInt (target, \"agility\"))\n      if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\n      if (attack.hit and attack.damage &gt; 0) {\n        target.health = target.health - attack.damage\n        list add (attack.status, \"hit\")\n        if (target.health &lt; 0) {\n          list add (attack.status, \"kill\")\n        }\n      }\n      else {\n        attack.damage = 0\n        list add (attack.status, \"miss\")\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"afterresolveattack\")) {\n        do (obj, \"afterresolveattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_attacker) {\n      foreach (status, attack.status) {\n        if (HasScript (obj, \"afterattack\"+status)) {\n          do (obj, \"afterattack\"+status, params)\n        }\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      foreach (status, attack.status) {\n        if (HasScript (obj, \"afterattacked\"+status)) {\n          do (obj, \"afterattacked\"+status, params)\n        }\n      }\n    }\n  }\n  if (attack.valid and HasString (attack, \"message\")) {\n    if (ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target) or target = game.pov or attacker = game.pov) {\n      message = attack.message\n      game.text_processor_variables = GetAttackParams (attack)\n      while (not message = null) {\n        newmessage = ProcessText (message)\n        if (message = newmessage) {\n          msg (message)\n          message = null\n        }\n        else {\n          message = newmessage\n        }\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_attacker) {\n      if (HasScript (obj, \"afterattack\")) {\n        do (obj, \"afterattack\", params)\n      }\n    }\n  }\n  if (attack.valid) {\n    foreach (obj, attack.filters_target) {\n      if (HasScript (obj, \"afterattacked\")) {\n        do (obj, \"afterattacked\", params)\n      }\n    }\n  }\n  destroy (attack.name)\n&lt;/function&gt;\n\n&lt;function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\"&gt;\n  result = NewDictionary()\n  foreach (attr, GetAttributeNames (attack, true)) {\n    dictionary add (result, attr, GetAttribute (attack, attr))\n  }\n  if (not DictionaryContains (result, \"attack\")) {\n    dictionary add (result, \"attack\", attack)\n  }\n  return (result)\n&lt;/function&gt;\n</code></pre>\n</details>\nJust a first version off the top of my head\n\n",
      "PostDate": "2018-08-30T16:25:56.1065244Z",
      "LastEditDate": "2018-09-01T08:22:58.0483231Z",
      "link": null
    },
    {
      "PostId": "be34669a-d3c8-4f73-a2d8-c51503cb6850",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(I'm thinking that the game I'm building with this will be mostly a procedural dungeon crawl, spawning random monsters. I just want to play with the systems, rather than coming up with a story that ends up being excessively convoluted. So I'm going to give the player a couple of classes to choose from, each with their own set of abilities, and see how many floors you can get down. As currently planned, the classes will include: Pimp, Philatelist, Edgelord, Janitor/Janitrix, Goth, and Barista)\r\n\r\n(At some point in the future, there might be plot involved. But it would be in the form of static dungeon segments, whether rooms or whole areas, which can be spliced into the randomly-generated part in any convenient place.)",
      "EditableFormat": "markdown",
      "HTML": "<p>(I'm thinking that the game I'm building with this will be mostly a procedural dungeon crawl, spawning random monsters. I just want to play with the systems, rather than coming up with a story that ends up being excessively convoluted. So I'm going to give the player a couple of classes to choose from, each with their own set of abilities, and see how many floors you can get down. As currently planned, the classes will include: Pimp, Philatelist, Edgelord, Janitor/Janitrix, Goth, and Barista)</p>\n<p>(At some point in the future, there might be plot involved. But it would be in the form of static dungeon segments, whether rooms or whole areas, which can be spliced into the randomly-generated part in any convenient place.)</p>\n\n",
      "PostDate": "2018-08-31T12:07:45.5621718Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "cf5533e7-2158-4af5-b491-24659f56d4c3",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "There seems to be an awful lot of copy-pasted code in the part above. I can do this better.\r\n\r\nEDIT: I realised there's some things I'm missing.\r\n<details>\r\n<summary>Old version of the code, preserved for the curious</summary>\r\n\r\n```\r\n<function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\">\r\n  if (Equal (attacker, \"RESUME\")) {\r\n    attacks = weapon\r\n  }\r\n  else {\r\n    object_name = \"current_attack\"\r\n    while (not GetObject(object_name) = null) {\r\n      object_name = object_name + \"_\"\r\n    }\r\n    create (object_name)\r\n    attack = GetObject (object_name)\r\n    attack.is_attack = true\r\n\r\n    if (attacker = null) attacker = game\r\n    if (weapon = null) {\r\n      if (HasObject (attacker, \"weapon\")) {\r\n        weapon = attacker.weapon\r\n      }\r\n      else {\r\n        weapon = attacker\r\n      }\r\n    }\r\n    if (spell = null) spell = weapon\r\n    attack.attacker = attacker\r\n    attack.weapon = weapon\r\n    attack.spell = spell\r\n    if (target = null) {\r\n      target = GetValidTargets (attack)\r\n      if (not GetBoolean (spell, \"attack_multiple\")) target = PickOneObject (target)\r\n    }\r\n    attack.target = target\r\n    attack.filters_attacker = NewObjectList()\r\n    if (not (spell = weapon or spell = attacker)) {\r\n      attack.filters_attacker = GetEffects (spell)\r\n    }\r\n    if (not weapon = attacker) {\r\n      attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (weapon))\r\n    }\r\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (attacker))\r\n    foreach (room, ListParents (attacker)) {\r\n      attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (room))\r\n    }\r\n    list add (attack.filters_attacker, game)\r\n    list add (attack.filters_attacker, attack)\r\n    attack.filters_target = GetEffects (target)\r\n    foreach (room, ListParents (target)) {\r\n      attack.filters_target = ListCombine (attack.filters_target, GetEffects (room))\r\n    }\r\n    list add (attack.filters_target, game)\r\n    list add (attack.filters_target, attack)\r\n    attacks = NewObjectList()\r\n    list add (attacks, attack)\r\n  }\r\n\r\n  DoAttackPhase (false, attacks, true, true, \"beforeattack\")\r\n  DoAttackPhase (false, attacks, true, false, \"beforemakeattack\")\r\n  DoAttackPhase (false, attacks, true, false, \"makeattack\") {\r\n    attack.attackroll = GetRandomInt(1, 12)\r\n    attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\r\n    if (HasString (spell, \"damageroll\")) {\r\n      attack.damage = eval (spell.damageroll, params)\r\n    }\r\n    if (HasInt (spell, \"damage\")) {\r\n      attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\r\n    }\r\n  }\r\n  DoAttackPhase (false, attacks, true, false, \"aftermakeattack\")\r\n  DoAttackPhase (false, attacks, true, true, \"onattack\")\r\n  DoAttackPhase (false, attacks, true, true, \"splitattack\") {\r\n    i = 0\r\n    while (i < ListCount (attacks)) {\r\n      attack = ListItem (attacks, i)\r\n      if (not HasAttribute (attack, \"target\")) {\r\n        list remove (attacks, attack)\r\n      }\r\n      else if (EndsWith (TypeOf (attack, \"target\"), \"list\")) {\r\n        foreach (target, attack.target) {\r\n          newattack = Clone (attack)\r\n          newattack.target = target\r\n          list add (attacks, newattack)\r\n        }\r\n        list remove (attacks, attack)\r\n      }\r\n      else {\r\n        i = i + 1\r\n      }\r\n    }\r\n  }\r\n  DoAttackPhase (false, attacks, false, true, \"beforeresolveattack\")\r\n  DoAttackPhase (false, attacks, false, true, \"resolveattack\") {\r\n    attack.dodgeroll = GetRandomInt (1, 12)\r\n    attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") > attack.dodgeroll + GetInt (target, \"agility\"))\r\n    if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\r\n      if (attack.hit and attack.damage > 0) {\r\n        target.health = target.health - attack.damage\r\n        list add (attack.status, \"hit\")\r\n        if (target.health < 0) {\r\n          list add (attack.status, \"kill\")\r\n        }\r\n      }\r\n      else {\r\n        attack.damage = 0\r\n        list add (attack.status, \"miss\")\r\n      }\r\n    }\r\n  }\r\n  DoAttackPhase (false, attacks, false, true, \"afterresolveattack\")\r\n  bystatus = NewDictionary()\r\n  foreach (attack, attacks) {\r\n    if (HasAttribute (attack, \"status\")) {\r\n      foreach (status, attack.status) {\r\n        if (not DictionaryContains (bystatus, status)) {\r\n          dictionary add (bystatus, status, NewObjectList())\r\n        }\r\n        list add (DictionaryItem (bystatus, status), attack)\r\n      }\r\n    }\r\n  }\r\n  foreach (status, bystatus) {\r\n    DoAttackPhase (false, DictionaryItem (bystatus, status), true, false, \"afterattack\"+status)\r\n    DoAttackPhase (false, DictionaryItem (bystatus, status), false, true, \"afterattacked\"+status)\r\n  }\r\n  if (ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target) or target = game.pov or attacker = game.pov) {\r\n    DoAttackPhase (true, attacks, true, true, \"showattackmessage\") {\r\n      if (HasString (attack, \"message\")) {\r\n        message = attack.message\r\n        game.text_processor_variables = GetAttackParams (attack)\r\n        while (not message = null) {\r\n          newmessage = ProcessText (message)\r\n          if (message = newmessage) {\r\n            msg (message)\r\n            message = null\r\n          }\r\n          else {\r\n            message = newmessage\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DoAttackPhase (false, attacks, true, true, \"afterattack\")\r\n  foreach (att, attacks) {\r\n    destroy (att.name)\r\n  }\r\n</function>\r\n\r\n<turnscript name=\"deferred_attacks\">\r\n  <enabled />\r\n  <script><![CDATA[\r\n  resume = NewObjectList()\r\n  foreach (attack, FilterByAttribute(AllObjects(), \"is_attack\", true)) {\r\n    switch (TypeOf (attack, \"deferred\")) {\r\n      case (\"int\") {\r\n        attack.deferred = attack.deferred - 1\r\n        if (attack.deferred < 0) {\r\n          attack.deferred = null\r\n        }\r\n      }\r\n      case (\"string\") {\r\n        if (Equal (true, eval (attack.deferred, MakeAttackParams(attack)))) {\r\n          attack.deferred = null\r\n        }\r\n      }\r\n      case (\"script\") {\r\n        do (attack, \"deferred\")\r\n      }\r\n    }\r\n    if (not HasAttribute (attack, \"deferred\")) {\r\n      list add (resume, attack)\r\n    }\r\n  }\r\n  if (ListCount (resume) > 0) {\r\n    DoAttack (\"RESUME\", resume)\r\n  }\r\n  ]]></script>\r\n</turnscript>\r\n\r\n<function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\">\r\n  result = NewDictionary()\r\n  foreach (attr, GetAttributeNames (attack, true)) {\r\n    dictionary add (result, attr, GetAttribute (attack, attr))\r\n  }\r\n  if (not DictionaryContains (result, \"attack\")) {\r\n    dictionary add (result, \"attack\", attack)\r\n  }\r\n  return (result)\r\n</function>\r\n\r\n<function name=\"DoAttackPhase\" parameters=\"singleton, attacks, for_attacker, for_target, phase, default\">\r\n  newattacks = NewObjectList()\r\n  foreach (attack, attacks) {\r\n    if (not HasAttribute (attack, \"phases_complete\")) attack.phases_complete = NewStringList()\r\n    done = false\r\n    if (ListContains (attack.phases_complete, phase)) {\r\n      done = true\r\n    }\r\n    else {\r\n      list add (attack.phases_complete, phase)\r\n      if (for_attacker) {\r\n        foreach (obj, attack.filters_attacker) {\r\n          if (HasScript (obj, phase) and (not done or not singleton)) {\r\n            do (obj, phase, MakeAttackParams (attack))\r\n            done = true\r\n          }\r\n        }\r\n      }\r\n      if (for_attacker and for_target) {\r\n        phase = phase + \"ed\"\r\n      }\r\n      if (for_target) {\r\n        foreach (obj, attack.filters_target) {\r\n          if (HasScript (obj, phase) and (not done or not singleton)) {\r\n            do (obj, phase, MakeAttackParams (attack))\r\n            done = true\r\n          }\r\n        }\r\n      }\r\n      if (IsDefined (\"default\") and not done) {\r\n        if (TypeOf (default) = \"script\") {\r\n          invoke (default, MakeAttackParams (attack)\r\n        }\r\n        done = true\r\n      }\r\n    }\r\n    if (HasObject (attack, \"replacement\")) {\r\n      list add (newattacks, attack.replacement)\r\n    } else if (HasAttribute (attack, \"replacement\")) {\r\n      newattacks = ListCombine (newattacks, attack.replacement)\r\n    } else if (not GetBoolean (attack, \"negated\") and not HasInt (attack, \"deferred\")) {\r\n      list add (newattacks, attack)\r\n    }\r\n  }\r\n  while (ListCount (attacks) > 0) {\r\n    list remove (attacks, ListItem (attacks, 0))\r\n  }\r\n  foreach (attack, newattacks) {\r\n    list add (attacks, newattacks)\r\n  }\r\n</function>\r\n\r\n<function name=\"GetEffects\" type=\"objectlist\" parameters=\"items\">\r\n  result = NewObjectList()\r\n  if (not EndsWith (TypeOf (items), \"list\")) {\r\n    item = items\r\n    items = NewObjectList()\r\n    list add (items, item)\r\n  }\r\n  foreach (item, items) {\r\n    list add (result, item)\r\n    foreach (effect, FilterByAttribute (GetDirectChildren(item), \"status_effect\", true)) {\r\n      list add (result, effect)\r\n    }\r\n    foreach (garment, GetWornFor (item)) {\r\n      foreach (effect, FilterByAttribute (GetDirectChildren (garment), \"status_effect\", true)) {\r\n        list add (result, effect)\r\n      }\r\n    }\r\n  }\r\n  return (result)\r\n</function>\r\n```\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>There seems to be an awful lot of copy-pasted code in the part above. I can do this better.</p>\n<p>EDIT: I realised there's some things I'm missing.</p>\n<details>\n<summary>Old version of the code, preserved for the curious</summary>\n<pre><code>&lt;function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\"&gt;\n  if (Equal (attacker, \"RESUME\")) {\n    attacks = weapon\n  }\n  else {\n    object_name = \"current_attack\"\n    while (not GetObject(object_name) = null) {\n      object_name = object_name + \"_\"\n    }\n    create (object_name)\n    attack = GetObject (object_name)\n    attack.is_attack = true\n\n    if (attacker = null) attacker = game\n    if (weapon = null) {\n      if (HasObject (attacker, \"weapon\")) {\n        weapon = attacker.weapon\n      }\n      else {\n        weapon = attacker\n      }\n    }\n    if (spell = null) spell = weapon\n    attack.attacker = attacker\n    attack.weapon = weapon\n    attack.spell = spell\n    if (target = null) {\n      target = GetValidTargets (attack)\n      if (not GetBoolean (spell, \"attack_multiple\")) target = PickOneObject (target)\n    }\n    attack.target = target\n    attack.filters_attacker = NewObjectList()\n    if (not (spell = weapon or spell = attacker)) {\n      attack.filters_attacker = GetEffects (spell)\n    }\n    if (not weapon = attacker) {\n      attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (weapon))\n    }\n    attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (attacker))\n    foreach (room, ListParents (attacker)) {\n      attack.filters_attacker = ListCombine (attack.filters_attacker, GetEffects (room))\n    }\n    list add (attack.filters_attacker, game)\n    list add (attack.filters_attacker, attack)\n    attack.filters_target = GetEffects (target)\n    foreach (room, ListParents (target)) {\n      attack.filters_target = ListCombine (attack.filters_target, GetEffects (room))\n    }\n    list add (attack.filters_target, game)\n    list add (attack.filters_target, attack)\n    attacks = NewObjectList()\n    list add (attacks, attack)\n  }\n\n  DoAttackPhase (false, attacks, true, true, \"beforeattack\")\n  DoAttackPhase (false, attacks, true, false, \"beforemakeattack\")\n  DoAttackPhase (false, attacks, true, false, \"makeattack\") {\n    attack.attackroll = GetRandomInt(1, 12)\n    attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\n    if (HasString (spell, \"damageroll\")) {\n      attack.damage = eval (spell.damageroll, params)\n    }\n    if (HasInt (spell, \"damage\")) {\n      attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\n    }\n  }\n  DoAttackPhase (false, attacks, true, false, \"aftermakeattack\")\n  DoAttackPhase (false, attacks, true, true, \"onattack\")\n  DoAttackPhase (false, attacks, true, true, \"splitattack\") {\n    i = 0\n    while (i &lt; ListCount (attacks)) {\n      attack = ListItem (attacks, i)\n      if (not HasAttribute (attack, \"target\")) {\n        list remove (attacks, attack)\n      }\n      else if (EndsWith (TypeOf (attack, \"target\"), \"list\")) {\n        foreach (target, attack.target) {\n          newattack = Clone (attack)\n          newattack.target = target\n          list add (attacks, newattack)\n        }\n        list remove (attacks, attack)\n      }\n      else {\n        i = i + 1\n      }\n    }\n  }\n  DoAttackPhase (false, attacks, false, true, \"beforeresolveattack\")\n  DoAttackPhase (false, attacks, false, true, \"resolveattack\") {\n    attack.dodgeroll = GetRandomInt (1, 12)\n    attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") &gt; attack.dodgeroll + GetInt (target, \"agility\"))\n    if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\n      if (attack.hit and attack.damage &gt; 0) {\n        target.health = target.health - attack.damage\n        list add (attack.status, \"hit\")\n        if (target.health &lt; 0) {\n          list add (attack.status, \"kill\")\n        }\n      }\n      else {\n        attack.damage = 0\n        list add (attack.status, \"miss\")\n      }\n    }\n  }\n  DoAttackPhase (false, attacks, false, true, \"afterresolveattack\")\n  bystatus = NewDictionary()\n  foreach (attack, attacks) {\n    if (HasAttribute (attack, \"status\")) {\n      foreach (status, attack.status) {\n        if (not DictionaryContains (bystatus, status)) {\n          dictionary add (bystatus, status, NewObjectList())\n        }\n        list add (DictionaryItem (bystatus, status), attack)\n      }\n    }\n  }\n  foreach (status, bystatus) {\n    DoAttackPhase (false, DictionaryItem (bystatus, status), true, false, \"afterattack\"+status)\n    DoAttackPhase (false, DictionaryItem (bystatus, status), false, true, \"afterattacked\"+status)\n  }\n  if (ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target) or target = game.pov or attacker = game.pov) {\n    DoAttackPhase (true, attacks, true, true, \"showattackmessage\") {\n      if (HasString (attack, \"message\")) {\n        message = attack.message\n        game.text_processor_variables = GetAttackParams (attack)\n        while (not message = null) {\n          newmessage = ProcessText (message)\n          if (message = newmessage) {\n            msg (message)\n            message = null\n          }\n          else {\n            message = newmessage\n          }\n        }\n      }\n    }\n  }\n  DoAttackPhase (false, attacks, true, true, \"afterattack\")\n  foreach (att, attacks) {\n    destroy (att.name)\n  }\n&lt;/function&gt;\n\n&lt;turnscript name=\"deferred_attacks\"&gt;\n  &lt;enabled /&gt;\n  &lt;script&gt;&lt;![CDATA[\n  resume = NewObjectList()\n  foreach (attack, FilterByAttribute(AllObjects(), \"is_attack\", true)) {\n    switch (TypeOf (attack, \"deferred\")) {\n      case (\"int\") {\n        attack.deferred = attack.deferred - 1\n        if (attack.deferred &lt; 0) {\n          attack.deferred = null\n        }\n      }\n      case (\"string\") {\n        if (Equal (true, eval (attack.deferred, MakeAttackParams(attack)))) {\n          attack.deferred = null\n        }\n      }\n      case (\"script\") {\n        do (attack, \"deferred\")\n      }\n    }\n    if (not HasAttribute (attack, \"deferred\")) {\n      list add (resume, attack)\n    }\n  }\n  if (ListCount (resume) &gt; 0) {\n    DoAttack (\"RESUME\", resume)\n  }\n  ]]&gt;&lt;/script&gt;\n&lt;/turnscript&gt;\n\n&lt;function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\"&gt;\n  result = NewDictionary()\n  foreach (attr, GetAttributeNames (attack, true)) {\n    dictionary add (result, attr, GetAttribute (attack, attr))\n  }\n  if (not DictionaryContains (result, \"attack\")) {\n    dictionary add (result, \"attack\", attack)\n  }\n  return (result)\n&lt;/function&gt;\n\n&lt;function name=\"DoAttackPhase\" parameters=\"singleton, attacks, for_attacker, for_target, phase, default\"&gt;\n  newattacks = NewObjectList()\n  foreach (attack, attacks) {\n    if (not HasAttribute (attack, \"phases_complete\")) attack.phases_complete = NewStringList()\n    done = false\n    if (ListContains (attack.phases_complete, phase)) {\n      done = true\n    }\n    else {\n      list add (attack.phases_complete, phase)\n      if (for_attacker) {\n        foreach (obj, attack.filters_attacker) {\n          if (HasScript (obj, phase) and (not done or not singleton)) {\n            do (obj, phase, MakeAttackParams (attack))\n            done = true\n          }\n        }\n      }\n      if (for_attacker and for_target) {\n        phase = phase + \"ed\"\n      }\n      if (for_target) {\n        foreach (obj, attack.filters_target) {\n          if (HasScript (obj, phase) and (not done or not singleton)) {\n            do (obj, phase, MakeAttackParams (attack))\n            done = true\n          }\n        }\n      }\n      if (IsDefined (\"default\") and not done) {\n        if (TypeOf (default) = \"script\") {\n          invoke (default, MakeAttackParams (attack)\n        }\n        done = true\n      }\n    }\n    if (HasObject (attack, \"replacement\")) {\n      list add (newattacks, attack.replacement)\n    } else if (HasAttribute (attack, \"replacement\")) {\n      newattacks = ListCombine (newattacks, attack.replacement)\n    } else if (not GetBoolean (attack, \"negated\") and not HasInt (attack, \"deferred\")) {\n      list add (newattacks, attack)\n    }\n  }\n  while (ListCount (attacks) &gt; 0) {\n    list remove (attacks, ListItem (attacks, 0))\n  }\n  foreach (attack, newattacks) {\n    list add (attacks, newattacks)\n  }\n&lt;/function&gt;\n\n&lt;function name=\"GetEffects\" type=\"objectlist\" parameters=\"items\"&gt;\n  result = NewObjectList()\n  if (not EndsWith (TypeOf (items), \"list\")) {\n    item = items\n    items = NewObjectList()\n    list add (items, item)\n  }\n  foreach (item, items) {\n    list add (result, item)\n    foreach (effect, FilterByAttribute (GetDirectChildren(item), \"status_effect\", true)) {\n      list add (result, effect)\n    }\n    foreach (garment, GetWornFor (item)) {\n      foreach (effect, FilterByAttribute (GetDirectChildren (garment), \"status_effect\", true)) {\n        list add (result, effect)\n      }\n    }\n  }\n  return (result)\n&lt;/function&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-08-31T13:06:33.7128788Z",
      "LastEditDate": "2018-09-01T08:23:50.8196046Z",
      "link": null
    },
    {
      "PostId": "375b0858-28e0-4919-a787-4e01093bedcb",
      "UserId": 373044,
      "Username": "LeftUnscarred",
      "AvatarUrl": "https://secure.gravatar.com/avatar/be5745cce4b8baf9a92118efdb619450?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "i couldnt even get combatkib to work anyone have an idea to tell me how to get it to work it says it loads and i followed the instructions from the site but i cant see the 3 new tabs it describes\r\n\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>i couldnt even get combatkib to work anyone have an idea to tell me how to get it to work it says it loads and i followed the instructions from the site but i cant see the 3 new tabs it describes</p>\n\n",
      "PostDate": "2018-08-31T18:18:54.3484603Z",
      "LastEditDate": "2018-08-31T18:24:46.249034Z",
      "link": null
    },
    {
      "PostId": "957ddcd5-eb07-4570-a298-2cfacad876ce",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@LeftUnscarred\r\nNot sure this is the best post to reply to. I started out thinking about the way CombatLib is implemented, but then changed to working out how I'd make a more versatile CombatLib.\r\n\r\n(My version shouldn't require modification - the functions are horrendously complex, but it allows you to do everything I've ever seen in an RPG battle system without changing them, so the user doesn't need to understand how they work internally)\r\n\r\nI might change the name to RPGLib or something like that. But changing the thread title would mess with the script I'm using to measure how much time I spend on various projects.\r\n\r\n\r\nAs far as your problems with CombatLib go, I'm afraid you'd have to ask someone who's using the desktop version of Quest.",
      "EditableFormat": "markdown",
      "HTML": "<p>@LeftUnscarred<br>\nNot sure this is the best post to reply to. I started out thinking about the way CombatLib is implemented, but then changed to working out how I'd make a more versatile CombatLib.</p>\n<p>(My version shouldn't require modification - the functions are horrendously complex, but it allows you to do everything I've ever seen in an RPG battle system without changing them, so the user doesn't need to understand how they work internally)</p>\n<p>I might change the name to RPGLib or something like that. But changing the thread title would mess with the script I'm using to measure how much time I spend on various projects.</p>\n<p>As far as your problems with CombatLib go, I'm afraid you'd have to ask someone who's using the desktop version of Quest.</p>\n\n",
      "PostDate": "2018-08-31T20:02:41.5083026Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "6e6b010d-1119-4058-86ea-1fc21f558533",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK… there's some horrible bits in here.\r\n\r\nThe whole section from `object_name = \"current_attack\"` down to `list add (attacks, attack)` needs a rewrite.\r\n\r\n<details><summary>Working on the code</summary>\r\n\r\nHere's a thought:\r\n```\r\n    object_name = \"current_attack\"\r\n    while (not GetObject(object_name) = null) {\r\n      object_name = object_name + \"_\"\r\n    }\r\n    create (object_name)\r\n    attack = GetObject (object_name)\r\n    attack.is_attack = true\r\n\r\n    attack.generate_filters => {\r\n      att = NewObjectList()\r\n      list add (att, this)\r\n      if (HasAttribute (this, \"spell\") and not (Equal(this.spell, this.weapon) or Equal(this.spell, this.attacker))) {\r\n        att = ListCombine (att, GetEffects (this.spell))\r\n      }\r\n      if (HasAttribute (this, \"weapon\") and not Equal(this.weapon, this.attacker)) {\r\n        att = ListCombine (att, GetEffects (this.weapon))\r\n      }\r\n      if (HasAttribute (this, \"attacker\")) {\r\n        att = ListCombine (att, GetEffects (this.attacker))\r\n        foreach (room, ListAllParents (this.attacker)) {\r\n          att = ListCombine (att, GetEffects (room))\r\n        }\r\n      }\r\n      list add (att, game)\r\n      this.filters_attacker = att\r\n  \r\n      def = NewObjectList()\r\n      list add (def, this)\r\n      if (HasAttribute (this, \"target\")) {\r\n        def = ListCombine (def, GetEffects (this.target))\r\n        foreach (room, ListAllParents (this.target)) {\r\n          def = ListCombine (def, GetEffects (room))\r\n        }\r\n      }\r\n      list add (def, game)\r\n      attack.filters_target = def\r\n    }\r\n    if (IsDefined (\"attacker\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"weapon\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"spell\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"target\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    attacks = NewObjectList()\r\n    list add (attacks, attack)\r\n```\r\nThen we have the function to generate the status-effect lists all in one place. So we can do that script attribute any time the spell's target changes, or something like that.\r\n\r\nTo the `DoAttackPhase` function, immediately after `      list add (attack.phases_complete, phase)` we add:\r\n```\r\n      do (attack, \"generate_filters\")\r\n```\r\n\r\nIn this script I've also used a function `ListAllParents` which should work as:\r\n```\r\n<function name=\"ListAllParents\" type=\"objectlist\" parameters=\"list\"><![CDATA[\r\n  if (TypeOf (list) = \"object\") {\r\n    return (ListParents (object))\r\n  }\r\n  result = NewObjectList()\r\n  i = 0\r\n  while (i < ListCount (list)) {\r\n    item = ListItem (list, i)\r\n    if (HasObject (item, \"parent\")) {\r\n      if (not ListContains (result, item.parent)) {\r\n        list add (list, item.parent)\r\n        list add (result, item.parent)\r\n      }\r\n    }\r\n    i = i + 1\r\n  }\r\n  return (result)\r\n]]></function>\r\n```\r\n\r\nHowever, I'm no longer checking that the attacker/weapon/target are valid.\r\n\r\nThat's fine. Before the line `DoAttackPhase (false, attacks, true, true, \"beforeattack\")` we can add:\r\n```\r\n  // This could be useful in the case of AI scripts\r\n  //    you could have a turnscript: `DoAttack()`\r\n  //    and add this script on the game element to determine which enemies need to do stuff\r\n  DoAttackPhase (true, attacks, true, false, \"findvalidattackers\") {\r\n    attack.valid_attackers = FilterByAttribute (AllObjects(), \"dead\", false)\r\n  }\r\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidattackers\")\r\n  DoAttackPhase (true, attacks, true, false, \"setattacker\") {\r\n    if (not HasAttribute (attack, \"attacker\")) {\r\n      if (HasAttribute (attack, \"valid_attackers\")) {\r\n        attack.attacker = attack.valid_attackers\r\n      }\r\n      else {\r\n        attack.negated = true\r\n      }\r\n    }\r\n    if (HasObject (attack, \"attacker\")) {\r\n      if (HasAttribute (attack, \"valid_attackers\")) {\r\n        if (not ListContains (attack.valid_attackers, attack.attacker)) {\r\n          attack.negated = true\r\n        }\r\n      }\r\n    else if (HasAttribute (attack, \"attacker\")) {\r\n      // it's a list\r\n      processed = NewObjectList()\r\n      foreach (trying, attack.attacker) {\r\n        if (not ListContains (processed, trying)) {\r\n          if (not HasAttribute (attack, \"valid_attackers\")) {\r\n            list add (processed, trying)\r\n          }\r\n          else if (ListContains (attack.valid_attackers)) {\r\n            list add (processed, trying)\r\n          }\r\n        }\r\n      }\r\n      if (ListCount (processed) = 0) {\r\n        attack.negated = true\r\n      }\r\n      else if (ListCount (processed) = 1) {\r\n        attack.attacker = ListItem (processed, 0)\r\n      }\r\n      else {\r\n        attack.replacement = NewObjectList()\r\n        foreach (attacker, processed) {\r\n          newclone = CloneObject (attack)\r\n          newclone.attacker = attacker\r\n          list add (attack.replacement, newclone)\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n... and similar for `weapon`, `spell`, and `target`\r\n\r\n</details>\r\n\r\nSo that the enemy AI system can use those attack phases to decide which weapon/spell/target an enemy chooses, and for the player character, presumably pick their equipped weapon if there is one or weapon=attacker otherwise, and the same for the spell/technique.\r\n\r\nNoting that I'm having weapon and spell separate, because a spell could either be an actual spell (weapon could be a staff that buffs it, or could be the caster), or a weapon technique (usable with a whole class of weapons), or the weapon (for that weapon's usual attack), or a martial arts technique (weapon = attacker) or the attacker (for their basic unarmed attack)",
      "EditableFormat": "markdown",
      "HTML": "<p>OK… there's some horrible bits in here.</p>\n<p>The whole section from <code>object_name = \"current_attack\"</code> down to <code>list add (attacks, attack)</code> needs a rewrite.</p>\n<details><summary>Working on the code</summary>\n<p>Here's a thought:</p>\n<pre><code>    object_name = \"current_attack\"\n    while (not GetObject(object_name) = null) {\n      object_name = object_name + \"_\"\n    }\n    create (object_name)\n    attack = GetObject (object_name)\n    attack.is_attack = true\n\n    attack.generate_filters =&gt; {\n      att = NewObjectList()\n      list add (att, this)\n      if (HasAttribute (this, \"spell\") and not (Equal(this.spell, this.weapon) or Equal(this.spell, this.attacker))) {\n        att = ListCombine (att, GetEffects (this.spell))\n      }\n      if (HasAttribute (this, \"weapon\") and not Equal(this.weapon, this.attacker)) {\n        att = ListCombine (att, GetEffects (this.weapon))\n      }\n      if (HasAttribute (this, \"attacker\")) {\n        att = ListCombine (att, GetEffects (this.attacker))\n        foreach (room, ListAllParents (this.attacker)) {\n          att = ListCombine (att, GetEffects (room))\n        }\n      }\n      list add (att, game)\n      this.filters_attacker = att\n  \n      def = NewObjectList()\n      list add (def, this)\n      if (HasAttribute (this, \"target\")) {\n        def = ListCombine (def, GetEffects (this.target))\n        foreach (room, ListAllParents (this.target)) {\n          def = ListCombine (def, GetEffects (room))\n        }\n      }\n      list add (def, game)\n      attack.filters_target = def\n    }\n    if (IsDefined (\"attacker\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"weapon\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"spell\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"target\")) {\n      attack.attacker = attacker\n    }\n    attacks = NewObjectList()\n    list add (attacks, attack)\n</code></pre>\n<p>Then we have the function to generate the status-effect lists all in one place. So we can do that script attribute any time the spell's target changes, or something like that.</p>\n<p>To the <code>DoAttackPhase</code> function, immediately after <code>list add (attack.phases_complete, phase)</code> we add:</p>\n<pre><code>      do (attack, \"generate_filters\")\n</code></pre>\n<p>In this script I've also used a function <code>ListAllParents</code> which should work as:</p>\n<pre><code>&lt;function name=\"ListAllParents\" type=\"objectlist\" parameters=\"list\"&gt;&lt;![CDATA[\n  if (TypeOf (list) = \"object\") {\n    return (ListParents (object))\n  }\n  result = NewObjectList()\n  i = 0\n  while (i &lt; ListCount (list)) {\n    item = ListItem (list, i)\n    if (HasObject (item, \"parent\")) {\n      if (not ListContains (result, item.parent)) {\n        list add (list, item.parent)\n        list add (result, item.parent)\n      }\n    }\n    i = i + 1\n  }\n  return (result)\n]]&gt;&lt;/function&gt;\n</code></pre>\n<p>However, I'm no longer checking that the attacker/weapon/target are valid.</p>\n<p>That's fine. Before the line <code>DoAttackPhase (false, attacks, true, true, \"beforeattack\")</code> we can add:</p>\n<pre><code>  // This could be useful in the case of AI scripts\n  //    you could have a turnscript: `DoAttack()`\n  //    and add this script on the game element to determine which enemies need to do stuff\n  DoAttackPhase (true, attacks, true, false, \"findvalidattackers\") {\n    attack.valid_attackers = FilterByAttribute (AllObjects(), \"dead\", false)\n  }\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidattackers\")\n  DoAttackPhase (true, attacks, true, false, \"setattacker\") {\n    if (not HasAttribute (attack, \"attacker\")) {\n      if (HasAttribute (attack, \"valid_attackers\")) {\n        attack.attacker = attack.valid_attackers\n      }\n      else {\n        attack.negated = true\n      }\n    }\n    if (HasObject (attack, \"attacker\")) {\n      if (HasAttribute (attack, \"valid_attackers\")) {\n        if (not ListContains (attack.valid_attackers, attack.attacker)) {\n          attack.negated = true\n        }\n      }\n    else if (HasAttribute (attack, \"attacker\")) {\n      // it's a list\n      processed = NewObjectList()\n      foreach (trying, attack.attacker) {\n        if (not ListContains (processed, trying)) {\n          if (not HasAttribute (attack, \"valid_attackers\")) {\n            list add (processed, trying)\n          }\n          else if (ListContains (attack.valid_attackers)) {\n            list add (processed, trying)\n          }\n        }\n      }\n      if (ListCount (processed) = 0) {\n        attack.negated = true\n      }\n      else if (ListCount (processed) = 1) {\n        attack.attacker = ListItem (processed, 0)\n      }\n      else {\n        attack.replacement = NewObjectList()\n        foreach (attacker, processed) {\n          newclone = CloneObject (attack)\n          newclone.attacker = attacker\n          list add (attack.replacement, newclone)\n        }\n      }\n    }\n  }\n</code></pre>\n<p>... and similar for <code>weapon</code>, <code>spell</code>, and <code>target</code></p>\n</details>\n<p>So that the enemy AI system can use those attack phases to decide which weapon/spell/target an enemy chooses, and for the player character, presumably pick their equipped weapon if there is one or weapon=attacker otherwise, and the same for the spell/technique.</p>\n<p>Noting that I'm having weapon and spell separate, because a spell could either be an actual spell (weapon could be a staff that buffs it, or could be the caster), or a weapon technique (usable with a whole class of weapons), or the weapon (for that weapon's usual attack), or a martial arts technique (weapon = attacker) or the attacker (for their basic unarmed attack)</p>\n\n",
      "PostDate": "2018-08-31T21:13:30.3737343Z",
      "LastEditDate": "2018-09-01T08:25:20.9216815Z",
      "link": null
    },
    {
      "PostId": "535cdd59-6135-4f11-b471-75936f00681b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I can't get this out of my head. So here's the proto-RPGlib as it stands.\r\nEdit: Just realised I missed out a script :p We now allow weapons to have an \"attack_attributes\" attribute; a list of attributes which should be copied from the spell/weapon/attacker to the attack itself. Useful for things like elemental affinities.\r\n\r\nNote that in the case of `attacker` not being specified, it attempts to start an attack for all valid attackers.\r\nIn the case of `weapon` or `spell` not being set, the `setspell` script will be run first. So a spell/technique object can have an `afterfindvalidweapons` script which filters `valid_weapons` based on the weapon type that spell or technique can be used with.\r\n\r\nThis huge function is really horrible. I think a lot of the scripts could be placed on the game element, making it easier to manage (but harder to copy into the web editor)\r\n\r\nStill haven't tested all this. I kind of want something that works in my head first.\r\n\r\nSo, the battle phases are currently:\r\n* AI hook phases\r\n  * findvalidattackers\r\n  * afterfindvalidattackers\r\n  * setattacker\r\n  * findvalidspells\r\n  * afterfindvalidspells\r\n  * setspell\r\n  * findvalidweapons\r\n  * afterfindvalidweapons\r\n  * setweapon\r\n  * findvalidtargets\r\n  * afterfindvalidtargets\r\n  * settarget\r\n* beforeattack\r\n* Attack roll phases:\r\n   * beforemakeattack\r\n   * makeattack\r\n   * aftermakeattack\r\n* onattack\r\n* splitattack\r\n* Damage resolution phases:\r\n   * beforeresolveattack\r\n   * resolveattack\r\n   * afterresolveattack\r\n* afterattack[hit / miss / crit / kill / etc]\r\n* showattackmessage\r\n* afterattack\r\n* destroyattack\r\n\r\n```\r\n<function name=\"SetupDefaultCombatScripts\"><![CDATA[\r\n  DefaultCombatScript (\"findvalidattackers\"){\r\n    attack.valid_attackers = FilterByAttribute (AllObjects(), \"dead\", false)\r\n  }\r\n  DefaultCombatScript (\"setattacker\") {\r\n    if (not HasAttribute (attack, \"attacker\")) {\r\n      if (HasAttribute (attack, \"valid_attackers\")) {\r\n        attack.attacker = attack.valid_attackers\r\n      }\r\n      else {\r\n        attack.negated = true\r\n      }\r\n    }\r\n    if (HasObject (attack, \"attacker\")) {\r\n      if (HasAttribute (attack, \"valid_attackers\")) {\r\n        if (not ListContains (attack.valid_attackers, attack.attacker)) {\r\n          attack.negated = true\r\n        }\r\n      }\r\n      else if (HasAttribute (attack, \"attacker\")) {\r\n        // it's a list\r\n        processed = NewObjectList()\r\n        foreach (trying, attack.attacker) {\r\n          if (not ListContains (processed, trying)) {\r\n            if (not HasAttribute (attack, \"valid_attackers\")) {\r\n              list add (processed, trying)\r\n            }\r\n            else if (ListContains (attack.valid_attackers)) {\r\n              list add (processed, trying)\r\n            }\r\n          }\r\n        }\r\n        if (ListCount (processed) = 0) {\r\n          attack.negated = true\r\n        }\r\n        else if (ListCount (processed) = 1) {\r\n          attack.attacker = ListItem (processed, 0)\r\n        }\r\n        else {\r\n          attack.replacement = NewObjectList()\r\n          foreach (attacker, processed) {\r\n            newclone = CloneObject (attack)\r\n            newclone.attacker = attacker\r\n            list add (attack.replacement, newclone)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DefaultCombatScript (\"findvalidspells\") {\r\n    attack.valid_spells = NewObjectList()\r\n    if (HasAttribute (attack, \"weapon\")) {\r\n      if (HasAttribute (attack.weapon, \"available_spells\")) {\r\n        attack.valid_spells = attack.weapon.available_spells\r\n      }\r\n    }\r\n    if (HasAttribute (attack, \"attacker\")) {\r\n      if (HasAttribute (attack.attacker, \"available_spells\")) {\r\n        attack.valid_spells = ListCombine (attack.valid_spells, attack.attacker.available_spells)\r\n      }\r\n    }\r\n  }\r\n  DefaultCombatScript (\"setspell\") {\r\n    if (not HasObject (attack, \"spell\") and not attacker = game.pov) {\r\n      attack.spell = PickOneObject (attack.valid_spells)\r\n    }\r\n    if (not HasObject (attack, \"spell\")) {\r\n      if (attack.attacker = game.pov) {\r\n        if (HasAttribute (attack, \"weapon\")) {\r\n          if (HasAttribute (weapon, \"default_spell\")) {\r\n            attack.spell = weapon.default_spell\r\n          }\r\n          else {\r\n            attack.spell = weapon\r\n          }\r\n        }\r\n        else if (HasAttribute (attacker, \"default_spell\")) {\r\n          attack.spell = attacker.default_spell\r\n        }\r\n        else {\r\n          attack.spell = attacker\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DefaultCombatScript (\"findvalidweapons\") {\r\n    attack.valid_weapons = FilterByAttribute (GetAllChildObjects (attack.attacker), \"is_weapon\", true)\r\n  }\r\n  DefaultCombatScript (\"setweapon\") {\r\n    if (not HasObject (attack, \"weapon\")) {\r\n      if (EndsWith (TypeOf (attack, \"weapon\"), \"list\")) {\r\n        attack.weapon = PickOneObject (attack.weapon)\r\n      }\r\n    }\r\n    if (not HasObject (attack, \"weapon\")) {\r\n      if (EndsWith (TypeOf (attack, \"valid_weapons\"), \"list\")) {\r\n        attack.weapon = PickOneObject (attack.weapon)\r\n      }\r\n    }\r\n    if (not HasObject (attack, \"weapon\")) {\r\n      attack.weapon = attack.attacker\r\n    }\r\n  }\r\n  DefaultCombatScript (\"findvalidtargets\") {\r\n    if (attacker = game.pov) {\r\n      attack.valid_targets = ScopeReachable()\r\n    }\r\n    else {\r\n      attack.valid_targets = FilterByAttribute (ListExclude (GetDirectChildren (attacker.parent), attacker), \"dead\", false)\r\n    }\r\n  }\r\n  DefaultCombatScript (\"settarget\") {\r\n    if (not HasAttribute (attack, \"target\") and not attacker = game.pov) {\r\n      attack.target = PickOneObject (attack.valid_targets)\r\n    }\r\n  }\r\n  DefaultCombatScript (\"beforeattack\") {\r\n    foreach (type, Split (\"spell;weapon;attacker\")) {\r\n      if (HasObject (attack, type)) {\r\n        obj = GetAttribute (attack, type)\r\n        if (HasAttribute (obj, \"attack_attributes\")) {\r\n          foreach (attr, obj.attack_attributes) {\r\n            if (not HasAttribute (attack, attr)) {\r\n              if (EndsWith (TypeOf (obj, \"attack_attributes\"), \"dictionary\")) {\r\n                set (attack, attr, DictionaryItem (obj.attack_attributes, attr))\r\n              }\r\n            }\r\n            if (HasAttribute (obj, attr) and not HasAttribute (attack, attr)) {\r\n              set (attack, attr, GetAttribute (obj, attr))\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DefaultCombatScript (\"makeattack\") {\r\n    attack.attackroll = GetRandomInt(1, 12)\r\n    attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\r\n    if (HasString (spell, \"damageroll\")) {\r\n      attack.damage = eval (spell.damageroll, params)\r\n    }\r\n    if (HasInt (spell, \"damage\")) {\r\n      attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\r\n    }\r\n  }\r\n  DefaultCombatScript (\"splitattack\") {\r\n    i = 0\r\n    while (i < ListCount (attacks)) {\r\n      attack = ListItem (attacks, i)\r\n      if (not HasAttribute (attack, \"target\")) {\r\n        list remove (attacks, attack)\r\n      }\r\n      else if (EndsWith (TypeOf (attack, \"target\"), \"list\")) {\r\n        foreach (target, attack.target) {\r\n          newattack = Clone (attack)\r\n          newattack.target = target\r\n          list add (attacks, newattack)\r\n        }\r\n        list remove (attacks, attack)\r\n      }\r\n      else {\r\n        i = i + 1\r\n      }\r\n    }\r\n  }\r\n  DefaultCombatScript (\"resolveattack\") {\r\n    attack.dodgeroll = GetRandomInt (1, 12)\r\n    attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") > attack.dodgeroll + GetInt (target, \"agility\"))\r\n    if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\r\n    if (attack.hit and attack.damage > 0) {\r\n      target.health = target.health - attack.damage\r\n      list add (attack.status, \"hit\")\r\n      if (target.health < 0) {\r\n        list add (attack.status, \"kill\")\r\n      }\r\n    }\r\n    else {\r\n      attack.damage = 0\r\n      list add (attack.status, \"miss\")\r\n    }\r\n  }\r\n  DefaultCombatScript (\"showattackmessage\") {\r\n    if (HasString (attack, \"message\")) {\r\n      message = attack.message\r\n      game.text_processor_variables = GetAttackParams (attack)\r\n      while (not message = null) {\r\n        newmessage = ProcessText (message)\r\n        if (message = newmessage) {\r\n          msg (message)\r\n          message = null\r\n        }\r\n        else {\r\n          message = newmessage\r\n        }\r\n      }\r\n    }\r\n  }\r\n]]></function>\r\n\r\n<function name=\"DefaultCombatScript\" parameters=\"name, script\">\r\n  if (not HasScript (game, name)) {\r\n    set (game, name, script)\r\n  }\r\n</function>\r\n\r\n<function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\">\r\n  if (Equal (attacker, \"RESUME\")) {\r\n    attacks = weapon\r\n  }\r\n  else {\r\n    object_name = \"current_attack\"\r\n    while (not GetObject(object_name) = null) {\r\n      object_name = object_name + \"_\"\r\n    }\r\n    create (object_name)\r\n    attack = GetObject (object_name)\r\n    attack.is_attack = true\r\n\r\n    attack.generate_filters => {\r\n      att = NewObjectList()\r\n      list add (att, this)\r\n      if (HasAttribute (this, \"spell\") and not (Equal(this.spell, this.weapon) or Equal(this.spell, this.attacker))) {\r\n        att = ListCombine (att, GetEffects (this.spell))\r\n      }\r\n      if (HasAttribute (this, \"weapon\") and not Equal(this.weapon, this.attacker)) {\r\n        att = ListCombine (att, GetEffects (this.weapon))\r\n      }\r\n      if (HasAttribute (this, \"attacker\")) {\r\n        att = ListCombine (att, GetEffects (this.attacker))\r\n        foreach (room, ListAllParents (this.attacker)) {\r\n          att = ListCombine (att, GetEffects (room))\r\n        }\r\n      }\r\n      list add (att, game)\r\n      this.filters_attacker = att\r\n  \r\n      def = NewObjectList()\r\n      list add (def, this)\r\n      if (HasAttribute (this, \"target\")) {\r\n        def = ListCombine (def, GetEffects (this.target))\r\n        foreach (room, ListAllParents (this.target)) {\r\n          def = ListCombine (def, GetEffects (room))\r\n        }\r\n      }\r\n      list add (def, game)\r\n      attack.filters_target = def\r\n    }\r\n    if (IsDefined (\"attacker\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"weapon\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"spell\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    if (IsDefined (\"target\")) {\r\n      attack.attacker = attacker\r\n    }\r\n    attacks = NewObjectList()\r\n    list add (attacks, attack)\r\n  }\r\n\r\n  // This could be useful in the case of AI scripts\r\n  //    you could have a turnscript: `DoAttack()`\r\n  //    and add this script on the game element to determine which enemies need to do stuff\r\n  DoAttackPhase (true, attacks, true, false, \"findvalidattackers\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidattackers\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"setattacker\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"findvalidspells\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidspells\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"setspell\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"findvalidweapons\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidweapons\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"setweapon\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"findvalidtargets\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidtargets\", null)\r\n  DoAttackPhase (true, attacks, true, false, \"settarget\", null)\r\n  DoAttackPhase (false, attacks, true, true, \"beforeattack\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"beforemakeattack\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"makeattack\", null)\r\n  DoAttackPhase (false, attacks, true, false, \"aftermakeattack\", null)\r\n  DoAttackPhase (false, attacks, true, true, \"onattack\", null)\r\n  DoAttackPhase (false, attacks, true, true, \"splitattack\", null)\r\n  DoAttackPhase (false, attacks, false, true, \"beforeresolveattack\", null)\r\n  DoAttackPhase (false, attacks, false, true, \"resolveattack\", null)\r\n  DoAttackPhase (false, attacks, false, true, \"afterresolveattack\", null)\r\n  bystatus = NewDictionary()\r\n  foreach (attack, attacks) {\r\n    if (HasAttribute (attack, \"status\")) {\r\n      foreach (status, attack.status) {\r\n        if (not DictionaryContains (bystatus, status)) {\r\n          dictionary add (bystatus, status, NewObjectList())\r\n        }\r\n        list add (DictionaryItem (bystatus, status), attack)\r\n      }\r\n    }\r\n  }\r\n  foreach (status, bystatus) {\r\n    DoAttackPhase (false, DictionaryItem (bystatus, status), true, false, \"afterattack\"+status, null)\r\n    DoAttackPhase (false, DictionaryItem (bystatus, status), false, true, \"afterattacked\"+status, null)\r\n  }\r\n  if (target = game.pov or attacker = game.pov or ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target)) {\r\n    DoAttackPhase (true, attacks, true, true, \"showattackmessage\", null)\r\n  }\r\n  else {\r\n    // A script the user can implement if they want the player to see a message about an attack hitting\r\n    //   when the player isn't in the same room\r\n    //       (\"You hear the distinctive {b:BOOM} of a fireball from a distant room!\")\r\n    DoAttackPhase (true, attacks, true, true, \"showremoteattackmessage\", null)\r\n  }\r\n  DoAttackPhase (false, attacks, true, true, \"afterattack\", null)\r\n  DoAttackPhase (false, attacks, true, true, \"destroyattack\") {\r\n    attack.destroy = true\r\n  }\r\n</function>\r\n\r\n<turnscript name=\"deferred_attacks\">\r\n  <enabled />\r\n  <script><![CDATA[\r\n  resume = NewObjectList()\r\n  foreach (attack, FilterByAttribute(AllObjects(), \"is_attack\", true)) {\r\n    switch (TypeOf (attack, \"deferred\")) {\r\n      case (\"int\") {\r\n        attack.deferred = attack.deferred - 1\r\n        if (attack.deferred < 0) {\r\n          attack.deferred = null\r\n        }\r\n      }\r\n      case (\"string\") {\r\n        if (Equal (true, eval (attack.deferred, MakeAttackParams(attack)))) {\r\n          attack.deferred = null\r\n        }\r\n      }\r\n      case (\"script\") {\r\n        do (attack, \"deferred\")\r\n      }\r\n    }\r\n    if (not HasAttribute (attack, \"deferred\")) {\r\n      list add (resume, attack)\r\n    }\r\n  }\r\n  if (ListCount (resume) > 0) {\r\n    DoAttack (\"RESUME\", resume)\r\n  }\r\n  ]]></script>\r\n</turnscript>\r\n\r\n<function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\">\r\n  result = NewDictionary()\r\n  foreach (attr, GetAttributeNames (attack, true)) {\r\n    dictionary add (result, attr, GetAttribute (attack, attr))\r\n  }\r\n  if (not DictionaryContains (result, \"attack\")) {\r\n    dictionary add (result, \"attack\", attack)\r\n  }\r\n  return (result)\r\n</function>\r\n\r\n<function name=\"DoAttackPhase\" parameters=\"singleton, attacks, for_attacker, for_target, phase, default\">\r\n  original_phase = phase\r\n  newattacks = NewObjectList()\r\n  foreach (attack, attacks) {\r\n    if (GetBoolean (game, \"combat_playthrough_menu\") or not HasScript (game, \"menucallback\")) {\r\n      if (not HasAttribute (attack, \"phases_complete\")) attack.phases_complete = NewStringList()\r\n      done = false\r\n      if (ListContains (attack.phases_complete, phase)) {\r\n        done = true\r\n      }\r\n      else {\r\n        do (attack, \"generate_filters\")\r\n        if (for_attacker) {\r\n          foreach (obj, attack.filters_attacker) {\r\n            if (HasScript (obj, phase) and (not done or not singleton)) {\r\n              do (obj, phase, MakeAttackParams (attack))\r\n              done = true\r\n            }\r\n          }\r\n        }\r\n        if (for_attacker and for_target) {\r\n          phase = phase + \"ed\"\r\n        }\r\n        if (for_target) {\r\n          foreach (obj, attack.filters_target) {\r\n            if (HasScript (obj, phase) and (not done or not singleton)) {\r\n              do (obj, phase, MakeAttackParams (attack))\r\n              done = true\r\n            }\r\n          }\r\n        }\r\n        if (IsDefined (\"default\") and not done) {\r\n          if (TypeOf (default) = \"script\") {\r\n            invoke (default, MakeAttackParams (attack)\r\n          }\r\n          done = true\r\n        }\r\n        list add (attack.phases_complete, phase)\r\n      }\r\n      if (HasObject (attack, \"replacement\")) {\r\n        replist = NewObjectList()\r\n        list add (replist, attack.replacement)\r\n        attack.replacement = replist\r\n      }\r\n      if (HasAttribute (attack, \"replacement\")) {\r\n        if (not singleton) {\r\n          DoAttackPhase(singleton, attack.replacement, for_attacker, for_target, original_phase, default)\r\n        }\r\n        newattacks = ListCombine (newattacks, attack.replacement)\r\n        if (not ListContains (attack.replacement, attack)) {\r\n          attack.destroy = true\r\n        }\r\n      }\r\n      if (not GetBoolean (attack, \"negated\") and not GetBoolean (attack, \"destroy\") and not HasAttribute (attack, \"deferred\")) {\r\n        list add (newattacks, attack)\r\n      }\r\n    }\r\n    else {\r\n      newattacks = NewObjectList()\r\n      if (not HasAttribute (attack, \"deferred\")) {\r\n        attack.deferred = \"not HasScript (game, \\\"menucallback\\\")\"\r\n      }\r\n    }\r\n  }\r\n  while (ListCount (attacks) > 0) {\r\n    list remove (attacks, ListItem (attacks, 0))\r\n  }\r\n  foreach (attack, FilterByAttribute (newattacks, \"destroy\", true)) {\r\n    destroy (attack.name)\r\n  }\r\n  foreach (attack, newattacks) {\r\n    list add (attacks, newattacks)\r\n  }\r\n</function>\r\n\r\n<function name=\"GetEffects\" type=\"objectlist\" parameters=\"items\">\r\n  result = NewObjectList()\r\n  if (not EndsWith (TypeOf (items), \"list\")) {\r\n    item = items\r\n    items = NewObjectList()\r\n    list add (items, item)\r\n  }\r\n  foreach (item, items) {\r\n    list add (result, item)\r\n    foreach (effect, FilterByAttribute (GetDirectChildren(item), \"status_effect\", true)) {\r\n      list add (result, effect)\r\n    }\r\n    foreach (garment, GetWornFor (item)) {\r\n      foreach (effect, FilterByAttribute (GetDirectChildren (garment), \"status_effect\", true)) {\r\n        list add (result, effect)\r\n      }\r\n    }\r\n  }\r\n  return (result)\r\n</function>\r\n\r\n<function name=\"ListAllParents\" type=\"objectlist\" parameters=\"list\"><![CDATA[\r\n  if (TypeOf (list) = \"object\") {\r\n    return (ListParents (object))\r\n  }\r\n  result = NewObjectList()\r\n  i = 0\r\n  while (i < ListCount (list)) {\r\n    item = ListItem (list, i)\r\n    if (HasObject (item, \"parent\")) {\r\n      if (not ListContains (result, item.parent)) {\r\n        list add (list, item.parent)\r\n        list add (result, item.parent)\r\n      }\r\n    }\r\n    i = i + 1\r\n  }\r\n  return (result)\r\n]]></function>\r\n```\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>I can't get this out of my head. So here's the proto-RPGlib as it stands.<br>\nEdit: Just realised I missed out a script :p We now allow weapons to have an \"attack_attributes\" attribute; a list of attributes which should be copied from the spell/weapon/attacker to the attack itself. Useful for things like elemental affinities.</p>\n<p>Note that in the case of <code>attacker</code> not being specified, it attempts to start an attack for all valid attackers.<br>\nIn the case of <code>weapon</code> or <code>spell</code> not being set, the <code>setspell</code> script will be run first. So a spell/technique object can have an <code>afterfindvalidweapons</code> script which filters <code>valid_weapons</code> based on the weapon type that spell or technique can be used with.</p>\n<p>This huge function is really horrible. I think a lot of the scripts could be placed on the game element, making it easier to manage (but harder to copy into the web editor)</p>\n<p>Still haven't tested all this. I kind of want something that works in my head first.</p>\n<p>So, the battle phases are currently:</p>\n<ul>\n<li>AI hook phases\n<ul>\n<li>findvalidattackers</li>\n<li>afterfindvalidattackers</li>\n<li>setattacker</li>\n<li>findvalidspells</li>\n<li>afterfindvalidspells</li>\n<li>setspell</li>\n<li>findvalidweapons</li>\n<li>afterfindvalidweapons</li>\n<li>setweapon</li>\n<li>findvalidtargets</li>\n<li>afterfindvalidtargets</li>\n<li>settarget</li>\n</ul>\n</li>\n<li>beforeattack</li>\n<li>Attack roll phases:\n<ul>\n<li>beforemakeattack</li>\n<li>makeattack</li>\n<li>aftermakeattack</li>\n</ul>\n</li>\n<li>onattack</li>\n<li>splitattack</li>\n<li>Damage resolution phases:\n<ul>\n<li>beforeresolveattack</li>\n<li>resolveattack</li>\n<li>afterresolveattack</li>\n</ul>\n</li>\n<li>afterattack[hit / miss / crit / kill / etc]</li>\n<li>showattackmessage</li>\n<li>afterattack</li>\n<li>destroyattack</li>\n</ul>\n<pre><code>&lt;function name=\"SetupDefaultCombatScripts\"&gt;&lt;![CDATA[\n  DefaultCombatScript (\"findvalidattackers\"){\n    attack.valid_attackers = FilterByAttribute (AllObjects(), \"dead\", false)\n  }\n  DefaultCombatScript (\"setattacker\") {\n    if (not HasAttribute (attack, \"attacker\")) {\n      if (HasAttribute (attack, \"valid_attackers\")) {\n        attack.attacker = attack.valid_attackers\n      }\n      else {\n        attack.negated = true\n      }\n    }\n    if (HasObject (attack, \"attacker\")) {\n      if (HasAttribute (attack, \"valid_attackers\")) {\n        if (not ListContains (attack.valid_attackers, attack.attacker)) {\n          attack.negated = true\n        }\n      }\n      else if (HasAttribute (attack, \"attacker\")) {\n        // it's a list\n        processed = NewObjectList()\n        foreach (trying, attack.attacker) {\n          if (not ListContains (processed, trying)) {\n            if (not HasAttribute (attack, \"valid_attackers\")) {\n              list add (processed, trying)\n            }\n            else if (ListContains (attack.valid_attackers)) {\n              list add (processed, trying)\n            }\n          }\n        }\n        if (ListCount (processed) = 0) {\n          attack.negated = true\n        }\n        else if (ListCount (processed) = 1) {\n          attack.attacker = ListItem (processed, 0)\n        }\n        else {\n          attack.replacement = NewObjectList()\n          foreach (attacker, processed) {\n            newclone = CloneObject (attack)\n            newclone.attacker = attacker\n            list add (attack.replacement, newclone)\n          }\n        }\n      }\n    }\n  }\n  DefaultCombatScript (\"findvalidspells\") {\n    attack.valid_spells = NewObjectList()\n    if (HasAttribute (attack, \"weapon\")) {\n      if (HasAttribute (attack.weapon, \"available_spells\")) {\n        attack.valid_spells = attack.weapon.available_spells\n      }\n    }\n    if (HasAttribute (attack, \"attacker\")) {\n      if (HasAttribute (attack.attacker, \"available_spells\")) {\n        attack.valid_spells = ListCombine (attack.valid_spells, attack.attacker.available_spells)\n      }\n    }\n  }\n  DefaultCombatScript (\"setspell\") {\n    if (not HasObject (attack, \"spell\") and not attacker = game.pov) {\n      attack.spell = PickOneObject (attack.valid_spells)\n    }\n    if (not HasObject (attack, \"spell\")) {\n      if (attack.attacker = game.pov) {\n        if (HasAttribute (attack, \"weapon\")) {\n          if (HasAttribute (weapon, \"default_spell\")) {\n            attack.spell = weapon.default_spell\n          }\n          else {\n            attack.spell = weapon\n          }\n        }\n        else if (HasAttribute (attacker, \"default_spell\")) {\n          attack.spell = attacker.default_spell\n        }\n        else {\n          attack.spell = attacker\n        }\n      }\n    }\n  }\n  DefaultCombatScript (\"findvalidweapons\") {\n    attack.valid_weapons = FilterByAttribute (GetAllChildObjects (attack.attacker), \"is_weapon\", true)\n  }\n  DefaultCombatScript (\"setweapon\") {\n    if (not HasObject (attack, \"weapon\")) {\n      if (EndsWith (TypeOf (attack, \"weapon\"), \"list\")) {\n        attack.weapon = PickOneObject (attack.weapon)\n      }\n    }\n    if (not HasObject (attack, \"weapon\")) {\n      if (EndsWith (TypeOf (attack, \"valid_weapons\"), \"list\")) {\n        attack.weapon = PickOneObject (attack.weapon)\n      }\n    }\n    if (not HasObject (attack, \"weapon\")) {\n      attack.weapon = attack.attacker\n    }\n  }\n  DefaultCombatScript (\"findvalidtargets\") {\n    if (attacker = game.pov) {\n      attack.valid_targets = ScopeReachable()\n    }\n    else {\n      attack.valid_targets = FilterByAttribute (ListExclude (GetDirectChildren (attacker.parent), attacker), \"dead\", false)\n    }\n  }\n  DefaultCombatScript (\"settarget\") {\n    if (not HasAttribute (attack, \"target\") and not attacker = game.pov) {\n      attack.target = PickOneObject (attack.valid_targets)\n    }\n  }\n  DefaultCombatScript (\"beforeattack\") {\n    foreach (type, Split (\"spell;weapon;attacker\")) {\n      if (HasObject (attack, type)) {\n        obj = GetAttribute (attack, type)\n        if (HasAttribute (obj, \"attack_attributes\")) {\n          foreach (attr, obj.attack_attributes) {\n            if (not HasAttribute (attack, attr)) {\n              if (EndsWith (TypeOf (obj, \"attack_attributes\"), \"dictionary\")) {\n                set (attack, attr, DictionaryItem (obj.attack_attributes, attr))\n              }\n            }\n            if (HasAttribute (obj, attr) and not HasAttribute (attack, attr)) {\n              set (attack, attr, GetAttribute (obj, attr))\n            }\n          }\n        }\n      }\n    }\n  }\n  DefaultCombatScript (\"makeattack\") {\n    attack.attackroll = GetRandomInt(1, 12)\n    attack.message = \"{=CapFirst(GetDisplayName(attack.attacker))} {=Conjugate(attack.attacker, \\\"attack\\\")} {=GetDisplayName(attack.target)} {either attack.hit:for {attack.damage} damage:but {=WriteVerb(attack.attacker, \\\"attack\\\")}.\"\n    if (HasString (spell, \"damageroll\")) {\n      attack.damage = eval (spell.damageroll, params)\n    }\n    if (HasInt (spell, \"damage\")) {\n      attack.damage = GetRandomInt (spell.damage, spell.damage * 2)\n    }\n  }\n  DefaultCombatScript (\"splitattack\") {\n    i = 0\n    while (i &lt; ListCount (attacks)) {\n      attack = ListItem (attacks, i)\n      if (not HasAttribute (attack, \"target\")) {\n        list remove (attacks, attack)\n      }\n      else if (EndsWith (TypeOf (attack, \"target\"), \"list\")) {\n        foreach (target, attack.target) {\n          newattack = Clone (attack)\n          newattack.target = target\n          list add (attacks, newattack)\n        }\n        list remove (attacks, attack)\n      }\n      else {\n        i = i + 1\n      }\n    }\n  }\n  DefaultCombatScript (\"resolveattack\") {\n    attack.dodgeroll = GetRandomInt (1, 12)\n    attack.hit = (attack.attackroll + GetSkill(attacker, \"combat\") &gt; attack.dodgeroll + GetInt (target, \"agility\"))\n    if (not HasAttribute (attack, \"status\")) attack.status = NewStringList()\n    if (attack.hit and attack.damage &gt; 0) {\n      target.health = target.health - attack.damage\n      list add (attack.status, \"hit\")\n      if (target.health &lt; 0) {\n        list add (attack.status, \"kill\")\n      }\n    }\n    else {\n      attack.damage = 0\n      list add (attack.status, \"miss\")\n    }\n  }\n  DefaultCombatScript (\"showattackmessage\") {\n    if (HasString (attack, \"message\")) {\n      message = attack.message\n      game.text_processor_variables = GetAttackParams (attack)\n      while (not message = null) {\n        newmessage = ProcessText (message)\n        if (message = newmessage) {\n          msg (message)\n          message = null\n        }\n        else {\n          message = newmessage\n        }\n      }\n    }\n  }\n]]&gt;&lt;/function&gt;\n\n&lt;function name=\"DefaultCombatScript\" parameters=\"name, script\"&gt;\n  if (not HasScript (game, name)) {\n    set (game, name, script)\n  }\n&lt;/function&gt;\n\n&lt;function name=\"DoAttack\" parameters=\"attacker, weapon, spell, target\"&gt;\n  if (Equal (attacker, \"RESUME\")) {\n    attacks = weapon\n  }\n  else {\n    object_name = \"current_attack\"\n    while (not GetObject(object_name) = null) {\n      object_name = object_name + \"_\"\n    }\n    create (object_name)\n    attack = GetObject (object_name)\n    attack.is_attack = true\n\n    attack.generate_filters =&gt; {\n      att = NewObjectList()\n      list add (att, this)\n      if (HasAttribute (this, \"spell\") and not (Equal(this.spell, this.weapon) or Equal(this.spell, this.attacker))) {\n        att = ListCombine (att, GetEffects (this.spell))\n      }\n      if (HasAttribute (this, \"weapon\") and not Equal(this.weapon, this.attacker)) {\n        att = ListCombine (att, GetEffects (this.weapon))\n      }\n      if (HasAttribute (this, \"attacker\")) {\n        att = ListCombine (att, GetEffects (this.attacker))\n        foreach (room, ListAllParents (this.attacker)) {\n          att = ListCombine (att, GetEffects (room))\n        }\n      }\n      list add (att, game)\n      this.filters_attacker = att\n  \n      def = NewObjectList()\n      list add (def, this)\n      if (HasAttribute (this, \"target\")) {\n        def = ListCombine (def, GetEffects (this.target))\n        foreach (room, ListAllParents (this.target)) {\n          def = ListCombine (def, GetEffects (room))\n        }\n      }\n      list add (def, game)\n      attack.filters_target = def\n    }\n    if (IsDefined (\"attacker\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"weapon\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"spell\")) {\n      attack.attacker = attacker\n    }\n    if (IsDefined (\"target\")) {\n      attack.attacker = attacker\n    }\n    attacks = NewObjectList()\n    list add (attacks, attack)\n  }\n\n  // This could be useful in the case of AI scripts\n  //    you could have a turnscript: `DoAttack()`\n  //    and add this script on the game element to determine which enemies need to do stuff\n  DoAttackPhase (true, attacks, true, false, \"findvalidattackers\", null)\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidattackers\", null)\n  DoAttackPhase (true, attacks, true, false, \"setattacker\", null)\n  DoAttackPhase (true, attacks, true, false, \"findvalidspells\", null)\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidspells\", null)\n  DoAttackPhase (true, attacks, true, false, \"setspell\", null)\n  DoAttackPhase (true, attacks, true, false, \"findvalidweapons\", null)\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidweapons\", null)\n  DoAttackPhase (true, attacks, true, false, \"setweapon\", null)\n  DoAttackPhase (true, attacks, true, false, \"findvalidtargets\", null)\n  DoAttackPhase (false, attacks, true, false, \"afterfindvalidtargets\", null)\n  DoAttackPhase (true, attacks, true, false, \"settarget\", null)\n  DoAttackPhase (false, attacks, true, true, \"beforeattack\", null)\n  DoAttackPhase (false, attacks, true, false, \"beforemakeattack\", null)\n  DoAttackPhase (false, attacks, true, false, \"makeattack\", null)\n  DoAttackPhase (false, attacks, true, false, \"aftermakeattack\", null)\n  DoAttackPhase (false, attacks, true, true, \"onattack\", null)\n  DoAttackPhase (false, attacks, true, true, \"splitattack\", null)\n  DoAttackPhase (false, attacks, false, true, \"beforeresolveattack\", null)\n  DoAttackPhase (false, attacks, false, true, \"resolveattack\", null)\n  DoAttackPhase (false, attacks, false, true, \"afterresolveattack\", null)\n  bystatus = NewDictionary()\n  foreach (attack, attacks) {\n    if (HasAttribute (attack, \"status\")) {\n      foreach (status, attack.status) {\n        if (not DictionaryContains (bystatus, status)) {\n          dictionary add (bystatus, status, NewObjectList())\n        }\n        list add (DictionaryItem (bystatus, status), attack)\n      }\n    }\n  }\n  foreach (status, bystatus) {\n    DoAttackPhase (false, DictionaryItem (bystatus, status), true, false, \"afterattack\"+status, null)\n    DoAttackPhase (false, DictionaryItem (bystatus, status), false, true, \"afterattacked\"+status, null)\n  }\n  if (target = game.pov or attacker = game.pov or ListContains (ScopeVisible(), attacker) or ListContains (ScopeVisible(), target)) {\n    DoAttackPhase (true, attacks, true, true, \"showattackmessage\", null)\n  }\n  else {\n    // A script the user can implement if they want the player to see a message about an attack hitting\n    //   when the player isn't in the same room\n    //       (\"You hear the distinctive {b:BOOM} of a fireball from a distant room!\")\n    DoAttackPhase (true, attacks, true, true, \"showremoteattackmessage\", null)\n  }\n  DoAttackPhase (false, attacks, true, true, \"afterattack\", null)\n  DoAttackPhase (false, attacks, true, true, \"destroyattack\") {\n    attack.destroy = true\n  }\n&lt;/function&gt;\n\n&lt;turnscript name=\"deferred_attacks\"&gt;\n  &lt;enabled /&gt;\n  &lt;script&gt;&lt;![CDATA[\n  resume = NewObjectList()\n  foreach (attack, FilterByAttribute(AllObjects(), \"is_attack\", true)) {\n    switch (TypeOf (attack, \"deferred\")) {\n      case (\"int\") {\n        attack.deferred = attack.deferred - 1\n        if (attack.deferred &lt; 0) {\n          attack.deferred = null\n        }\n      }\n      case (\"string\") {\n        if (Equal (true, eval (attack.deferred, MakeAttackParams(attack)))) {\n          attack.deferred = null\n        }\n      }\n      case (\"script\") {\n        do (attack, \"deferred\")\n      }\n    }\n    if (not HasAttribute (attack, \"deferred\")) {\n      list add (resume, attack)\n    }\n  }\n  if (ListCount (resume) &gt; 0) {\n    DoAttack (\"RESUME\", resume)\n  }\n  ]]&gt;&lt;/script&gt;\n&lt;/turnscript&gt;\n\n&lt;function name=\"MakeAttackParams\" type=\"dictionary\" parameters=\"attack\"&gt;\n  result = NewDictionary()\n  foreach (attr, GetAttributeNames (attack, true)) {\n    dictionary add (result, attr, GetAttribute (attack, attr))\n  }\n  if (not DictionaryContains (result, \"attack\")) {\n    dictionary add (result, \"attack\", attack)\n  }\n  return (result)\n&lt;/function&gt;\n\n&lt;function name=\"DoAttackPhase\" parameters=\"singleton, attacks, for_attacker, for_target, phase, default\"&gt;\n  original_phase = phase\n  newattacks = NewObjectList()\n  foreach (attack, attacks) {\n    if (GetBoolean (game, \"combat_playthrough_menu\") or not HasScript (game, \"menucallback\")) {\n      if (not HasAttribute (attack, \"phases_complete\")) attack.phases_complete = NewStringList()\n      done = false\n      if (ListContains (attack.phases_complete, phase)) {\n        done = true\n      }\n      else {\n        do (attack, \"generate_filters\")\n        if (for_attacker) {\n          foreach (obj, attack.filters_attacker) {\n            if (HasScript (obj, phase) and (not done or not singleton)) {\n              do (obj, phase, MakeAttackParams (attack))\n              done = true\n            }\n          }\n        }\n        if (for_attacker and for_target) {\n          phase = phase + \"ed\"\n        }\n        if (for_target) {\n          foreach (obj, attack.filters_target) {\n            if (HasScript (obj, phase) and (not done or not singleton)) {\n              do (obj, phase, MakeAttackParams (attack))\n              done = true\n            }\n          }\n        }\n        if (IsDefined (\"default\") and not done) {\n          if (TypeOf (default) = \"script\") {\n            invoke (default, MakeAttackParams (attack)\n          }\n          done = true\n        }\n        list add (attack.phases_complete, phase)\n      }\n      if (HasObject (attack, \"replacement\")) {\n        replist = NewObjectList()\n        list add (replist, attack.replacement)\n        attack.replacement = replist\n      }\n      if (HasAttribute (attack, \"replacement\")) {\n        if (not singleton) {\n          DoAttackPhase(singleton, attack.replacement, for_attacker, for_target, original_phase, default)\n        }\n        newattacks = ListCombine (newattacks, attack.replacement)\n        if (not ListContains (attack.replacement, attack)) {\n          attack.destroy = true\n        }\n      }\n      if (not GetBoolean (attack, \"negated\") and not GetBoolean (attack, \"destroy\") and not HasAttribute (attack, \"deferred\")) {\n        list add (newattacks, attack)\n      }\n    }\n    else {\n      newattacks = NewObjectList()\n      if (not HasAttribute (attack, \"deferred\")) {\n        attack.deferred = \"not HasScript (game, \\\"menucallback\\\")\"\n      }\n    }\n  }\n  while (ListCount (attacks) &gt; 0) {\n    list remove (attacks, ListItem (attacks, 0))\n  }\n  foreach (attack, FilterByAttribute (newattacks, \"destroy\", true)) {\n    destroy (attack.name)\n  }\n  foreach (attack, newattacks) {\n    list add (attacks, newattacks)\n  }\n&lt;/function&gt;\n\n&lt;function name=\"GetEffects\" type=\"objectlist\" parameters=\"items\"&gt;\n  result = NewObjectList()\n  if (not EndsWith (TypeOf (items), \"list\")) {\n    item = items\n    items = NewObjectList()\n    list add (items, item)\n  }\n  foreach (item, items) {\n    list add (result, item)\n    foreach (effect, FilterByAttribute (GetDirectChildren(item), \"status_effect\", true)) {\n      list add (result, effect)\n    }\n    foreach (garment, GetWornFor (item)) {\n      foreach (effect, FilterByAttribute (GetDirectChildren (garment), \"status_effect\", true)) {\n        list add (result, effect)\n      }\n    }\n  }\n  return (result)\n&lt;/function&gt;\n\n&lt;function name=\"ListAllParents\" type=\"objectlist\" parameters=\"list\"&gt;&lt;![CDATA[\n  if (TypeOf (list) = \"object\") {\n    return (ListParents (object))\n  }\n  result = NewObjectList()\n  i = 0\n  while (i &lt; ListCount (list)) {\n    item = ListItem (list, i)\n    if (HasObject (item, \"parent\")) {\n      if (not ListContains (result, item.parent)) {\n        list add (list, item.parent)\n        list add (result, item.parent)\n      }\n    }\n    i = i + 1\n  }\n  return (result)\n]]&gt;&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2018-09-01T09:23:50.5666013Z",
      "LastEditDate": "2018-09-03T15:18:03.7992193Z",
      "link": null
    },
    {
      "PostId": "8b413d13-03a4-485b-89d1-62f0ed1f1a58",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK ... question for people who aren't so interested in reading through huge chunks of code.\r\n\r\nThe point of this was to make some core functions so that any type of attack you want to create can be done simply, with minimal code. And you can make your own weapons, spells and monsters without needing to understand how DoAttack() works, just like you can create your own commands and verbs without needing to understand how the parser functions work.\r\n\r\nSo… I *think* this should be able to handle any kind of attack you want to make.\r\nWhat kind of attack would you like to see?\r\n\r\nHere's one that comes to mind; a grenade:\r\n```\r\n<object name=\"grenades\">\r\n  <attr name=\"is_weapon\" type=\"boolean\">true</attr>\r\n  <number type=\"int\">7</number>\r\n  <look type=\"string\">A bunch of {this.number} grenades</look>\r\n  <damage type=\"int\">24</damage>\r\n  <elements type=\"simplestringlist\">fire;percussion</elements>\r\n  <attr name=\"attack_attributes\" type=\"simplestringlist\">elements</attr>\r\n\r\n  <beforeattack type=\"script\"><![CDATA[\r\n    // at the start of throwing the grenade, deduct 1 from the number the attacker is carrying\r\n    this.number = this.number - 1\r\n    if (this.number <= 0) {\r\n      if (Has (this)) {\r\n        msg (\"That was my last grenade.\")\r\n      }\r\n      RemoveObject (this)\r\n    }\r\n  ]]></beforeattack>\r\n\r\n  <aftermakeattack type=\"script\">\r\n    // after the grenade is thrown, make it visible, put it in the room with the target\r\n    // and set it to go off after 3 turns\r\n    attack.visible = true\r\n    attack.alias = \"grenade (LIVE!)\"\r\n    attack.look = \"The grenade looks like it's about to go off!\"\r\n    attack.deferred = 3\r\n    attack.take = true\r\n    attack.drop = true\r\n    attack.displayverbs = Split (\"look;take\")\r\n    attack.inventoryverbs = Split (\"look;drop\")\r\n    attack.parent = attack.target.parent\r\n    attack.message = \"{either Contains(target,attack):{=GetDisplayAlias(target)} was carrying a grenade. Bad idea:Exploding fragments do {attack.damage} damage to {=GetDisplayAlias(target)}}.\"\r\n  </aftermakeattack>\r\n\r\n  <onattack type=\"script\">\r\n    // The grenade is going off now, so work out who's within range\r\n    //    First, find the room containing the grenade, even if someone picked it up\r\n    room = attack.parent\r\n    while (not room = null and not GetBoolean (room, \"isroom\")) {\r\n      room = room.parent\r\n    }\r\n    if (room = null) {\r\n      attack.destroy = true\r\n    }\r\n    else {\r\n      // Set the grenade's targets to everyone in the room\r\n      msg (\"A grenade goes off in the \" + GetDisplayAlias (room) \".\")\r\n      attack.target = FilterByAttribute (GetDirectChildren (room), \"dead\", false)\r\n      // And make sure that anyone carrying the grenade suffers\r\n      attack.beforeresolveattack => {\r\n        if (Contains (target, attack)) {\r\n          attack.damage = attack.damage * GetRandomInt (5, 9)\r\n        }\r\n      }\r\n    }\r\n  </onattack>\r\n</object>\r\n```\r\n\r\nAnd here's a simple status effect that makes you immune to fire:\r\n```\r\n<object name=\"fireproof\">\r\n  <attr name=\"status_effect\" type=\"boolean\">true</attr>\r\n  <visible>false</visible>\r\n  <beforeresolveattack type=\"script\">\r\n    if (HasAttribute (attack, \"elements\")) {\r\n      if (ListContains (elements, \"fire\")) {\r\n        attack.destroy = true\r\n        if (not IsDefined (\"alias\")) {\r\n          alias = GetDisplayAlias (spell)\r\n        }\r\n        msg (CapFirst(GetDisplayAlias(this.parent)) + \" is protected from the \" + alias + \" by their Fireproof Aura.\")\r\n      }\r\n    }\r\n  </beforeresolveattack>\r\n</object>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>OK ... question for people who aren't so interested in reading through huge chunks of code.</p>\n<p>The point of this was to make some core functions so that any type of attack you want to create can be done simply, with minimal code. And you can make your own weapons, spells and monsters without needing to understand how DoAttack() works, just like you can create your own commands and verbs without needing to understand how the parser functions work.</p>\n<p>So… I <em>think</em> this should be able to handle any kind of attack you want to make.<br>\nWhat kind of attack would you like to see?</p>\n<p>Here's one that comes to mind; a grenade:</p>\n<pre><code>&lt;object name=\"grenades\"&gt;\n  &lt;attr name=\"is_weapon\" type=\"boolean\"&gt;true&lt;/attr&gt;\n  &lt;number type=\"int\"&gt;7&lt;/number&gt;\n  &lt;look type=\"string\"&gt;A bunch of {this.number} grenades&lt;/look&gt;\n  &lt;damage type=\"int\"&gt;24&lt;/damage&gt;\n  &lt;elements type=\"simplestringlist\"&gt;fire;percussion&lt;/elements&gt;\n  &lt;attr name=\"attack_attributes\" type=\"simplestringlist\"&gt;elements&lt;/attr&gt;\n\n  &lt;beforeattack type=\"script\"&gt;&lt;![CDATA[\n    // at the start of throwing the grenade, deduct 1 from the number the attacker is carrying\n    this.number = this.number - 1\n    if (this.number &lt;= 0) {\n      if (Has (this)) {\n        msg (\"That was my last grenade.\")\n      }\n      RemoveObject (this)\n    }\n  ]]&gt;&lt;/beforeattack&gt;\n\n  &lt;aftermakeattack type=\"script\"&gt;\n    // after the grenade is thrown, make it visible, put it in the room with the target\n    // and set it to go off after 3 turns\n    attack.visible = true\n    attack.alias = \"grenade (LIVE!)\"\n    attack.look = \"The grenade looks like it's about to go off!\"\n    attack.deferred = 3\n    attack.take = true\n    attack.drop = true\n    attack.displayverbs = Split (\"look;take\")\n    attack.inventoryverbs = Split (\"look;drop\")\n    attack.parent = attack.target.parent\n    attack.message = \"{either Contains(target,attack):{=GetDisplayAlias(target)} was carrying a grenade. Bad idea:Exploding fragments do {attack.damage} damage to {=GetDisplayAlias(target)}}.\"\n  &lt;/aftermakeattack&gt;\n\n  &lt;onattack type=\"script\"&gt;\n    // The grenade is going off now, so work out who's within range\n    //    First, find the room containing the grenade, even if someone picked it up\n    room = attack.parent\n    while (not room = null and not GetBoolean (room, \"isroom\")) {\n      room = room.parent\n    }\n    if (room = null) {\n      attack.destroy = true\n    }\n    else {\n      // Set the grenade's targets to everyone in the room\n      msg (\"A grenade goes off in the \" + GetDisplayAlias (room) \".\")\n      attack.target = FilterByAttribute (GetDirectChildren (room), \"dead\", false)\n      // And make sure that anyone carrying the grenade suffers\n      attack.beforeresolveattack =&gt; {\n        if (Contains (target, attack)) {\n          attack.damage = attack.damage * GetRandomInt (5, 9)\n        }\n      }\n    }\n  &lt;/onattack&gt;\n&lt;/object&gt;\n</code></pre>\n<p>And here's a simple status effect that makes you immune to fire:</p>\n<pre><code>&lt;object name=\"fireproof\"&gt;\n  &lt;attr name=\"status_effect\" type=\"boolean\"&gt;true&lt;/attr&gt;\n  &lt;visible&gt;false&lt;/visible&gt;\n  &lt;beforeresolveattack type=\"script\"&gt;\n    if (HasAttribute (attack, \"elements\")) {\n      if (ListContains (elements, \"fire\")) {\n        attack.destroy = true\n        if (not IsDefined (\"alias\")) {\n          alias = GetDisplayAlias (spell)\n        }\n        msg (CapFirst(GetDisplayAlias(this.parent)) + \" is protected from the \" + alias + \" by their Fireproof Aura.\")\n      }\n    }\n  &lt;/beforeresolveattack&gt;\n&lt;/object&gt;\n</code></pre>\n\n",
      "PostDate": "2018-09-01T22:38:20.2518089Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "fb0584b0-f311-417d-a5cd-9c90b6d23937",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yes, I'd like to see a new combat code, and I'd like to see how the attacking works for that code.",
      "EditableFormat": "markdown",
      "HTML": "<p>Yes, I'd like to see a new combat code, and I'd like to see how the attacking works for that code.</p>\n\n",
      "PostDate": "2018-09-03T00:34:39.988895Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "869cc07c-5081-41ad-91b2-b3df21e93042",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Looking forward to seeing how this turns out. I sent you a PM by the way (I have found the system flags them as read even when not sometimes, so you might not realise).",
      "EditableFormat": "markdown",
      "HTML": "<p>Looking forward to seeing how this turns out. I sent you a PM by the way (I have found the system flags them as read even when not sometimes, so you might not realise).</p>\n\n",
      "PostDate": "2018-09-03T08:38:43.7612003Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d2426f32-3e4d-4109-9782-e36af13bb19b",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Awesome work mrangel (along with all of the other stuff you've done too), been lurking on your posts/threads of quest code, and plan to study all of them, eventually. Thanks for the awesome code work you've done on everything, this post/thread, and others!",
      "EditableFormat": "markdown",
      "HTML": "<p>Awesome work mrangel (along with all of the other stuff you've done too), been lurking on your posts/threads of quest code, and plan to study all of them, eventually. Thanks for the awesome code work you've done on everything, this post/thread, and others!</p>\n\n",
      "PostDate": "2018-09-03T13:26:39.6256883Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "93253524-f185-49ff-b7b3-eca1ca6ad29f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This one's still got issues, but I think I can see the shape of it.\r\n\r\nThe functions probably need renaming, because it's not just for combat. It's a simple way to handle spellcasting as well, and it feels weird using a function called DoAttack() to apply a healing spell on someone.\r\n\r\nOff the top of my head, here's a couple of commands that could be useful:\r\n```\r\n<command name=\"attack\">\r\n  <pattern>attack #object#</pattern>\r\n  <script>\r\n    if (GetBoolean (object, \"dead\")) {\r\n      msg (CapFirst (WriteVerb(object, \"be\")) + \" already dead.\")\r\n    }\r\n    else if (HasBoolean (object, \"dead\")) {\r\n      DoAttack (game.pov, null, null, object)\r\n    }\r\n    else if (HasScript(object, \"attack\")) {\r\n      do (object, \"attack\")\r\n    }\r\n    else if (HasString(object, \"attack\")) {\r\n      game.text_processor_this = object\r\n      msg (object.attack)\r\n    }\r\n    else {\r\n      msg (\"That isn't something you can attack.\")\r\n    }\r\n  </script>\r\n<command>\r\n\r\n<command name=\"spellcast\">\r\n  <pattern>cast #object_spell# on #object_target#;cast #object_spell#</pattern>\r\n  <script>\r\n    if (not IsDefined (\"object_target\")) {\r\n      object_target = null\r\n    }\r\n    DoAttack (game.pov, null, object_spell, object_target)\r\n  </script>\r\n</command>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>This one's still got issues, but I think I can see the shape of it.</p>\n<p>The functions probably need renaming, because it's not just for combat. It's a simple way to handle spellcasting as well, and it feels weird using a function called DoAttack() to apply a healing spell on someone.</p>\n<p>Off the top of my head, here's a couple of commands that could be useful:</p>\n<pre><code>&lt;command name=\"attack\"&gt;\n  &lt;pattern&gt;attack #object#&lt;/pattern&gt;\n  &lt;script&gt;\n    if (GetBoolean (object, \"dead\")) {\n      msg (CapFirst (WriteVerb(object, \"be\")) + \" already dead.\")\n    }\n    else if (HasBoolean (object, \"dead\")) {\n      DoAttack (game.pov, null, null, object)\n    }\n    else if (HasScript(object, \"attack\")) {\n      do (object, \"attack\")\n    }\n    else if (HasString(object, \"attack\")) {\n      game.text_processor_this = object\n      msg (object.attack)\n    }\n    else {\n      msg (\"That isn't something you can attack.\")\n    }\n  &lt;/script&gt;\n&lt;command&gt;\n\n&lt;command name=\"spellcast\"&gt;\n  &lt;pattern&gt;cast #object_spell# on #object_target#;cast #object_spell#&lt;/pattern&gt;\n  &lt;script&gt;\n    if (not IsDefined (\"object_target\")) {\n      object_target = null\n    }\n    DoAttack (game.pov, null, object_spell, object_target)\n  &lt;/script&gt;\n&lt;/command&gt;\n</code></pre>\n\n",
      "PostDate": "2018-09-03T13:55:18.2705585Z",
      "LastEditDate": "2018-09-03T13:57:22.7917558Z",
      "link": null
    },
    {
      "PostId": "77c5b7f9-71f4-4e9a-ae59-cf3b775e6dfa",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Next step is making it work nicely with menus. I figure that a sword could have a script like:\r\n```\r\n<setspell type=\"script\">\r\n  if (not IsDefined (\"spell\")) {\r\n    // Assume this function returns a list of objects like \"stab\", \"slash\", \"Infinite Bladestorm\", etc\r\n    spells = GetWeaponAttackTypes (attacker, this)\r\n    if (attacker = game.pov) {\r\n      list add (spells, \"Cancel\")\r\n      ShowMenu (\"How do you want to attack?\", spells, false) {\r\n        if (result = \"Cancel\") {\r\n          attack.destroy = true\r\n        }\r\n        else {\r\n          attack.spell = GetObject (result)\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      // It's an NPC, so pick randomly\r\n      attack.spell = PickOneObject (spells)\r\n    }\r\n  }\r\n</setspell>\r\n```\r\nI *think* I can see a place in DoAttackPhase where it could check for the existence of `game.menucallback` and hold off running any of the remaining phases until next turn; as well as ensuring that all our variables are accessible within the menu callback.\r\n\r\nDo you think that would be useful? It's adding some fairly inscrutable code, but created with the intent that there will be no need for the user to modify it.",
      "EditableFormat": "markdown",
      "HTML": "<p>Next step is making it work nicely with menus. I figure that a sword could have a script like:</p>\n<pre><code>&lt;setspell type=\"script\"&gt;\n  if (not IsDefined (\"spell\")) {\n    // Assume this function returns a list of objects like \"stab\", \"slash\", \"Infinite Bladestorm\", etc\n    spells = GetWeaponAttackTypes (attacker, this)\n    if (attacker = game.pov) {\n      list add (spells, \"Cancel\")\n      ShowMenu (\"How do you want to attack?\", spells, false) {\n        if (result = \"Cancel\") {\n          attack.destroy = true\n        }\n        else {\n          attack.spell = GetObject (result)\n        }\n      }\n    }\n    else {\n      // It's an NPC, so pick randomly\n      attack.spell = PickOneObject (spells)\n    }\n  }\n&lt;/setspell&gt;\n</code></pre>\n<p>I <em>think</em> I can see a place in DoAttackPhase where it could check for the existence of <code>game.menucallback</code> and hold off running any of the remaining phases until next turn; as well as ensuring that all our variables are accessible within the menu callback.</p>\n<p>Do you think that would be useful? It's adding some fairly inscrutable code, but created with the intent that there will be no need for the user to modify it.</p>\n\n",
      "PostDate": "2018-09-03T15:30:48.1680246Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
