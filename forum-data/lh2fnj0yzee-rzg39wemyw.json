{
  "Topic": {
    "TopicId": "lh2fnj0yzee-rzg39wemyw",
    "ForumId": "18",
    "Title": "Turn Scripts, Turn Counts, and Multiple Commands (Another suppressturnscripts Adventure!)",
    "LastUpdated": "2018-05-23T02:37:19.4961695Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "207292d1-0680-4ef4-a20c-f7e8823bb20f",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have another fix for this which involves changes in the C# code, but, since the average user isn't building Quest in Visual Studio, I came up with this, too.\r\n\r\n### FOR DESKTOP USERS ONLY\r\n\r\nWe can modify the ```FinishTurn``` and ```ResolveNextName``` functions to make turn scripts and turn counts behave correctly when the player is allowed to enter multiple commands.\r\n\r\n**ResolveNextName (mod):**\r\n\r\n<details>\r\n\r\n```xml\r\n  <function name=\"ResolveNextName\"><![CDATA[\r\n    resolvedall = false\r\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\r\n    if (queuetype = \"stringlist\") {\r\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\r\n      if (queuelength > 0) {\r\n        // Pop next variable off the queue\r\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\r\n        if (queuelength = 1) {\r\n          game.pov.currentcommandvarlistqueue = null\r\n        }\r\n        else {\r\n          newqueue = NewStringList()\r\n          for (i, 1, queuelength - 1) {\r\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\r\n          }\r\n          game.pov.currentcommandvarlistqueue = newqueue\r\n        }\r\n        // Resolve variable\r\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n        if (value <> \"\") {\r\n          result = null\r\n          resolvinglist = false\r\n          // This is to resolve issue 626\r\n          if (StartsWith(var, \"objectexit\")) {\r\n            result = ResolveName(var, value, \"exit\")\r\n          }\r\n          if (result = null) {\r\n            if (StartsWith(var, \"object\")) {\r\n              if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\r\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\r\n                game.pov.currentcommandpendingvariable = var\r\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\r\n                ResolveNameList (value, \"object\")\r\n                resolvinglist = true\r\n              }\r\n              else {\r\n                result = ResolveName(var, value, \"object\")\r\n              }\r\n            }\r\n            else if (StartsWith(var, \"exit\")) {\r\n              result = ResolveName(var, value, \"exit\")\r\n            }\r\n            else if (StartsWith(var, \"text\")) {\r\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n            }\r\n            else {\r\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\r\n            }\r\n          }\r\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\r\n          if (result = null) {\r\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\r\n              UnresolvedCommand (value, var)\r\n            }\r\n          }\r\n          else {\r\n            AddToResolvedNames (var, result)\r\n          }\r\n        }\r\n        else {\r\n          ResolveNextName\r\n        }\r\n      }\r\n      else {\r\n        resolvedall = true\r\n      }\r\n    }\r\n    else if (queuetype = \"null\") {\r\n      resolvedall = true\r\n    }\r\n    else {\r\n      error (\"Invalid queue type\")\r\n    }\r\n    if (resolvedall) {\r\n      // All the objects have been resolved, so now we can actually do the command\r\n      // TO DO: game.lastobjects should be game.pov.lastobjects\r\n      game.lastobjects = game.pov.currentcommandresolvedobjects\r\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\r\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\r\n        if (LengthOf(game.pov.currentcommand) > 0) {\r\n          start transaction (game.pov.currentcommand)\r\n        }\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\r\n        // TO DO: game.unresolved* should be game.pov.unresolved*\r\n        game.unresolvedcommand = null\r\n        game.unresolvedcommandvarlist = null\r\n        game.unresolvedcommandkey = null\r\n      }\r\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n        // This is the bit that actually runs the commands\r\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n        // Next 2 lines modded by KV to fix issues with multiple commands\r\n        game.runturnscripts = true\r\n        FinishTurn\r\n        // END OF MOD\r\n      }\r\n      HandleNextCommandQueueItem\r\n    }\r\n  ]]></function>\r\n```\r\n\r\n</details>\r\n\r\n---\r\n**FinishTurn (mod):**\r\n\r\n<details>\r\n\r\n```xml\r\n  <function name=\"FinishTurn\">\r\n    // Modded by KV to handle multiple commands correctly\r\n    if (GetBoolean(game,\"runturnscripts\")) {\r\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\r\n        RunTurnScripts\r\n      }\r\n    }\r\n    game.runturnscripts = false\r\n    // END OF MOD\r\n    game.suppressturnscripts = false\r\n    UpdateStatusAttributes\r\n    CheckDarkness\r\n    UpdateObjectLinks\r\n  </function>\r\n```\r\n\r\n</details>\r\n\r\n---\r\nThe example game's code:\r\n\r\n<details>\r\n\r\n```xml\r\n<!--Saved by Quest 5.8.6708.15638-->\r\n<asl version=\"550\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Suppressing the Turn Scripts\">\r\n    <gameid>65c36394-fcd4-4abf-89a5-4d0659cb4ef7</gameid>\r\n    <version>0.6</version>\r\n    <firstpublished>2018</firstpublished>\r\n    <feature_advancedscripts />\r\n    <turns type=\"int\">0</turns>\r\n    <statusattributes type=\"stringdictionary\">\r\n      <item>\r\n        <key>turns</key>\r\n        <value>Turns: !</value>\r\n      </item>\r\n    </statusattributes>\r\n    <description><![CDATA[A test game.<br/><br/>Enter HINT:  no turn scripts, and no turn count<br/><br/>Enter TEST ONE: turn scripts fire once, and the turn count increases by 1<br/><br/>Enter TEST TWO:  no turn scripts, and no turn count]]></description>\r\n    <author>KV</author>\r\n    <suppressturnscripts type=\"boolean\">false</suppressturnscripts>\r\n    <multiplecommands />\r\n    <inituserinterface type=\"script\">\r\n      JS.eval (\"function testOne(){\tsetTimeout(function(){\t\tASLEvent('CallMeWithASL','The turn scripts fired once and the turn count increased by one.');\t\tif (webPlayer){\t\t  setTimeout(function(){\t\t    scrollToEnd();\t\t  },500);\t\t}\t},1);};\")\r\n      JS.eval (\"function testTwo(){\tsetTimeout(function(){\t\tASLEvent('CallMeWithASL','This suppressed the turn scripts and the turn count.');\t\tif (webPlayer){\t\t  setTimeout(function(){\t\t    scrollToEnd();\t\t  },500);\t\t}\t},1);};\")\r\n    </inituserinterface>\r\n  </game>\r\n  <turnscript name=\"test_turnscript\">\r\n    <enabled />\r\n    <script><![CDATA[\r\n      msg (\"<b><center><br/>I AM THE TEST TURNSCRIPT!<br/></center></b>\")\r\n    ]]></script>\r\n  </turnscript>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <description><![CDATA[<br/>Enter (or click):<br/>  {command:HINT}, {command:TEST ONE},  {command:TEST TWO},  {command:TEST ONE. TEST TWO}, or  {command:HINT. TEST TWO}]]></description>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n    </object>\r\n    <object name=\"Ralph\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"namedmale\" />\r\n    </object>\r\n  </object>\r\n  <command name=\"hint\">\r\n    <pattern>hint;hints</pattern>\r\n    <script>\r\n      game.suppressturnscripts = true\r\n      msg (\"This story has no hints.\")\r\n    </script>\r\n  </command>\r\n  <command name=\"testone\">\r\n    <pattern>test one</pattern>\r\n    <script>\r\n      JS.testOne ()\r\n    </script>\r\n  </command>\r\n  <command name=\"testtwo\">\r\n    <pattern>test two</pattern>\r\n    <script>\r\n      game.suppressturnscripts = true\r\n      JS.testTwo ()\r\n    </script>\r\n  </command>\r\n  <turnscript name=\"turn_count\">\r\n    <enabled />\r\n    <script>\r\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\r\n        IncreaseObjectCounter (game, \"turns\")\r\n      }\r\n    </script>\r\n  </turnscript>\r\n  <function name=\"ResolveNextName\"><![CDATA[\r\n    resolvedall = false\r\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\r\n    if (queuetype = \"stringlist\") {\r\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\r\n      if (queuelength > 0) {\r\n        // Pop next variable off the queue\r\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\r\n        if (queuelength = 1) {\r\n          game.pov.currentcommandvarlistqueue = null\r\n        }\r\n        else {\r\n          newqueue = NewStringList()\r\n          for (i, 1, queuelength - 1) {\r\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\r\n          }\r\n          game.pov.currentcommandvarlistqueue = newqueue\r\n        }\r\n        // Resolve variable\r\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n        if (value <> \"\") {\r\n          result = null\r\n          resolvinglist = false\r\n          // This is to resolve issue 626\r\n          if (StartsWith(var, \"objectexit\")) {\r\n            result = ResolveName(var, value, \"exit\")\r\n          }\r\n          if (result = null) {\r\n            if (StartsWith(var, \"object\")) {\r\n              if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\r\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\r\n                game.pov.currentcommandpendingvariable = var\r\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\r\n                ResolveNameList (value, \"object\")\r\n                resolvinglist = true\r\n              }\r\n              else {\r\n                result = ResolveName(var, value, \"object\")\r\n              }\r\n            }\r\n            else if (StartsWith(var, \"exit\")) {\r\n              result = ResolveName(var, value, \"exit\")\r\n            }\r\n            else if (StartsWith(var, \"text\")) {\r\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n            }\r\n            else {\r\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\r\n            }\r\n          }\r\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\r\n          if (result = null) {\r\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\r\n              UnresolvedCommand (value, var)\r\n            }\r\n          }\r\n          else {\r\n            AddToResolvedNames (var, result)\r\n          }\r\n        }\r\n        else {\r\n          ResolveNextName\r\n        }\r\n      }\r\n      else {\r\n        resolvedall = true\r\n      }\r\n    }\r\n    else if (queuetype = \"null\") {\r\n      resolvedall = true\r\n    }\r\n    else {\r\n      error (\"Invalid queue type\")\r\n    }\r\n    if (resolvedall) {\r\n      // All the objects have been resolved, so now we can actually do the command\r\n      // TO DO: game.lastobjects should be game.pov.lastobjects\r\n      game.lastobjects = game.pov.currentcommandresolvedobjects\r\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\r\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\r\n        if (LengthOf(game.pov.currentcommand) > 0) {\r\n          start transaction (game.pov.currentcommand)\r\n        }\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\r\n        // TO DO: game.unresolved* should be game.pov.unresolved*\r\n        game.unresolvedcommand = null\r\n        game.unresolvedcommandvarlist = null\r\n        game.unresolvedcommandkey = null\r\n      }\r\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n        // This is the bit that actually runs the commands\r\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n        game.runturnscripts = true\r\n        FinishTurn\r\n      }\r\n      HandleNextCommandQueueItem\r\n    }\r\n  ]]></function>\r\n  <function name=\"FinishTurn\">\r\n    if (GetBoolean(game,\"runturnscripts\")) {\r\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\r\n        RunTurnScripts\r\n      }\r\n    }\r\n    game.runturnscripts = false\r\n    game.suppressturnscripts = false\r\n    UpdateStatusAttributes\r\n    CheckDarkness\r\n    UpdateObjectLinks\r\n  </function>\r\n  <function name=\"CallMeWithASL\" parameters=\"data\">\r\n    msg (data)\r\n  </function>\r\n</asl>\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I have another fix for this which involves changes in the C# code, but, since the average user isn't building Quest in Visual Studio, I came up with this, too.</p>\n<h3>FOR DESKTOP USERS ONLY</h3>\n<p>We can modify the <code>FinishTurn</code> and <code>ResolveNextName</code> functions to make turn scripts and turn counts behave correctly when the player is allowed to enter multiple commands.</p>\n<p><strong>ResolveNextName (mod):</strong></p>\n<details>\n<pre><code>  &lt;function name=\"ResolveNextName\"&gt;&lt;![CDATA[\n    resolvedall = false\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\n    if (queuetype = \"stringlist\") {\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\n      if (queuelength &gt; 0) {\n        // Pop next variable off the queue\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\n        if (queuelength = 1) {\n          game.pov.currentcommandvarlistqueue = null\n        }\n        else {\n          newqueue = NewStringList()\n          for (i, 1, queuelength - 1) {\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\n          }\n          game.pov.currentcommandvarlistqueue = newqueue\n        }\n        // Resolve variable\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n        if (value &lt;&gt; \"\") {\n          result = null\n          resolvinglist = false\n          // This is to resolve issue 626\n          if (StartsWith(var, \"objectexit\")) {\n            result = ResolveName(var, value, \"exit\")\n          }\n          if (result = null) {\n            if (StartsWith(var, \"object\")) {\n              if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\n                game.pov.currentcommandpendingvariable = var\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\n                ResolveNameList (value, \"object\")\n                resolvinglist = true\n              }\n              else {\n                result = ResolveName(var, value, \"object\")\n              }\n            }\n            else if (StartsWith(var, \"exit\")) {\n              result = ResolveName(var, value, \"exit\")\n            }\n            else if (StartsWith(var, \"text\")) {\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n            }\n            else {\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\n            }\n          }\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\n          if (result = null) {\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\n              UnresolvedCommand (value, var)\n            }\n          }\n          else {\n            AddToResolvedNames (var, result)\n          }\n        }\n        else {\n          ResolveNextName\n        }\n      }\n      else {\n        resolvedall = true\n      }\n    }\n    else if (queuetype = \"null\") {\n      resolvedall = true\n    }\n    else {\n      error (\"Invalid queue type\")\n    }\n    if (resolvedall) {\n      // All the objects have been resolved, so now we can actually do the command\n      // TO DO: game.lastobjects should be game.pov.lastobjects\n      game.lastobjects = game.pov.currentcommandresolvedobjects\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\n        if (LengthOf(game.pov.currentcommand) &gt; 0) {\n          start transaction (game.pov.currentcommand)\n        }\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\n        // TO DO: game.unresolved* should be game.pov.unresolved*\n        game.unresolvedcommand = null\n        game.unresolvedcommandvarlist = null\n        game.unresolvedcommandkey = null\n      }\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n        // This is the bit that actually runs the commands\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n        // Next 2 lines modded by KV to fix issues with multiple commands\n        game.runturnscripts = true\n        FinishTurn\n        // END OF MOD\n      }\n      HandleNextCommandQueueItem\n    }\n  ]]&gt;&lt;/function&gt;\n</code></pre>\n</details>\n<hr>\n<p><strong>FinishTurn (mod):</strong></p>\n<details>\n<pre><code>  &lt;function name=\"FinishTurn\"&gt;\n    // Modded by KV to handle multiple commands correctly\n    if (GetBoolean(game,\"runturnscripts\")) {\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\n        RunTurnScripts\n      }\n    }\n    game.runturnscripts = false\n    // END OF MOD\n    game.suppressturnscripts = false\n    UpdateStatusAttributes\n    CheckDarkness\n    UpdateObjectLinks\n  &lt;/function&gt;\n</code></pre>\n</details>\n<hr>\n<p>The example game's code:</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.8.6708.15638--&gt;\n&lt;asl version=\"550\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Suppressing the Turn Scripts\"&gt;\n    &lt;gameid&gt;65c36394-fcd4-4abf-89a5-4d0659cb4ef7&lt;/gameid&gt;\n    &lt;version&gt;0.6&lt;/version&gt;\n    &lt;firstpublished&gt;2018&lt;/firstpublished&gt;\n    &lt;feature_advancedscripts /&gt;\n    &lt;turns type=\"int\"&gt;0&lt;/turns&gt;\n    &lt;statusattributes type=\"stringdictionary\"&gt;\n      &lt;item&gt;\n        &lt;key&gt;turns&lt;/key&gt;\n        &lt;value&gt;Turns: !&lt;/value&gt;\n      &lt;/item&gt;\n    &lt;/statusattributes&gt;\n    &lt;description&gt;&lt;![CDATA[A test game.&lt;br/&gt;&lt;br/&gt;Enter HINT:  no turn scripts, and no turn count&lt;br/&gt;&lt;br/&gt;Enter TEST ONE: turn scripts fire once, and the turn count increases by 1&lt;br/&gt;&lt;br/&gt;Enter TEST TWO:  no turn scripts, and no turn count]]&gt;&lt;/description&gt;\n    &lt;author&gt;KV&lt;/author&gt;\n    &lt;suppressturnscripts type=\"boolean\"&gt;false&lt;/suppressturnscripts&gt;\n    &lt;multiplecommands /&gt;\n    &lt;inituserinterface type=\"script\"&gt;\n      JS.eval (\"function testOne(){\tsetTimeout(function(){\t\tASLEvent('CallMeWithASL','The turn scripts fired once and the turn count increased by one.');\t\tif (webPlayer){\t\t  setTimeout(function(){\t\t    scrollToEnd();\t\t  },500);\t\t}\t},1);};\")\n      JS.eval (\"function testTwo(){\tsetTimeout(function(){\t\tASLEvent('CallMeWithASL','This suppressed the turn scripts and the turn count.');\t\tif (webPlayer){\t\t  setTimeout(function(){\t\t    scrollToEnd();\t\t  },500);\t\t}\t},1);};\")\n    &lt;/inituserinterface&gt;\n  &lt;/game&gt;\n  &lt;turnscript name=\"test_turnscript\"&gt;\n    &lt;enabled /&gt;\n    &lt;script&gt;&lt;![CDATA[\n      msg (\"&lt;b&gt;&lt;center&gt;&lt;br/&gt;I AM THE TEST TURNSCRIPT!&lt;br/&gt;&lt;/center&gt;&lt;/b&gt;\")\n    ]]&gt;&lt;/script&gt;\n  &lt;/turnscript&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;description&gt;&lt;![CDATA[&lt;br/&gt;Enter (or click):&lt;br/&gt;  {command:HINT}, {command:TEST ONE},  {command:TEST TWO},  {command:TEST ONE. TEST TWO}, or  {command:HINT. TEST TWO}]]&gt;&lt;/description&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n    &lt;/object&gt;\n    &lt;object name=\"Ralph\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"namedmale\" /&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;command name=\"hint\"&gt;\n    &lt;pattern&gt;hint;hints&lt;/pattern&gt;\n    &lt;script&gt;\n      game.suppressturnscripts = true\n      msg (\"This story has no hints.\")\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;command name=\"testone\"&gt;\n    &lt;pattern&gt;test one&lt;/pattern&gt;\n    &lt;script&gt;\n      JS.testOne ()\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;command name=\"testtwo\"&gt;\n    &lt;pattern&gt;test two&lt;/pattern&gt;\n    &lt;script&gt;\n      game.suppressturnscripts = true\n      JS.testTwo ()\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;turnscript name=\"turn_count\"&gt;\n    &lt;enabled /&gt;\n    &lt;script&gt;\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\n        IncreaseObjectCounter (game, \"turns\")\n      }\n    &lt;/script&gt;\n  &lt;/turnscript&gt;\n  &lt;function name=\"ResolveNextName\"&gt;&lt;![CDATA[\n    resolvedall = false\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\n    if (queuetype = \"stringlist\") {\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\n      if (queuelength &gt; 0) {\n        // Pop next variable off the queue\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\n        if (queuelength = 1) {\n          game.pov.currentcommandvarlistqueue = null\n        }\n        else {\n          newqueue = NewStringList()\n          for (i, 1, queuelength - 1) {\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\n          }\n          game.pov.currentcommandvarlistqueue = newqueue\n        }\n        // Resolve variable\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n        if (value &lt;&gt; \"\") {\n          result = null\n          resolvinglist = false\n          // This is to resolve issue 626\n          if (StartsWith(var, \"objectexit\")) {\n            result = ResolveName(var, value, \"exit\")\n          }\n          if (result = null) {\n            if (StartsWith(var, \"object\")) {\n              if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\n                game.pov.currentcommandpendingvariable = var\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\n                ResolveNameList (value, \"object\")\n                resolvinglist = true\n              }\n              else {\n                result = ResolveName(var, value, \"object\")\n              }\n            }\n            else if (StartsWith(var, \"exit\")) {\n              result = ResolveName(var, value, \"exit\")\n            }\n            else if (StartsWith(var, \"text\")) {\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n            }\n            else {\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\n            }\n          }\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\n          if (result = null) {\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\n              UnresolvedCommand (value, var)\n            }\n          }\n          else {\n            AddToResolvedNames (var, result)\n          }\n        }\n        else {\n          ResolveNextName\n        }\n      }\n      else {\n        resolvedall = true\n      }\n    }\n    else if (queuetype = \"null\") {\n      resolvedall = true\n    }\n    else {\n      error (\"Invalid queue type\")\n    }\n    if (resolvedall) {\n      // All the objects have been resolved, so now we can actually do the command\n      // TO DO: game.lastobjects should be game.pov.lastobjects\n      game.lastobjects = game.pov.currentcommandresolvedobjects\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\n        if (LengthOf(game.pov.currentcommand) &gt; 0) {\n          start transaction (game.pov.currentcommand)\n        }\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\n        // TO DO: game.unresolved* should be game.pov.unresolved*\n        game.unresolvedcommand = null\n        game.unresolvedcommandvarlist = null\n        game.unresolvedcommandkey = null\n      }\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n        // This is the bit that actually runs the commands\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n        game.runturnscripts = true\n        FinishTurn\n      }\n      HandleNextCommandQueueItem\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"FinishTurn\"&gt;\n    if (GetBoolean(game,\"runturnscripts\")) {\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\n        RunTurnScripts\n      }\n    }\n    game.runturnscripts = false\n    game.suppressturnscripts = false\n    UpdateStatusAttributes\n    CheckDarkness\n    UpdateObjectLinks\n  &lt;/function&gt;\n  &lt;function name=\"CallMeWithASL\" parameters=\"data\"&gt;\n    msg (data)\n  &lt;/function&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-05-23T02:37:19.4961695Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b98d0c26-b695-4048-a417-69e7258d86c5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmm...\r\nIf you set `game.suppressturnscripts = true` within a turnscript, it will suppress turnscripts for the next command executed in the current turn, or do nothing if there are no more commands this turn.\r\n\r\nI'm not sure if there's any reason you'd ever do that, but it's certainly an unexpected behaviour.\r\n\r\nAlso, turnscripts that do things like modify the UI don't need to run once per command; and if they're interacting with JS this could break stuff unpredictably. Similarly, you only want to run turnscripts after each command, not all the other stuff in FinishTurn.\r\n\r\nAlso, if you have turnscripts doing stuff like keeping JS and Quest variables in sync, you want them to run even if a turn isn't a real turn; there should be some mechanism for making specific turnscripts \"immune\" to `suppressturnscripts`. In this case, you'd have to remove the \"suppress\" check from FinishTurn into RunTurnScripts.\r\n\r\nI'd instead change the first function to include:\r\n```\r\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n        // This is the bit that actually runs the commands\r\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n        RunCommandTurnScripts()\r\n      }\r\n```\r\nAnd then…\r\n```\r\n  <function name=\"RunCommandTurnScripts\">\r\n    if (IsGameRunning()) {\r\n      if (game.menucallback = null) {\r\n        scripts = ObjectListSort(FilterByAttribute(AllTurnScripts(), \"percommand\", true), \"name\")\r\n        if (GetBoolean (game, \"suppressturnscripts\")) {\r\n          game.commandturnscriptssuppressed = true\r\n          game.suppressturnscripts = false\r\n          scripts = FilterByAttribute (scripts, \"always\", true)\r\n        }\r\n        foreach (turnscript, scripts) {\r\n          if (GetBoolean(turnscript, \"enabled\")) {\r\n            inscope = false\r\n            if (turnscript.parent = game or turnscript.parent = null) {\r\n              inscope = true\r\n            } else {\r\n              if (Contains(turnscript.parent, game.pov)) {\r\n                inscope = true\r\n              }\r\n            }\r\n            if (inscope) {\r\n              do (turnscript, \"script\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  </function>\r\n\r\n  <function name=\"RunTurnScripts\">\r\n    if (IsGameRunning()) {\r\n      if (game.menucallback = null) {\r\n        scripts = ObjectListSort(FilterByNotAttribute(AllTurnScripts(), \"percommand\", true), \"name\")\r\n        if (GetBoolean(game, \"commandturnscriptssuppressed\")) {\r\n          scripts = FilterByAttribute (scripts, \"always\", true)\r\n          game.commandturnscriptssuppressed = false\r\n        }\r\n        else if (GetBoolean(game, \"suppressturnscripts\")) {\r\n          scripts = FilterByAttribute (scripts, \"always\", true)\r\n        }\r\n        game.suppressturnscripts = false\r\n        foreach (turnscript, scripts) {\r\n          if (GetBoolean(turnscript, \"enabled\")) {\r\n            inscope = false\r\n            if (turnscript.parent = game or turnscript.parent = null) {\r\n              inscope = true\r\n            } else {\r\n              if (Contains(turnscript.parent, game.pov)) {\r\n                inscope = true\r\n              }\r\n            }\r\n            if (inscope) {\r\n              do (turnscript, \"script\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  </function>\r\n\r\n  <function name=\"FinishTurn\">\r\n    RunTurnScripts\r\n    UpdateStatusAttributes\r\n    CheckDarkness\r\n    UpdateObjectLinks\r\n  </function>\r\n```\r\nSo now you can give a turnscript a boolean attribute/flag `percommand` which causes it to run after each command rather than at the end of the turn, and a flag `always` which causes it to ignore  `game.suppressturnscripts`.\r\n\r\nAt the moment, suppressturnscripts suppresses both the ones after this command, and the ones after each turn. If the a turnscript sets `suppressturnscripts` to true, it will stop the ones at the end of the turn, and the turnscripts on the subsequent command this turn if there is one. Not sure that's any more useful behaviour, but it seems more consistent.\r\n\r\n(And yes, I'm throwing myself into code as a way to escape rising panic over non-sales of <a href=\"https://smarturl.it/whitebox\">my new book</a>, whose pre-orders are currently low enough that Amazon will probably fail to notify people following my author page when it comes out. If I'm not coherent, just ignore me)",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmm...<br>\nIf you set <code>game.suppressturnscripts = true</code> within a turnscript, it will suppress turnscripts for the next command executed in the current turn, or do nothing if there are no more commands this turn.</p>\n<p>I'm not sure if there's any reason you'd ever do that, but it's certainly an unexpected behaviour.</p>\n<p>Also, turnscripts that do things like modify the UI don't need to run once per command; and if they're interacting with JS this could break stuff unpredictably. Similarly, you only want to run turnscripts after each command, not all the other stuff in FinishTurn.</p>\n<p>Also, if you have turnscripts doing stuff like keeping JS and Quest variables in sync, you want them to run even if a turn isn't a real turn; there should be some mechanism for making specific turnscripts \"immune\" to <code>suppressturnscripts</code>. In this case, you'd have to remove the \"suppress\" check from FinishTurn into RunTurnScripts.</p>\n<p>I'd instead change the first function to include:</p>\n<pre><code>      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n        // This is the bit that actually runs the commands\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n        RunCommandTurnScripts()\n      }\n</code></pre>\n<p>And then…</p>\n<pre><code>  &lt;function name=\"RunCommandTurnScripts\"&gt;\n    if (IsGameRunning()) {\n      if (game.menucallback = null) {\n        scripts = ObjectListSort(FilterByAttribute(AllTurnScripts(), \"percommand\", true), \"name\")\n        if (GetBoolean (game, \"suppressturnscripts\")) {\n          game.commandturnscriptssuppressed = true\n          game.suppressturnscripts = false\n          scripts = FilterByAttribute (scripts, \"always\", true)\n        }\n        foreach (turnscript, scripts) {\n          if (GetBoolean(turnscript, \"enabled\")) {\n            inscope = false\n            if (turnscript.parent = game or turnscript.parent = null) {\n              inscope = true\n            } else {\n              if (Contains(turnscript.parent, game.pov)) {\n                inscope = true\n              }\n            }\n            if (inscope) {\n              do (turnscript, \"script\")\n            }\n          }\n        }\n      }\n    }\n  &lt;/function&gt;\n\n  &lt;function name=\"RunTurnScripts\"&gt;\n    if (IsGameRunning()) {\n      if (game.menucallback = null) {\n        scripts = ObjectListSort(FilterByNotAttribute(AllTurnScripts(), \"percommand\", true), \"name\")\n        if (GetBoolean(game, \"commandturnscriptssuppressed\")) {\n          scripts = FilterByAttribute (scripts, \"always\", true)\n          game.commandturnscriptssuppressed = false\n        }\n        else if (GetBoolean(game, \"suppressturnscripts\")) {\n          scripts = FilterByAttribute (scripts, \"always\", true)\n        }\n        game.suppressturnscripts = false\n        foreach (turnscript, scripts) {\n          if (GetBoolean(turnscript, \"enabled\")) {\n            inscope = false\n            if (turnscript.parent = game or turnscript.parent = null) {\n              inscope = true\n            } else {\n              if (Contains(turnscript.parent, game.pov)) {\n                inscope = true\n              }\n            }\n            if (inscope) {\n              do (turnscript, \"script\")\n            }\n          }\n        }\n      }\n    }\n  &lt;/function&gt;\n\n  &lt;function name=\"FinishTurn\"&gt;\n    RunTurnScripts\n    UpdateStatusAttributes\n    CheckDarkness\n    UpdateObjectLinks\n  &lt;/function&gt;\n</code></pre>\n<p>So now you can give a turnscript a boolean attribute/flag <code>percommand</code> which causes it to run after each command rather than at the end of the turn, and a flag <code>always</code> which causes it to ignore  <code>game.suppressturnscripts</code>.</p>\n<p>At the moment, suppressturnscripts suppresses both the ones after this command, and the ones after each turn. If the a turnscript sets <code>suppressturnscripts</code> to true, it will stop the ones at the end of the turn, and the turnscripts on the subsequent command this turn if there is one. Not sure that's any more useful behaviour, but it seems more consistent.</p>\n<p>(And yes, I'm throwing myself into code as a way to escape rising panic over non-sales of <a href=\"https://smarturl.it/whitebox\">my new book</a>, whose pre-orders are currently low enough that Amazon will probably fail to notify people following my author page when it comes out. If I'm not coherent, just ignore me)</p>\n\n",
      "PostDate": "2018-05-23T12:09:05.1144514Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "45b08284-c737-47cd-a75a-5bba533a693f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Also: I notice that if a command runs ShowMenu, it will suppress all turnscripts until the menu is either answered or ignored. But the same doesn't apply for Ask. This seems an odd distinction. In that case, should `always` scripts still run?\r\n\r\n(Answering myself: Yes they should. If the player types \"put box on table. eat poison. put apple in box.\" and the poison displays an \"are you sure?\" menu, the turnscript that handles indenting of the places/objects pane should still run)\r\n\r\nActually… I think rather than having RunTurnScripts check for a menu callback, we should have ShowMenu set suppressturnscripts. (Is that how it works in 5.8? I haven't checked. If so, remove the menucallback check from the code I just posted). This way, if the user wants to show a menu without suppressing turnscripts for some reason (for example, if it's a conversation menu and you want the in-game clock to increment after each line) you can just set the flag to false again after displaying the menu.",
      "EditableFormat": "markdown",
      "HTML": "<p>Also: I notice that if a command runs ShowMenu, it will suppress all turnscripts until the menu is either answered or ignored. But the same doesn't apply for Ask. This seems an odd distinction. In that case, should <code>always</code> scripts still run?</p>\n<p>(Answering myself: Yes they should. If the player types \"put box on table. eat poison. put apple in box.\" and the poison displays an \"are you sure?\" menu, the turnscript that handles indenting of the places/objects pane should still run)</p>\n<p>Actually… I think rather than having RunTurnScripts check for a menu callback, we should have ShowMenu set suppressturnscripts. (Is that how it works in 5.8? I haven't checked. If so, remove the menucallback check from the code I just posted). This way, if the user wants to show a menu without suppressing turnscripts for some reason (for example, if it's a conversation menu and you want the in-game clock to increment after each line) you can just set the flag to false again after displaying the menu.</p>\n\n",
      "PostDate": "2018-05-23T12:19:40.9692641Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b3e5283e-f0df-4c0c-9550-759dafca861a",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Off-topic, I always defend the forum when someone else brings this up, but it really sucks when I can't find code from older threads.\r\n\r\n...and I know: it's all about my search terms.\r\n\r\n[Expletive deleted]... I forgot what I was even looking for now...\r\n\r\nOh yeah!   You (mrangel) had code to override scripts during play.  It created a dictionary (if nonexistent) and added the script(s) to it, so we could easily do things in the same vein of ```var clearScreenBak = clearScreen;function clearScreen(){clearScreenBak();addTextAndScroll('Thank you for clearing the screen!  (Oh... I guess this text just defeated the purpose, huh?')``` with Quest scripts.",
      "EditableFormat": "markdown",
      "HTML": "<p>Off-topic, I always defend the forum when someone else brings this up, but it really sucks when I can't find code from older threads.</p>\n<p>...and I know: it's all about my search terms.</p>\n<p>[Expletive deleted]... I forgot what I was even looking for now...</p>\n<p>Oh yeah!   You (mrangel) had code to override scripts during play.  It created a dictionary (if nonexistent) and added the script(s) to it, so we could easily do things in the same vein of <code>var clearScreenBak = clearScreen;function clearScreen(){clearScreenBak();addTextAndScroll('Thank you for clearing the screen! (Oh... I guess this text just defeated the purpose, huh?')</code> with Quest scripts.</p>\n\n",
      "PostDate": "2018-05-23T12:33:54.3209139Z",
      "LastEditDate": "2018-05-23T12:34:41.3150464Z",
      "link": null
    },
    {
      "PostId": "c7c8f0fe-abc5-4c86-b8b0-a63c8baa3875",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I've done variations on that a few times; but it's ugly and doesn't work with functions ):",
      "EditableFormat": "markdown",
      "HTML": "<p>I've done variations on that a few times; but it's ugly and doesn't work with functions ):</p>\n\n",
      "PostDate": "2018-05-23T12:41:12.7067092Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4645fe1c-3453-4987-b0b6-c52e35e6b4ce",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> doesn't work with functions\r\n\r\nThe \"F\" word...",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>doesn't work with functions</p>\n</blockquote>\n<p>The \"F\" word...</p>\n\n",
      "PostDate": "2018-05-23T12:52:51.0489486Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "eb83ceeb-4b2c-4799-a35b-9696670015d6",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  I think rather than having RunTurnScripts check for a menu callback, we should have ShowMenu set suppressturnscripts. (Is that how it works in 5.8? I haven't checked.\r\n\r\nI don't think it works this way.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I think rather than having RunTurnScripts check for a menu callback, we should have ShowMenu set suppressturnscripts. (Is that how it works in 5.8? I haven't checked.</p>\n</blockquote>\n<p>I don't think it works this way.</p>\n\n",
      "PostDate": "2018-05-23T13:32:58.1767712Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "30946f22-5332-483d-a5c9-83c831fe2566",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Silly example comes to mind:\r\n\r\n>*You can see: A table (on which there is a plate (on which there is bacon))*\r\n>\r\n>==> get bacon\r\n> *You take it. It's hot. Would you like to eat it before it cools down?*\r\n>\r\n> **Eat bacon?**\r\n> 1. Yes\r\n> 2. Yes!\r\n> 3. YES!\r\n>\r\n>==>\r\n\r\nYou've just picked up the bacon. It's in the inventory pane now. But it's still got `&nbsp;&nbsp;&nbsp;&nbsp;` at the start of its listalias, because the menu prevented turnscripts from running.\r\n\r\nSo, in the last blocks of code I posted, I'd say remove both `if (game.menucallback = null) {` checks, and either:\r\n\r\n1. Change `if (GetBoolean(game, \"suppressturnscripts\"))` to `if (GetBoolean(game, \"suppressturnscripts\") or HasScript(game, \"menucallback\"))`\r\n\r\nOR\r\n\r\n2. Add `game.suppressturnscripts = true` to the ShowMenu function.",
      "EditableFormat": "markdown",
      "HTML": "<p>Silly example comes to mind:</p>\n<blockquote>\n<p><em>You can see: A table (on which there is a plate (on which there is bacon))</em></p>\n<p>==&gt; get bacon<br>\n<em>You take it. It's hot. Would you like to eat it before it cools down?</em></p>\n<p><strong>Eat bacon?</strong></p>\n<ol>\n<li>Yes</li>\n<li>Yes!</li>\n<li>YES!</li>\n</ol>\n<p>==&gt;</p>\n</blockquote>\n<p>You've just picked up the bacon. It's in the inventory pane now. But it's still got <code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</code> at the start of its listalias, because the menu prevented turnscripts from running.</p>\n<p>So, in the last blocks of code I posted, I'd say remove both <code>if (game.menucallback = null) {</code> checks, and either:</p>\n<ol>\n<li>Change <code>if (GetBoolean(game, \"suppressturnscripts\"))</code> to <code>if (GetBoolean(game, \"suppressturnscripts\") or HasScript(game, \"menucallback\"))</code></li>\n</ol>\n<p>OR</p>\n<ol start=\"2\">\n<li>Add <code>game.suppressturnscripts = true</code> to the ShowMenu function.</li>\n</ol>\n\n",
      "PostDate": "2018-05-23T14:20:09.5722882Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3bcc1981-e425-416c-b559-28657e2ded38",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Awesome!\r\n\r\nThank you!",
      "EditableFormat": "markdown",
      "HTML": "<p>Awesome!</p>\n<p>Thank you!</p>\n\n",
      "PostDate": "2018-05-23T18:34:30.1551795Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "04006330-d03f-4c3b-a932-f3b66a388117",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmm… I'm assuming that the turnscript created by SetTurnTimeout should not have `always` set; but should it have `percommand`?\r\n\r\nI'd say no, so as not to unexpectedly change the behaviour of games when Quest is updated. But maybe there should be a parallel function:\r\n```\r\n  <function name=\"SetCommandTimeout\" parameters=\"commandcount, script\">\r\n    name = GetUniqueElementName(\"turnscript\")\r\n    SetTurnTimeoutID (commandcount, name, script)\r\n    turnscript = GetObject (name)\r\n    if (not turnscript = null) {\r\n      turnscript.percommand = true\r\n    }\r\n  </function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmm… I'm assuming that the turnscript created by SetTurnTimeout should not have <code>always</code> set; but should it have <code>percommand</code>?</p>\n<p>I'd say no, so as not to unexpectedly change the behaviour of games when Quest is updated. But maybe there should be a parallel function:</p>\n<pre><code>  &lt;function name=\"SetCommandTimeout\" parameters=\"commandcount, script\"&gt;\n    name = GetUniqueElementName(\"turnscript\")\n    SetTurnTimeoutID (commandcount, name, script)\n    turnscript = GetObject (name)\n    if (not turnscript = null) {\n      turnscript.percommand = true\n    }\n  &lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2018-05-23T19:27:50.1946316Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "a60705e5-3e34-4466-8079-1d6a43e2bd67",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  I notice that if a command runs ShowMenu, it will suppress all turnscripts until the menu is either answered or ignored. But the same doesn't apply for Ask. This seems an odd distinction. In that case, should always scripts still run?\r\n\r\nI really wish I'd have seen this bit!  (My fault for perusing when I should be reading!)\r\n\r\nFix:\r\n\r\n```\r\n <function name=\"ShowMenuResponse\" parameters=\"option\">\r\n    if (game.menucallback = null) {\r\n      error (\"Unexpected menu response\")\r\n    }\r\n    else {\r\n      parameters = NewStringDictionary()\r\n      dictionary add (parameters, \"result\", UnescapeQuotes(option))\r\n      script = game.menucallback\r\n      ClearMenu\r\n      if (not GetBoolean(game, \"disambiguating\")) {\r\n        game.runturnscripts = true\r\n      }\r\n      game.disambiguating = false\r\n      invoke (script, parameters)\r\n    }\r\n  </function>\r\n```\r\n```\r\n  <function name=\"ResolveNameFromList\" parameters=\"variable, value, objtype, scope, secondaryscope\" type=\"object\"><![CDATA[\r\n    value = Trim(LCase(value))\r\n    fullmatches = NewObjectList()\r\n    partialmatches = NewObjectList()\r\n    foreach (obj, scope) {\r\n      name = LCase(GetDisplayAlias(obj))\r\n      CompareNames (name, value, obj, fullmatches, partialmatches)\r\n      if (obj.alt <> null) {\r\n        foreach (altname, obj.alt) {\r\n          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\r\n        }\r\n      }\r\n    }\r\n    // allow referring to objects from the previous command by gender or article\r\n    if (objtype = \"object\" and game.lastobjects <> null) {\r\n      foreach (obj, game.lastobjects) {\r\n        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)\r\n        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)\r\n      }\r\n    }\r\n    // Also check the secondary scope, but only if we have not found anything yet\r\n    if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 0 and not secondaryscope = null) {\r\n      foreach (obj, secondaryscope) {\r\n        name = LCase(GetDisplayAlias(obj))\r\n        CompareNames (name, value, obj, fullmatches, partialmatches)\r\n        if (obj.alt <> null) {\r\n          foreach (altname, obj.alt) {\r\n            CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (ListCount(fullmatches) = 1) {\r\n      return (ListItem(fullmatches, 0))\r\n    }\r\n    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {\r\n      return (ListItem(partialmatches, 0))\r\n    }\r\n    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {\r\n      return (null)\r\n    }\r\n    else {\r\n      game.disambiguating = true\r\n      candidates = ListCompact(ListCombine(fullmatches, partialmatches))\r\n      if (LengthOf(variable) > 0) {\r\n        // single object command, so after showing the menu, add the object to game.pov.currentcommandresolvedelements\r\n        game.pov.currentcommandpendingvariable = variable\r\n        ShowMenu (DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\r\n          varname = game.pov.currentcommandpendingvariable\r\n          game.pov.currentcommandpendingvariable = null\r\n          if (result <> null) {\r\n            AddToResolvedNames (varname, GetObject(result))\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        // multi-object command, so after showing the menu, add the object to the list\r\n        game.pov.currentcommandmultiobjectpending = true\r\n        ShowMenu (DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\r\n          if (result <> null) {\r\n            list add (game.pov.currentcommandpendingobjectlist, GetObject(result))\r\n            ResolveNextNameListItem\r\n          }\r\n        }\r\n      }\r\n      return (null)\r\n    }\r\n  ]]></function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I notice that if a command runs ShowMenu, it will suppress all turnscripts until the menu is either answered or ignored. But the same doesn't apply for Ask. This seems an odd distinction. In that case, should always scripts still run?</p>\n</blockquote>\n<p>I really wish I'd have seen this bit!  (My fault for perusing when I should be reading!)</p>\n<p>Fix:</p>\n<pre><code> &lt;function name=\"ShowMenuResponse\" parameters=\"option\"&gt;\n    if (game.menucallback = null) {\n      error (\"Unexpected menu response\")\n    }\n    else {\n      parameters = NewStringDictionary()\n      dictionary add (parameters, \"result\", UnescapeQuotes(option))\n      script = game.menucallback\n      ClearMenu\n      if (not GetBoolean(game, \"disambiguating\")) {\n        game.runturnscripts = true\n      }\n      game.disambiguating = false\n      invoke (script, parameters)\n    }\n  &lt;/function&gt;\n</code></pre>\n<pre><code>  &lt;function name=\"ResolveNameFromList\" parameters=\"variable, value, objtype, scope, secondaryscope\" type=\"object\"&gt;&lt;![CDATA[\n    value = Trim(LCase(value))\n    fullmatches = NewObjectList()\n    partialmatches = NewObjectList()\n    foreach (obj, scope) {\n      name = LCase(GetDisplayAlias(obj))\n      CompareNames (name, value, obj, fullmatches, partialmatches)\n      if (obj.alt &lt;&gt; null) {\n        foreach (altname, obj.alt) {\n          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\n        }\n      }\n    }\n    // allow referring to objects from the previous command by gender or article\n    if (objtype = \"object\" and game.lastobjects &lt;&gt; null) {\n      foreach (obj, game.lastobjects) {\n        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)\n        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)\n      }\n    }\n    // Also check the secondary scope, but only if we have not found anything yet\n    if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 0 and not secondaryscope = null) {\n      foreach (obj, secondaryscope) {\n        name = LCase(GetDisplayAlias(obj))\n        CompareNames (name, value, obj, fullmatches, partialmatches)\n        if (obj.alt &lt;&gt; null) {\n          foreach (altname, obj.alt) {\n            CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\n          }\n        }\n      }\n    }\n    if (ListCount(fullmatches) = 1) {\n      return (ListItem(fullmatches, 0))\n    }\n    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {\n      return (ListItem(partialmatches, 0))\n    }\n    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {\n      return (null)\n    }\n    else {\n      game.disambiguating = true\n      candidates = ListCompact(ListCombine(fullmatches, partialmatches))\n      if (LengthOf(variable) &gt; 0) {\n        // single object command, so after showing the menu, add the object to game.pov.currentcommandresolvedelements\n        game.pov.currentcommandpendingvariable = variable\n        ShowMenu (DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\n          varname = game.pov.currentcommandpendingvariable\n          game.pov.currentcommandpendingvariable = null\n          if (result &lt;&gt; null) {\n            AddToResolvedNames (varname, GetObject(result))\n          }\n        }\n      }\n      else {\n        // multi-object command, so after showing the menu, add the object to the list\n        game.pov.currentcommandmultiobjectpending = true\n        ShowMenu (DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\n          if (result &lt;&gt; null) {\n            list add (game.pov.currentcommandpendingobjectlist, GetObject(result))\n            ResolveNextNameListItem\n          }\n        }\n      }\n      return (null)\n    }\n  ]]&gt;&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2018-05-24T15:24:11.3538241Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e2afa395-b992-40b1-9fba-a12ece68d8f2",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "PS\r\n\r\n```FinishTurn``` is working differently in Quest 5.8.\r\n\r\nIt was called from WorldModel.cs, but now it's called from ```ResolveNextName``` (and now ```ShowMenuResponse``` shall call it, too, unless game.disambiguating is true).",
      "EditableFormat": "markdown",
      "HTML": "<p>PS</p>\n<p><code>FinishTurn</code> is working differently in Quest 5.8.</p>\n<p>It was called from WorldModel.cs, but now it's called from <code>ResolveNextName</code> (and now <code>ShowMenuResponse</code> shall call it, too, unless game.disambiguating is true).</p>\n\n",
      "PostDate": "2018-05-24T15:31:12.5701512Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e135a0c5-36a4-4786-bbb3-d2217ef5b66e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ah, ignore my previous suggestions then.",
      "EditableFormat": "markdown",
      "HTML": "<p>Ah, ignore my previous suggestions then.</p>\n\n",
      "PostDate": "2018-05-24T16:39:16.6278505Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "08bf4828-be60-418e-a408-f4f83bfe9753",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "XanMag is awesome! (I generally only mention this when he removes SPAM, but he's pretty much all-round awesome!)",
      "EditableFormat": "markdown",
      "HTML": "<p>XanMag is awesome! (I generally only mention this when he removes SPAM, but he's pretty much all-round awesome!)</p>\n\n",
      "PostDate": "2018-05-25T08:57:51.2461895Z",
      "LastEditDate": "2018-05-26T18:51:38.6091329Z",
      "link": null
    },
    {
      "PostId": "81c10ce0-d196-4ae9-bca7-815ace82a834",
      "UserId": 341771,
      "Username": "JenniferCampbell",
      "AvatarUrl": "https://secure.gravatar.com/avatar/8b9a63b5bbacc531368953df3a1709ec?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The worst part is that the spammer has used up a perfectly good username.  Some day, a guy named Martin Tolley who GM's table-top role playing games is going to come along to sign up.  He's in for a real disappointment!",
      "EditableFormat": "markdown",
      "HTML": "<p>The worst part is that the spammer has used up a perfectly good username.  Some day, a guy named Martin Tolley who GM's table-top role playing games is going to come along to sign up.  He's in for a real disappointment!</p>\n\n",
      "PostDate": "2018-05-25T11:16:55.5965947Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "cb667d98-4f0d-452a-b3c8-6b50229f3d04",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> `FinishTurn` is working differently in Quest 5.8.\r\n\r\nLooked over it again; and I still think this is a really bad idea. I stand by my earlier suggestion: give turnscripts a `percommand` flag, and have those turnscripts called after each command. Moving the call to `FinishCommand` seems to have no additional benefits over this method, and introduces a whole swarm of bugs.\r\n\r\nFinishTurn does a few different things, including running turnscripts. Running *some* turnscripts after every action is preferable.\r\n\r\nHowever, optimal behaviour would be for `UpdateStatusAttributes`, `CheckDarkness`, and `UpdateObjectLinks` should be guaranteed to run each time Quest sends a bundle of output to the browser, whether that's from a command, an unresolvedcommand script, or an ASLEvent. This is why FinishTurn is called from the core.\r\n\r\n`FinishTurn` *should* be called from the core code, because that is the only way to guarantee it is the last thing to run after all scripts have terminated, regardless of what those scripts are. It is only some turnscripts that should be moved.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p><code>FinishTurn</code> is working differently in Quest 5.8.</p>\n</blockquote>\n<p>Looked over it again; and I still think this is a really bad idea. I stand by my earlier suggestion: give turnscripts a <code>percommand</code> flag, and have those turnscripts called after each command. Moving the call to <code>FinishCommand</code> seems to have no additional benefits over this method, and introduces a whole swarm of bugs.</p>\n<p>FinishTurn does a few different things, including running turnscripts. Running <em>some</em> turnscripts after every action is preferable.</p>\n<p>However, optimal behaviour would be for <code>UpdateStatusAttributes</code>, <code>CheckDarkness</code>, and <code>UpdateObjectLinks</code> should be guaranteed to run each time Quest sends a bundle of output to the browser, whether that's from a command, an unresolvedcommand script, or an ASLEvent. This is why FinishTurn is called from the core.</p>\n<p><code>FinishTurn</code> <em>should</em> be called from the core code, because that is the only way to guarantee it is the last thing to run after all scripts have terminated, regardless of what those scripts are. It is only some turnscripts that should be moved.</p>\n\n",
      "PostDate": "2018-05-31T07:30:19.711319Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3edeb132-b8e8-424a-8131-c7738f9be76d",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yeah, I've dealt with a few issues concerning this since it was added to the beta build, but the wrinkles seem to be ironed out now.\r\n\r\n---\r\nI originally brought it up because multiple commands only triggered ```FinishTurn``` once, and I found a way to make it work differently.\r\n\r\nWithin hours, I found a way to make it all work correctly without modifying the hard-coded scripts, but I think Pixie prefers bypassing those hard-coded scripts if possible, in an attempt to make Quest less dependent on the C# code.  (I am not speaking on behalf of Pixie, mind you; this is mere conjecture.)\r\n\r\nAnyway, the only issues I've seen were when someone had a pre 5.8 work-in-progress loaded in the editor. ( And these games all had modified functions from the core library (such as ```FinishTurn```).)\r\n\r\n---\r\nThese are the functions which have been modified (I don't think I've missed any):\r\n\r\n\r\n```\r\n  <function name=\"FinishTurn\">\r\n    if (GetBoolean(game,\"runturnscripts\")) {\r\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\r\n        RunTurnScripts\r\n      }\r\n    }\r\n    game.runturnscripts = false\r\n    game.suppressturnscripts = false\r\n    UpdateStatusAttributes\r\n    CheckDarkness\r\n    UpdateObjectLinks\r\n  </function>  \r\n```\r\n\r\n\r\n```\r\n  <function name=\"StartGame\">\r\n    <![CDATA[\r\n    StartTurnOutputSection\r\n    if (game.showtitle) {\r\n      JS.StartOutputSection (\"title\")\r\n      PrintCentered (\"<span style=\\\"font-size:260%\\\">\" + game.gamename + \"</span>\")\r\n      if (game.subtitle <> null) {\r\n        if (LengthOf(game.subtitle) > 0) {\r\n          PrintCentered (\"<span style=\\\"font-size:130%\\\">\" + game.subtitle + \"</span>\")\r\n        }\r\n      }\r\n      if (game.author <> null) {\r\n        if (LengthOf(game.author) > 0) {\r\n          PrintCentered (\"<br/><span style=\\\"font-size:140%\\\">[By] \" + game.author + \"</span>\")\r\n        }\r\n      }\r\n      msg (\"<div style=\\\"margin-top:20px\\\"></div>\")\r\n      JS.EndOutputSection (\"title\")\r\n    }\r\n    if (game.pov = null) {\r\n      playerObject = GetObject(\"player\")\r\n      if (playerObject = null) {\r\n        if (ListCount(AllObjects()) > 0) {\r\n          firstRoom = ObjectListItem(AllObjects(), 0)\r\n        }\r\n        else {\r\n          create (\"room\")\r\n          firstRoom = room\r\n        }\r\n        create (\"player\")\r\n        player.parent = firstRoom\r\n      }\r\n      game.pov = player\r\n    }\r\n    else {\r\n      InitPOV (null, game.pov)\r\n    }\r\n    InitStatusAttributes\r\n    UpdateStatusAttributes\r\n    InitVerbsList\r\n    if (HasScript(game, \"start\")) do (game, \"start\")\r\n    foreach (obj, AllObjects()) {\r\n      if (HasScript(obj, \"_initialise_\")) do (obj, \"_initialise_\")\r\n    }\r\n    UpdateStatusAttributes\r\n    UpdateObjectLinks\r\n    on ready {\r\n      if (game.gridmap) {\r\n        Grid_DrawPlayerInRoom (game.pov.parent)\r\n      }\r\n      if (game.displayroomdescriptiononstart) {\r\n        OnEnterRoom (null)\r\n      }\r\n      UpdateStatusAttributes\r\n      UpdateObjectLinks\r\n    }\r\n    // Added by KV to use the old JS clearScreen if the transcript is disabled\r\n    if (GetBoolean(game, \"notranscript\")){\r\n      JS.eval(\"transcriptEnabled = false;\")\r\n    }\r\n    game.runturnscripts = false\r\n    FinishTurn\r\n    ]]>\r\n  </function>\r\n```\r\n\r\n```\r\n <function name=\"HandleCommand\" parameters=\"command, metadata\">\r\n    <![CDATA[\r\n    handled = false\r\n    if (game.menucallback <> null) {\r\n      if (HandleMenuTextResponse(command)) {\r\n        handled = true\r\n      }\r\n      else {\r\n        if (game.menuallowcancel) {\r\n          ClearMenu\r\n        }\r\n        else {\r\n          handled = true\r\n        }\r\n      }\r\n    }\r\n    if (not handled) {\r\n      StartTurnOutputSection\r\n      if (StartsWith (command, \"*\")) {\r\n        // Modified by KV to bypass turn scripts and turn counts, and to print \"Noted.\"\r\n        game.suppressturnscripts = true\r\n        msg (\"\")\r\n        msg (SafeXML (command))\r\n        msg(\"Noted.\")\r\n\t// Added for Quest 5.8    - KV\r\n\tFinishTurn\r\n      }\r\n      else {    \r\n        shownlink = false\r\n        if (game.echocommand) {\r\n          if (metadata <> null and game.enablehyperlinks and game.echohyperlinks) {\r\n            foreach (key, metadata) {\r\n              if (EndsWith(command, key)) {\r\n                objectname = StringDictionaryItem(metadata, key)\r\n                object = GetObject(objectname)\r\n                if (object <> null) {\r\n                  msg (\"\")\r\n                  msg (\"&gt; \" + Left(command, LengthOf(command) - LengthOf(key)) + \"{object:\" + object.name + \"}\" )\r\n                  shownlink = true\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (not shownlink) {\r\n            msg (\"\")\r\n            OutputTextRaw (\"&gt; \" + SafeXML(command))\r\n          }\r\n        }\r\n        if (game.command_newline) {\r\n          msg (\"\")\r\n        }\r\n        game.pov.commandmetadata = metadata\r\n        if (game.multiplecommands){\t\t\r\n          commands = Split(command, \".\")\r\n          if (ListCount(commands) = 1) {\r\n            game.pov.commandqueue = null\r\n            HandleSingleCommand (Trim(command))\r\n          }\r\n          else {\r\n            game.pov.commandqueue = commands\r\n            HandleNextCommandQueueItem\r\n          }\r\n\t\t    }\r\n        else {\r\n          game.pov.commandqueue = null\r\n          HandleSingleCommand (Trim(command))\t\r\n        }\t\t\r\n      }\r\n    }\r\n    ]]>\r\n  </function>\r\n\r\n```\r\n\r\n\r\n```\r\n <function name=\"ResolveNameFromList\" parameters=\"variable, value, objtype, scope, secondaryscope\" type=\"object\">\r\n    <![CDATA[\r\n    value = Trim(LCase(value))\r\n    fullmatches = NewObjectList()\r\n    partialmatches = NewObjectList()\r\n    \r\n    foreach (obj, scope) {\r\n      name = LCase(GetDisplayAlias(obj))\r\n      CompareNames (name, value, obj, fullmatches, partialmatches)\r\n      if (obj.alt <> null) {\r\n        foreach (altname, obj.alt) {\r\n          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\r\n        }\r\n      }\r\n    }\r\n    \r\n    // allow referring to objects from the previous command by gender or article\r\n    \r\n    if (objtype = \"object\" and game.lastobjects <> null) {\r\n      foreach (obj, game.lastobjects) {\r\n        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)\r\n        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)\r\n      }\r\n    }\r\n\r\n    // Also check the secondary scope, but only if we have not found anything yet\r\n    \r\n    if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 0 and not secondaryscope = null) {\r\n      foreach (obj, secondaryscope) {\r\n        name = LCase(GetDisplayAlias(obj))\r\n        CompareNames (name, value, obj, fullmatches, partialmatches)\r\n        if (obj.alt <> null) {\r\n          foreach (altname, obj.alt) {\r\n            CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\r\n          }\r\n        }\r\n      }\r\n    }    \r\n    \r\n    if (ListCount(fullmatches) = 1) {\r\n      return (ListItem(fullmatches, 0))\r\n    }\r\n    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {\r\n      return (ListItem(partialmatches, 0))\r\n    }\r\n    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {\r\n      return (null)\r\n    }\r\n    else {\r\n      // Added this line to resolve issue with new FinishTurn setup in 580\r\n      game.disambiguating = true\r\n      candidates = ListCompact(ListCombine(fullmatches, partialmatches))\r\n      \r\n      if (LengthOf(variable) > 0) {\r\n        // single object command, so after showing the menu, add the object to game.pov.currentcommandresolvedelements\r\n        game.pov.currentcommandpendingvariable = variable\r\n      \r\n        ShowMenu(DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\r\n          varname = game.pov.currentcommandpendingvariable\r\n          game.pov.currentcommandpendingvariable = null\r\n          if (result <> null) {\r\n            AddToResolvedNames(varname, GetObject(result))\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        // multi-object command, so after showing the menu, add the object to the list\r\n        \r\n        game.pov.currentcommandmultiobjectpending = true\r\n        \r\n        ShowMenu(DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\r\n          if (result <> null) {\r\n            list add (game.pov.currentcommandpendingobjectlist, GetObject(result))\r\n            ResolveNextNameListItem\r\n          }\r\n        }        \r\n      }\r\n      \r\n      return (null)\r\n    }\r\n    ]]>\r\n  </function>\r\n```\r\n\r\n```\r\n  <function name=\"ResolveNextName\">\r\n        <![CDATA[\r\n    resolvedall = false\r\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\r\n    if (queuetype = \"stringlist\") {\r\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\r\n      if (queuelength > 0) {\r\n        // Pop next variable off the queue\r\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\r\n        if (queuelength = 1) {\r\n          game.pov.currentcommandvarlistqueue = null\r\n        }\r\n        else {\r\n          newqueue = NewStringList()\r\n          for (i, 1, queuelength - 1) {\r\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\r\n          }\r\n          game.pov.currentcommandvarlistqueue = newqueue\r\n        }\r\n        // Resolve variable\r\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n        if (value <> \"\") {\r\n          result = null\r\n          resolvinglist = false\r\n          // This is to resolve issue 626\r\n          if (StartsWith(var, \"objectexit\")) {\r\n            result = ResolveName(var, value, \"exit\")\r\n          }\r\n          if (result = null) {\r\n            if (StartsWith(var, \"object\")) {\r\n              if (GetBoolean(game.pov.currentcommandpattern, \"allow_all\")) {\r\n                scope = FilterByAttribute(GetScope(\"object\", \"\", \"object\"), \"scenery\", false)\r\n                game.pov.currentcommandpendingobjectscope = ListExclude(scope, FilterByAttribute(scope, \"not_all\", true))\r\n                game.pov.currentcommandpendingvariable = var\r\n                ResolveNameList (value, \"object\")\r\n                resolvinglist = true\r\n              }\r\n              else if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\r\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\r\n                game.pov.currentcommandpendingvariable = var\r\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\r\n                ResolveNameList (value, \"object\")\r\n                resolvinglist = true\r\n              }\r\n              else {\r\n                result = ResolveName(var, value, \"object\")\r\n              }\r\n            }\r\n            else if (StartsWith(var, \"exit\")) {\r\n              result = ResolveName(var, value, \"exit\")\r\n            }\r\n            else if (StartsWith(var, \"text\")) {\r\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\r\n            }\r\n            else {\r\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\r\n            }\r\n          }\r\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\r\n          if (result = null) {\r\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\r\n              UnresolvedCommand (value, var)\r\n            }\r\n          }\r\n          else {\r\n            AddToResolvedNames (var, result)\r\n          }\r\n        }\r\n        else {\r\n          ResolveNextName\r\n        }\r\n      }\r\n      else {\r\n        resolvedall = true\r\n      }\r\n    }\r\n    else if (queuetype = \"null\") {\r\n      resolvedall = true\r\n    }\r\n    else {\r\n      error (\"Invalid queue type\")\r\n    }\r\n    if (resolvedall) {\r\n      // All the objects have been resolved, so now we can actually do the command\r\n      // TO DO: game.lastobjects should be game.pov.lastobjects\r\n      game.lastobjects = game.pov.currentcommandresolvedobjects\r\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\r\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\r\n        if (LengthOf(game.pov.currentcommand) > 0) {\r\n          start transaction (game.pov.currentcommand)\r\n        }\r\n      }\r\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\r\n        // TO DO: game.unresolved* should be game.pov.unresolved*\r\n        game.unresolvedcommand = null\r\n        game.unresolvedcommandvarlist = null\r\n        game.unresolvedcommandkey = null\r\n      }\r\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\r\n        // This is the bit that actually runs the commands\r\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\r\n      }\r\n      //\r\n      //Setting game.runturnscripts to true to run turn scripts after ShowMenu , show menu, ask, or Ask.\r\n      //This works in conjuction with FinishTurn, which has also been modified as of Quest 5.8.\r\n      //- KV, 2018/05/25\r\n      game.runturnscripts = true\r\n      FinishTurn\r\n      HandleNextCommandQueueItem\r\n    }\r\n  ]]></function>\r\n```\r\n\r\n```\r\n  <function name=\"ShowMenuResponse\" parameters=\"option\">\r\n    if (game.menucallback = null) {\r\n      error (\"Unexpected menu response\")\r\n    }\r\n    else {\r\n      parameters = NewStringDictionary()\r\n      dictionary add (parameters, \"result\", UnescapeQuotes(option))\r\n      script = game.menucallback\r\n      ClearMenu\r\n      // Added by KV to handle the new FinishTurn setup in 580\r\n      if (not GetBoolean(game, \"disambiguating\")) {\r\n        game.runturnscripts = true\r\n      }\r\n      game.disambiguating = false\r\n      invoke (script, parameters)\r\n      FinishTurn\r\n    }\r\n  </function>\r\n```\r\n\r\n---\r\nThis is a big change, and it makes me nervous, too.  I think it's going to be okay, though.  I'm pretty sure Pixie has tested the [expletive deleted] out of it, and I've tried to break it every way I can think of (which, admittedly, isn't saying much).",
      "EditableFormat": "markdown",
      "HTML": "<p>Yeah, I've dealt with a few issues concerning this since it was added to the beta build, but the wrinkles seem to be ironed out now.</p>\n<hr>\n<p>I originally brought it up because multiple commands only triggered <code>FinishTurn</code> once, and I found a way to make it work differently.</p>\n<p>Within hours, I found a way to make it all work correctly without modifying the hard-coded scripts, but I think Pixie prefers bypassing those hard-coded scripts if possible, in an attempt to make Quest less dependent on the C# code.  (I am not speaking on behalf of Pixie, mind you; this is mere conjecture.)</p>\n<p>Anyway, the only issues I've seen were when someone had a pre 5.8 work-in-progress loaded in the editor. ( And these games all had modified functions from the core library (such as <code>FinishTurn</code>).)</p>\n<hr>\n<p>These are the functions which have been modified (I don't think I've missed any):</p>\n<pre><code>  &lt;function name=\"FinishTurn\"&gt;\n    if (GetBoolean(game,\"runturnscripts\")) {\n      if (not GetBoolean(game, \"suppressturnscripts\")) {\n        RunTurnScripts\n      }\n    }\n    game.runturnscripts = false\n    game.suppressturnscripts = false\n    UpdateStatusAttributes\n    CheckDarkness\n    UpdateObjectLinks\n  &lt;/function&gt;  \n</code></pre>\n<pre><code>  &lt;function name=\"StartGame\"&gt;\n    &lt;![CDATA[\n    StartTurnOutputSection\n    if (game.showtitle) {\n      JS.StartOutputSection (\"title\")\n      PrintCentered (\"&lt;span style=\\\"font-size:260%\\\"&gt;\" + game.gamename + \"&lt;/span&gt;\")\n      if (game.subtitle &lt;&gt; null) {\n        if (LengthOf(game.subtitle) &gt; 0) {\n          PrintCentered (\"&lt;span style=\\\"font-size:130%\\\"&gt;\" + game.subtitle + \"&lt;/span&gt;\")\n        }\n      }\n      if (game.author &lt;&gt; null) {\n        if (LengthOf(game.author) &gt; 0) {\n          PrintCentered (\"&lt;br/&gt;&lt;span style=\\\"font-size:140%\\\"&gt;[By] \" + game.author + \"&lt;/span&gt;\")\n        }\n      }\n      msg (\"&lt;div style=\\\"margin-top:20px\\\"&gt;&lt;/div&gt;\")\n      JS.EndOutputSection (\"title\")\n    }\n    if (game.pov = null) {\n      playerObject = GetObject(\"player\")\n      if (playerObject = null) {\n        if (ListCount(AllObjects()) &gt; 0) {\n          firstRoom = ObjectListItem(AllObjects(), 0)\n        }\n        else {\n          create (\"room\")\n          firstRoom = room\n        }\n        create (\"player\")\n        player.parent = firstRoom\n      }\n      game.pov = player\n    }\n    else {\n      InitPOV (null, game.pov)\n    }\n    InitStatusAttributes\n    UpdateStatusAttributes\n    InitVerbsList\n    if (HasScript(game, \"start\")) do (game, \"start\")\n    foreach (obj, AllObjects()) {\n      if (HasScript(obj, \"_initialise_\")) do (obj, \"_initialise_\")\n    }\n    UpdateStatusAttributes\n    UpdateObjectLinks\n    on ready {\n      if (game.gridmap) {\n        Grid_DrawPlayerInRoom (game.pov.parent)\n      }\n      if (game.displayroomdescriptiononstart) {\n        OnEnterRoom (null)\n      }\n      UpdateStatusAttributes\n      UpdateObjectLinks\n    }\n    // Added by KV to use the old JS clearScreen if the transcript is disabled\n    if (GetBoolean(game, \"notranscript\")){\n      JS.eval(\"transcriptEnabled = false;\")\n    }\n    game.runturnscripts = false\n    FinishTurn\n    ]]&gt;\n  &lt;/function&gt;\n</code></pre>\n<pre><code> &lt;function name=\"HandleCommand\" parameters=\"command, metadata\"&gt;\n    &lt;![CDATA[\n    handled = false\n    if (game.menucallback &lt;&gt; null) {\n      if (HandleMenuTextResponse(command)) {\n        handled = true\n      }\n      else {\n        if (game.menuallowcancel) {\n          ClearMenu\n        }\n        else {\n          handled = true\n        }\n      }\n    }\n    if (not handled) {\n      StartTurnOutputSection\n      if (StartsWith (command, \"*\")) {\n        // Modified by KV to bypass turn scripts and turn counts, and to print \"Noted.\"\n        game.suppressturnscripts = true\n        msg (\"\")\n        msg (SafeXML (command))\n        msg(\"Noted.\")\n\t// Added for Quest 5.8    - KV\n\tFinishTurn\n      }\n      else {    \n        shownlink = false\n        if (game.echocommand) {\n          if (metadata &lt;&gt; null and game.enablehyperlinks and game.echohyperlinks) {\n            foreach (key, metadata) {\n              if (EndsWith(command, key)) {\n                objectname = StringDictionaryItem(metadata, key)\n                object = GetObject(objectname)\n                if (object &lt;&gt; null) {\n                  msg (\"\")\n                  msg (\"&amp;gt; \" + Left(command, LengthOf(command) - LengthOf(key)) + \"{object:\" + object.name + \"}\" )\n                  shownlink = true\n                }\n              }\n            }\n          }\n          if (not shownlink) {\n            msg (\"\")\n            OutputTextRaw (\"&amp;gt; \" + SafeXML(command))\n          }\n        }\n        if (game.command_newline) {\n          msg (\"\")\n        }\n        game.pov.commandmetadata = metadata\n        if (game.multiplecommands){\t\t\n          commands = Split(command, \".\")\n          if (ListCount(commands) = 1) {\n            game.pov.commandqueue = null\n            HandleSingleCommand (Trim(command))\n          }\n          else {\n            game.pov.commandqueue = commands\n            HandleNextCommandQueueItem\n          }\n\t\t    }\n        else {\n          game.pov.commandqueue = null\n          HandleSingleCommand (Trim(command))\t\n        }\t\t\n      }\n    }\n    ]]&gt;\n  &lt;/function&gt;\n\n</code></pre>\n<pre><code> &lt;function name=\"ResolveNameFromList\" parameters=\"variable, value, objtype, scope, secondaryscope\" type=\"object\"&gt;\n    &lt;![CDATA[\n    value = Trim(LCase(value))\n    fullmatches = NewObjectList()\n    partialmatches = NewObjectList()\n    \n    foreach (obj, scope) {\n      name = LCase(GetDisplayAlias(obj))\n      CompareNames (name, value, obj, fullmatches, partialmatches)\n      if (obj.alt &lt;&gt; null) {\n        foreach (altname, obj.alt) {\n          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\n        }\n      }\n    }\n    \n    // allow referring to objects from the previous command by gender or article\n    \n    if (objtype = \"object\" and game.lastobjects &lt;&gt; null) {\n      foreach (obj, game.lastobjects) {\n        CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)\n        CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)\n      }\n    }\n\n    // Also check the secondary scope, but only if we have not found anything yet\n    \n    if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 0 and not secondaryscope = null) {\n      foreach (obj, secondaryscope) {\n        name = LCase(GetDisplayAlias(obj))\n        CompareNames (name, value, obj, fullmatches, partialmatches)\n        if (obj.alt &lt;&gt; null) {\n          foreach (altname, obj.alt) {\n            CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)\n          }\n        }\n      }\n    }    \n    \n    if (ListCount(fullmatches) = 1) {\n      return (ListItem(fullmatches, 0))\n    }\n    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {\n      return (ListItem(partialmatches, 0))\n    }\n    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {\n      return (null)\n    }\n    else {\n      // Added this line to resolve issue with new FinishTurn setup in 580\n      game.disambiguating = true\n      candidates = ListCompact(ListCombine(fullmatches, partialmatches))\n      \n      if (LengthOf(variable) &gt; 0) {\n        // single object command, so after showing the menu, add the object to game.pov.currentcommandresolvedelements\n        game.pov.currentcommandpendingvariable = variable\n      \n        ShowMenu(DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\n          varname = game.pov.currentcommandpendingvariable\n          game.pov.currentcommandpendingvariable = null\n          if (result &lt;&gt; null) {\n            AddToResolvedNames(varname, GetObject(result))\n          }\n        }\n      }\n      else {\n        // multi-object command, so after showing the menu, add the object to the list\n        \n        game.pov.currentcommandmultiobjectpending = true\n        \n        ShowMenu(DynamicTemplate(\"DisambiguateMenu\", value), candidates, true) {\n          if (result &lt;&gt; null) {\n            list add (game.pov.currentcommandpendingobjectlist, GetObject(result))\n            ResolveNextNameListItem\n          }\n        }        \n      }\n      \n      return (null)\n    }\n    ]]&gt;\n  &lt;/function&gt;\n</code></pre>\n<pre><code>  &lt;function name=\"ResolveNextName\"&gt;\n        &lt;![CDATA[\n    resolvedall = false\n    queuetype = TypeOf(game.pov, \"currentcommandvarlistqueue\")\n    if (queuetype = \"stringlist\") {\n      queuelength = ListCount(game.pov.currentcommandvarlistqueue)\n      if (queuelength &gt; 0) {\n        // Pop next variable off the queue\n        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)\n        if (queuelength = 1) {\n          game.pov.currentcommandvarlistqueue = null\n        }\n        else {\n          newqueue = NewStringList()\n          for (i, 1, queuelength - 1) {\n            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))\n          }\n          game.pov.currentcommandvarlistqueue = newqueue\n        }\n        // Resolve variable\n        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n        if (value &lt;&gt; \"\") {\n          result = null\n          resolvinglist = false\n          // This is to resolve issue 626\n          if (StartsWith(var, \"objectexit\")) {\n            result = ResolveName(var, value, \"exit\")\n          }\n          if (result = null) {\n            if (StartsWith(var, \"object\")) {\n              if (GetBoolean(game.pov.currentcommandpattern, \"allow_all\")) {\n                scope = FilterByAttribute(GetScope(\"object\", \"\", \"object\"), \"scenery\", false)\n                game.pov.currentcommandpendingobjectscope = ListExclude(scope, FilterByAttribute(scope, \"not_all\", true))\n                game.pov.currentcommandpendingvariable = var\n                ResolveNameList (value, \"object\")\n                resolvinglist = true\n              }\n              else if (HasScript(game.pov.currentcommandpattern, \"multipleobjects\")) {\n                game.pov.currentcommandpendingobjectlist = NewObjectList()\n                game.pov.currentcommandpendingvariable = var\n                do (game.pov.currentcommandpattern, \"multipleobjects\")\n                ResolveNameList (value, \"object\")\n                resolvinglist = true\n              }\n              else {\n                result = ResolveName(var, value, \"object\")\n              }\n            }\n            else if (StartsWith(var, \"exit\")) {\n              result = ResolveName(var, value, \"exit\")\n            }\n            else if (StartsWith(var, \"text\")) {\n              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)\n            }\n            else {\n              error (\"Unhandled command variable '\" + var + \"' - command variable names must begin with 'object', 'exit' or 'text'\")\n            }\n          }\n          // at this point, ResolveName has returned - either an object name, unresolved, or pending\n          if (result = null) {\n            if ((not resolvinglist) and LengthOf(GetString(game.pov, \"currentcommandpendingvariable\")) = 0) {\n              UnresolvedCommand (value, var)\n            }\n          }\n          else {\n            AddToResolvedNames (var, result)\n          }\n        }\n        else {\n          ResolveNextName\n        }\n      }\n      else {\n        resolvedall = true\n      }\n    }\n    else if (queuetype = \"null\") {\n      resolvedall = true\n    }\n    else {\n      error (\"Invalid queue type\")\n    }\n    if (resolvedall) {\n      // All the objects have been resolved, so now we can actually do the command\n      // TO DO: game.lastobjects should be game.pov.lastobjects\n      game.lastobjects = game.pov.currentcommandresolvedobjects\n      if (not DictionaryContains(game.pov.currentcommandresolvedelements, \"multiple\")) {\n        dictionary add (game.pov.currentcommandresolvedelements, \"multiple\", false)\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isundo\")) {\n        if (LengthOf(game.pov.currentcommand) &gt; 0) {\n          start transaction (game.pov.currentcommand)\n        }\n      }\n      if (not GetBoolean(game.pov.currentcommandpattern, \"isoops\")) {\n        // TO DO: game.unresolved* should be game.pov.unresolved*\n        game.unresolvedcommand = null\n        game.unresolvedcommandvarlist = null\n        game.unresolvedcommandkey = null\n      }\n      if (HasScript(game.pov.currentcommandpattern, \"script\")) {\n        // This is the bit that actually runs the commands\n        do (game.pov.currentcommandpattern, \"script\", game.pov.currentcommandresolvedelements)\n      }\n      //\n      //Setting game.runturnscripts to true to run turn scripts after ShowMenu , show menu, ask, or Ask.\n      //This works in conjuction with FinishTurn, which has also been modified as of Quest 5.8.\n      //- KV, 2018/05/25\n      game.runturnscripts = true\n      FinishTurn\n      HandleNextCommandQueueItem\n    }\n  ]]&gt;&lt;/function&gt;\n</code></pre>\n<pre><code>  &lt;function name=\"ShowMenuResponse\" parameters=\"option\"&gt;\n    if (game.menucallback = null) {\n      error (\"Unexpected menu response\")\n    }\n    else {\n      parameters = NewStringDictionary()\n      dictionary add (parameters, \"result\", UnescapeQuotes(option))\n      script = game.menucallback\n      ClearMenu\n      // Added by KV to handle the new FinishTurn setup in 580\n      if (not GetBoolean(game, \"disambiguating\")) {\n        game.runturnscripts = true\n      }\n      game.disambiguating = false\n      invoke (script, parameters)\n      FinishTurn\n    }\n  &lt;/function&gt;\n</code></pre>\n<hr>\n<p>This is a big change, and it makes me nervous, too.  I think it's going to be okay, though.  I'm pretty sure Pixie has tested the [expletive deleted] out of it, and I've tried to break it every way I can think of (which, admittedly, isn't saying much).</p>\n\n",
      "PostDate": "2018-05-31T07:50:39.9508385Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e0d5dca0-e717-4201-9797-70037552c90b",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I know you can't test this, mrangel.\r\n\r\nGive me monkey wrench suggestions, and I'll throw them in there.  If this can be broken, I'm sure Pixie would very much appreciate it if we break it while it's still in beta.",
      "EditableFormat": "markdown",
      "HTML": "<p>I know you can't test this, mrangel.</p>\n<p>Give me monkey wrench suggestions, and I'll throw them in there.  If this can be broken, I'm sure Pixie would very much appreciate it if we break it while it's still in beta.</p>\n\n",
      "PostDate": "2018-05-31T09:33:30.7140048Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bc5dfc26-ded6-43bc-aadb-25f3003c8007",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is the method I came up with which does not involve any changes to the hard-coded stuff:\r\n\r\nhttps://github.com/KVonGit/QuestStuff/wiki/Turn-Scripts-Turn-Counts-and-Multiple-Commands",
      "EditableFormat": "markdown",
      "HTML": "<p>This is the method I came up with which does not involve any changes to the hard-coded stuff:</p>\n<p>https://github.com/KVonGit/QuestStuff/wiki/Turn-Scripts-Turn-Counts-and-Multiple-Commands</p>\n\n",
      "PostDate": "2018-05-31T10:15:11.7766347Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8af2b30e-7429-4409-96c0-487182eb086f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm not thinking so much about bugs (but the big one that comes to mind is javascript timeouts), as from a design perspective.\r\n\r\nUnder the current version, turnscripts are run once per batch of data between server and client. If you want to make them run once per command, you have to override ResolveNextName.\r\n\r\nWith the call to FinishTurn moved, turnscripts run once per command. If you have one that you only want to run once per data-batch… that looks like it would be more difficult. There's a reason it was done in C#.\r\n\r\nGiving the player the ability to run turnscripts for every command, that's a good thing. But not replacing existing behaviour. Anyone whose game uses turnscripts will find them behaving differently after upgrading; and I don't see any benefit to justify that.\r\n\r\nSorry; didn't mean to rant. It just seems weird to make a change that alters the behaviour users might be expecting, reduces efficiency, and increases complexity… I can't see the upside.",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm not thinking so much about bugs (but the big one that comes to mind is javascript timeouts), as from a design perspective.</p>\n<p>Under the current version, turnscripts are run once per batch of data between server and client. If you want to make them run once per command, you have to override ResolveNextName.</p>\n<p>With the call to FinishTurn moved, turnscripts run once per command. If you have one that you only want to run once per data-batch… that looks like it would be more difficult. There's a reason it was done in C#.</p>\n<p>Giving the player the ability to run turnscripts for every command, that's a good thing. But not replacing existing behaviour. Anyone whose game uses turnscripts will find them behaving differently after upgrading; and I don't see any benefit to justify that.</p>\n<p>Sorry; didn't mean to rant. It just seems weird to make a change that alters the behaviour users might be expecting, reduces efficiency, and increases complexity… I can't see the upside.</p>\n\n",
      "PostDate": "2018-05-31T11:32:23.4593985Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bd035c01-586b-4e8c-9e9b-26ee9c15a5e6",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  javascript timeouts\r\n\r\nWhat is an example of this?  (I've been awake far too long to think clearly on this one.  Not being argumentative at all.)\r\n\r\n---\r\n> Under the current version, turnscripts are run once per batch of data between server and client. If you want to make them run once per command, you have to override ```ResolveNextName```.\r\n\r\nYep, and ```FinishTurn```.  That's all I did in the code in that last link I posted, which is actually my preferred version in retrospect, but it **does** appear to work fine either way, so...\r\n\r\n...and, again, admittedly, I was the one who came up with the changes to the hard-coded functions.\r\n\r\n---\r\nI've helped 3 people with issues after updating to the current beta, and it only took a few minutes a piece, and 2 of those were using one of my libraries that was overriding ```FinishTurn``` as well as suppressing the turn scripts unnecessarily in one bit of code.\r\n\r\n---\r\n> With the call to FinishTurn moved, turnscripts run once per command. If you have one that you only want to run once per data-batch… that looks like it would be more difficult. There's a reason it was done in C#.\r\n\r\nIt's definitely more difficult.  (See all the code I posted above.)\r\n\r\n---\r\n> Anyone whose game uses turnscripts will find them behaving differently after upgrading; and I don't see any benefit to justify that.\r\n\r\nThey shouldn't unless they have one of these functions overridden:\r\n\r\n```\r\nFinishTurn\r\n\r\nStartGame\r\n\r\nHandleCommand\r\n\r\nResolveNameFromList\r\n\r\nResolveNextName\r\n\r\nShowMenuResponse\r\n```\r\n\r\n---\r\nThat rules all the online authors out, because they can't override functions anyway.\r\n\r\n...and (this is just my feeling on this subject) anyone who has overridden these function in the first place should be knowledgeable enough to adjust their mod to work after the upgrade.\r\n\r\nEveryone seems to disagree with me here, but I don't upgrade an application I'm using unless **a)** I finish my current project(s) first, or **b)** I am fully prepared to deal with all the issues my old code creates in the new \"environment\".\r\n\r\n---\r\nAlso, the C# code is checking the ASL version before deciding whether or not it calls ```TryFinishTurn```.  If the ASL version is less than 580, it works the old way.  So, published games are totally safe.\r\n\r\n\r\n---\r\n> Sorry; didn't mean to rant. It just seems weird to make a change that alters the behaviour users might be expecting, reduces efficiency, and increases complexity… I can't see the upside.\r\n\r\nI think your input is valued, mrangel.  And I didn't think you were ranting.\r\n\r\n...and I hope you didn't think I was arguing or anything.  I'm just listing the stuff I know about all this.\r\n\r\nIt's all due to me (I'm pretty sure).  First, I was always crying about an ASLEvent firing the turn scripts an extra time.  Then, I started whining about the multiple commands only firing one turn script.  Then, I was all like, \"hey, Pixie.  Check out this code.  It makes stuff work like we'd expect.\"",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>javascript timeouts</p>\n</blockquote>\n<p>What is an example of this?  (I've been awake far too long to think clearly on this one.  Not being argumentative at all.)</p>\n<hr>\n<blockquote>\n<p>Under the current version, turnscripts are run once per batch of data between server and client. If you want to make them run once per command, you have to override <code>ResolveNextName</code>.</p>\n</blockquote>\n<p>Yep, and <code>FinishTurn</code>.  That's all I did in the code in that last link I posted, which is actually my preferred version in retrospect, but it <strong>does</strong> appear to work fine either way, so...</p>\n<p>...and, again, admittedly, I was the one who came up with the changes to the hard-coded functions.</p>\n<hr>\n<p>I've helped 3 people with issues after updating to the current beta, and it only took a few minutes a piece, and 2 of those were using one of my libraries that was overriding <code>FinishTurn</code> as well as suppressing the turn scripts unnecessarily in one bit of code.</p>\n<hr>\n<blockquote>\n<p>With the call to FinishTurn moved, turnscripts run once per command. If you have one that you only want to run once per data-batch… that looks like it would be more difficult. There's a reason it was done in C#.</p>\n</blockquote>\n<p>It's definitely more difficult.  (See all the code I posted above.)</p>\n<hr>\n<blockquote>\n<p>Anyone whose game uses turnscripts will find them behaving differently after upgrading; and I don't see any benefit to justify that.</p>\n</blockquote>\n<p>They shouldn't unless they have one of these functions overridden:</p>\n<pre><code>FinishTurn\n\nStartGame\n\nHandleCommand\n\nResolveNameFromList\n\nResolveNextName\n\nShowMenuResponse\n</code></pre>\n<hr>\n<p>That rules all the online authors out, because they can't override functions anyway.</p>\n<p>...and (this is just my feeling on this subject) anyone who has overridden these function in the first place should be knowledgeable enough to adjust their mod to work after the upgrade.</p>\n<p>Everyone seems to disagree with me here, but I don't upgrade an application I'm using unless <strong>a)</strong> I finish my current project(s) first, or <strong>b)</strong> I am fully prepared to deal with all the issues my old code creates in the new \"environment\".</p>\n<hr>\n<p>Also, the C# code is checking the ASL version before deciding whether or not it calls <code>TryFinishTurn</code>.  If the ASL version is less than 580, it works the old way.  So, published games are totally safe.</p>\n<hr>\n<blockquote>\n<p>Sorry; didn't mean to rant. It just seems weird to make a change that alters the behaviour users might be expecting, reduces efficiency, and increases complexity… I can't see the upside.</p>\n</blockquote>\n<p>I think your input is valued, mrangel.  And I didn't think you were ranting.</p>\n<p>...and I hope you didn't think I was arguing or anything.  I'm just listing the stuff I know about all this.</p>\n<p>It's all due to me (I'm pretty sure).  First, I was always crying about an ASLEvent firing the turn scripts an extra time.  Then, I started whining about the multiple commands only firing one turn script.  Then, I was all like, \"hey, Pixie.  Check out this code.  It makes stuff work like we'd expect.\"</p>\n\n",
      "PostDate": "2018-05-31T12:04:13.0485651Z",
      "LastEditDate": "2018-05-31T12:24:33.1472485Z",
      "link": null
    },
    {
      "PostId": "79ebb1b9-74c9-4e1c-82d0-87c7cc61af0f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> First, I was always crying about an ASLEvent firing the turn scripts an extra time.\r\n\r\nYeah. Imagine I've got a turnscript that counts how many turns the player has taken.\r\nI've got some clicky-button UI stuff that uses ASLEvent to do something that doesn't count as a turn. So, I made that function set an attribute that causes the turn counter to skip the next increment. It works as intended.\r\n\r\nThen I load my game in an updated version of quest. Now, ASLEvent *doesn't* fire a turnscript. So the player clicks my fancy button, and it works fine, but the *next* command they type doesn't count as a turn.\r\n\r\nI could come up with a similar example for the multiple commands thing.\r\n\r\nThat is not ideal. It doesn't matter that I've not overridden any of the core functions. If the behaviour of a language feature changes, it will require users to change their code around it. And I might not notice, because I'd already tested the countdown code.\r\n\r\n(I can't check if turnscripts fire after calling ASLEvent in this new version, but it doesn't look like they will)\r\n\r\nSometimes, it might be worth causing a flag day. But you have to think if it's worth it.\r\nI've asked a few times now, but maybe you missed it. Is there any benefit to moving the call to `FinishTurn`? It really looks like change for the sake of change.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>First, I was always crying about an ASLEvent firing the turn scripts an extra time.</p>\n</blockquote>\n<p>Yeah. Imagine I've got a turnscript that counts how many turns the player has taken.<br>\nI've got some clicky-button UI stuff that uses ASLEvent to do something that doesn't count as a turn. So, I made that function set an attribute that causes the turn counter to skip the next increment. It works as intended.</p>\n<p>Then I load my game in an updated version of quest. Now, ASLEvent <em>doesn't</em> fire a turnscript. So the player clicks my fancy button, and it works fine, but the <em>next</em> command they type doesn't count as a turn.</p>\n<p>I could come up with a similar example for the multiple commands thing.</p>\n<p>That is not ideal. It doesn't matter that I've not overridden any of the core functions. If the behaviour of a language feature changes, it will require users to change their code around it. And I might not notice, because I'd already tested the countdown code.</p>\n<p>(I can't check if turnscripts fire after calling ASLEvent in this new version, but it doesn't look like they will)</p>\n<p>Sometimes, it might be worth causing a flag day. But you have to think if it's worth it.<br>\nI've asked a few times now, but maybe you missed it. Is there any benefit to moving the call to <code>FinishTurn</code>? It really looks like change for the sake of change.</p>\n\n",
      "PostDate": "2018-05-31T13:27:02.6552909Z",
      "LastEditDate": "2018-05-31T13:37:49.9379202Z",
      "link": null
    },
    {
      "PostId": "d3c54fe6-f42f-42e3-985a-22e5e55db02e",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> I've asked a few times now, but maybe you missed it. Is there any benefit to moving the call to FinishTurn?\r\n\r\nNo, I didn't miss it.  I listed the events which led to these changes.  I mentioned that the changes make me nervous, and that I prefer my second bit of code (which doesn't alter the hard-coded stuff).  Then, I posted the link to that code.\r\n\r\nThe only benefit of which I am aware could be attained by changing ResolveNextName and FinishTurn, and nothing else, as I've posted (and as you pointed out).\r\n\r\nDoes Pixie know something I don't, though?  Probably so.\r\n\r\n---\r\n...and I'm going to check out the ASLEvent thing, but I'm pretty sure you are correct.  It no longer runs the turn scripts, and this was one of the goals (for me anyway).\r\n\r\n---\r\nRandom question:\r\n\r\nWhat's the difference between breaking TAKE and DROP to handle scope differently and possibly breaking ASLEvent to handle multiple commands?  Besides ASLEvent calls being used much less by authors?\r\n\r\n(Remember that I am not lobbying for the recent changes.  Nor am I arguing. Nor am I saying two wrongs make a right.  Nor am I saying either of these changes were wrong.  I'm just asking.)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I've asked a few times now, but maybe you missed it. Is there any benefit to moving the call to FinishTurn?</p>\n</blockquote>\n<p>No, I didn't miss it.  I listed the events which led to these changes.  I mentioned that the changes make me nervous, and that I prefer my second bit of code (which doesn't alter the hard-coded stuff).  Then, I posted the link to that code.</p>\n<p>The only benefit of which I am aware could be attained by changing ResolveNextName and FinishTurn, and nothing else, as I've posted (and as you pointed out).</p>\n<p>Does Pixie know something I don't, though?  Probably so.</p>\n<hr>\n<p>...and I'm going to check out the ASLEvent thing, but I'm pretty sure you are correct.  It no longer runs the turn scripts, and this was one of the goals (for me anyway).</p>\n<hr>\n<p>Random question:</p>\n<p>What's the difference between breaking TAKE and DROP to handle scope differently and possibly breaking ASLEvent to handle multiple commands?  Besides ASLEvent calls being used much less by authors?</p>\n<p>(Remember that I am not lobbying for the recent changes.  Nor am I arguing. Nor am I saying two wrongs make a right.  Nor am I saying either of these changes were wrong.  I'm just asking.)</p>\n\n",
      "PostDate": "2018-05-31T14:34:29.0637308Z",
      "LastEditDate": "2018-05-31T15:07:59.8765015Z",
      "link": null
    },
    {
      "PostId": "dcfdc5a0-5c2c-40ad-8bd0-d22edb2d5c99",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "With the changes to the hard-coded functions, a call to ```ASLEvent``` no longer triggers the turn scripts.\r\n\r\nThis is how I expect it to behave, unless the event calls something which handles a command.  (I have admitted I'm a crazy person on numerous occasions, though.)\r\n\r\n---\r\nI keep saying this, and I know I'm the minority, but:\r\n\r\nI don't believe anyone should update any game-creation software without expecting to have to change the old code in their game.  This is true for Inform, TADS, or anything.  (And any software, really.)\r\n\r\n---\r\nI'm not saying that these specific changes are worth the trouble.  And, again, I got nervous about it and tried to back out of these changes, but Pixie has been running all sorts of tests, and he seems to prefer the way things work with the changes.   (I'm sure he'll chime in once he sees these recent posts.)\r\n\r\n---\r\nHere's a small example game and the output in 5.7.2 then 5.8:\r\n\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.8.6724.15602-->\r\n<asl version=\"580\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"hkg;fj\">\r\n    <gameid>72653bf5-68c4-44bb-967f-ecac9b40e3e0</gameid>\r\n    <version>1.0</version>\r\n    <firstpublished>2018</firstpublished>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <isroom />\r\n    <beforeenter type=\"script\">\r\n    </beforeenter>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n    </object>\r\n  </object>\r\n  <turnscript name=\"tester\">\r\n    <enabled />\r\n    <script>\r\n      msg (\"TURN SCRIPT\")\r\n    </script>\r\n  </turnscript>\r\n  <command name=\"tst\">\r\n    <pattern>test</pattern>\r\n    <script>\r\n      JS.eval (\"ASLEvent('SayHello', 'hello');\")\r\n    </script>\r\n  </command>\r\n  <function name=\"SayHello\" parameters=\"txt\">\r\n    msg (txt)\r\n  </function>\r\n</asl>\r\n```\r\n\r\n---\r\nQuest 5.7.2\r\n\r\n```\r\nYou are in a room.\r\n\r\n> test\r\nTURN SCRIPT\r\nhello\r\nTURN SCRIPT\r\n\r\n> test\r\nTURN SCRIPT\r\nhello\r\nTURN SCRIPT\r\n```\r\n\r\n---\r\nQuest 5.8\r\n```\r\nYou are in a room.\r\n\r\n> test\r\nTURN SCRIPT\r\nhello\r\n\r\n> test\r\nTURN SCRIPT\r\nhello\r\n```\r\n\r\n</details>\r\n\r\n---\r\nIf we stick with the current changes, a few people will have to edit some scripts which call ```ASLEvent``` if they open an existing version 550 game in Quest 5.8.\r\n\r\nIf we don't make these changes to the C# code, a few authors will be saved from having to edit a few scripts, but every author who creates a game afterwards will still have to deal with the fact that an ```ASLEvent``` calls turn scripts an extra time.\r\n\r\nEither way, folks doing crazy stuff with ```ASLEvent``` will have to do extra work, which we all signed up for (knowingly or not) when we scripted said crazy stuff.  And we especially invite problems when working on older code after we've updated our game-creation software.",
      "EditableFormat": "markdown",
      "HTML": "<p>With the changes to the hard-coded functions, a call to <code>ASLEvent</code> no longer triggers the turn scripts.</p>\n<p>This is how I expect it to behave, unless the event calls something which handles a command.  (I have admitted I'm a crazy person on numerous occasions, though.)</p>\n<hr>\n<p>I keep saying this, and I know I'm the minority, but:</p>\n<p>I don't believe anyone should update any game-creation software without expecting to have to change the old code in their game.  This is true for Inform, TADS, or anything.  (And any software, really.)</p>\n<hr>\n<p>I'm not saying that these specific changes are worth the trouble.  And, again, I got nervous about it and tried to back out of these changes, but Pixie has been running all sorts of tests, and he seems to prefer the way things work with the changes.   (I'm sure he'll chime in once he sees these recent posts.)</p>\n<hr>\n<p>Here's a small example game and the output in 5.7.2 then 5.8:</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.8.6724.15602--&gt;\n&lt;asl version=\"580\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"hkg;fj\"&gt;\n    &lt;gameid&gt;72653bf5-68c4-44bb-967f-ecac9b40e3e0&lt;/gameid&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;firstpublished&gt;2018&lt;/firstpublished&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;isroom /&gt;\n    &lt;beforeenter type=\"script\"&gt;\n    &lt;/beforeenter&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;turnscript name=\"tester\"&gt;\n    &lt;enabled /&gt;\n    &lt;script&gt;\n      msg (\"TURN SCRIPT\")\n    &lt;/script&gt;\n  &lt;/turnscript&gt;\n  &lt;command name=\"tst\"&gt;\n    &lt;pattern&gt;test&lt;/pattern&gt;\n    &lt;script&gt;\n      JS.eval (\"ASLEvent('SayHello', 'hello');\")\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;function name=\"SayHello\" parameters=\"txt\"&gt;\n    msg (txt)\n  &lt;/function&gt;\n&lt;/asl&gt;\n</code></pre>\n<hr>\n<p>Quest 5.7.2</p>\n<pre><code>You are in a room.\n\n&gt; test\nTURN SCRIPT\nhello\nTURN SCRIPT\n\n&gt; test\nTURN SCRIPT\nhello\nTURN SCRIPT\n</code></pre>\n<hr>\n<p>Quest 5.8</p>\n<pre><code>You are in a room.\n\n&gt; test\nTURN SCRIPT\nhello\n\n&gt; test\nTURN SCRIPT\nhello\n</code></pre>\n</details>\n<hr>\n<p>If we stick with the current changes, a few people will have to edit some scripts which call <code>ASLEvent</code> if they open an existing version 550 game in Quest 5.8.</p>\n<p>If we don't make these changes to the C# code, a few authors will be saved from having to edit a few scripts, but every author who creates a game afterwards will still have to deal with the fact that an <code>ASLEvent</code> calls turn scripts an extra time.</p>\n<p>Either way, folks doing crazy stuff with <code>ASLEvent</code> will have to do extra work, which we all signed up for (knowingly or not) when we scripted said crazy stuff.  And we especially invite problems when working on older code after we've updated our game-creation software.</p>\n\n",
      "PostDate": "2018-05-31T15:07:09.1108978Z",
      "LastEditDate": "2018-05-31T15:15:19.4394323Z",
      "link": null
    },
    {
      "PostId": "731ffaab-6194-413a-a578-8df97d5ab6b5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> What's the difference between breaking TAKE and DROP to handle scope differently and possibly breaking ASLEvent to handle multiple commands? Besides ASLEvent calls being used much less by authors?\r\n\r\nI would say that you should never break existing behaviour. If a feature of the engine, or some function, works a particular way in a release version, it should continue to work that way in all future versions. Maybe that's because I've spent too much time in software engineering lectures.\r\nIf you're adding an extra parameter to a function, it should be optional. Calling the function without that parameter should give the same behaviour it did before.\r\nIf you're changing turnscripts so that the user gets the option of running them once-per-turn or once-per-command, then the default option (what happens if you import a game from a previous version) should be the way the previous version behaved.\r\n\r\n\r\n(What's the thing with breaking take/drop? Have I missed something?)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>What's the difference between breaking TAKE and DROP to handle scope differently and possibly breaking ASLEvent to handle multiple commands? Besides ASLEvent calls being used much less by authors?</p>\n</blockquote>\n<p>I would say that you should never break existing behaviour. If a feature of the engine, or some function, works a particular way in a release version, it should continue to work that way in all future versions. Maybe that's because I've spent too much time in software engineering lectures.<br>\nIf you're adding an extra parameter to a function, it should be optional. Calling the function without that parameter should give the same behaviour it did before.<br>\nIf you're changing turnscripts so that the user gets the option of running them once-per-turn or once-per-command, then the default option (what happens if you import a game from a previous version) should be the way the previous version behaved.</p>\n<p>(What's the thing with breaking take/drop? Have I missed something?)</p>\n\n",
      "PostDate": "2018-05-31T15:18:25.816026Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ed0bbbec-f7c5-4037-9ca0-46b6450867f7",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "You know what? \r\n\r\nSomeone could easily add 1 line (maybe 3 lines) of code to Quest 5.8 to make a call to ASLEvent run the turn scripts like it always has...\r\n\r\n (I'm slow sometimes.)",
      "EditableFormat": "markdown",
      "HTML": "<p>You know what?</p>\n<p>Someone could easily add 1 line (maybe 3 lines) of code to Quest 5.8 to make a call to ASLEvent run the turn scripts like it always has...</p>\n<p>(I'm slow sometimes.)</p>\n\n",
      "PostDate": "2018-05-31T15:19:52.7554338Z",
      "LastEditDate": "2018-05-31T15:41:17.629197Z",
      "link": null
    },
    {
      "PostId": "bc9f4649-ee9d-446c-b16e-904cb21c31a8",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The TAKE/DROP thing happened with the last two updates (5.7.1 and 5.7.2), but only to those of us who had overridden TAKE and DROP.\r\n\r\n...and I just thought of making ```ALSEvent``` calls handle turn scripts the same way, but we had our posts crossed up again.",
      "EditableFormat": "markdown",
      "HTML": "<p>The TAKE/DROP thing happened with the last two updates (5.7.1 and 5.7.2), but only to those of us who had overridden TAKE and DROP.</p>\n<p>...and I just thought of making <code>ALSEvent</code> calls handle turn scripts the same way, but we had our posts crossed up again.</p>\n\n",
      "PostDate": "2018-05-31T15:23:01.8791991Z",
      "LastEditDate": "2018-05-31T15:23:20.801546Z",
      "link": null
    },
    {
      "PostId": "e0416f54-6b9b-4433-896c-c5a2b8fc0dfc",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "For those of you just joining us, mrangel and I are not arguing, nor are we really debating.  We are merely sharing perspectives.\r\n\r\n(For the record, I admit that his perspective is usually the more logical.)",
      "EditableFormat": "markdown",
      "HTML": "<p>For those of you just joining us, mrangel and I are not arguing, nor are we really debating.  We are merely sharing perspectives.</p>\n<p>(For the record, I admit that his perspective is usually the more logical.)</p>\n\n",
      "PostDate": "2018-05-31T15:32:09.0358897Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0dd018fb-71c6-47d0-9996-a15b5c76838d",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is what handles a call to ASLEvent in the end:\r\n\r\n```\r\npublic void SendEvent(string eventName, string param)\r\n        {\r\n            Element handler;\r\n            m_elements.TryGetValue(ElementType.Function, eventName, out handler);\r\n\r\n            if (handler == null)\r\n            {\r\n                Print(string.Format(\"Error - no handler for event '{0}'\", eventName));\r\n                return;\r\n            }\r\n\r\n            Parameters parameters = new Parameters();\r\n            parameters.Add((string)handler.Fields[FieldDefinitions.ParamNames][0], param);\r\n\r\n            RunProcedure(eventName, parameters, false);\r\n            if (Version >= WorldModelVersion.v540)\r\n            {\r\n                if (Version < WorldModelVersion.v580)\r\n                {\r\n                    TryFinishTurn();\r\n                }\r\n                if (State != GameState.Finished)\r\n                {\r\n                    UpdateLists();\r\n                }\r\n                SendNextTimerRequest();\r\n            }\r\n        }\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>This is what handles a call to ASLEvent in the end:</p>\n<pre><code>public void SendEvent(string eventName, string param)\n        {\n            Element handler;\n            m_elements.TryGetValue(ElementType.Function, eventName, out handler);\n\n            if (handler == null)\n            {\n                Print(string.Format(\"Error - no handler for event '{0}'\", eventName));\n                return;\n            }\n\n            Parameters parameters = new Parameters();\n            parameters.Add((string)handler.Fields[FieldDefinitions.ParamNames][0], param);\n\n            RunProcedure(eventName, parameters, false);\n            if (Version &gt;= WorldModelVersion.v540)\n            {\n                if (Version &lt; WorldModelVersion.v580)\n                {\n                    TryFinishTurn();\n                }\n                if (State != GameState.Finished)\n                {\n                    UpdateLists();\n                }\n                SendNextTimerRequest();\n            }\n        }\n</code></pre>\n\n",
      "PostDate": "2018-05-31T15:47:59.3646209Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d92c174c-da76-4cfe-92e6-21a4d4f3c2b9",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It just feels like...\r\n\r\n1. Move this function out of the C# code.\r\n2. ????\r\n3. Profit!\r\n\r\nI just wish I could see the benefit.\r\n\r\n> ...and I just thought of making ALSEvent calls handle turn scripts the same way, but we had our posts crossed up again.\r\n\r\nAnother thought comes to mind. When a timer script triggers, is `FinishTurn` called after it? I can't work out when that happens, unless it's still being called from the C# code.",
      "EditableFormat": "markdown",
      "HTML": "<p>It just feels like...</p>\n<ol>\n<li>Move this function out of the C# code.</li>\n<li>????</li>\n<li>Profit!</li>\n</ol>\n<p>I just wish I could see the benefit.</p>\n<blockquote>\n<p>...and I just thought of making ALSEvent calls handle turn scripts the same way, but we had our posts crossed up again.</p>\n</blockquote>\n<p>Another thought comes to mind. When a timer script triggers, is <code>FinishTurn</code> called after it? I can't work out when that happens, unless it's still being called from the C# code.</p>\n\n",
      "PostDate": "2018-05-31T15:52:55.4810607Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "720e4d67-1c6e-4de0-a8d5-505aeea0efac",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Is the C# code not what's keeping Quest from running under Linux or Mac?  (I don't know the answer.  I'm seriously asking.)\r\n\r\n---\r\n> When a timer script triggers, is FinishTurn called after it? \r\n\r\nTesting now...",
      "EditableFormat": "markdown",
      "HTML": "<p>Is the C# code not what's keeping Quest from running under Linux or Mac?  (I don't know the answer.  I'm seriously asking.)</p>\n<hr>\n<blockquote>\n<p>When a timer script triggers, is FinishTurn called after it?</p>\n</blockquote>\n<p>Testing now...</p>\n\n",
      "PostDate": "2018-05-31T15:54:53.3126828Z",
      "LastEditDate": "2018-05-31T15:56:00.859807Z",
      "link": null
    },
    {
      "PostId": "547c8b46-c16a-4f4a-8514-5e7e67dffc0a",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "A timer doesn't trigger turn scripts in either version of Quest.",
      "EditableFormat": "markdown",
      "HTML": "<p>A timer doesn't trigger turn scripts in either version of Quest.</p>\n\n",
      "PostDate": "2018-05-31T16:01:33.1339341Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e4fc5557-7094-4bfa-8b36-564e505cce9b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Interesting :p That's going to confuse me now.\r\n\r\nOh... FinishTurn calls UpdateStatusAttributes; but it doesn't need to, because the C# code calls UpdateStatusAttributes right after it anyway.\r\nThat fixes some of the potential issues; but is a little counterintuitive.",
      "EditableFormat": "markdown",
      "HTML": "<p>Interesting :p That's going to confuse me now.</p>\n<p>Oh... FinishTurn calls UpdateStatusAttributes; but it doesn't need to, because the C# code calls UpdateStatusAttributes right after it anyway.<br>\nThat fixes some of the potential issues; but is a little counterintuitive.</p>\n\n",
      "PostDate": "2018-05-31T16:13:33.5727946Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ae42241e-37e3-46a2-97e4-99ab5ed05556",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> That's going to confuse me now.\r\n\r\nHeh.  If I had a nickel for every time I've said *that* over the past week...\r\n\r\n---\r\nSo...  Do we really *want* each call to ```ASLEvent```to fire the turn scripts?\r\n\r\nI mean, I don't.\r\n\r\n...but I'm all for taking a vote on it (especially since I am in no way in charge of anything [insert evil grin here]).",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>That's going to confuse me now.</p>\n</blockquote>\n<p>Heh.  If I had a nickel for every time I've said <em>that</em> over the past week...</p>\n<hr>\n<p>So...  Do we really <em>want</em> each call to <code>ASLEvent</code>to fire the turn scripts?</p>\n<p>I mean, I don't.</p>\n<p>...but I'm all for taking a vote on it (especially since I am in no way in charge of anything [insert evil grin here]).</p>\n\n",
      "PostDate": "2018-05-31T16:21:02.5044312Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "69caab8e-8623-4c4f-9edb-4c1d0d6f97fa",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> So... Do we really want each call to `ASLEvent` to fire the turn scripts?\r\n\r\nIf you say 'yes', it's going to make some scripts a lot more complex, and be a pain for some users; but most of those users have likely already been looking for a way to make it work. Not ideal.\r\n\r\nIf you say 'no', it's going to make some scripts more complex, and be a pain for some users. Including some whose code previously worked, or who already had implemented a workaround for the other problem. Not ideal; but probably would have been a better solution if it had been done that originally.\r\n\r\nWe want it to fire **some** of the turnscripts (for example, your `UpdateContentsInLists` turnscript should be run). So, add a flag to control it; a checkbox on the turnscript tab in the editor. And make the default fit the previous version's behaviour, so that people upgrading the editor don't find their games suddenly changing behaviour.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>So... Do we really want each call to <code>ASLEvent</code> to fire the turn scripts?</p>\n</blockquote>\n<p>If you say 'yes', it's going to make some scripts a lot more complex, and be a pain for some users; but most of those users have likely already been looking for a way to make it work. Not ideal.</p>\n<p>If you say 'no', it's going to make some scripts more complex, and be a pain for some users. Including some whose code previously worked, or who already had implemented a workaround for the other problem. Not ideal; but probably would have been a better solution if it had been done that originally.</p>\n<p>We want it to fire <strong>some</strong> of the turnscripts (for example, your <code>UpdateContentsInLists</code> turnscript should be run). So, add a flag to control it; a checkbox on the turnscript tab in the editor. And make the default fit the previous version's behaviour, so that people upgrading the editor don't find their games suddenly changing behaviour.</p>\n\n",
      "PostDate": "2018-05-31T16:56:28.2575576Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "53e11323-35c4-4699-960f-9865620c4acd",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  Not ideal; but probably would have been a better solution if it had been done that originally.\r\n\r\nExactly.  \r\n\r\nOnce upon an update, Quest was updated to handle WEAR and REMOVE, so the required code was added, which caused everyone with custom WEAR and REMOVE stuff in a game they were editing to do some extra work when editing in an upgraded editor.\r\n\r\nThis was fine, because everyone agreed that Quest should handle those commands by default in the first place.  I view the ```ASLEvent``` thing the same way.\r\n\r\n---\r\n> We want it to fire some of the turnscripts... So, add a flag to control it; a checkbox on the turnscript tab in the editor. And make the default fit the previous version's behaviour, so that people upgrading the editor don't find their games suddenly changing behaviour.\r\n\r\nWe pretty much already had this going on, sans the checkbox, before these changes.  (Setting **game.suppressturnscripts** to true, then checking for that in ```FinishTurn```.)\r\n\r\n---\r\n> people upgrading the editor don't find their games suddenly changing behaviour\r\n\r\nThis will only effect games being edited in 5.8, not published games being played in 5.8.\r\n\r\n---\r\n### THOUGHTS\r\n\r\n1. We're going to need Pixie's two cents.\r\n\r\n2. Web users cannot modify ```FinishTurn``` to suppress turn scripts when calling an ```ASLEvent```,  but they *can* call ```FinishTurn``` from any ```ASLEvent``` to control what happens with this new setup.\r\n\r\n3. Any fixes which were previously applied to try to control the turn scripts when calling an ```ASLEvent``` would probably be sloppy scripts which only decremented the turn count (not rolling back changes applied by any turn scripts), unless the author had the desktop version of Quest and modified ```FinishTurn``` and/or ```RunTurnScripts``` while they were at it.\r\n\r\n4.  This does not effect published games, only games being edited in 5.8 which were created before 5.8.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Not ideal; but probably would have been a better solution if it had been done that originally.</p>\n</blockquote>\n<p>Exactly.</p>\n<p>Once upon an update, Quest was updated to handle WEAR and REMOVE, so the required code was added, which caused everyone with custom WEAR and REMOVE stuff in a game they were editing to do some extra work when editing in an upgraded editor.</p>\n<p>This was fine, because everyone agreed that Quest should handle those commands by default in the first place.  I view the <code>ASLEvent</code> thing the same way.</p>\n<hr>\n<blockquote>\n<p>We want it to fire some of the turnscripts... So, add a flag to control it; a checkbox on the turnscript tab in the editor. And make the default fit the previous version's behaviour, so that people upgrading the editor don't find their games suddenly changing behaviour.</p>\n</blockquote>\n<p>We pretty much already had this going on, sans the checkbox, before these changes.  (Setting <strong>game.suppressturnscripts</strong> to true, then checking for that in <code>FinishTurn</code>.)</p>\n<hr>\n<blockquote>\n<p>people upgrading the editor don't find their games suddenly changing behaviour</p>\n</blockquote>\n<p>This will only effect games being edited in 5.8, not published games being played in 5.8.</p>\n<hr>\n<h3>THOUGHTS</h3>\n<ol>\n<li>\n<p>We're going to need Pixie's two cents.</p>\n</li>\n<li>\n<p>Web users cannot modify <code>FinishTurn</code> to suppress turn scripts when calling an <code>ASLEvent</code>,  but they <em>can</em> call <code>FinishTurn</code> from any <code>ASLEvent</code> to control what happens with this new setup.</p>\n</li>\n<li>\n<p>Any fixes which were previously applied to try to control the turn scripts when calling an <code>ASLEvent</code> would probably be sloppy scripts which only decremented the turn count (not rolling back changes applied by any turn scripts), unless the author had the desktop version of Quest and modified <code>FinishTurn</code> and/or <code>RunTurnScripts</code> while they were at it.</p>\n</li>\n<li>\n<p>This does not effect published games, only games being edited in 5.8 which were created before 5.8.</p>\n</li>\n</ol>\n\n",
      "PostDate": "2018-05-31T17:11:55.0627178Z",
      "LastEditDate": "2018-05-31T19:06:38.3000916Z",
      "link": null
    }
  ]
}
