{
  "Topic": {
    "TopicId": "nog_dxhdaeqzltv314mp1q",
    "ForumId": "18",
    "Title": "A Way To Save/Load Between Versions on Desktop or Online: SaveLoadCode Library (Quest 5.8)",
    "LastUpdated": "2022-03-13T04:30:52.4816008Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "e0d9245a-5bec-4a0d-ab90-fa1a778326f8",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "_(Below is a copy of my post from the main Quest Forum <a href=\"http://textadventures.co.uk/forum/quest/topic/0c6ypzyna0clj4jw_3ohmw/a-way-to-save-load-between-versions-on-desktop-or-online-saveloadcodes\">here</a>. Posted here in Libraries and Code Samples so it won't get buried.)_\r\n\r\n**Please see the github (<a href=\"https://github.com/Leviathon44/SaveLoadCode/\">https://github.com/Leviathon44/SaveLoadCode/</a>) for the latest version!**\r\n\r\nHello everyone! \r\n\r\nBeen a big fan of text adventure games for a while, but just recently decided to try my hand at making one of my own! One of the things I wanted to be able to do with my game was give the player the ability to save their game and resume playing even on a future version of the game.\r\n\r\nI considered using the SaveLoad library created by Pix (<a href=\"https://github.com/ThePix/quest/wiki/Library:-Save-and-Load\">https://github.com/ThePix/quest/wiki/Library:-Save-and-Load</a>), but unfortunately some of its limitations didn't quite work for what I had in mind. In particular, I wanted the player to be able to save their game to an actual file that could then be loaded on either the online player or desktop player. The solution I came up with was a copy/pastable code that could then be saved locally, but you may prefer Pix's cleaner in-game save/load menu solution. Additionally, I wanted to be able to change the player object (game.pov) mid-game, which is unfortunately a limitation of Pix's library. \r\n\r\nBesides that, one of the primary differences between Pix's SaveLoad library and mine is that their library saves objects explicitly, rather than procedurally, which allows the author to ensure they're ONLY saving the attributes they want to in exchange for some extra legwork. My library, on the other hand, grabs everything it can, then excludes the attributes you don't want. This means that although my library is (theoretically) easier to integrate into existing games, extra care may be required to ensure you're saving all the attributes you truly want to (especially when it comes to ensuring compatibility between saves). I highly recommend checking out Pix's library as well as mine, as both have their merits!\r\n\r\nThis may be something that others have already encountered and come up with solutions for, but I wasn't able to find any concrete examples in my online or forum searches, so I figured I would share my solution here in case others would like to use it as well!\r\n\r\nWhat I came up with is a system to save and load the player's game by creating a <b>SaveGameCode</b> function that collects nearly every attribute in the player's game, as well as a <b>LoadGameCode</b> function that parses out the saved code to update any changed attributes. Paired with some javascript to add a popup UI for the functions as well as base64 encoding (to limit the player's ability to directly edit savegames), I tried to keep everything as modular as possible, with self-explanatory comments, so others could use it too.\r\n\r\n## What do these functions do?\r\nThese functions allow you to save your game in the form of a base64-encoded code. This code can be saved locally, then copied into the load function to allow the player to load their game. \r\n\r\nWhat this means is that players can play the game online, save their progress to a save code, then load and resume that progress on a desktop version of the same game, or vice-versa. This also means that saves can be stored SEPARATELY from the rest of the Quest game, potentially allowing a player to continue their old save even on a new version of the game (provided you, as the author, account for that, but more on that in the wiki). Furthermore, loading a save code is typically MUCH faster than loading a traditional Quest 5.8 save, as traditional Quest saves save the ENTIRE game each time (and thus require you to load the entire game each time).\r\n\r\n### The _SaveGameCode_ function\r\nI encourage you to look at the source code to learn more, but at a high level the SaveGameCode function works by parsing through all objects, exits, and turnscripts in the game to save as many changeable attributes as possible in the form of a long 'SaveString'. There are some limitations to this (see the 'Limitations' section in the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a>), but for most applications the SaveString that is created is enough to completely recreate the player's game state when fed back in to the LoadGameCode function. And all of this happens more or less ***automatically*** after installing the functions and javascript, so it can potentially be added on to nearly any existing game (barring limitations)!\r\n\r\n### The _LoadGameCode_ function\r\nYou probably can guess, but the _LoadGameCode_ function is responsible for parsing a given SaveString created by the SaveGameCode function, converting it back into usable object and attribute data, and updating the corresponding attributes in the game to recreate the player's saved state. There's a bit more to it, but that's the high-level explanation. To learn more, I again highly recommend checking out the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> and/or source code!\r\n\r\n### The _SaveLoadJavaCode.js_ javascript\r\nIn addition to those two functions, I also included some additional javascript functions for converting the savecode to/from Base64 encoding (to make it a little harder to 'cheat' by editing your save state), as well as provide a nice UI for presenting the savecode and a nice UI for the player to paste existing savecodes into.\r\n\r\n### **Additional Included Functions:**\r\n\r\n### The _SaveCheckpoints_ function\r\nSaveCheckpoint works very similarly to SaveGameCode, except instead of saving the SaveString to present it to the player, it instead will save a SaveString to a game.checkpoints stringdictionary. If game.checkpoints does not exist when SaveCheckpoints is called, then it will create it.\r\n\r\nThis is useful for saving checkpoints internally that can then be loaded internally using the LoadCheckpoint function.\r\n\r\nSee the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> for more details.\r\n\r\n### The _LoadCheckpoint_ function\r\nLoadCheckpoint works very similarly to LoadGameCode, except it will not print any messages and it will not overwrite existing checkpoint data. It will also only load existing checkpoints. If it cannot find a matching checkpoint in game.checkpoints, it will throw an error.\r\n\r\nUseful for loading internally-created checkpoints (i.e. after a \"you have died! Would you like to reload before you died?\" type screen, for instance).\r\n\r\n### The _GetSaveGameCodeDelims_ function\r\nGetSaveGameCodeDelims() returns a stringlist of the delimiters used by the SaveGameCode function.\r\n\r\nUseful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveGameCode contain a banned delimiter, the game will not save/load properly.\r\n\r\n### The _GetSaveCheckpointDelims_ function\r\nGetSaveCheckpointDelims() returns a stringlist of the delimiters used by the SaveCheckpoint function.\r\n\r\nUseful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveCheckpoint contain a banned delimiter, the game will not save/load checkpoints properly.\r\n\r\n<hr>\r\nI've now completed the wiki page for these functions. Check it out if you're interested, as it goes into great detail regarding how to use these functions in your game, their limitations, workarounds, etc: <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>\r\n\r\nI also created a small test game to show off some of the functionality here (albeit slightly out of date): <a href=\"http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/\">http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/</a>\r\n\r\nI've also set up a git repository with these functions and commands drawn up in a library, 'SaveLoadCodeFunctionsLibrary.aslx', and the required javascript, 'SaveLoadJavaCode.js', here: <a href=\"https://github.com/Leviathon44/SaveLoadCode\">https://github.com/Leviathon44/SaveLoadCode</a>.\r\n\r\n**Again, please check the github (<a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>) for the latest version!**\r\n\r\nSpecial thanks to KV, mrangel, and Pix! Your forum posts and functions over the years were a valuable resource in getting this made, and mrangel's help in particular helped me solve some of the trickier issues allowing me to improve this library! I hope others find this useful!\r\n<hr>\r\n<h3>The code for the entire test game:</h3>\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.8.6836.13983-->\r\n<asl version=\"580\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Save Testing\">\r\n    <gameid>932164b2-0eae-47d6-94b4-402d8a2238d9</gameid>\r\n    <version>3.0</version>\r\n    <firstpublished>2022</firstpublished>\r\n    <feature_devmode />\r\n    <attr name=\"devmode_setinitscript\" type=\"boolean\">false</attr>\r\n    <attr name=\"devmode_changepovpos\" type=\"boolean\">false</attr>\r\n    <devmode_setverbs />\r\n    <gridmap />\r\n    <showscore type=\"boolean\">false</showscore>\r\n    <showhealth type=\"boolean\">false</showhealth>\r\n    <showmoney type=\"boolean\">false</showmoney>\r\n    <attr name=\"feature_limitinventory\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_lightdark\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_asktell\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_annotations\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_advancedwearables\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_advancedscripts\" type=\"boolean\">false</attr>\r\n    <appendobjectdescription type=\"boolean\">false</appendobjectdescription>\r\n    <allowlookdirections type=\"boolean\">false</allowlookdirections>\r\n    <multiplecommands type=\"boolean\">false</multiplecommands>\r\n    <command_newline />\r\n    <clearscreenonroomenter type=\"boolean\">false</clearscreenonroomenter>\r\n    <autodisplayverbs />\r\n    <author>Leviathon</author>\r\n    <start type=\"script\">\r\n      // Initialization script for SaveLoadCode functionality...\r\n      // Create a list of all object and exit names present in game at start. This way we can keep track of which objects/exits the player has created/destroyed while playing by comparing to this list when saving/loading.\r\n      set (game, \"StartingObjStrList\", NewStringList ())\r\n      foreach (startobj, AllObjects()) {\r\n        list add (game.StartingObjStrList, startobj.name)\r\n      }\r\n      foreach (startobj, AllExits()) {\r\n        list add (game.StartingObjStrList, startobj.name)\r\n      }\r\n      set (game, \"checkpoints\", NewStringDictionary())\r\n      // End of SaveLoadCode initialization script\r\n    </start>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <isroom />\r\n    <description><![CDATA[This is the starting room of the SaveLoadCode functionality demo.<br/><br/>Type \"SaveCode\" at any time to create a save code, allowing you to load later. Copy the code to a notepad document to save it for later!<br/><br/>Type \"LoadCode\" at any time to load a previously saved code. Paste in your previously-saved save code to load your game!]]></description>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <StringAttribute>Stringy Bingy</StringAttribute>\r\n      <alias>Francis</alias>\r\n      <ObjectListRedux type=\"objectlist\"></ObjectListRedux>\r\n    </object>\r\n    <object name=\"BoingoBall\">\r\n      <inherit name=\"editor_object\" />\r\n      <IsBall />\r\n      <MemoryDict type=\"stringdictionary\">\r\n        <item>\r\n          <key>Mem1</key>\r\n          <value>Memories of 1</value>\r\n        </item>\r\n        <item>\r\n          <key>Mem2</key>\r\n          <value>Memories of 2</value>\r\n        </item>\r\n      </MemoryDict>\r\n      <ListOfString type=\"stringlist\">\r\n        <value>Brock</value>\r\n        <value>Misty</value>\r\n        <value>Ash</value>\r\n        <value>Pikachu</value>\r\n      </ListOfString>\r\n      <look>This is an object with a bunch of attributes attached to it. The SaveGameCode and LoadGameCode functions will save all its attributes and update them on load if they've changed.</look>\r\n    </object>\r\n    <exit name=\"KeyRoomDoor\" alias=\"east\" to=\"Key Room\">\r\n      <inherit name=\"eastdirection\" />\r\n      <locked />\r\n      <runscript />\r\n      <script type=\"script\"><![CDATA[\r\n        if (DoorKey.parent=game.pov and this.locked=true) {\r\n          msg (\"<i>You unlock the door and enter</i>\")\r\n          this.locked = false\r\n          game.pov.parent = Key Room\r\n        }\r\n        else if (this.locked=true) {\r\n          msg (\"That way is locked.\")\r\n        }\r\n        else {\r\n          game.pov.parent = Key Room\r\n        }\r\n      ]]></script>\r\n    </exit>\r\n    <exit alias=\"north\" to=\"SideRoom\">\r\n      <inherit name=\"northdirection\" />\r\n    </exit>\r\n    <object name=\"DoorKey\">\r\n      <inherit name=\"editor_object\" />\r\n      <take />\r\n      <alias>Key</alias>\r\n      <feature_usegive />\r\n      <use type=\"script\"><![CDATA[\r\n        if (game.pov.parent=room and KeyRoomDoor.locked=True) {\r\n          msg (\"<i>Using the key, you unlock the door!</i>\")\r\n          KeyRoomDoor.locked = False\r\n          msg (\"<br>As you walk through the door, the key disintegrates in your hand, <i>destroying</i> it. (i.e. The Key object itself has been destroyed. If you type 'SaveCode' now, when you load that save the Key will still be destroyed!)\")\r\n          destroy (\"DoorKey\")\r\n        }\r\n        else if (game.pov.parent=room and KeyRoomDoor.locked=False) {\r\n          msg (\"<i>The door is already unlocked!</i>\")\r\n        }\r\n        else {\r\n          msg (\"<i>There are no locks to use this on here!</i>\")\r\n        }\r\n      ]]></use>\r\n    </object>\r\n    <object name=\"SaveCheckpoint Button\">\r\n      <inherit name=\"editor_object\" />\r\n      <look><![CDATA[Using this button will create a checkpoint! Using it more than once will overwrite the existing checkpoint.<br/><br/>If you find the LoadCheckpoint Button, you can then load the checkpoint created here.]]></look>\r\n      <feature_usegive />\r\n      <displayverbs type=\"stringlist\">\r\n        <value>Look at</value>\r\n        <value>Use</value>\r\n      </displayverbs>\r\n      <use type=\"script\">\r\n        SaveCheckpoint (\"Checkpoint\")\r\n      </use>\r\n    </object>\r\n  </object>\r\n  <object name=\"Key Room\">\r\n    <inherit name=\"editor_room\" />\r\n    <description><![CDATA[You made it in!<br/><br/>If you save now and load from a new game, this room will still be unlocked!]]></description>\r\n    <enter type=\"script\">\r\n    </enter>\r\n    <firstenter type=\"script\">\r\n    </firstenter>\r\n    <exit alias=\"west\" to=\"room\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"SideRoom\">\r\n    <inherit name=\"editor_room\" />\r\n    <description><![CDATA[A side room. When you load, this room will show up on the map since you've explored it now! (It was harder to make this happen than you think it would be...)<br/><br/>{here DoorKey:You see a {object:DoorKey} on the floor!}]]></description>\r\n    <exit alias=\"south\" to=\"room\">\r\n      <inherit name=\"southdirection\" />\r\n    </exit>\r\n    <exit alias=\"west\" to=\"OtherSideRoom\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n    <exit alias=\"down\" to=\"Basement\">\r\n      <inherit name=\"downdirection\" />\r\n    </exit>\r\n    <object name=\"LoadCheckpoint Button\">\r\n      <inherit name=\"editor_object\" />\r\n      <feature_usegive />\r\n      <use type=\"script\">\r\n        LoadCheckpoint (\"Checkpoint\")\r\n      </use>\r\n      <displayverbs type=\"stringlist\">\r\n        <value>Look at</value>\r\n        <value>Use</value>\r\n      </displayverbs>\r\n      <look>Using this button will load the checkpoint created by the SaveCheckpoint Button (if one was created...)</look>\r\n    </object>\r\n  </object>\r\n  <object name=\"OtherSideRoom\">\r\n    <inherit name=\"editor_room\" />\r\n    <exit alias=\"east\" to=\"SideRoom\">\r\n      <inherit name=\"eastdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"Basement\">\r\n    <inherit name=\"editor_room\" />\r\n    <attr name=\"grid_fill\">Teal</attr>\r\n    <exit alias=\"up\" to=\"SideRoom\">\r\n      <inherit name=\"updirection\" />\r\n    </exit>\r\n    <exit alias=\"east\" to=\"Basement Side\">\r\n      <inherit name=\"eastdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"Basement Side\">\r\n    <inherit name=\"editor_room\" />\r\n    <attr name=\"grid_fill\">Teal</attr>\r\n    <exit alias=\"west\" to=\"Basement\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n  </object>\r\n  <command>\r\n    <pattern>SaveCode</pattern>\r\n    <script>\r\n      SuppressTurnscripts\r\n      SaveGameCode (True)\r\n    </script>\r\n  </command>\r\n  <command>\r\n    <pattern>LoadCode</pattern>\r\n    <script>\r\n      SuppressTurnscripts\r\n      JS.LoadGamePrompt ()\r\n    </script>\r\n  </command>\r\n  <function name=\"LoadGameCode\" parameters=\"SaveGameCodeDecoded\"><![CDATA[\r\n    // LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\r\n    SuppressTurnscripts\r\n    // NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\r\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\n    OldestAllowedVersion = 2.0\r\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\n    DebugMode = False\r\n    // Msg for Debugging:\r\n    if (DebugMode) {\r\n      msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n    }\r\n    // Set up other variables for later\r\n    bla => {\r\n    }\r\n    upgradesave = False\r\n    Proceed = False\r\n    SkippedAttList = \"\"\r\n    CreatedObjDebugList = \"\"\r\n    DestroyedObjDebugList = \"\"\r\n    // Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\r\n    CheckForCheck = Right(SaveGameCodeDecoded,2)\r\n    if (CheckForCheck=\"✓✓\") {\r\n      upgradesave = True\r\n      SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\r\n    }\r\n    // Retrieve delimiters from end of SaveGameCodeDecoded\r\n    Dls = Right(SaveGameCodeDecoded,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Remove delimiters from end of SaveGameCode\r\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n    // Special logic to extract saved game.checkpoints attribute\r\n    D4toD1 = D4+D3+D2+D1\r\n    CheckpointSplit = Split(SaveCode, D4toD1)\r\n    SaveCode = ListItem(CheckpointSplit,0)\r\n    CheckpointKeys = ListItem(CheckpointSplit,1)\r\n    // If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\r\n    if (not CheckpointKeys=\"\") {\r\n      CheckpointKeyList = Split(CheckpointKeys, D3)\r\n      game.checkpoints = NewStringDictionary()\r\n      for (xx, 0, ListCount(CheckpointKeyList)-1) {\r\n        key = ListItem(CheckpointKeyList,xx)\r\n        val = ListItem(CheckpointSplit,xx+1)\r\n        DictionaryAdd (game.checkpoints, key, val)\r\n      }\r\n    }\r\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n    }\r\n    CDList = Split(CreatedDestroyedInfo,D1)\r\n    CSection = ListItem (CDList, 0)\r\n    DSection = ListItem (CDList, 1)\r\n    if (CSection=\"\") {\r\n      CreatedList = NewStringList()\r\n    }\r\n    else {\r\n      CreatedList = Split (CSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (CreatedList, \" \")\r\n    }\r\n    if (DSection=\"\") {\r\n      DestroyedList = NewStringList()\r\n    }\r\n    else {\r\n      DestroyedList = Split (DSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (DestroyedList, \" \")\r\n    }\r\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>GridGInfo: \"+GridGInfo)\r\n    }\r\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\n    if (DebugMode) {\r\n      msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n    }\r\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\n    GameIdDelim = Instr (SaveCode, D1)\r\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\n    GameIdObjectEl = ListItem (GameInfo,0)\r\n    GameIdElements = Split(GameIdObjectEl,D2)\r\n    Loaded_GameId = ListItem (GameIdElements, 3)\r\n    GameVerObjectEl = ListItem (GameInfo,1)\r\n    GameVerElements = Split(GameVerObjectEl,D2)\r\n    VersionString = ListItem (GameVerElements, 3)\r\n    Loaded_GameVersion = ToDouble(VersionString)\r\n    GamePOVObjectEl = ListItem (GameInfo,2)\r\n    GamePOVElements = Split(GamePOVObjectEl,D2)\r\n    GamePOVName = ListItem (GamePOVElements, 3)\r\n    if (StartsWith(GamePOVName,\"Object: \")) {\r\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n    }\r\n    GamePOVObject = GetObject (GamePOVName)\r\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n    // Check that the save belongs to this game by comparing gameIds\r\n    if (not Loaded_GameId=game.gameid) {\r\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n    }\r\n    else {\r\n      // Compare version of game in SaveCode to version of game loading it\r\n      ThisGame_GameVersion = ToDouble(game.version)\r\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n      }\r\n      else {\r\n        OldestAllowedVersion_Double = OldestAllowedVersion\r\n      }\r\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n      if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n        if (upgradesave = False) {\r\n          if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n            msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br><br>Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\r\n            // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\r\n            create (\"SaveGameDecodedObj\")\r\n            set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\r\n            ShowMenu (\"\", Split(\"Yes;No\"), false) {\r\n              switch (result) {\r\n                case (\"Yes\") {\r\n                  SuppressTurnscripts\r\n                  msg (\"Save code identified! Proceeding with load, please wait...\")\r\n                  OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\r\n                  LoadGameCode (OlderSaveCode)\r\n                  destroy (\"SaveGameDecodedObj\")\r\n                }\r\n                case (\"No\") {\r\n                  SuppressTurnscripts\r\n                  msg (\"Load Aborted.\")\r\n                  destroy (\"SaveGameDecodedObj\")\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n          }\r\n        }\r\n        else {\r\n          msg (\"Applying savecode from older version...\")\r\n          Proceed = True\r\n        }\r\n      }\r\n      else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n      }\r\n      else {\r\n        msg (\"Proceeding with load...\")\r\n        Proceed = True\r\n      }\r\n      if (Proceed=True) {\r\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n        if (ListCount(CreatedList)>0) {\r\n          foreach (o, CreatedList) {\r\n            // Check that objects don't already exist...\r\n            IsThere = GetObject(o)\r\n            if (Equal(IsThere,null)) {\r\n              // If not, create the object\r\n              create (o)\r\n              CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        player.grid_coordinates = null\r\n        // Split the save code up into all objects. Then parse through the value of each object attribute\r\n        SavedObjectList = Split(SaveCode, D1)\r\n        foreach (o, SavedObjectList) {\r\n          Skip_Att = False\r\n          objelements = Split(o, D2)\r\n          objectname = ListItem (objelements, 0)\r\n          object = GetObject (objectname)\r\n          attributename = ListItem (objelements, 1)\r\n          fullname = objectname+\".\"+attributename\r\n          preload_att_value = GetAttribute (object, attributename)\r\n          att_datatype = ListItem (objelements, 2)\r\n          if (ListCount(objelements)=3) {\r\n            att_value = \"\"\r\n          }\r\n          else {\r\n            att_value = ListItem (objelements, 3)\r\n          }\r\n          // Check that the attribute is supported\r\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n            Skip_Att = True\r\n            SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n          }\r\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n          att_value_obj = att_value\r\n          if (att_datatype=\"object\") {\r\n            if (StartsWith(att_value,\"Object: \")) {\r\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              att_value_obj = GetObject(att_value)\r\n            }\r\n          }\r\n          else if (att_datatype=\"boolean\") {\r\n            if (att_value=\"True\") {\r\n              att_value_obj = True\r\n            }\r\n            else {\r\n              att_value_obj = False\r\n            }\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            att_value_obj = ToInt(att_value)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            att_value_obj = ToDouble(att_value)\r\n          }\r\n          else if (att_datatype=\"stringlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringList()\r\n            }\r\n            else {\r\n              att_value_obj = Split (att_value, D3)\r\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n              list remove (att_value_obj, \" \")\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectList()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectList()\r\n              objlistlist = Split (att_value, D3)\r\n              foreach (olt, objlistlist) {\r\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n                if (StartsWith(olt,\"Object: \")) {\r\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n                  if (not value=null) {\r\n                    list add (att_value_obj, value)\r\n                  }\r\n                  else {\r\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewStringDictionary()\r\n              // Add dictionary values from SaveGame\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                value = ListItem(KeyValList, 1)\r\n                DictionaryAdd (att_value_obj, key, value)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectDictionary()\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                obj = ListItem(KeyValList, 1)\r\n                if (StartsWith(obj,\"Object: \")) {\r\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                }\r\n                else {\r\n                  value = obj\r\n                }\r\n                if (not value=null) {\r\n                  DictionaryAdd (att_value_obj, key, value)\r\n                }\r\n                else {\r\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (objectname=GamePOVName and attributename=\"parent\") {\r\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n            Skip_Att = True\r\n            GamePOVParent = att_value_obj\r\n          }\r\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n            if (Equal(preload_att_value,null)) {\r\n              if (DebugMode) {\r\n                msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n              }\r\n              preload_att_value = \"null\"\r\n            }\r\n            // Msgs for debugging:\r\n            if (DebugMode) {\r\n              msg (\"objectname=\"+objectname)\r\n              msg (\"attributename=\"+attributename)\r\n              msg (\"att_datatype=\"+att_datatype)\r\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n              if (Equal(preload_att_value,\"null\")) {\r\n                msg (\"preload_att_datatype=null\")\r\n              }\r\n              else {\r\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n              }\r\n              msg (\"att_value=\"+ToString(att_value))\r\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n              msg (\"<br>\")\r\n            }\r\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n              if (DebugMode) {\r\n                msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n              }\r\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n              cha = \"changed\" + attributename\r\n              if (HasAttribute (object, cha)) {\r\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n                scr = GetAttribute (object, cha)\r\n                set (object, cha, bla)\r\n              }\r\n              // Update the attributes in the game with those from the SaveCode...\r\n              if (att_datatype=\"boolean\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"int\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"double\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"object\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n                // NOTE TO DEVELOPER:\r\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n                if (upgradesave = True) {\r\n                  // This section will trigger if the player is loading a save from a previous game version\r\n                  ReplaceContents = True\r\n                }\r\n                else {\r\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n                  ReplaceContents = True\r\n                }\r\n                if (att_datatype=\"stringlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace stringlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                    FinalList = NewStringList()\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    CompactList = ListCompact (CombinedList)\r\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                    foreach (olt, CompactList) {\r\n                      list add (FinalList, olt)\r\n                    }\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace objectlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    FinalList = ObjectListCompact (CombinedList)\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"stringdictionary\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                    Dummy = NewStringDictionary()\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectdictionary\") {\r\n                  if (upgradesave = False) {\r\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      if (StartsWith(value,\"Object: \")) {\r\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                      }\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n              }\r\n              else if (att_datatype=\"string\") {\r\n                set (object, attributename, att_value)\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n              }\r\n              if (HasAttribute (object, cha)) {\r\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n                set (object, cha, scr)\r\n                scr => {\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n        AllSavedGrids = Split(GridGInfo,D4)\r\n        if (DebugMode) {\r\n          msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n        }\r\n        foreach (A, AllSavedGrids) {\r\n          UDictionary = NewDictionary()\r\n          ItemAndValue = Split(A,\"&%&\")\r\n          ObjAndAtt = ListItem(ItemAndValue,0)\r\n          ObjAndAtt = Split(ObjAndAtt,D2)\r\n          objectname = ListItem(ObjAndAtt,0)\r\n          attributename = ListItem(ObjAndAtt,1)\r\n          object = GetObject(objectname)\r\n          GridVals = ListItem(ItemAndValue,1)\r\n          GridVals = Split(GridVals,D1)\r\n          foreach (B, GridVals) {\r\n            UKeyAndUVal = Split(B,D2)\r\n            UKey = ListItem(UKeyAndUVal,0)\r\n            UVal = ListItem(UKeyAndUVal,1)\r\n            UVal = Split(UVal,D3)\r\n            LDictionary = NewDictionary()\r\n            foreach (C, UVal) {\r\n              LkeyAndLval = Split(C,\" = \")\r\n              Lkey = ListItem(LkeyAndLval,0)\r\n              LvalAndType = ListItem(LkeyAndLval,1)\r\n              LvalAndType = Split(LvalAndType,\":\")\r\n              Lval_str = ListItem(LvalAndType,0)\r\n              LType = ListItem(LvalAndType,1)\r\n              if (LType=\"int\") {\r\n                Lval = ToInt(Lval_str)\r\n              }\r\n              else if (LType=\"double\") {\r\n                Lval = ToDouble(Lval_str)\r\n              }\r\n              else if (LType=\"boolean\") {\r\n                if (Lval_str=\"True\") {\r\n                  Lval = True\r\n                }\r\n                else {\r\n                  Lval = False\r\n                }\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n              }\r\n              DictionaryAdd (LDictionary, Lkey, Lval)\r\n            }\r\n            DictionaryAdd (UDictionary, UKey, LDictionary)\r\n          }\r\n          if (DebugMode) {\r\n            msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n          }\r\n          set (object, attributename, UDictionary)\r\n        }\r\n        // Destroy any objects that the player destroyed during their saved game, if any\r\n        if (ListCount(DestroyedList)>0) {\r\n          foreach (o, DestroyedList) {\r\n            // Check that objects still exist...\r\n            IsThere = GetObject(o)\r\n            if (not Equal(IsThere,null)) {\r\n              // If its there, destroy the object\r\n              destroy (o)\r\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        msg (\"Load complete!\")\r\n        if (DebugMode) {\r\n          msg (\"Created objects: \"+CreatedObjDebugList)\r\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n          msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n        }\r\n        // Finally, update game.pov.parent and game.pov\r\n        wait {\r\n          set (GamePOVObject, \"parent\", GamePOVParent)\r\n          game.pov = GamePOVObject\r\n          // player.grid_coordinates = null\r\n          JS.Grid_ClearAllLayers ()\r\n          Grid_Redraw\r\n          Grid_DrawPlayerInRoom (game.pov.parent)\r\n          ClearScreen\r\n          ShowRoomDescription\r\n        }\r\n      }\r\n    }\r\n  ]]></function>\r\n  <function name=\"SaveGameCode\" parameters=\"ShowCodePopupFlag\" type=\"string\"><![CDATA[\r\n    // SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\r\n    // The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\r\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\n    SuppressTurnscripts\r\n    // Make sure ShowCodePopupFlag is of type 'boolean'\r\n    if (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\r\n      X = TypeOf(ShowCodePopupFlag)\r\n      error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    SaveString = \"\"\r\n    CreatedObj = NewStringList()\r\n    DestroyedObj = NewStringList()\r\n    // Set delimiters.\r\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\n    D1 = \"|\"\r\n    D2 = \"$\"\r\n    D3 = \";\"\r\n    D4 = \"@\"\r\n    // Save the player's current map before saving\r\n    // Make sure first two entries are gameid and version (for load function)\r\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n    // Record all changable object attributes\r\n    foreach (o, AllObjects()) {\r\n      objectname = o.name\r\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n            // Confirm there are no banned delimiters in the list entries\r\n            v = GetAttribute (o, attributename)\r\n            if (ListCount(v)>0) {\r\n              if (att_datatype=\"stringlist\") {\r\n                foreach (listcheck, v) {\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n            // Confirm there are no banned delimiters in the dictionary entries\r\n            v = GetAttribute (o, attributename)\r\n            if (DictionaryCount(v)>0) {\r\n              foreach (dictkey, v) {\r\n                if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                }\r\n                if (att_datatype=\"stringdictionary\") {\r\n                  dictitm = DictionaryItem (v, dictkey)\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (o, AllExits()) {\r\n      objectname = o.name\r\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (turnscript, AllTurnScripts()) {\r\n      // Check for which turnscripts are enabled/disabled\r\n      if (GetBoolean(turnscript, \"enabled\")) {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n      }\r\n      else {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n      }\r\n    }\r\n    // Determine if any objects were destroyed by the player since game start...\r\n    foreach (objectname, game.StartingObjStrList) {\r\n      IsThere = GetObject(objectname)\r\n      if (Equal(IsThere,null)) {\r\n        list add (DestroyedObj, objectname)\r\n      }\r\n    }\r\n    // Save the game.timeelapsed attribute\r\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\r\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\n    if (HasAttribute (game, \"SaveAtts\")) {\r\n      SaveAttType = TypeOf(game.SaveAtts)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveAtts)>0) {\r\n          foreach (x, game.SaveAtts) {\r\n            AttValue = GetAttribute (game, x)\r\n            att_datatype = TypeOf(AttValue)\r\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n            }\r\n            else if (Equal(x,\"checkpoints\")) {\r\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n            }\r\n            else if (Equal(AttValue,null)) {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\n    if (HasAttribute (game, \"SaveTimers\")) {\r\n      SaveAttType = TypeOf(game.SaveTimers)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveTimers)>0) {\r\n          foreach (x, game.SaveTimers) {\r\n            T = GetObject(x)\r\n            if (not Equal(T,null)) {\r\n              TimerName = x.name\r\n              TimerValue1 = x.trigger\r\n              TimerValue2 = x.interval\r\n              TimerValue3 = x.enabled\r\n              TimerValue1Type = TypeOf(TimerValue1)\r\n              TimerValue2Type = TypeOf(TimerValue2)\r\n              TimerValue3Type = TypeOf(TimerValue3)\r\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\n    foreach (o, AllObjects()) {\r\n      foreach (attributename, GetAttributeNames(o,false)) {\r\n        objectname = o.name\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add on the list of created/destroyed objects...\r\n    X = ToString(CreatedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    X = ToString(DestroyedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n    // Special logic needed in order to save the game.checkpoints attribute\r\n    D4toD1 = D4+D3+D2+D1\r\n    if (HasAttribute(game,\"checkpoints\")) {\r\n      if (DictionaryCount(game.checkpoints)>0) {\r\n        KeyList = \"\"\r\n        CheckValList = \"\"\r\n        foreach (k, game.checkpoints) {\r\n          KeyList = KeyList+k+D3\r\n          val = DictionaryItem(game.checkpoints, k)\r\n          CheckValList = CheckValList+val+D4toD1\r\n        }\r\n        // Remove final D3 from KeyList string and final D4toD1 from CheckValList\r\n        KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\r\n        CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\r\n        // Add game.checkpoints data to SaveString\r\n        SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\r\n      }\r\n      else {\r\n        // If game.checkpoints empty, just add D4toD1 to SaveString.\r\n        SaveString = SaveString+D4toD1\r\n      }\r\n    }\r\n    else {\r\n      // If game.checkpoints non-existant, just add D4toD1 to SaveString.\r\n      SaveString = SaveString+D4toD1\r\n    }\r\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\n    SaveString = SaveString+D1+D2+D3+D4\r\n    // msg for Debugging:\r\n    // msg (SaveString+\"<br><br>\")\r\n    if (ShowCodePopupFlag=True) {\r\n      // Create save code and present to player in textbox\r\n      JS.CreateSaveCode (SaveString)\r\n      JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\r\n    }\r\n    return (SaveString)\r\n  ]]></function>\r\n  <function name=\"SaveCheckpoint\" parameters=\"CheckpointName\" type=\"string\"><![CDATA[\r\n    // SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\r\n    // The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\r\n    // If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\r\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\n    SuppressTurnscripts\r\n    // Check if game.checkpoints exists. If not, create it.\r\n    if (not HasAttribute(game, \"checkpoints\")) {\r\n      set (game, \"checkpoints\", NewStringDictionary())\r\n    }\r\n    // Make sure CheckpointName input is of 'string' datatype\r\n    if (not TypeOf(CheckpointName)=\"string\") {\r\n      X = TypeOf(CheckpointName)\r\n      error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    SaveString = \"\"\r\n    CreatedObj = NewStringList()\r\n    DestroyedObj = NewStringList()\r\n    // Set delimiters.\r\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\n    D1 = \"|\"\r\n    D2 = \"$\"\r\n    D3 = \";\"\r\n    D4 = \"@\"\r\n    // Save the player's current map before saving\r\n    // Make sure first two entries are gameid and version (for load function)\r\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n    // Record all changable object attributes\r\n    foreach (o, AllObjects()) {\r\n      objectname = o.name\r\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n            // Confirm there are no banned delimiters in the list entries\r\n            v = GetAttribute (o, attributename)\r\n            if (ListCount(v)>0) {\r\n              if (att_datatype=\"stringlist\") {\r\n                foreach (listcheck, v) {\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n            // Confirm there are no banned delimiters in the dictionary entries\r\n            v = GetAttribute (o, attributename)\r\n            if (DictionaryCount(v)>0) {\r\n              foreach (dictkey, v) {\r\n                if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                }\r\n                if (att_datatype=\"stringdictionary\") {\r\n                  dictitm = DictionaryItem (v, dictkey)\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (o, AllExits()) {\r\n      objectname = o.name\r\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (turnscript, AllTurnScripts()) {\r\n      // Check for which turnscripts are enabled/disabled\r\n      if (GetBoolean(turnscript, \"enabled\")) {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n      }\r\n      else {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n      }\r\n    }\r\n    // Determine if any objects were destroyed by the player since game start...\r\n    foreach (objectname, game.StartingObjStrList) {\r\n      IsThere = GetObject(objectname)\r\n      if (Equal(IsThere,null)) {\r\n        list add (DestroyedObj, objectname)\r\n      }\r\n    }\r\n    // Save the game.timeelapsed attribute\r\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\r\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\n    if (HasAttribute (game, \"SaveAtts\")) {\r\n      SaveAttType = TypeOf(game.SaveAtts)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveAtts)>0) {\r\n          foreach (x, game.SaveAtts) {\r\n            AttValue = GetAttribute (game, x)\r\n            att_datatype = TypeOf(AttValue)\r\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n            }\r\n            else if (Equal(x,\"checkpoints\")) {\r\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n            }\r\n            else if (Equal(AttValue,null)) {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\n    if (HasAttribute (game, \"SaveTimers\")) {\r\n      SaveAttType = TypeOf(game.SaveTimers)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveTimers)>0) {\r\n          foreach (x, game.SaveTimers) {\r\n            T = GetObject(x)\r\n            if (not Equal(T,null)) {\r\n              TimerName = x.name\r\n              TimerValue1 = x.trigger\r\n              TimerValue2 = x.interval\r\n              TimerValue3 = x.enabled\r\n              TimerValue1Type = TypeOf(TimerValue1)\r\n              TimerValue2Type = TypeOf(TimerValue2)\r\n              TimerValue3Type = TypeOf(TimerValue3)\r\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\n    foreach (o, AllObjects()) {\r\n      foreach (attributename, GetAttributeNames(o,false)) {\r\n        objectname = o.name\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add on the list of created/destroyed objects...\r\n    X = ToString(CreatedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    X = ToString(DestroyedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\n    SaveString = SaveString+D1+D2+D3+D4\r\n    // msg for Debugging:\r\n    // msg (SaveString+\"<br><br>\")\r\n    // Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\r\n    if (not CheckpointName=\"\") {\r\n      DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\r\n    }\r\n    return (SaveString)\r\n  ]]></function>\r\n  <function name=\"LoadCheckpoint\" parameters=\"CheckpointName\"><![CDATA[\r\n    // LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\r\n    // Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\r\n    SuppressTurnscripts\r\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\n    OldestAllowedVersion = 2.0\r\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\n    DebugMode = False\r\n    // Msg for Debugging:\r\n    if (DebugMode) {\r\n      msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n    }\r\n    // Make sure CheckpointName input is of type 'string'\r\n    if (not TypeOf(CheckpointName)=\"string\") {\r\n      X = TypeOf(CheckpointName)\r\n      error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    // Retrieve SaveString from game.checkpoints dictionary\r\n    if (HasAttribute(game, \"checkpoints\")) {\r\n      if (DictionaryContains(game.checkpoints, CheckpointName)) {\r\n        SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\r\n      }\r\n      else {\r\n        error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\r\n      }\r\n    }\r\n    else {\r\n      error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\r\n    }\r\n    // Set up other variables for later\r\n    bla => {\r\n    }\r\n    upgradesave = False\r\n    Proceed = False\r\n    SkippedAttList = \"\"\r\n    CreatedObjDebugList = \"\"\r\n    DestroyedObjDebugList = \"\"\r\n    // Retrieve delimiters from end of SaveGameCodeDecoded\r\n    Dls = Right(SaveGameCodeDecoded,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Remove delimiters from end of SaveGameCode\r\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n    }\r\n    CDList = Split(CreatedDestroyedInfo,D1)\r\n    CSection = ListItem (CDList, 0)\r\n    DSection = ListItem (CDList, 1)\r\n    if (CSection=\"\") {\r\n      CreatedList = NewStringList()\r\n    }\r\n    else {\r\n      CreatedList = Split (CSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (CreatedList, \" \")\r\n    }\r\n    if (DSection=\"\") {\r\n      DestroyedList = NewStringList()\r\n    }\r\n    else {\r\n      DestroyedList = Split (DSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (DestroyedList, \" \")\r\n    }\r\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>GridGInfo: \"+GridGInfo)\r\n    }\r\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\n    if (DebugMode) {\r\n      msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n    }\r\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\n    GameIdDelim = Instr (SaveCode, D1)\r\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\n    GameIdObjectEl = ListItem (GameInfo,0)\r\n    GameIdElements = Split(GameIdObjectEl,D2)\r\n    Loaded_GameId = ListItem (GameIdElements, 3)\r\n    GameVerObjectEl = ListItem (GameInfo,1)\r\n    GameVerElements = Split(GameVerObjectEl,D2)\r\n    VersionString = ListItem (GameVerElements, 3)\r\n    Loaded_GameVersion = ToDouble(VersionString)\r\n    GamePOVObjectEl = ListItem (GameInfo,2)\r\n    GamePOVElements = Split(GamePOVObjectEl,D2)\r\n    GamePOVName = ListItem (GamePOVElements, 3)\r\n    if (StartsWith(GamePOVName,\"Object: \")) {\r\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n    }\r\n    GamePOVObject = GetObject (GamePOVName)\r\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n    // Check that the save belongs to this game by comparing gameIds\r\n    if (not Loaded_GameId=game.gameid) {\r\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n    }\r\n    else {\r\n      // Compare version of game in SaveCode to version of game loading it\r\n      ThisGame_GameVersion = ToDouble(game.version)\r\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n      }\r\n      else {\r\n        OldestAllowedVersion_Double = OldestAllowedVersion\r\n      }\r\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n      if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n        if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n          upgradesave = True\r\n          Proceed = True\r\n        }\r\n        else {\r\n          error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n        }\r\n      }\r\n      else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n      }\r\n      else {\r\n        Proceed = True\r\n      }\r\n      if (Proceed=True) {\r\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n        if (ListCount(CreatedList)>0) {\r\n          foreach (o, CreatedList) {\r\n            // Check that objects don't already exist...\r\n            IsThere = GetObject(o)\r\n            if (Equal(IsThere,null)) {\r\n              // If not, create the object\r\n              create (o)\r\n              CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        player.grid_coordinates = null\r\n        // Split the save code up into all objects. Then parse through the value of each object attribute\r\n        SavedObjectList = Split(SaveCode, D1)\r\n        foreach (o, SavedObjectList) {\r\n          Skip_Att = False\r\n          objelements = Split(o, D2)\r\n          objectname = ListItem (objelements, 0)\r\n          object = GetObject (objectname)\r\n          attributename = ListItem (objelements, 1)\r\n          fullname = objectname+\".\"+attributename\r\n          preload_att_value = GetAttribute (object, attributename)\r\n          att_datatype = ListItem (objelements, 2)\r\n          if (ListCount(objelements)=3) {\r\n            att_value = \"\"\r\n          }\r\n          else {\r\n            att_value = ListItem (objelements, 3)\r\n          }\r\n          // Check that the attribute is supported\r\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n            Skip_Att = True\r\n            SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n          }\r\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n          att_value_obj = att_value\r\n          if (att_datatype=\"object\") {\r\n            if (StartsWith(att_value,\"Object: \")) {\r\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              att_value_obj = GetObject(att_value)\r\n            }\r\n          }\r\n          else if (att_datatype=\"boolean\") {\r\n            if (att_value=\"True\") {\r\n              att_value_obj = True\r\n            }\r\n            else {\r\n              att_value_obj = False\r\n            }\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            att_value_obj = ToInt(att_value)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            att_value_obj = ToDouble(att_value)\r\n          }\r\n          else if (att_datatype=\"stringlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringList()\r\n            }\r\n            else {\r\n              att_value_obj = Split (att_value, D3)\r\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n              list remove (att_value_obj, \" \")\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectList()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectList()\r\n              objlistlist = Split (att_value, D3)\r\n              foreach (olt, objlistlist) {\r\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n                if (StartsWith(olt,\"Object: \")) {\r\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n                  if (not value=null) {\r\n                    list add (att_value_obj, value)\r\n                  }\r\n                  else {\r\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewStringDictionary()\r\n              // Add dictionary values from SaveGame\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                value = ListItem(KeyValList, 1)\r\n                DictionaryAdd (att_value_obj, key, value)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectDictionary()\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                obj = ListItem(KeyValList, 1)\r\n                if (StartsWith(obj,\"Object: \")) {\r\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                }\r\n                else {\r\n                  value = obj\r\n                }\r\n                if (not value=null) {\r\n                  DictionaryAdd (att_value_obj, key, value)\r\n                }\r\n                else {\r\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (objectname=GamePOVName and attributename=\"parent\") {\r\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n            Skip_Att = True\r\n            GamePOVParent = att_value_obj\r\n          }\r\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n            if (Equal(preload_att_value,null)) {\r\n              if (DebugMode) {\r\n                msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n              }\r\n              preload_att_value = \"null\"\r\n            }\r\n            // Msgs for debugging:\r\n            if (DebugMode) {\r\n              msg (\"objectname=\"+objectname)\r\n              msg (\"attributename=\"+attributename)\r\n              msg (\"att_datatype=\"+att_datatype)\r\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n              if (Equal(preload_att_value,\"null\")) {\r\n                msg (\"preload_att_datatype=null\")\r\n              }\r\n              else {\r\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n              }\r\n              msg (\"att_value=\"+ToString(att_value))\r\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n              msg (\"<br>\")\r\n            }\r\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n              if (DebugMode) {\r\n                msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n              }\r\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n              cha = \"changed\" + attributename\r\n              if (HasAttribute (object, cha)) {\r\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n                scr = GetAttribute (object, cha)\r\n                set (object, cha, bla)\r\n              }\r\n              // Update the attributes in the game with those from the SaveCode...\r\n              if (att_datatype=\"boolean\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"int\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"double\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"object\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n                // NOTE TO DEVELOPER:\r\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n                if (upgradesave = True) {\r\n                  // This section will trigger if the player is loading a save from a previous game version\r\n                  ReplaceContents = True\r\n                }\r\n                else {\r\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n                  ReplaceContents = True\r\n                }\r\n                if (att_datatype=\"stringlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace stringlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                    FinalList = NewStringList()\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    CompactList = ListCompact (CombinedList)\r\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                    foreach (olt, CompactList) {\r\n                      list add (FinalList, olt)\r\n                    }\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace objectlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    FinalList = ObjectListCompact (CombinedList)\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"stringdictionary\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                    Dummy = NewStringDictionary()\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectdictionary\") {\r\n                  if (upgradesave = False) {\r\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      if (StartsWith(value,\"Object: \")) {\r\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                      }\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n              }\r\n              else if (att_datatype=\"string\") {\r\n                set (object, attributename, att_value)\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n              }\r\n              if (HasAttribute (object, cha)) {\r\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n                set (object, cha, scr)\r\n                scr => {\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n        AllSavedGrids = Split(GridGInfo,D4)\r\n        if (DebugMode) {\r\n          msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n        }\r\n        foreach (A, AllSavedGrids) {\r\n          UDictionary = NewDictionary()\r\n          ItemAndValue = Split(A,\"&%&\")\r\n          ObjAndAtt = ListItem(ItemAndValue,0)\r\n          ObjAndAtt = Split(ObjAndAtt,D2)\r\n          objectname = ListItem(ObjAndAtt,0)\r\n          attributename = ListItem(ObjAndAtt,1)\r\n          object = GetObject(objectname)\r\n          GridVals = ListItem(ItemAndValue,1)\r\n          GridVals = Split(GridVals,D1)\r\n          foreach (B, GridVals) {\r\n            UKeyAndUVal = Split(B,D2)\r\n            UKey = ListItem(UKeyAndUVal,0)\r\n            UVal = ListItem(UKeyAndUVal,1)\r\n            UVal = Split(UVal,D3)\r\n            LDictionary = NewDictionary()\r\n            foreach (C, UVal) {\r\n              LkeyAndLval = Split(C,\" = \")\r\n              Lkey = ListItem(LkeyAndLval,0)\r\n              LvalAndType = ListItem(LkeyAndLval,1)\r\n              LvalAndType = Split(LvalAndType,\":\")\r\n              Lval_str = ListItem(LvalAndType,0)\r\n              LType = ListItem(LvalAndType,1)\r\n              if (LType=\"int\") {\r\n                Lval = ToInt(Lval_str)\r\n              }\r\n              else if (LType=\"double\") {\r\n                Lval = ToDouble(Lval_str)\r\n              }\r\n              else if (LType=\"boolean\") {\r\n                if (Lval_str=\"True\") {\r\n                  Lval = True\r\n                }\r\n                else {\r\n                  Lval = False\r\n                }\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n              }\r\n              DictionaryAdd (LDictionary, Lkey, Lval)\r\n            }\r\n            DictionaryAdd (UDictionary, UKey, LDictionary)\r\n          }\r\n          if (DebugMode) {\r\n            msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n          }\r\n          set (object, attributename, UDictionary)\r\n        }\r\n        // Destroy any objects that the player destroyed during their saved game, if any\r\n        if (ListCount(DestroyedList)>0) {\r\n          foreach (o, DestroyedList) {\r\n            // Check that objects still exist...\r\n            IsThere = GetObject(o)\r\n            if (not Equal(IsThere,null)) {\r\n              // If its there, destroy the object\r\n              destroy (o)\r\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        if (DebugMode) {\r\n          msg (\"Created objects: \"+CreatedObjDebugList)\r\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n          msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n        }\r\n        // Finally, update game.pov.parent and game.pov\r\n        set (GamePOVObject, \"parent\", GamePOVParent)\r\n        game.pov = GamePOVObject\r\n        // player.grid_coordinates = null\r\n        JS.Grid_ClearAllLayers ()\r\n        Grid_Redraw\r\n        Grid_DrawPlayerInRoom (game.pov.parent)\r\n        ClearScreen\r\n        ShowRoomDescription\r\n      }\r\n    }\r\n  ]]></function>\r\n  <function name=\"GetSaveGameCodeDelims\" type=\"stringlist\">\r\n    // GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\r\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\n    DelimList = NewStringList()\r\n    SaveString = SaveGameCode(False)\r\n    // Retrieve delimiters from end of SaveString\r\n    Dls = Right(SaveString,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Add to list\r\n    list add (DelimList, D1)\r\n    list add (DelimList, D2)\r\n    list add (DelimList, D3)\r\n    list add (DelimList, D4)\r\n    // Return the list of delimiters as a string list\r\n    return (DelimList)\r\n  </function>\r\n  <function name=\"GetSaveCheckpointDelims\" type=\"stringlist\">\r\n    // GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\r\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\n    DelimList = NewStringList()\r\n    SaveString = SaveCheckpoint(\"\")\r\n    // Retrieve delimiters from end of SaveString\r\n    Dls = Right(SaveString,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Add to list\r\n    list add (DelimList, D1)\r\n    list add (DelimList, D2)\r\n    list add (DelimList, D3)\r\n    list add (DelimList, D4)\r\n    // Return the list of delimiters as a string list\r\n    return (DelimList)\r\n  </function>\r\n  <javascript src=\"SaveLoadJavaCode.js\" />\r\n</asl>\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p><em>(Below is a copy of my post from the main Quest Forum <a href=\"http://textadventures.co.uk/forum/quest/topic/0c6ypzyna0clj4jw_3ohmw/a-way-to-save-load-between-versions-on-desktop-or-online-saveloadcodes\">here</a>. Posted here in Libraries and Code Samples so it won't get buried.)</em></p>\n<p><strong>Please see the github (<a href=\"https://github.com/Leviathon44/SaveLoadCode/\">https://github.com/Leviathon44/SaveLoadCode/</a>) for the latest version!</strong></p>\n<p>Hello everyone!</p>\n<p>Been a big fan of text adventure games for a while, but just recently decided to try my hand at making one of my own! One of the things I wanted to be able to do with my game was give the player the ability to save their game and resume playing even on a future version of the game.</p>\n<p>I considered using the SaveLoad library created by Pix (<a href=\"https://github.com/ThePix/quest/wiki/Library:-Save-and-Load\">https://github.com/ThePix/quest/wiki/Library:-Save-and-Load</a>), but unfortunately some of its limitations didn't quite work for what I had in mind. In particular, I wanted the player to be able to save their game to an actual file that could then be loaded on either the online player or desktop player. The solution I came up with was a copy/pastable code that could then be saved locally, but you may prefer Pix's cleaner in-game save/load menu solution. Additionally, I wanted to be able to change the player object (game.pov) mid-game, which is unfortunately a limitation of Pix's library.</p>\n<p>Besides that, one of the primary differences between Pix's SaveLoad library and mine is that their library saves objects explicitly, rather than procedurally, which allows the author to ensure they're ONLY saving the attributes they want to in exchange for some extra legwork. My library, on the other hand, grabs everything it can, then excludes the attributes you don't want. This means that although my library is (theoretically) easier to integrate into existing games, extra care may be required to ensure you're saving all the attributes you truly want to (especially when it comes to ensuring compatibility between saves). I highly recommend checking out Pix's library as well as mine, as both have their merits!</p>\n<p>This may be something that others have already encountered and come up with solutions for, but I wasn't able to find any concrete examples in my online or forum searches, so I figured I would share my solution here in case others would like to use it as well!</p>\n<p>What I came up with is a system to save and load the player's game by creating a <b>SaveGameCode</b> function that collects nearly every attribute in the player's game, as well as a <b>LoadGameCode</b> function that parses out the saved code to update any changed attributes. Paired with some javascript to add a popup UI for the functions as well as base64 encoding (to limit the player's ability to directly edit savegames), I tried to keep everything as modular as possible, with self-explanatory comments, so others could use it too.</p>\n<h2>What do these functions do?</h2>\n<p>These functions allow you to save your game in the form of a base64-encoded code. This code can be saved locally, then copied into the load function to allow the player to load their game.</p>\n<p>What this means is that players can play the game online, save their progress to a save code, then load and resume that progress on a desktop version of the same game, or vice-versa. This also means that saves can be stored SEPARATELY from the rest of the Quest game, potentially allowing a player to continue their old save even on a new version of the game (provided you, as the author, account for that, but more on that in the wiki). Furthermore, loading a save code is typically MUCH faster than loading a traditional Quest 5.8 save, as traditional Quest saves save the ENTIRE game each time (and thus require you to load the entire game each time).</p>\n<h3>The <em>SaveGameCode</em> function</h3>\n<p>I encourage you to look at the source code to learn more, but at a high level the SaveGameCode function works by parsing through all objects, exits, and turnscripts in the game to save as many changeable attributes as possible in the form of a long 'SaveString'. There are some limitations to this (see the 'Limitations' section in the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a>), but for most applications the SaveString that is created is enough to completely recreate the player's game state when fed back in to the LoadGameCode function. And all of this happens more or less <strong><em>automatically</em></strong> after installing the functions and javascript, so it can potentially be added on to nearly any existing game (barring limitations)!</p>\n<h3>The <em>LoadGameCode</em> function</h3>\n<p>You probably can guess, but the <em>LoadGameCode</em> function is responsible for parsing a given SaveString created by the SaveGameCode function, converting it back into usable object and attribute data, and updating the corresponding attributes in the game to recreate the player's saved state. There's a bit more to it, but that's the high-level explanation. To learn more, I again highly recommend checking out the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> and/or source code!</p>\n<h3>The <em>SaveLoadJavaCode.js</em> javascript</h3>\n<p>In addition to those two functions, I also included some additional javascript functions for converting the savecode to/from Base64 encoding (to make it a little harder to 'cheat' by editing your save state), as well as provide a nice UI for presenting the savecode and a nice UI for the player to paste existing savecodes into.</p>\n<h3><strong>Additional Included Functions:</strong></h3>\n<h3>The <em>SaveCheckpoints</em> function</h3>\n<p>SaveCheckpoint works very similarly to SaveGameCode, except instead of saving the SaveString to present it to the player, it instead will save a SaveString to a game.checkpoints stringdictionary. If game.checkpoints does not exist when SaveCheckpoints is called, then it will create it.</p>\n<p>This is useful for saving checkpoints internally that can then be loaded internally using the LoadCheckpoint function.</p>\n<p>See the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> for more details.</p>\n<h3>The <em>LoadCheckpoint</em> function</h3>\n<p>LoadCheckpoint works very similarly to LoadGameCode, except it will not print any messages and it will not overwrite existing checkpoint data. It will also only load existing checkpoints. If it cannot find a matching checkpoint in game.checkpoints, it will throw an error.</p>\n<p>Useful for loading internally-created checkpoints (i.e. after a \"you have died! Would you like to reload before you died?\" type screen, for instance).</p>\n<h3>The <em>GetSaveGameCodeDelims</em> function</h3>\n<p>GetSaveGameCodeDelims() returns a stringlist of the delimiters used by the SaveGameCode function.</p>\n<p>Useful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveGameCode contain a banned delimiter, the game will not save/load properly.</p>\n<h3>The <em>GetSaveCheckpointDelims</em> function</h3>\n<p>GetSaveCheckpointDelims() returns a stringlist of the delimiters used by the SaveCheckpoint function.</p>\n<p>Useful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveCheckpoint contain a banned delimiter, the game will not save/load checkpoints properly.</p>\n<hr>\nI've now completed the wiki page for these functions. Check it out if you're interested, as it goes into great detail regarding how to use these functions in your game, their limitations, workarounds, etc: <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>\n<p>I also created a small test game to show off some of the functionality here (albeit slightly out of date): <a href=\"http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/\">http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/</a></p>\n<p>I've also set up a git repository with these functions and commands drawn up in a library, 'SaveLoadCodeFunctionsLibrary.aslx', and the required javascript, 'SaveLoadJavaCode.js', here: <a href=\"https://github.com/Leviathon44/SaveLoadCode\">https://github.com/Leviathon44/SaveLoadCode</a>.</p>\n<p><strong>Again, please check the github (<a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>) for the latest version!</strong></p>\n<p>Special thanks to KV, mrangel, and Pix! Your forum posts and functions over the years were a valuable resource in getting this made, and mrangel's help in particular helped me solve some of the trickier issues allowing me to improve this library! I hope others find this useful!</p>\n<hr>\n<h3>The code for the entire test game:</h3>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.8.6836.13983--&gt;\n&lt;asl version=\"580\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Save Testing\"&gt;\n    &lt;gameid&gt;932164b2-0eae-47d6-94b4-402d8a2238d9&lt;/gameid&gt;\n    &lt;version&gt;3.0&lt;/version&gt;\n    &lt;firstpublished&gt;2022&lt;/firstpublished&gt;\n    &lt;feature_devmode /&gt;\n    &lt;attr name=\"devmode_setinitscript\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"devmode_changepovpos\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;devmode_setverbs /&gt;\n    &lt;gridmap /&gt;\n    &lt;showscore type=\"boolean\"&gt;false&lt;/showscore&gt;\n    &lt;showhealth type=\"boolean\"&gt;false&lt;/showhealth&gt;\n    &lt;showmoney type=\"boolean\"&gt;false&lt;/showmoney&gt;\n    &lt;attr name=\"feature_limitinventory\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_lightdark\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_asktell\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_annotations\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_advancedwearables\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_advancedscripts\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;appendobjectdescription type=\"boolean\"&gt;false&lt;/appendobjectdescription&gt;\n    &lt;allowlookdirections type=\"boolean\"&gt;false&lt;/allowlookdirections&gt;\n    &lt;multiplecommands type=\"boolean\"&gt;false&lt;/multiplecommands&gt;\n    &lt;command_newline /&gt;\n    &lt;clearscreenonroomenter type=\"boolean\"&gt;false&lt;/clearscreenonroomenter&gt;\n    &lt;autodisplayverbs /&gt;\n    &lt;author&gt;Leviathon&lt;/author&gt;\n    &lt;start type=\"script\"&gt;\n      // Initialization script for SaveLoadCode functionality...\n      // Create a list of all object and exit names present in game at start. This way we can keep track of which objects/exits the player has created/destroyed while playing by comparing to this list when saving/loading.\n      set (game, \"StartingObjStrList\", NewStringList ())\n      foreach (startobj, AllObjects()) {\n        list add (game.StartingObjStrList, startobj.name)\n      }\n      foreach (startobj, AllExits()) {\n        list add (game.StartingObjStrList, startobj.name)\n      }\n      set (game, \"checkpoints\", NewStringDictionary())\n      // End of SaveLoadCode initialization script\n    &lt;/start&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;isroom /&gt;\n    &lt;description&gt;&lt;![CDATA[This is the starting room of the SaveLoadCode functionality demo.&lt;br/&gt;&lt;br/&gt;Type \"SaveCode\" at any time to create a save code, allowing you to load later. Copy the code to a notepad document to save it for later!&lt;br/&gt;&lt;br/&gt;Type \"LoadCode\" at any time to load a previously saved code. Paste in your previously-saved save code to load your game!]]&gt;&lt;/description&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;StringAttribute&gt;Stringy Bingy&lt;/StringAttribute&gt;\n      &lt;alias&gt;Francis&lt;/alias&gt;\n      &lt;ObjectListRedux type=\"objectlist\"&gt;&lt;/ObjectListRedux&gt;\n    &lt;/object&gt;\n    &lt;object name=\"BoingoBall\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;IsBall /&gt;\n      &lt;MemoryDict type=\"stringdictionary\"&gt;\n        &lt;item&gt;\n          &lt;key&gt;Mem1&lt;/key&gt;\n          &lt;value&gt;Memories of 1&lt;/value&gt;\n        &lt;/item&gt;\n        &lt;item&gt;\n          &lt;key&gt;Mem2&lt;/key&gt;\n          &lt;value&gt;Memories of 2&lt;/value&gt;\n        &lt;/item&gt;\n      &lt;/MemoryDict&gt;\n      &lt;ListOfString type=\"stringlist\"&gt;\n        &lt;value&gt;Brock&lt;/value&gt;\n        &lt;value&gt;Misty&lt;/value&gt;\n        &lt;value&gt;Ash&lt;/value&gt;\n        &lt;value&gt;Pikachu&lt;/value&gt;\n      &lt;/ListOfString&gt;\n      &lt;look&gt;This is an object with a bunch of attributes attached to it. The SaveGameCode and LoadGameCode functions will save all its attributes and update them on load if they've changed.&lt;/look&gt;\n    &lt;/object&gt;\n    &lt;exit name=\"KeyRoomDoor\" alias=\"east\" to=\"Key Room\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n      &lt;locked /&gt;\n      &lt;runscript /&gt;\n      &lt;script type=\"script\"&gt;&lt;![CDATA[\n        if (DoorKey.parent=game.pov and this.locked=true) {\n          msg (\"&lt;i&gt;You unlock the door and enter&lt;/i&gt;\")\n          this.locked = false\n          game.pov.parent = Key Room\n        }\n        else if (this.locked=true) {\n          msg (\"That way is locked.\")\n        }\n        else {\n          game.pov.parent = Key Room\n        }\n      ]]&gt;&lt;/script&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"north\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"northdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;object name=\"DoorKey\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;take /&gt;\n      &lt;alias&gt;Key&lt;/alias&gt;\n      &lt;feature_usegive /&gt;\n      &lt;use type=\"script\"&gt;&lt;![CDATA[\n        if (game.pov.parent=room and KeyRoomDoor.locked=True) {\n          msg (\"&lt;i&gt;Using the key, you unlock the door!&lt;/i&gt;\")\n          KeyRoomDoor.locked = False\n          msg (\"&lt;br&gt;As you walk through the door, the key disintegrates in your hand, &lt;i&gt;destroying&lt;/i&gt; it. (i.e. The Key object itself has been destroyed. If you type 'SaveCode' now, when you load that save the Key will still be destroyed!)\")\n          destroy (\"DoorKey\")\n        }\n        else if (game.pov.parent=room and KeyRoomDoor.locked=False) {\n          msg (\"&lt;i&gt;The door is already unlocked!&lt;/i&gt;\")\n        }\n        else {\n          msg (\"&lt;i&gt;There are no locks to use this on here!&lt;/i&gt;\")\n        }\n      ]]&gt;&lt;/use&gt;\n    &lt;/object&gt;\n    &lt;object name=\"SaveCheckpoint Button\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;look&gt;&lt;![CDATA[Using this button will create a checkpoint! Using it more than once will overwrite the existing checkpoint.&lt;br/&gt;&lt;br/&gt;If you find the LoadCheckpoint Button, you can then load the checkpoint created here.]]&gt;&lt;/look&gt;\n      &lt;feature_usegive /&gt;\n      &lt;displayverbs type=\"stringlist\"&gt;\n        &lt;value&gt;Look at&lt;/value&gt;\n        &lt;value&gt;Use&lt;/value&gt;\n      &lt;/displayverbs&gt;\n      &lt;use type=\"script\"&gt;\n        SaveCheckpoint (\"Checkpoint\")\n      &lt;/use&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Key Room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;description&gt;&lt;![CDATA[You made it in!&lt;br/&gt;&lt;br/&gt;If you save now and load from a new game, this room will still be unlocked!]]&gt;&lt;/description&gt;\n    &lt;enter type=\"script\"&gt;\n    &lt;/enter&gt;\n    &lt;firstenter type=\"script\"&gt;\n    &lt;/firstenter&gt;\n    &lt;exit alias=\"west\" to=\"room\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"SideRoom\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;description&gt;&lt;![CDATA[A side room. When you load, this room will show up on the map since you've explored it now! (It was harder to make this happen than you think it would be...)&lt;br/&gt;&lt;br/&gt;{here DoorKey:You see a {object:DoorKey} on the floor!}]]&gt;&lt;/description&gt;\n    &lt;exit alias=\"south\" to=\"room\"&gt;\n      &lt;inherit name=\"southdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"west\" to=\"OtherSideRoom\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"down\" to=\"Basement\"&gt;\n      &lt;inherit name=\"downdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;object name=\"LoadCheckpoint Button\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;feature_usegive /&gt;\n      &lt;use type=\"script\"&gt;\n        LoadCheckpoint (\"Checkpoint\")\n      &lt;/use&gt;\n      &lt;displayverbs type=\"stringlist\"&gt;\n        &lt;value&gt;Look at&lt;/value&gt;\n        &lt;value&gt;Use&lt;/value&gt;\n      &lt;/displayverbs&gt;\n      &lt;look&gt;Using this button will load the checkpoint created by the SaveCheckpoint Button (if one was created...)&lt;/look&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"OtherSideRoom\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;exit alias=\"east\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Basement\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;attr name=\"grid_fill\"&gt;Teal&lt;/attr&gt;\n    &lt;exit alias=\"up\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"updirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"east\" to=\"Basement Side\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Basement Side\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;attr name=\"grid_fill\"&gt;Teal&lt;/attr&gt;\n    &lt;exit alias=\"west\" to=\"Basement\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;command&gt;\n    &lt;pattern&gt;SaveCode&lt;/pattern&gt;\n    &lt;script&gt;\n      SuppressTurnscripts\n      SaveGameCode (True)\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;command&gt;\n    &lt;pattern&gt;LoadCode&lt;/pattern&gt;\n    &lt;script&gt;\n      SuppressTurnscripts\n      JS.LoadGamePrompt ()\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;function name=\"LoadGameCode\" parameters=\"SaveGameCodeDecoded\"&gt;&lt;![CDATA[\n    // LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\n    SuppressTurnscripts\n    // NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\n    OldestAllowedVersion = 2.0\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\n    DebugMode = False\n    // Msg for Debugging:\n    if (DebugMode) {\n      msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n    }\n    // Set up other variables for later\n    bla =&gt; {\n    }\n    upgradesave = False\n    Proceed = False\n    SkippedAttList = \"\"\n    CreatedObjDebugList = \"\"\n    DestroyedObjDebugList = \"\"\n    // Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\n    CheckForCheck = Right(SaveGameCodeDecoded,2)\n    if (CheckForCheck=\"✓✓\") {\n      upgradesave = True\n      SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\n    }\n    // Retrieve delimiters from end of SaveGameCodeDecoded\n    Dls = Right(SaveGameCodeDecoded,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Remove delimiters from end of SaveGameCode\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n    // Special logic to extract saved game.checkpoints attribute\n    D4toD1 = D4+D3+D2+D1\n    CheckpointSplit = Split(SaveCode, D4toD1)\n    SaveCode = ListItem(CheckpointSplit,0)\n    CheckpointKeys = ListItem(CheckpointSplit,1)\n    // If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\n    if (not CheckpointKeys=\"\") {\n      CheckpointKeyList = Split(CheckpointKeys, D3)\n      game.checkpoints = NewStringDictionary()\n      for (xx, 0, ListCount(CheckpointKeyList)-1) {\n        key = ListItem(CheckpointKeyList,xx)\n        val = ListItem(CheckpointSplit,xx+1)\n        DictionaryAdd (game.checkpoints, key, val)\n      }\n    }\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n    }\n    CDList = Split(CreatedDestroyedInfo,D1)\n    CSection = ListItem (CDList, 0)\n    DSection = ListItem (CDList, 1)\n    if (CSection=\"\") {\n      CreatedList = NewStringList()\n    }\n    else {\n      CreatedList = Split (CSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (CreatedList, \" \")\n    }\n    if (DSection=\"\") {\n      DestroyedList = NewStringList()\n    }\n    else {\n      DestroyedList = Split (DSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (DestroyedList, \" \")\n    }\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n    }\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n    }\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\n    GameIdDelim = Instr (SaveCode, D1)\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\n    GameIdObjectEl = ListItem (GameInfo,0)\n    GameIdElements = Split(GameIdObjectEl,D2)\n    Loaded_GameId = ListItem (GameIdElements, 3)\n    GameVerObjectEl = ListItem (GameInfo,1)\n    GameVerElements = Split(GameVerObjectEl,D2)\n    VersionString = ListItem (GameVerElements, 3)\n    Loaded_GameVersion = ToDouble(VersionString)\n    GamePOVObjectEl = ListItem (GameInfo,2)\n    GamePOVElements = Split(GamePOVObjectEl,D2)\n    GamePOVName = ListItem (GamePOVElements, 3)\n    if (StartsWith(GamePOVName,\"Object: \")) {\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n    }\n    GamePOVObject = GetObject (GamePOVName)\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n    // Check that the save belongs to this game by comparing gameIds\n    if (not Loaded_GameId=game.gameid) {\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n    }\n    else {\n      // Compare version of game in SaveCode to version of game loading it\n      ThisGame_GameVersion = ToDouble(game.version)\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n      }\n      else {\n        OldestAllowedVersion_Double = OldestAllowedVersion\n      }\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n      if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n        if (upgradesave = False) {\n          if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n            msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;&lt;br&gt;Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\n            // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\n            create (\"SaveGameDecodedObj\")\n            set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\n            ShowMenu (\"\", Split(\"Yes;No\"), false) {\n              switch (result) {\n                case (\"Yes\") {\n                  SuppressTurnscripts\n                  msg (\"Save code identified! Proceeding with load, please wait...\")\n                  OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\n                  LoadGameCode (OlderSaveCode)\n                  destroy (\"SaveGameDecodedObj\")\n                }\n                case (\"No\") {\n                  SuppressTurnscripts\n                  msg (\"Load Aborted.\")\n                  destroy (\"SaveGameDecodedObj\")\n                }\n              }\n            }\n          }\n          else {\n            error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n          }\n        }\n        else {\n          msg (\"Applying savecode from older version...\")\n          Proceed = True\n        }\n      }\n      else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n      }\n      else {\n        msg (\"Proceeding with load...\")\n        Proceed = True\n      }\n      if (Proceed=True) {\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n        if (ListCount(CreatedList)&gt;0) {\n          foreach (o, CreatedList) {\n            // Check that objects don't already exist...\n            IsThere = GetObject(o)\n            if (Equal(IsThere,null)) {\n              // If not, create the object\n              create (o)\n              CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        player.grid_coordinates = null\n        // Split the save code up into all objects. Then parse through the value of each object attribute\n        SavedObjectList = Split(SaveCode, D1)\n        foreach (o, SavedObjectList) {\n          Skip_Att = False\n          objelements = Split(o, D2)\n          objectname = ListItem (objelements, 0)\n          object = GetObject (objectname)\n          attributename = ListItem (objelements, 1)\n          fullname = objectname+\".\"+attributename\n          preload_att_value = GetAttribute (object, attributename)\n          att_datatype = ListItem (objelements, 2)\n          if (ListCount(objelements)=3) {\n            att_value = \"\"\n          }\n          else {\n            att_value = ListItem (objelements, 3)\n          }\n          // Check that the attribute is supported\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n            Skip_Att = True\n            SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n          }\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n          att_value_obj = att_value\n          if (att_datatype=\"object\") {\n            if (StartsWith(att_value,\"Object: \")) {\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n            }\n            else {\n              att_value_obj = GetObject(att_value)\n            }\n          }\n          else if (att_datatype=\"boolean\") {\n            if (att_value=\"True\") {\n              att_value_obj = True\n            }\n            else {\n              att_value_obj = False\n            }\n          }\n          else if (att_datatype=\"int\") {\n            att_value_obj = ToInt(att_value)\n          }\n          else if (att_datatype=\"double\") {\n            att_value_obj = ToDouble(att_value)\n          }\n          else if (att_datatype=\"stringlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringList()\n            }\n            else {\n              att_value_obj = Split (att_value, D3)\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n              list remove (att_value_obj, \" \")\n            }\n          }\n          else if (att_datatype=\"objectlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectList()\n            }\n            else {\n              att_value_obj = NewObjectList()\n              objlistlist = Split (att_value, D3)\n              foreach (olt, objlistlist) {\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n                if (StartsWith(olt,\"Object: \")) {\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n                  if (not value=null) {\n                    list add (att_value_obj, value)\n                  }\n                  else {\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringDictionary()\n            }\n            else {\n              att_value_obj = NewStringDictionary()\n              // Add dictionary values from SaveGame\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                value = ListItem(KeyValList, 1)\n                DictionaryAdd (att_value_obj, key, value)\n              }\n            }\n          }\n          else if (att_datatype=\"objectdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectDictionary()\n            }\n            else {\n              att_value_obj = NewObjectDictionary()\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                obj = ListItem(KeyValList, 1)\n                if (StartsWith(obj,\"Object: \")) {\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                }\n                else {\n                  value = obj\n                }\n                if (not value=null) {\n                  DictionaryAdd (att_value_obj, key, value)\n                }\n                else {\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                }\n              }\n            }\n          }\n          if (objectname=GamePOVName and attributename=\"parent\") {\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n            Skip_Att = True\n            GamePOVParent = att_value_obj\n          }\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n            if (Equal(preload_att_value,null)) {\n              if (DebugMode) {\n                msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n              }\n              preload_att_value = \"null\"\n            }\n            // Msgs for debugging:\n            if (DebugMode) {\n              msg (\"objectname=\"+objectname)\n              msg (\"attributename=\"+attributename)\n              msg (\"att_datatype=\"+att_datatype)\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\n              if (Equal(preload_att_value,\"null\")) {\n                msg (\"preload_att_datatype=null\")\n              }\n              else {\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n              }\n              msg (\"att_value=\"+ToString(att_value))\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n              msg (\"&lt;br&gt;\")\n            }\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n              if (DebugMode) {\n                msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n              }\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n              cha = \"changed\" + attributename\n              if (HasAttribute (object, cha)) {\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n                scr = GetAttribute (object, cha)\n                set (object, cha, bla)\n              }\n              // Update the attributes in the game with those from the SaveCode...\n              if (att_datatype=\"boolean\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"int\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"double\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"object\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n                // NOTE TO DEVELOPER:\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n                if (upgradesave = True) {\n                  // This section will trigger if the player is loading a save from a previous game version\n                  ReplaceContents = True\n                }\n                else {\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n                  ReplaceContents = True\n                }\n                if (att_datatype=\"stringlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace stringlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\n                    FinalList = NewStringList()\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    CompactList = ListCompact (CombinedList)\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                    foreach (olt, CompactList) {\n                      list add (FinalList, olt)\n                    }\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"objectlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace objectlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    FinalList = ObjectListCompact (CombinedList)\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"stringdictionary\") {\n                  if (ReplaceContents = True) {\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                    Dummy = NewStringDictionary()\n                  }\n                  else {\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n                else if (att_datatype=\"objectdictionary\") {\n                  if (upgradesave = False) {\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      if (StartsWith(value,\"Object: \")) {\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                      }\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n              }\n              else if (att_datatype=\"string\") {\n                set (object, attributename, att_value)\n              }\n              else {\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n              }\n              if (HasAttribute (object, cha)) {\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n                set (object, cha, scr)\n                scr =&gt; {\n                }\n              }\n            }\n          }\n        }\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n        AllSavedGrids = Split(GridGInfo,D4)\n        if (DebugMode) {\n          msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n        }\n        foreach (A, AllSavedGrids) {\n          UDictionary = NewDictionary()\n          ItemAndValue = Split(A,\"&amp;%&amp;\")\n          ObjAndAtt = ListItem(ItemAndValue,0)\n          ObjAndAtt = Split(ObjAndAtt,D2)\n          objectname = ListItem(ObjAndAtt,0)\n          attributename = ListItem(ObjAndAtt,1)\n          object = GetObject(objectname)\n          GridVals = ListItem(ItemAndValue,1)\n          GridVals = Split(GridVals,D1)\n          foreach (B, GridVals) {\n            UKeyAndUVal = Split(B,D2)\n            UKey = ListItem(UKeyAndUVal,0)\n            UVal = ListItem(UKeyAndUVal,1)\n            UVal = Split(UVal,D3)\n            LDictionary = NewDictionary()\n            foreach (C, UVal) {\n              LkeyAndLval = Split(C,\" = \")\n              Lkey = ListItem(LkeyAndLval,0)\n              LvalAndType = ListItem(LkeyAndLval,1)\n              LvalAndType = Split(LvalAndType,\":\")\n              Lval_str = ListItem(LvalAndType,0)\n              LType = ListItem(LvalAndType,1)\n              if (LType=\"int\") {\n                Lval = ToInt(Lval_str)\n              }\n              else if (LType=\"double\") {\n                Lval = ToDouble(Lval_str)\n              }\n              else if (LType=\"boolean\") {\n                if (Lval_str=\"True\") {\n                  Lval = True\n                }\n                else {\n                  Lval = False\n                }\n              }\n              else {\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n              }\n              DictionaryAdd (LDictionary, Lkey, Lval)\n            }\n            DictionaryAdd (UDictionary, UKey, LDictionary)\n          }\n          if (DebugMode) {\n            msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n          }\n          set (object, attributename, UDictionary)\n        }\n        // Destroy any objects that the player destroyed during their saved game, if any\n        if (ListCount(DestroyedList)&gt;0) {\n          foreach (o, DestroyedList) {\n            // Check that objects still exist...\n            IsThere = GetObject(o)\n            if (not Equal(IsThere,null)) {\n              // If its there, destroy the object\n              destroy (o)\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        msg (\"Load complete!\")\n        if (DebugMode) {\n          msg (\"Created objects: \"+CreatedObjDebugList)\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n          msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n        }\n        // Finally, update game.pov.parent and game.pov\n        wait {\n          set (GamePOVObject, \"parent\", GamePOVParent)\n          game.pov = GamePOVObject\n          // player.grid_coordinates = null\n          JS.Grid_ClearAllLayers ()\n          Grid_Redraw\n          Grid_DrawPlayerInRoom (game.pov.parent)\n          ClearScreen\n          ShowRoomDescription\n        }\n      }\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"SaveGameCode\" parameters=\"ShowCodePopupFlag\" type=\"string\"&gt;&lt;![CDATA[\n    // SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\n    // The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\n    SuppressTurnscripts\n    // Make sure ShowCodePopupFlag is of type 'boolean'\n    if (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\n      X = TypeOf(ShowCodePopupFlag)\n      error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    SaveString = \"\"\n    CreatedObj = NewStringList()\n    DestroyedObj = NewStringList()\n    // Set delimiters.\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\n    D1 = \"|\"\n    D2 = \"$\"\n    D3 = \";\"\n    D4 = \"@\"\n    // Save the player's current map before saving\n    // Make sure first two entries are gameid and version (for load function)\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n    // Record all changable object attributes\n    foreach (o, AllObjects()) {\n      objectname = o.name\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n            // Confirm there are no banned delimiters in the list entries\n            v = GetAttribute (o, attributename)\n            if (ListCount(v)&gt;0) {\n              if (att_datatype=\"stringlist\") {\n                foreach (listcheck, v) {\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n            // Confirm there are no banned delimiters in the dictionary entries\n            v = GetAttribute (o, attributename)\n            if (DictionaryCount(v)&gt;0) {\n              foreach (dictkey, v) {\n                if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                }\n                if (att_datatype=\"stringdictionary\") {\n                  dictitm = DictionaryItem (v, dictkey)\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (o, AllExits()) {\n      objectname = o.name\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (turnscript, AllTurnScripts()) {\n      // Check for which turnscripts are enabled/disabled\n      if (GetBoolean(turnscript, \"enabled\")) {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n      }\n      else {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n      }\n    }\n    // Determine if any objects were destroyed by the player since game start...\n    foreach (objectname, game.StartingObjStrList) {\n      IsThere = GetObject(objectname)\n      if (Equal(IsThere,null)) {\n        list add (DestroyedObj, objectname)\n      }\n    }\n    // Save the game.timeelapsed attribute\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\n    if (HasAttribute (game, \"SaveAtts\")) {\n      SaveAttType = TypeOf(game.SaveAtts)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveAtts)&gt;0) {\n          foreach (x, game.SaveAtts) {\n            AttValue = GetAttribute (game, x)\n            att_datatype = TypeOf(AttValue)\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n            }\n            else if (Equal(x,\"checkpoints\")) {\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n            }\n            else if (Equal(AttValue,null)) {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n            }\n            else {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n      }\n    }\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\n    if (HasAttribute (game, \"SaveTimers\")) {\n      SaveAttType = TypeOf(game.SaveTimers)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveTimers)&gt;0) {\n          foreach (x, game.SaveTimers) {\n            T = GetObject(x)\n            if (not Equal(T,null)) {\n              TimerName = x.name\n              TimerValue1 = x.trigger\n              TimerValue2 = x.interval\n              TimerValue3 = x.enabled\n              TimerValue1Type = TypeOf(TimerValue1)\n              TimerValue2Type = TypeOf(TimerValue2)\n              TimerValue3Type = TypeOf(TimerValue3)\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n            }\n            else {\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n      }\n    }\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\n    foreach (o, AllObjects()) {\n      foreach (attributename, GetAttributeNames(o,false)) {\n        objectname = o.name\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n      }\n    }\n    // Add on the list of created/destroyed objects...\n    X = ToString(CreatedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    X = ToString(DestroyedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n    // Special logic needed in order to save the game.checkpoints attribute\n    D4toD1 = D4+D3+D2+D1\n    if (HasAttribute(game,\"checkpoints\")) {\n      if (DictionaryCount(game.checkpoints)&gt;0) {\n        KeyList = \"\"\n        CheckValList = \"\"\n        foreach (k, game.checkpoints) {\n          KeyList = KeyList+k+D3\n          val = DictionaryItem(game.checkpoints, k)\n          CheckValList = CheckValList+val+D4toD1\n        }\n        // Remove final D3 from KeyList string and final D4toD1 from CheckValList\n        KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\n        CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\n        // Add game.checkpoints data to SaveString\n        SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\n      }\n      else {\n        // If game.checkpoints empty, just add D4toD1 to SaveString.\n        SaveString = SaveString+D4toD1\n      }\n    }\n    else {\n      // If game.checkpoints non-existant, just add D4toD1 to SaveString.\n      SaveString = SaveString+D4toD1\n    }\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\n    SaveString = SaveString+D1+D2+D3+D4\n    // msg for Debugging:\n    // msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\n    if (ShowCodePopupFlag=True) {\n      // Create save code and present to player in textbox\n      JS.CreateSaveCode (SaveString)\n      JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\n    }\n    return (SaveString)\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"SaveCheckpoint\" parameters=\"CheckpointName\" type=\"string\"&gt;&lt;![CDATA[\n    // SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\n    // The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\n    // If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\n    SuppressTurnscripts\n    // Check if game.checkpoints exists. If not, create it.\n    if (not HasAttribute(game, \"checkpoints\")) {\n      set (game, \"checkpoints\", NewStringDictionary())\n    }\n    // Make sure CheckpointName input is of 'string' datatype\n    if (not TypeOf(CheckpointName)=\"string\") {\n      X = TypeOf(CheckpointName)\n      error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    SaveString = \"\"\n    CreatedObj = NewStringList()\n    DestroyedObj = NewStringList()\n    // Set delimiters.\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\n    D1 = \"|\"\n    D2 = \"$\"\n    D3 = \";\"\n    D4 = \"@\"\n    // Save the player's current map before saving\n    // Make sure first two entries are gameid and version (for load function)\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n    // Record all changable object attributes\n    foreach (o, AllObjects()) {\n      objectname = o.name\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n            // Confirm there are no banned delimiters in the list entries\n            v = GetAttribute (o, attributename)\n            if (ListCount(v)&gt;0) {\n              if (att_datatype=\"stringlist\") {\n                foreach (listcheck, v) {\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n            // Confirm there are no banned delimiters in the dictionary entries\n            v = GetAttribute (o, attributename)\n            if (DictionaryCount(v)&gt;0) {\n              foreach (dictkey, v) {\n                if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                }\n                if (att_datatype=\"stringdictionary\") {\n                  dictitm = DictionaryItem (v, dictkey)\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (o, AllExits()) {\n      objectname = o.name\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (turnscript, AllTurnScripts()) {\n      // Check for which turnscripts are enabled/disabled\n      if (GetBoolean(turnscript, \"enabled\")) {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n      }\n      else {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n      }\n    }\n    // Determine if any objects were destroyed by the player since game start...\n    foreach (objectname, game.StartingObjStrList) {\n      IsThere = GetObject(objectname)\n      if (Equal(IsThere,null)) {\n        list add (DestroyedObj, objectname)\n      }\n    }\n    // Save the game.timeelapsed attribute\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\n    if (HasAttribute (game, \"SaveAtts\")) {\n      SaveAttType = TypeOf(game.SaveAtts)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveAtts)&gt;0) {\n          foreach (x, game.SaveAtts) {\n            AttValue = GetAttribute (game, x)\n            att_datatype = TypeOf(AttValue)\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n            }\n            else if (Equal(x,\"checkpoints\")) {\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n            }\n            else if (Equal(AttValue,null)) {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n            }\n            else {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n      }\n    }\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\n    if (HasAttribute (game, \"SaveTimers\")) {\n      SaveAttType = TypeOf(game.SaveTimers)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveTimers)&gt;0) {\n          foreach (x, game.SaveTimers) {\n            T = GetObject(x)\n            if (not Equal(T,null)) {\n              TimerName = x.name\n              TimerValue1 = x.trigger\n              TimerValue2 = x.interval\n              TimerValue3 = x.enabled\n              TimerValue1Type = TypeOf(TimerValue1)\n              TimerValue2Type = TypeOf(TimerValue2)\n              TimerValue3Type = TypeOf(TimerValue3)\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n            }\n            else {\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n      }\n    }\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\n    foreach (o, AllObjects()) {\n      foreach (attributename, GetAttributeNames(o,false)) {\n        objectname = o.name\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n      }\n    }\n    // Add on the list of created/destroyed objects...\n    X = ToString(CreatedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    X = ToString(DestroyedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\n    SaveString = SaveString+D1+D2+D3+D4\n    // msg for Debugging:\n    // msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\n    // Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\n    if (not CheckpointName=\"\") {\n      DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\n    }\n    return (SaveString)\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"LoadCheckpoint\" parameters=\"CheckpointName\"&gt;&lt;![CDATA[\n    // LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\n    // Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\n    SuppressTurnscripts\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\n    OldestAllowedVersion = 2.0\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\n    DebugMode = False\n    // Msg for Debugging:\n    if (DebugMode) {\n      msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n    }\n    // Make sure CheckpointName input is of type 'string'\n    if (not TypeOf(CheckpointName)=\"string\") {\n      X = TypeOf(CheckpointName)\n      error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    // Retrieve SaveString from game.checkpoints dictionary\n    if (HasAttribute(game, \"checkpoints\")) {\n      if (DictionaryContains(game.checkpoints, CheckpointName)) {\n        SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\n      }\n      else {\n        error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\n      }\n    }\n    else {\n      error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\n    }\n    // Set up other variables for later\n    bla =&gt; {\n    }\n    upgradesave = False\n    Proceed = False\n    SkippedAttList = \"\"\n    CreatedObjDebugList = \"\"\n    DestroyedObjDebugList = \"\"\n    // Retrieve delimiters from end of SaveGameCodeDecoded\n    Dls = Right(SaveGameCodeDecoded,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Remove delimiters from end of SaveGameCode\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n    }\n    CDList = Split(CreatedDestroyedInfo,D1)\n    CSection = ListItem (CDList, 0)\n    DSection = ListItem (CDList, 1)\n    if (CSection=\"\") {\n      CreatedList = NewStringList()\n    }\n    else {\n      CreatedList = Split (CSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (CreatedList, \" \")\n    }\n    if (DSection=\"\") {\n      DestroyedList = NewStringList()\n    }\n    else {\n      DestroyedList = Split (DSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (DestroyedList, \" \")\n    }\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n    }\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n    }\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\n    GameIdDelim = Instr (SaveCode, D1)\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\n    GameIdObjectEl = ListItem (GameInfo,0)\n    GameIdElements = Split(GameIdObjectEl,D2)\n    Loaded_GameId = ListItem (GameIdElements, 3)\n    GameVerObjectEl = ListItem (GameInfo,1)\n    GameVerElements = Split(GameVerObjectEl,D2)\n    VersionString = ListItem (GameVerElements, 3)\n    Loaded_GameVersion = ToDouble(VersionString)\n    GamePOVObjectEl = ListItem (GameInfo,2)\n    GamePOVElements = Split(GamePOVObjectEl,D2)\n    GamePOVName = ListItem (GamePOVElements, 3)\n    if (StartsWith(GamePOVName,\"Object: \")) {\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n    }\n    GamePOVObject = GetObject (GamePOVName)\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n    // Check that the save belongs to this game by comparing gameIds\n    if (not Loaded_GameId=game.gameid) {\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n    }\n    else {\n      // Compare version of game in SaveCode to version of game loading it\n      ThisGame_GameVersion = ToDouble(game.version)\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n      }\n      else {\n        OldestAllowedVersion_Double = OldestAllowedVersion\n      }\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n      if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n        if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n          upgradesave = True\n          Proceed = True\n        }\n        else {\n          error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n        }\n      }\n      else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n      }\n      else {\n        Proceed = True\n      }\n      if (Proceed=True) {\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n        if (ListCount(CreatedList)&gt;0) {\n          foreach (o, CreatedList) {\n            // Check that objects don't already exist...\n            IsThere = GetObject(o)\n            if (Equal(IsThere,null)) {\n              // If not, create the object\n              create (o)\n              CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        player.grid_coordinates = null\n        // Split the save code up into all objects. Then parse through the value of each object attribute\n        SavedObjectList = Split(SaveCode, D1)\n        foreach (o, SavedObjectList) {\n          Skip_Att = False\n          objelements = Split(o, D2)\n          objectname = ListItem (objelements, 0)\n          object = GetObject (objectname)\n          attributename = ListItem (objelements, 1)\n          fullname = objectname+\".\"+attributename\n          preload_att_value = GetAttribute (object, attributename)\n          att_datatype = ListItem (objelements, 2)\n          if (ListCount(objelements)=3) {\n            att_value = \"\"\n          }\n          else {\n            att_value = ListItem (objelements, 3)\n          }\n          // Check that the attribute is supported\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n            Skip_Att = True\n            SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n          }\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n          att_value_obj = att_value\n          if (att_datatype=\"object\") {\n            if (StartsWith(att_value,\"Object: \")) {\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n            }\n            else {\n              att_value_obj = GetObject(att_value)\n            }\n          }\n          else if (att_datatype=\"boolean\") {\n            if (att_value=\"True\") {\n              att_value_obj = True\n            }\n            else {\n              att_value_obj = False\n            }\n          }\n          else if (att_datatype=\"int\") {\n            att_value_obj = ToInt(att_value)\n          }\n          else if (att_datatype=\"double\") {\n            att_value_obj = ToDouble(att_value)\n          }\n          else if (att_datatype=\"stringlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringList()\n            }\n            else {\n              att_value_obj = Split (att_value, D3)\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n              list remove (att_value_obj, \" \")\n            }\n          }\n          else if (att_datatype=\"objectlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectList()\n            }\n            else {\n              att_value_obj = NewObjectList()\n              objlistlist = Split (att_value, D3)\n              foreach (olt, objlistlist) {\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n                if (StartsWith(olt,\"Object: \")) {\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n                  if (not value=null) {\n                    list add (att_value_obj, value)\n                  }\n                  else {\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringDictionary()\n            }\n            else {\n              att_value_obj = NewStringDictionary()\n              // Add dictionary values from SaveGame\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                value = ListItem(KeyValList, 1)\n                DictionaryAdd (att_value_obj, key, value)\n              }\n            }\n          }\n          else if (att_datatype=\"objectdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectDictionary()\n            }\n            else {\n              att_value_obj = NewObjectDictionary()\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                obj = ListItem(KeyValList, 1)\n                if (StartsWith(obj,\"Object: \")) {\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                }\n                else {\n                  value = obj\n                }\n                if (not value=null) {\n                  DictionaryAdd (att_value_obj, key, value)\n                }\n                else {\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                }\n              }\n            }\n          }\n          if (objectname=GamePOVName and attributename=\"parent\") {\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n            Skip_Att = True\n            GamePOVParent = att_value_obj\n          }\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n            if (Equal(preload_att_value,null)) {\n              if (DebugMode) {\n                msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n              }\n              preload_att_value = \"null\"\n            }\n            // Msgs for debugging:\n            if (DebugMode) {\n              msg (\"objectname=\"+objectname)\n              msg (\"attributename=\"+attributename)\n              msg (\"att_datatype=\"+att_datatype)\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\n              if (Equal(preload_att_value,\"null\")) {\n                msg (\"preload_att_datatype=null\")\n              }\n              else {\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n              }\n              msg (\"att_value=\"+ToString(att_value))\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n              msg (\"&lt;br&gt;\")\n            }\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n              if (DebugMode) {\n                msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n              }\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n              cha = \"changed\" + attributename\n              if (HasAttribute (object, cha)) {\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n                scr = GetAttribute (object, cha)\n                set (object, cha, bla)\n              }\n              // Update the attributes in the game with those from the SaveCode...\n              if (att_datatype=\"boolean\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"int\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"double\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"object\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n                // NOTE TO DEVELOPER:\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n                if (upgradesave = True) {\n                  // This section will trigger if the player is loading a save from a previous game version\n                  ReplaceContents = True\n                }\n                else {\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n                  ReplaceContents = True\n                }\n                if (att_datatype=\"stringlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace stringlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\n                    FinalList = NewStringList()\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    CompactList = ListCompact (CombinedList)\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                    foreach (olt, CompactList) {\n                      list add (FinalList, olt)\n                    }\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"objectlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace objectlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    FinalList = ObjectListCompact (CombinedList)\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"stringdictionary\") {\n                  if (ReplaceContents = True) {\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                    Dummy = NewStringDictionary()\n                  }\n                  else {\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n                else if (att_datatype=\"objectdictionary\") {\n                  if (upgradesave = False) {\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      if (StartsWith(value,\"Object: \")) {\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                      }\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n              }\n              else if (att_datatype=\"string\") {\n                set (object, attributename, att_value)\n              }\n              else {\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n              }\n              if (HasAttribute (object, cha)) {\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n                set (object, cha, scr)\n                scr =&gt; {\n                }\n              }\n            }\n          }\n        }\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n        AllSavedGrids = Split(GridGInfo,D4)\n        if (DebugMode) {\n          msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n        }\n        foreach (A, AllSavedGrids) {\n          UDictionary = NewDictionary()\n          ItemAndValue = Split(A,\"&amp;%&amp;\")\n          ObjAndAtt = ListItem(ItemAndValue,0)\n          ObjAndAtt = Split(ObjAndAtt,D2)\n          objectname = ListItem(ObjAndAtt,0)\n          attributename = ListItem(ObjAndAtt,1)\n          object = GetObject(objectname)\n          GridVals = ListItem(ItemAndValue,1)\n          GridVals = Split(GridVals,D1)\n          foreach (B, GridVals) {\n            UKeyAndUVal = Split(B,D2)\n            UKey = ListItem(UKeyAndUVal,0)\n            UVal = ListItem(UKeyAndUVal,1)\n            UVal = Split(UVal,D3)\n            LDictionary = NewDictionary()\n            foreach (C, UVal) {\n              LkeyAndLval = Split(C,\" = \")\n              Lkey = ListItem(LkeyAndLval,0)\n              LvalAndType = ListItem(LkeyAndLval,1)\n              LvalAndType = Split(LvalAndType,\":\")\n              Lval_str = ListItem(LvalAndType,0)\n              LType = ListItem(LvalAndType,1)\n              if (LType=\"int\") {\n                Lval = ToInt(Lval_str)\n              }\n              else if (LType=\"double\") {\n                Lval = ToDouble(Lval_str)\n              }\n              else if (LType=\"boolean\") {\n                if (Lval_str=\"True\") {\n                  Lval = True\n                }\n                else {\n                  Lval = False\n                }\n              }\n              else {\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n              }\n              DictionaryAdd (LDictionary, Lkey, Lval)\n            }\n            DictionaryAdd (UDictionary, UKey, LDictionary)\n          }\n          if (DebugMode) {\n            msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n          }\n          set (object, attributename, UDictionary)\n        }\n        // Destroy any objects that the player destroyed during their saved game, if any\n        if (ListCount(DestroyedList)&gt;0) {\n          foreach (o, DestroyedList) {\n            // Check that objects still exist...\n            IsThere = GetObject(o)\n            if (not Equal(IsThere,null)) {\n              // If its there, destroy the object\n              destroy (o)\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        if (DebugMode) {\n          msg (\"Created objects: \"+CreatedObjDebugList)\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n          msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n        }\n        // Finally, update game.pov.parent and game.pov\n        set (GamePOVObject, \"parent\", GamePOVParent)\n        game.pov = GamePOVObject\n        // player.grid_coordinates = null\n        JS.Grid_ClearAllLayers ()\n        Grid_Redraw\n        Grid_DrawPlayerInRoom (game.pov.parent)\n        ClearScreen\n        ShowRoomDescription\n      }\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"GetSaveGameCodeDelims\" type=\"stringlist\"&gt;\n    // GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\n    DelimList = NewStringList()\n    SaveString = SaveGameCode(False)\n    // Retrieve delimiters from end of SaveString\n    Dls = Right(SaveString,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Add to list\n    list add (DelimList, D1)\n    list add (DelimList, D2)\n    list add (DelimList, D3)\n    list add (DelimList, D4)\n    // Return the list of delimiters as a string list\n    return (DelimList)\n  &lt;/function&gt;\n  &lt;function name=\"GetSaveCheckpointDelims\" type=\"stringlist\"&gt;\n    // GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\n    DelimList = NewStringList()\n    SaveString = SaveCheckpoint(\"\")\n    // Retrieve delimiters from end of SaveString\n    Dls = Right(SaveString,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Add to list\n    list add (DelimList, D1)\n    list add (DelimList, D2)\n    list add (DelimList, D3)\n    list add (DelimList, D4)\n    // Return the list of delimiters as a string list\n    return (DelimList)\n  &lt;/function&gt;\n  &lt;javascript src=\"SaveLoadJavaCode.js\" /&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2022-03-13T04:30:52.4816008Z",
      "LastEditDate": "2023-01-17T03:27:33.4128391Z",
      "link": null
    }
  ]
}
