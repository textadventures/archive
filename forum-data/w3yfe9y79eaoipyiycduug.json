{
  "Topic": {
    "TopicId": "w3yfe9y79eaoipyiycduug",
    "ForumId": "18",
    "Title": "Messing around with DiceRoll",
    "LastUpdated": "2019-10-22T09:59:26.2938445Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "e8906316-47d7-4532-b80d-0b65d76c21be",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I happened to look at the `DiceRoll` function in the core recently, and found the code a little odd. Among other things, it will let you do \"2d6+3\" or \"3d6-5\", but not \"4-2d6\" or \"2d6+2d8\". And I started wondering how hard it would be to make something like that work.\r\n\r\nHere's two versions that came off the top of my head:\r\n```\r\n<function name=\"DiceRoll\" parameters=\"expression\" type=\"int\">\r\n  expression = Replace (Replace (LCase(expression), \" \", \"\"), \"-\", \"+-\")\r\n  total = 0\r\n  foreach (dice, Split (expression, \"+\")) {\r\n    if (IsInt (dice)) {\r\n      total = total + dice\r\n    }\r\n    else {\r\n      if (Left (dice, 1) = \"-\") {\r\n        expression = Mid (dice, 2)\r\n        negative = -1\r\n      }\r\n      else {\r\n        negative = 1\r\n      }\r\n      if (Left (dice, 1) = \"d\") {\r\n        dice = \"1\"+dice\r\n      }\r\n      parts = Split (dice, \"d\")\r\n      if (ListCount (parts) = 2 and IsInt (StringListItem (parts, 0)) and IsInt (StringListItem (parts, 1))) {\r\n        sides = ToInt (StringListItem (parts, 1))\r\n        for (i, 1, ToInt (StringListItem (parts, 0))) {\r\n          total = total + negative * GetRandomInt (1, sides)\r\n        }\r\n      }\r\n      else {\r\n        error (\"Can't parse dice type: \"+dice)\r\n      }\r\n    }\r\n  }\r\n  return (total)\r\n</function>\r\n```\r\nThe use of Replace probably makes this a little less efficient, but I think it's pretty close to the original; and will happily handle systems like the Time Lord RPG (\"d6 - d6\" is common) or similar.\r\n\r\nBut once I got thinking about it, I wondered how hard it would be to make one that will understand expressions like \"2d6 * 1d6\", or \"1d12 - (d6 + d8)\" too…\r\n\r\n```\r\n<function name=\"DiceRoll\" parameters=\"expression\" type=\"int\">\r\n  expression = LCase (expression)\r\n  if (IsRegexMatch (\"[^x/×÷+\\\\-d^*\\\\s\\\\d\\\\(\\\\)]\", expression)) {\r\n    error (\"Invalid dice roll: \"+expression)\r\n  }\r\n  expression = Replace (expression, \"×\", \"*\")\r\n  expression = Replace (expression, \"x\", \"*\")\r\n  expression = Replace (expression, \"÷\", \"/\")\r\n  while (Instr (expression, \"d\") > 0)) {\r\n    parts = Populate (\"^(?<pre>.*?)(?<count>\\\\d+)?\\\\s*d\\\\s*(?<dice>\\\\d+)(?<post>.*)$\", expression)\r\n    if (DictionaryContains (parts, \"count\")) {\r\n      count = ToInt (DictionaryItem (parts, \"count\"))\r\n    }\r\n    else {\r\n      count = 1\r\n    }\r\n    dice = ToInt (DictionaryItem (parts, \"dice\"))\r\n    total = 0\r\n    for (i, 1, count) {\r\n      total = total + GetRandomInt (1, dice)\r\n    }\r\n    expression = DictionaryItem (parts, \"pre\") + ToString (total) + DictionaryItem (parts, \"post\")\r\n  }\r\n  result = eval (expression)\r\n  return (result)\r\n</function>\r\n```\r\n(Yes, I'm cheating. That searches the string for any part that looks like \"2d12\" or whatever, and replaces that expression with a number. So by the time there's no \"d\" left in the string, we've got something like \"12 + (3 * 4)\" which I can then pass to `eval` to do the maths.)\r\n\r\nI kind of wish I could make the 'd' work like a real operator, so you could do \"(1d6+2)d8\", but that would mean making the code as long as the original `DiceRoll` function… ahh, but let's do it anyway\r\n```\r\n<function name=\"DiceRoll\" parameters=\"expression\" type=\"int\">\r\n  expression = LCase (expression)\r\n  if (IsRegexMatch (\"[^x/×÷+\\\\-d^%*\\\\s\\\\d\\\\(\\\\)]\", expression)) {\r\n    error (\"Invalid dice roll: \"+expression)\r\n  }\r\n  expression = Replace (expression, \"×\", \"*\")\r\n  expression = Replace (expression, \"x\", \"*\")\r\n  expression = Replace (expression, \"÷\", \"/\")\r\n  while (Instr (expression, \"d\") > 0)) {\r\n    while (IsRegexMatch (\"^(?<pre>.*)\\\\((?<expr>[+-*/^%\\\\d\\\\s]+)\\\\)(?<post>.*)$\", expression)) {\r\n      parts = Populate (\"^(?<pre>.*)\\\\((?<expr>[+-*/^%\\\\d\\\\s]+)\\\\)(?<post>.*)$\", expression)\r\n      expression = DictionaryItem (parts, \"pre\") + ToString (eval (DictionaryItem (parts, \"expr\"))) + DictionaryItem (parts, \"post\")\r\n    }\r\n    parts = Populate (\"^(?<pre>.*?)(?<count>\\\\d+)?\\\\s*d\\\\s*(?<dice>\\\\d+)(?<post>.*)$\", expression)\r\n    if (DictionaryContains (parts, \"count\")) {\r\n      count = ToInt (DictionaryItem (parts, \"count\"))\r\n    }\r\n    else {\r\n      count = 1\r\n    }\r\n    dice = ToInt (DictionaryItem (parts, \"dice\"))\r\n    total = 0\r\n    for (i, 1, count) {\r\n      total = total + GetRandomInt (1, dice)\r\n    }\r\n    expression = DictionaryItem (parts, \"pre\") + ToString (total) + DictionaryItem (parts, \"post\")\r\n  }\r\n  result = eval (expression)\r\n  return (result)\r\n</function>\r\n```\r\nNow that's certainly less efficient than the original DiceRoll function… or maybe not. Because rather than using Quest code with Instr and similar to disassemble the string, we're using a regular expression. It'll run over the string more times, but it only gets really expensive if you give it a more complex expression.\r\n\r\n(I did simple substitutions to replace `×` (or `x`) and `÷` with `*` and `/`, just in case you're making some RPG-styled thing and you want to have an expression like `6d6 ÷ 4` to show to the player, and then pass the same string to `DiceRoll`)",
      "EditableFormat": "markdown",
      "HTML": "<p>I happened to look at the <code>DiceRoll</code> function in the core recently, and found the code a little odd. Among other things, it will let you do \"2d6+3\" or \"3d6-5\", but not \"4-2d6\" or \"2d6+2d8\". And I started wondering how hard it would be to make something like that work.</p>\n<p>Here's two versions that came off the top of my head:</p>\n<pre><code>&lt;function name=\"DiceRoll\" parameters=\"expression\" type=\"int\"&gt;\n  expression = Replace (Replace (LCase(expression), \" \", \"\"), \"-\", \"+-\")\n  total = 0\n  foreach (dice, Split (expression, \"+\")) {\n    if (IsInt (dice)) {\n      total = total + dice\n    }\n    else {\n      if (Left (dice, 1) = \"-\") {\n        expression = Mid (dice, 2)\n        negative = -1\n      }\n      else {\n        negative = 1\n      }\n      if (Left (dice, 1) = \"d\") {\n        dice = \"1\"+dice\n      }\n      parts = Split (dice, \"d\")\n      if (ListCount (parts) = 2 and IsInt (StringListItem (parts, 0)) and IsInt (StringListItem (parts, 1))) {\n        sides = ToInt (StringListItem (parts, 1))\n        for (i, 1, ToInt (StringListItem (parts, 0))) {\n          total = total + negative * GetRandomInt (1, sides)\n        }\n      }\n      else {\n        error (\"Can't parse dice type: \"+dice)\n      }\n    }\n  }\n  return (total)\n&lt;/function&gt;\n</code></pre>\n<p>The use of Replace probably makes this a little less efficient, but I think it's pretty close to the original; and will happily handle systems like the Time Lord RPG (\"d6 - d6\" is common) or similar.</p>\n<p>But once I got thinking about it, I wondered how hard it would be to make one that will understand expressions like \"2d6 * 1d6\", or \"1d12 - (d6 + d8)\" too…</p>\n<pre><code>&lt;function name=\"DiceRoll\" parameters=\"expression\" type=\"int\"&gt;\n  expression = LCase (expression)\n  if (IsRegexMatch (\"[^x/×÷+\\\\-d^*\\\\s\\\\d\\\\(\\\\)]\", expression)) {\n    error (\"Invalid dice roll: \"+expression)\n  }\n  expression = Replace (expression, \"×\", \"*\")\n  expression = Replace (expression, \"x\", \"*\")\n  expression = Replace (expression, \"÷\", \"/\")\n  while (Instr (expression, \"d\") &gt; 0)) {\n    parts = Populate (\"^(?&lt;pre&gt;.*?)(?&lt;count&gt;\\\\d+)?\\\\s*d\\\\s*(?&lt;dice&gt;\\\\d+)(?&lt;post&gt;.*)$\", expression)\n    if (DictionaryContains (parts, \"count\")) {\n      count = ToInt (DictionaryItem (parts, \"count\"))\n    }\n    else {\n      count = 1\n    }\n    dice = ToInt (DictionaryItem (parts, \"dice\"))\n    total = 0\n    for (i, 1, count) {\n      total = total + GetRandomInt (1, dice)\n    }\n    expression = DictionaryItem (parts, \"pre\") + ToString (total) + DictionaryItem (parts, \"post\")\n  }\n  result = eval (expression)\n  return (result)\n&lt;/function&gt;\n</code></pre>\n<p>(Yes, I'm cheating. That searches the string for any part that looks like \"2d12\" or whatever, and replaces that expression with a number. So by the time there's no \"d\" left in the string, we've got something like \"12 + (3 * 4)\" which I can then pass to <code>eval</code> to do the maths.)</p>\n<p>I kind of wish I could make the 'd' work like a real operator, so you could do \"(1d6+2)d8\", but that would mean making the code as long as the original <code>DiceRoll</code> function… ahh, but let's do it anyway</p>\n<pre><code>&lt;function name=\"DiceRoll\" parameters=\"expression\" type=\"int\"&gt;\n  expression = LCase (expression)\n  if (IsRegexMatch (\"[^x/×÷+\\\\-d^%*\\\\s\\\\d\\\\(\\\\)]\", expression)) {\n    error (\"Invalid dice roll: \"+expression)\n  }\n  expression = Replace (expression, \"×\", \"*\")\n  expression = Replace (expression, \"x\", \"*\")\n  expression = Replace (expression, \"÷\", \"/\")\n  while (Instr (expression, \"d\") &gt; 0)) {\n    while (IsRegexMatch (\"^(?&lt;pre&gt;.*)\\\\((?&lt;expr&gt;[+-*/^%\\\\d\\\\s]+)\\\\)(?&lt;post&gt;.*)$\", expression)) {\n      parts = Populate (\"^(?&lt;pre&gt;.*)\\\\((?&lt;expr&gt;[+-*/^%\\\\d\\\\s]+)\\\\)(?&lt;post&gt;.*)$\", expression)\n      expression = DictionaryItem (parts, \"pre\") + ToString (eval (DictionaryItem (parts, \"expr\"))) + DictionaryItem (parts, \"post\")\n    }\n    parts = Populate (\"^(?&lt;pre&gt;.*?)(?&lt;count&gt;\\\\d+)?\\\\s*d\\\\s*(?&lt;dice&gt;\\\\d+)(?&lt;post&gt;.*)$\", expression)\n    if (DictionaryContains (parts, \"count\")) {\n      count = ToInt (DictionaryItem (parts, \"count\"))\n    }\n    else {\n      count = 1\n    }\n    dice = ToInt (DictionaryItem (parts, \"dice\"))\n    total = 0\n    for (i, 1, count) {\n      total = total + GetRandomInt (1, dice)\n    }\n    expression = DictionaryItem (parts, \"pre\") + ToString (total) + DictionaryItem (parts, \"post\")\n  }\n  result = eval (expression)\n  return (result)\n&lt;/function&gt;\n</code></pre>\n<p>Now that's certainly less efficient than the original DiceRoll function… or maybe not. Because rather than using Quest code with Instr and similar to disassemble the string, we're using a regular expression. It'll run over the string more times, but it only gets really expensive if you give it a more complex expression.</p>\n<p>(I did simple substitutions to replace <code>×</code> (or <code>x</code>) and <code>÷</code> with <code>*</code> and <code>/</code>, just in case you're making some RPG-styled thing and you want to have an expression like <code>6d6 ÷ 4</code> to show to the player, and then pass the same string to <code>DiceRoll</code>)</p>\n\n",
      "PostDate": "2019-10-22T09:59:26.2938445Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8fd8e387-43cc-41a5-a292-42a97566d197",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/vjdH3t6b.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": " \"2d6+3\" or \"3d6-5\", OK, you got that easy, but you are over thinking the rest...\r\n \"4-2d6\" -> R=4-DiceRoll(\"2d6\")\r\n \"2d6+2d8\".  -> R=DiceRoll(\"2d6\") + DiceRoll(\"2d8\")\r\nAlso:\r\n5d6÷4 -> R=DiceRoll(\"5d6\")/4\r\n\r\nSimpler, no extra coding required.\r\nAltho, from something I recently learned...\r\nDiceRoll is an easy to use function, for the programmer, it is a very hard function for Quest to process.\r\nGetRandomInt() is much easer on Quest, and not that hard to use...\r\nAfter all, earlier programmers used rnd(0) to generate numbers between 0 and 1, the multiplied the range needed, then \"int\"ed it...\r\nR=int(rnd(0)*6)+1\r\nto get a 1d6 result...\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>\"2d6+3\" or \"3d6-5\", OK, you got that easy, but you are over thinking the rest...<br>\n\"4-2d6\" -&gt; R=4-DiceRoll(\"2d6\")<br>\n\"2d6+2d8\".  -&gt; R=DiceRoll(\"2d6\") + DiceRoll(\"2d8\")<br>\nAlso:<br>\n5d6÷4 -&gt; R=DiceRoll(\"5d6\")/4</p>\n<p>Simpler, no extra coding required.<br>\nAltho, from something I recently learned...<br>\nDiceRoll is an easy to use function, for the programmer, it is a very hard function for Quest to process.<br>\nGetRandomInt() is much easer on Quest, and not that hard to use...<br>\nAfter all, earlier programmers used rnd(0) to generate numbers between 0 and 1, the multiplied the range needed, then \"int\"ed it...<br>\nR=int(rnd(0)*6)+1<br>\nto get a 1d6 result...</p>\n\n",
      "PostDate": "2019-10-23T03:47:11.8783266Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0b4b4f8b-ef44-4fe9-833d-31e8f4312773",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "However, there are situations where a DiceRoll function is useful. Most notably if you're trying to implement a tabletop RPG system in Quest; or to make a game that looks like an RPG system. If these rolls are, for example, a weapon's damage,  then where do you put that additional code you're suggesting? Do you have a combat function with dozens of special cases for different weapons?\r\n\r\nThe first version was vaguely  grounded in the real  world; because in  D&D (2nd ed) it  was possible to have weapons with a damage rating of \"d8 + d6\" or \"4 - d6\". So in the situation where the DiceRoll function has a real advantage over just using GetRandomInt,  there could be a case where someone expects it to be able to handle those.\r\n\r\nThe other two are pretty much \"take the concept and run with it\". I know they're not likely to be used, but something irks  me about having an arbitrary line in the sand. Saying that a function can handle addition and subtraction, but that's all, seems a  little arbitrary. I'm pretty sure I've seen tabletop systems that want you to roll half of 2d6, though the name of the system escapes me at present (I've played a lot of games of varying degrees of obscurity).\r\n\r\nThe disadvantage of DiceRoll is that it is a heavy load on the processor, so should be avoided where possible.  The advantage of it is that a string specifier allows  a lot of flexibility to be stores in a single  attribute. I'm just maximising that flexibility.\r\n\r\n(and if you're  going to point out that 2nd ed is  very old, I know that. But  if it's been done once, that puts it in the set of \"things that game designers might want to do\".)\r\n\r\n<details><summary>&gt;&gt; Alternate method</summary>\r\n\r\nIf there wasn't an existing DiceRoll method, I'd more likely suggest one with more sensible arguments.\r\n```\r\n<function name=\"Dice\" parameters=\"count,sides,bonus\" type=\"int\">\r\n  if (not IsDefined(\"sides\")) return (GetRandomInt (1, count))\r\n  total = 0\r\n  for (i, 1, count) {\r\n    total = total + GetRandomInt  (1, sides)\r\n  }\r\n  if (IsDefined (bonus)) total = total + bonus\r\n  return (total)\r\n</function>\r\n```\r\n\r\nThen instead of  `DiceRoll (\"2d6+4\")` you'd be writing  `Dice(2,6,4)` and not have the extra inefficiency. And a game designer who's trying to implement their favourite old-and-overcomplex tabletop system could write:\r\n```\r\nshortsword.damage = \"Dice(6)\"\r\nlongsword.damage = \"Dice(8)\"\r\nvolleybow.damage = \"9 - Dice(2,6)\"\r\ncaltrops.damage = \"Dice(2,4) / 2\"\r\nmastercraftedfidgetsword.damage = \"Dice(8)+Dice(6)\"\r\n```\r\nand then the damage resolution function can pass those strings directly  to  `eval()` instead of to `DiceRoll()`.\r\n\r\nAlthough… if you're trying to use the system from a tabletop game, there's a good chance you want the player to have the feel of the game as well. So you might want to have the line \"Damage: d8 + d6\" show up as part of a weapon's description. In which case, it would save so much work if you have a DiceRoll function that can operate on the same string.\r\n</details>\r\n\r\n<hr/>\r\nNow, I really want to run a benchmark. Use the core DiceRoll function to roll \"2d6+4\" as many times as possible in three seconds, and then do the same using the functions above. Report how many times each of them managed to make the roll, and see how it stacks up.\r\n\r\n<details><summary>&gt;&gt; An even sillier (but less processor-hungry) way to handle arbitrary dice rolls</summary>\r\nI know this is a weird way to do it. But it should be faster than the existing method; maybe even faster than using GetRandomInt directly…\r\n\r\n```\r\n<function name=\"DiceRoll\" parameters=\"expression\" type=\"int\">\r\n  dice = CompileDice (expression)\r\n  total = ListItem (dice, 0)\r\n  options = ListItem (dice, 1)\r\n  roll = GetRandomInt (1, options)\r\n  for (i, 2, ListCount (dice)-1) {\r\n    d = ListItem (dice, i)\r\n    if (d > 0) total = total + (roll % d) + 1\r\n    else total = total - (roll % -d) - 1\r\n    roll = roll / d\r\n  }\r\n  return (total)\r\n</function>\r\n\r\n<function name=\"CompileDice\" parameters=\"expression\" type=\"list\">\r\n  if (HasAttribute (game, \"dicecache\")) {\r\n    if (DictionaryContains (game.dicecache, expression)) {\r\n      return (DictionaryItem (game.dicecache, expression))\r\n    }\r\n  }\r\n  else {\r\n    game.dicecache = NewDictionary()\r\n  }\r\n  normalexpr = Replace (Replace (expression, \" \", \"\"), \"-\", \"+-\")\r\n  result = NewList()\r\n  numeric = 0\r\n  options = 1\r\n  foreach (part, Split (normalexpr, \"+\")) {\r\n    pos = Instr (part, \"d\")\r\n    if (pos = 0) {\r\n      numeric = numeric + ToInt (part)\r\n      count = 0\r\n    }\r\n    else if (pos = 1) {\r\n      count = 1\r\n      sides = ToInt (Mid (part, 2))\r\n    }\r\n    else {\r\n      if (pos = 2 and Left (part, 1) = \"-\") count = -1\r\n      else sides = ToInt (Left (part, pos-1))\r\n      sides = ToInt (Mid (part, pos+1))\r\n    }\r\n    if (count < 0) {\r\n      count = -count\r\n      sides = -sides\r\n    }\r\n    for (i, 1, count) {\r\n      list add (result, sides)\r\n      options = options * sides\r\n    }\r\n  }\r\n  list add (result, numeric)\r\n  if (options < 0) {\r\n    options = -options\r\n  }\r\n  list add (result, options)\r\n  for (i, 1, ListCount (result) - 2) {\r\n    die = ListItem (result, 0)\r\n    list remove (result, die)\r\n    list add (result, die)\r\n  }\r\n  dictionary add (game.dicecache, expression, result)\r\n  return (result)\r\n</function>\r\n```\r\n\r\nThat should handle all the plus and minus options; but it only needs to examine the string you pass to it the first time you use it. After that, it caches a table of the possible results of that dice roll, and determines a single random int as a lookup against that table.\r\n\r\nNow I'd really love to see how that performs… but it's not something I can test using the online version.\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>However, there are situations where a DiceRoll function is useful. Most notably if you're trying to implement a tabletop RPG system in Quest; or to make a game that looks like an RPG system. If these rolls are, for example, a weapon's damage,  then where do you put that additional code you're suggesting? Do you have a combat function with dozens of special cases for different weapons?</p>\n<p>The first version was vaguely  grounded in the real  world; because in  D&amp;D (2nd ed) it  was possible to have weapons with a damage rating of \"d8 + d6\" or \"4 - d6\". So in the situation where the DiceRoll function has a real advantage over just using GetRandomInt,  there could be a case where someone expects it to be able to handle those.</p>\n<p>The other two are pretty much \"take the concept and run with it\". I know they're not likely to be used, but something irks  me about having an arbitrary line in the sand. Saying that a function can handle addition and subtraction, but that's all, seems a  little arbitrary. I'm pretty sure I've seen tabletop systems that want you to roll half of 2d6, though the name of the system escapes me at present (I've played a lot of games of varying degrees of obscurity).</p>\n<p>The disadvantage of DiceRoll is that it is a heavy load on the processor, so should be avoided where possible.  The advantage of it is that a string specifier allows  a lot of flexibility to be stores in a single  attribute. I'm just maximising that flexibility.</p>\n<p>(and if you're  going to point out that 2nd ed is  very old, I know that. But  if it's been done once, that puts it in the set of \"things that game designers might want to do\".)</p>\n<details><summary>&gt;&gt; Alternate method</summary>\n<p>If there wasn't an existing DiceRoll method, I'd more likely suggest one with more sensible arguments.</p>\n<pre><code>&lt;function name=\"Dice\" parameters=\"count,sides,bonus\" type=\"int\"&gt;\n  if (not IsDefined(\"sides\")) return (GetRandomInt (1, count))\n  total = 0\n  for (i, 1, count) {\n    total = total + GetRandomInt  (1, sides)\n  }\n  if (IsDefined (bonus)) total = total + bonus\n  return (total)\n&lt;/function&gt;\n</code></pre>\n<p>Then instead of  <code>DiceRoll (\"2d6+4\")</code> you'd be writing  <code>Dice(2,6,4)</code> and not have the extra inefficiency. And a game designer who's trying to implement their favourite old-and-overcomplex tabletop system could write:</p>\n<pre><code>shortsword.damage = \"Dice(6)\"\nlongsword.damage = \"Dice(8)\"\nvolleybow.damage = \"9 - Dice(2,6)\"\ncaltrops.damage = \"Dice(2,4) / 2\"\nmastercraftedfidgetsword.damage = \"Dice(8)+Dice(6)\"\n</code></pre>\n<p>and then the damage resolution function can pass those strings directly  to  <code>eval()</code> instead of to <code>DiceRoll()</code>.</p>\n<p>Although… if you're trying to use the system from a tabletop game, there's a good chance you want the player to have the feel of the game as well. So you might want to have the line \"Damage: d8 + d6\" show up as part of a weapon's description. In which case, it would save so much work if you have a DiceRoll function that can operate on the same string.</p>\n</details>\n<hr>\nNow, I really want to run a benchmark. Use the core DiceRoll function to roll \"2d6+4\" as many times as possible in three seconds, and then do the same using the functions above. Report how many times each of them managed to make the roll, and see how it stacks up.\n<details><summary>&gt;&gt; An even sillier (but less processor-hungry) way to handle arbitrary dice rolls</summary>\nI know this is a weird way to do it. But it should be faster than the existing method; maybe even faster than using GetRandomInt directly…\n<pre><code>&lt;function name=\"DiceRoll\" parameters=\"expression\" type=\"int\"&gt;\n  dice = CompileDice (expression)\n  total = ListItem (dice, 0)\n  options = ListItem (dice, 1)\n  roll = GetRandomInt (1, options)\n  for (i, 2, ListCount (dice)-1) {\n    d = ListItem (dice, i)\n    if (d &gt; 0) total = total + (roll % d) + 1\n    else total = total - (roll % -d) - 1\n    roll = roll / d\n  }\n  return (total)\n&lt;/function&gt;\n\n&lt;function name=\"CompileDice\" parameters=\"expression\" type=\"list\"&gt;\n  if (HasAttribute (game, \"dicecache\")) {\n    if (DictionaryContains (game.dicecache, expression)) {\n      return (DictionaryItem (game.dicecache, expression))\n    }\n  }\n  else {\n    game.dicecache = NewDictionary()\n  }\n  normalexpr = Replace (Replace (expression, \" \", \"\"), \"-\", \"+-\")\n  result = NewList()\n  numeric = 0\n  options = 1\n  foreach (part, Split (normalexpr, \"+\")) {\n    pos = Instr (part, \"d\")\n    if (pos = 0) {\n      numeric = numeric + ToInt (part)\n      count = 0\n    }\n    else if (pos = 1) {\n      count = 1\n      sides = ToInt (Mid (part, 2))\n    }\n    else {\n      if (pos = 2 and Left (part, 1) = \"-\") count = -1\n      else sides = ToInt (Left (part, pos-1))\n      sides = ToInt (Mid (part, pos+1))\n    }\n    if (count &lt; 0) {\n      count = -count\n      sides = -sides\n    }\n    for (i, 1, count) {\n      list add (result, sides)\n      options = options * sides\n    }\n  }\n  list add (result, numeric)\n  if (options &lt; 0) {\n    options = -options\n  }\n  list add (result, options)\n  for (i, 1, ListCount (result) - 2) {\n    die = ListItem (result, 0)\n    list remove (result, die)\n    list add (result, die)\n  }\n  dictionary add (game.dicecache, expression, result)\n  return (result)\n&lt;/function&gt;\n</code></pre>\n<p>That should handle all the plus and minus options; but it only needs to examine the string you pass to it the first time you use it. After that, it caches a table of the possible results of that dice roll, and determines a single random int as a lookup against that table.</p>\n<p>Now I'd really love to see how that performs… but it's not something I can test using the online version.</p>\n</details>\n\n",
      "PostDate": "2019-10-23T09:33:58.0489593Z",
      "LastEditDate": "2019-11-13T01:55:12.4317906Z",
      "link": null
    },
    {
      "PostId": "322489e4-e421-4f79-ac20-ec5d666beb80",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "just a small thing for consideration:\r\n\r\nthe built-in 'DiceRoll ()' doesn't have the means (as far as I know, which is nothing, of this built-in Function's coding, lol) of deciding/inputting the values of each of the sides, which maybe people may want such a feature/mechanic available to them\r\n\r\nyou choose/input the number of desired sides, but the sides' Values, start at 1 and increase by 1 for each additional side (example, a 6-sided dice's sides' values: 1, 2, 3, 4, 5, 6)\r\n\r\nbut someone may want for example, a six-sided dice with sides' Values of: 3, 14, 37, 61, 79, 85",
      "EditableFormat": "markdown",
      "HTML": "<p>just a small thing for consideration:</p>\n<p>the built-in 'DiceRoll ()' doesn't have the means (as far as I know, which is nothing, of this built-in Function's coding, lol) of deciding/inputting the values of each of the sides, which maybe people may want such a feature/mechanic available to them</p>\n<p>you choose/input the number of desired sides, but the sides' Values, start at 1 and increase by 1 for each additional side (example, a 6-sided dice's sides' values: 1, 2, 3, 4, 5, 6)</p>\n<p>but someone may want for example, a six-sided dice with sides' Values of: 3, 14, 37, 61, 79, 85</p>\n\n",
      "PostDate": "2019-11-13T01:25:31.4502806Z",
      "LastEditDate": "2019-11-13T01:26:33.8534106Z",
      "link": null
    },
    {
      "PostId": "2c907422-70b0-4009-ad2b-50190c69aa5f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> but someone may want for example, a six-sided dice with sides' Values of: 3, 14, 37, 61, 79, 85\r\n\r\n```\r\nresult = ToInt (PickOneString (Split (\"3;14;37;61;79;85\")))\r\n```\r\n\r\nNot quite as simple. However, the general case of this problem risks turning the dice roller's expressions into a full-blown expression language. When you start thinking of things like this, you'd probably be better making the string an expression which can be evaluated.\r\n\r\nHmm… using the regular expressions method, it wouldn't be too hard to transform \"XdY\" into \"RollDice(X, Y)\"; and maybe have an expression for an array literal. So something like \"3d[3, 14, 37, 61, 79, 85]\" turns into `RollDice (3, Split(\"3;14;37;61;79;85\"))` which can then be passed to `eval`.\r\nBut the problem is that once you start doing things like that, you pretty much have to parse the string. You end up implementing a whole programming language just for one function. That's why I figured that it would be both easier and more powerful to only deal with the actual dice, and let `eval` handle the rest.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>but someone may want for example, a six-sided dice with sides' Values of: 3, 14, 37, 61, 79, 85</p>\n</blockquote>\n<pre><code>result = ToInt (PickOneString (Split (\"3;14;37;61;79;85\")))\n</code></pre>\n<p>Not quite as simple. However, the general case of this problem risks turning the dice roller's expressions into a full-blown expression language. When you start thinking of things like this, you'd probably be better making the string an expression which can be evaluated.</p>\n<p>Hmm… using the regular expressions method, it wouldn't be too hard to transform \"XdY\" into \"RollDice(X, Y)\"; and maybe have an expression for an array literal. So something like \"3d[3, 14, 37, 61, 79, 85]\" turns into <code>RollDice (3, Split(\"3;14;37;61;79;85\"))</code> which can then be passed to <code>eval</code>.<br>\nBut the problem is that once you start doing things like that, you pretty much have to parse the string. You end up implementing a whole programming language just for one function. That's why I figured that it would be both easier and more powerful to only deal with the actual dice, and let <code>eval</code> handle the rest.</p>\n\n",
      "PostDate": "2019-11-13T01:49:22.852609Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
