{
  "Topic": {
    "TopicId": "zwwenv9q30kl-4cun1t9yq",
    "ForumId": "10",
    "Title": "Debugging infinite loops",
    "LastUpdated": "2017-09-17T14:10:30.6228043Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "61d36139-7b94-4adc-9530-c0f5143f582d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hi folks!\r\n\r\nI was having some pain today trying to debug an infinite loop… hard to see what's happening when it's doing too much stuff. So I came up with this. A turn script that sets `game.debug_count` to zero, and then a debug function:\r\n```\r\nif (GetBoolean(game, \"debug_mode\")) {\r\n  if (not HasInt(game, \"debug_count\")) {\r\n    game.debug_count = 1\r\n  }\r\n  else if (game.debug_count > 600) {\r\n    error (\"***** DEBUG OVERFLOW *****\")\r\n  }\r\n  else {\r\n    game.debug_count = game.debug_count + 1\r\n  }\r\n  if (HasString(game, \"debug_level\")) {\r\n    message = debug_level + message\r\n  }\r\n  msg (\"<p style=\\\"whitespace: pre;\\\">DEBUG: \"+message+\"</p>\")\r\n}\r\n```\r\nSo if one script outputs more than 400 lines of debug messages (like it's stuck in an infinite loop), it calls `error`.\r\nHaven't been able to test this yet... looks like the server just went down. But while I wait, thought I'd post here; see if anyone else can point out a better way to do it, and if anyone would find it useful.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hi folks!</p>\n<p>I was having some pain today trying to debug an infinite loop… hard to see what's happening when it's doing too much stuff. So I came up with this. A turn script that sets <code>game.debug_count</code> to zero, and then a debug function:</p>\n<pre><code>if (GetBoolean(game, \"debug_mode\")) {\n  if (not HasInt(game, \"debug_count\")) {\n    game.debug_count = 1\n  }\n  else if (game.debug_count &gt; 600) {\n    error (\"***** DEBUG OVERFLOW *****\")\n  }\n  else {\n    game.debug_count = game.debug_count + 1\n  }\n  if (HasString(game, \"debug_level\")) {\n    message = debug_level + message\n  }\n  msg (\"&lt;p style=\\\"whitespace: pre;\\\"&gt;DEBUG: \"+message+\"&lt;/p&gt;\")\n}\n</code></pre>\n<p>So if one script outputs more than 400 lines of debug messages (like it's stuck in an infinite loop), it calls <code>error</code>.<br>\nHaven't been able to test this yet... looks like the server just went down. But while I wait, thought I'd post here; see if anyone else can point out a better way to do it, and if anyone would find it useful.</p>\n\n",
      "PostDate": "2017-09-17T14:10:30.6228043Z",
      "LastEditDate": "2017-09-17T14:13:54.8320008Z",
      "link": null
    },
    {
      "PostId": "f471595c-9932-4cfd-94d7-83d0a3af30ec",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Oh, that's not useful then.\r\n`error` prints a message and exits the current function.\r\n`finish` doesn't do anything\r\nIs there actually a way to force the calling script to stop? Putting `while ([actual condition] and not game.debug_overflow) {` on every loop works; but I was hoping it would be possible to just interrupt the game and flush remaining output.",
      "EditableFormat": "markdown",
      "HTML": "<p>Oh, that's not useful then.<br>\n<code>error</code> prints a message and exits the current function.<br>\n<code>finish</code> doesn't do anything<br>\nIs there actually a way to force the calling script to stop? Putting <code>while ([actual condition] and not game.debug_overflow) {</code> on every loop works; but I was hoping it would be possible to just interrupt the game and flush remaining output.</p>\n\n",
      "PostDate": "2017-09-17T14:24:02.1626166Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "71184611-c815-43e5-b349-332b1c49dc57",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "http://i.imgur.com/BXvaaIub.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Sounds like you need a command from Basic called stop, or end...\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Sounds like you need a command from Basic called stop, or end...</p>\n\n",
      "PostDate": "2017-09-17T19:27:48.6138138Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "29472ca8-33ea-4db7-baab-b95daf6e9373",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I was thinking of Perl's `die`.\r\nI expected `finish` to work like that, or at least `error` to stop the function, but it seems errors are localised to the function, not to the running script.",
      "EditableFormat": "markdown",
      "HTML": "<p>I was thinking of Perl's <code>die</code>.<br>\nI expected <code>finish</code> to work like that, or at least <code>error</code> to stop the function, but it seems errors are localised to the function, not to the running script.</p>\n\n",
      "PostDate": "2017-09-17T21:11:18.6718623Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5bab0321-6dd6-4220-8947-4498c0fcfe34",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "if you find a way to stop/terminate/'break'/'exit' (or 'try/catch' error-n-exception-handling) scripting let us know!\r\n\r\nas we need that to avoid crashes due to looping of getting user inputs... lol",
      "EditableFormat": "markdown",
      "HTML": "<p>if you find a way to stop/terminate/'break'/'exit' (or 'try/catch' error-n-exception-handling) scripting let us know!</p>\n<p>as we need that to avoid crashes due to looping of getting user inputs... lol</p>\n\n",
      "PostDate": "2017-09-17T23:49:58.4395971Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3a1fcc96-3d20-4569-8bcc-3184a8448438",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have a short term solution.\r\n\r\nUse a show menu. Type \"no\" for the ignore thing.\r\n\r\nThe bracket numbers/places may be messed up here...\r\n```\r\noptions = Split(\"Dun-dun\", \";\")\r\nShowMenu (\"THING\", options, false) {\r\n  switch (result) {\r\n    case (\"Dun-dun\") {\r\n      msg (\"You made an infinite loop.\")\r\n    }\r\n  }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I have a short term solution.</p>\n<p>Use a show menu. Type \"no\" for the ignore thing.</p>\n<p>The bracket numbers/places may be messed up here...</p>\n<pre><code>options = Split(\"Dun-dun\", \";\")\nShowMenu (\"THING\", options, false) {\n  switch (result) {\n    case (\"Dun-dun\") {\n      msg (\"You made an infinite loop.\")\n    }\n  }\n}\n</code></pre>\n\n",
      "PostDate": "2017-09-18T00:33:01.1751809Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "41ce3f0b-b96d-48b6-92e8-f61da64b8d7f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "jmnevil: What's the point in that?\r\n\r\nEdit: Sorry that was a bit terse.\r\n\r\nFrom my understanding, ShowMenu() just displays a menu. But in this case, output seems to being buffered and never displayed (presumably because the server waits for the script to end before sending everything to the client; or maybe the client waits to receive all the data before putting it onscreen).\r\n\r\nThe \"allow cancel\" option just sets a flag telling the parser to ignore all other commands until the menu has been answered. That's no help when it's in an infinite loop, because the script doesn't finish.",
      "EditableFormat": "markdown",
      "HTML": "<p>jmnevil: What's the point in that?</p>\n<p>Edit: Sorry that was a bit terse.</p>\n<p>From my understanding, ShowMenu() just displays a menu. But in this case, output seems to being buffered and never displayed (presumably because the server waits for the script to end before sending everything to the client; or maybe the client waits to receive all the data before putting it onscreen).</p>\n<p>The \"allow cancel\" option just sets a flag telling the parser to ignore all other commands until the menu has been answered. That's no help when it's in an infinite loop, because the script doesn't finish.</p>\n\n",
      "PostDate": "2017-09-18T09:30:47.6366217Z",
      "LastEditDate": "2017-09-18T11:38:20.3733501Z",
      "link": null
    },
    {
      "PostId": "c037d71c-799b-4a80-9258-7e18e33b101f",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It was just an idea for a short term solution until someone (probably The Pixie) came with better code.\r\n\r\nOh... so you don't want to stop the infinite code loop...? I didn't know it worked like that. (Server waits till end?) I just figured if you put it in at the right place, it would work...",
      "EditableFormat": "markdown",
      "HTML": "<p>It was just an idea for a short term solution until someone (probably The Pixie) came with better code.</p>\n<p>Oh... so you don't want to stop the infinite code loop...? I didn't know it worked like that. (Server waits till end?) I just figured if you put it in at the right place, it would work...</p>\n\n",
      "PostDate": "2017-09-18T13:15:19.3494635Z",
      "LastEditDate": "2017-09-18T13:20:36.2896223Z",
      "link": null
    },
    {
      "PostId": "025b6bd3-217a-4d12-95f5-143ae818f5c7",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yes, I want to stop the infinite loop. But ShowMenu or show menu won't do that. It stops the user entering other commands, but it doesn't stop scripts that are already running. Think about it: code that comes after the ShowMenu (but not in the result callback) executes right away. Otherwise you couldn't do:\r\n```\r\nShowMenu (... blah ...) {\r\n  // do something with the result\r\n}\r\nmsg (\"(Here's some more detailed explanation of what the options mean, to help you choose)\")\r\n```\r\n\r\nAt least… that's what I understood from glancing through the Core functions. Am I wrong?",
      "EditableFormat": "markdown",
      "HTML": "<p>Yes, I want to stop the infinite loop. But ShowMenu or show menu won't do that. It stops the user entering other commands, but it doesn't stop scripts that are already running. Think about it: code that comes after the ShowMenu (but not in the result callback) executes right away. Otherwise you couldn't do:</p>\n<pre><code>ShowMenu (... blah ...) {\n  // do something with the result\n}\nmsg (\"(Here's some more detailed explanation of what the options mean, to help you choose)\")\n</code></pre>\n<p>At least… that's what I understood from glancing through the Core functions. Am I wrong?</p>\n\n",
      "PostDate": "2017-09-18T14:46:50.1754061Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "16e3d7d7-64d4-41fd-bb79-5c913ec0c1cf",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "http://i.imgur.com/FOIjtApb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Have you tried using ```on ready```?\r\n\r\nhttp://docs.textadventures.co.uk/quest/scripts/on_ready.html\r\n\r\n---\r\nNevermind.  That did nothing.",
      "EditableFormat": "markdown",
      "HTML": "<p>Have you tried using <code>on ready</code>?</p>\n<p>http://docs.textadventures.co.uk/quest/scripts/on_ready.html</p>\n<hr>\n<p>Nevermind.  That did nothing.</p>\n\n",
      "PostDate": "2017-09-18T21:55:49.3763873Z",
      "LastEditDate": "2017-09-18T22:01:59.6372376Z",
      "link": null
    },
    {
      "PostId": "4b28b1ef-612f-4bf3-8405-2b1ab78c6a55",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The behaviour of `on ready` is a bit quirky. It doesn't stop anything called after it, though. If there's not a menu currently being shown or something like that, the code in it will execute immediately. If there's previously been a `show menu` call, the \"ready\" code will be delayed until the Quest engine has processed the player's response - which it won't do until the current script has finished.",
      "EditableFormat": "markdown",
      "HTML": "<p>The behaviour of <code>on ready</code> is a bit quirky. It doesn't stop anything called after it, though. If there's not a menu currently being shown or something like that, the code in it will execute immediately. If there's previously been a <code>show menu</code> call, the \"ready\" code will be delayed until the Quest engine has processed the player's response - which it won't do until the current script has finished.</p>\n\n",
      "PostDate": "2017-09-18T22:24:57.4895228Z",
      "LastEditDate": "2017-09-19T02:09:53.0388554Z",
      "link": null
    },
    {
      "PostId": "c2dc5e57-52ec-4757-b4ac-cf0ac9f31017",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "http://i.imgur.com/BXvaaIub.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "In Basic, there is a command that will stop execution of the program...\r\n^C   (Ctrl C)\r\nI doubt it is something that could be placed in a Quest script, but it could be in the Quest core code...\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>In Basic, there is a command that will stop execution of the program...<br>\n^C   (Ctrl C)<br>\nI doubt it is something that could be placed in a Quest script, but it could be in the Quest core code...</p>\n\n",
      "PostDate": "2017-09-19T01:46:31.1609245Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "6b6bd5a7-73b6-40c3-8e64-f774e55bb586",
      "UserId": 5574,
      "Username": "R2T1",
      "AvatarUrl": "http://i.imgur.com/32ogfqMb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The only way I know to debug an infinite loop is to print a message immediately before it executes and another immediately after.\r\nOnce you strike the infinite loop, (ie. only get start message and not end message) you can then insert messages into the loop and run again (... and again ...)  until you squash the bug.\r\nHowever, if you are trying to trap for this in case the user does something to cause it, you would need to setup your inputs to filter out all but the correct answer(s).\r\nI can't think of any other way. I don't think it is even possible in other languages I have used. (various BASICs, C, C++, VB, VBA, Python and others)\r\nOn the other hand, you may need to delve into the core Quest code to get to its processing levels.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>The only way I know to debug an infinite loop is to print a message immediately before it executes and another immediately after.<br>\nOnce you strike the infinite loop, (ie. only get start message and not end message) you can then insert messages into the loop and run again (... and again ...)  until you squash the bug.<br>\nHowever, if you are trying to trap for this in case the user does something to cause it, you would need to setup your inputs to filter out all but the correct answer(s).<br>\nI can't think of any other way. I don't think it is even possible in other languages I have used. (various BASICs, C, C++, VB, VBA, Python and others)<br>\nOn the other hand, you may need to delve into the core Quest code to get to its processing levels.</p>\n\n",
      "PostDate": "2017-09-19T02:31:37.1254909Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2be877a4-8ff2-4c88-a919-f0033bbae191",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "http://i.imgur.com/BXvaaIub.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmmm...\r\nMaybe it was another command I was thinking...\r\nOr maybe that was for batch files???\r\nOh, well...\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmmm...<br>\nMaybe it was another command I was thinking...<br>\nOr maybe that was for batch files???<br>\nOh, well...</p>\n\n",
      "PostDate": "2017-09-19T03:54:59.1087343Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "95907335-dc82-4013-86f2-57e1512b48f1",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@mrangel\r\n\r\n `on ready` will wait for any blocks to complete but not scripts. Script commands in lower case, like `show menu`, use blocks, whilst functions in capitals, like ShowMenu, use scripts. None of which is useful here...\r\n\r\n\r\n@R2T1\r\n\r\nAgreed.",
      "EditableFormat": "markdown",
      "HTML": "<p>@mrangel</p>\n<p><code>on ready</code> will wait for any blocks to complete but not scripts. Script commands in lower case, like <code>show menu</code>, use blocks, whilst functions in capitals, like ShowMenu, use scripts. None of which is useful here...</p>\n<p>@R2T1</p>\n<p>Agreed.</p>\n\n",
      "PostDate": "2017-09-19T08:47:58.0572589Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "755e7082-4e30-4378-b36e-039cd80290f6",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I say, I just delete glitchy, offending code, and start over. No need to deal with infinite loops when you can just delete the whole thing.\r\n\r\nI also figured out how to comment on Alex W.'s blog, about this issue... so.... I don't know if he'll respond...",
      "EditableFormat": "markdown",
      "HTML": "<p>I say, I just delete glitchy, offending code, and start over. No need to deal with infinite loops when you can just delete the whole thing.</p>\n<p>I also figured out how to comment on Alex W.'s blog, about this issue... so.... I don't know if he'll respond...</p>\n\n",
      "PostDate": "2017-09-19T12:04:02.4918262Z",
      "LastEditDate": "2017-09-19T12:05:38.0569377Z",
      "link": null
    },
    {
      "PostId": "dba1ce69-6dcf-499e-96f1-95273c2973d7",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Oh, I found this. https://textadventures.co.uk/forum/quest/topic/ugrtq5ysmk6xnbdxkp7hxw/quest-keeps-crashing-while-i-try-to-work-solved\r\nI don't know if it will answer your question, but it said something about infinite loops...",
      "EditableFormat": "markdown",
      "HTML": "<p>Oh, I found this. https://textadventures.co.uk/forum/quest/topic/ugrtq5ysmk6xnbdxkp7hxw/quest-keeps-crashing-while-i-try-to-work-solved<br>\nI don't know if it will answer your question, but it said something about infinite loops...</p>\n\n",
      "PostDate": "2017-09-27T14:10:53.9287897Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8ef424d6-a052-4d1a-812f-718e41ebb23a",
      "UserId": 307193,
      "Username": "lordpalandus",
      "AvatarUrl": "https://secure.gravatar.com/avatar/637feacf8e8a52834eaa284e96f879bf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "If you are getting infinite loops check the Boolean logic that controls the loop. Make sure that there is a proper decrement or increment variable that controls how many times it loops. \r\n\r\nAlso, make sure you don't have too many calculations that occur within that loop... as Quest doesn't like too many calculations... this can make it appear like the program has frozen, but in reality its just being excruciatingly slow. When I had just started out with quest I had made one that did like 500+ calculations within one loop, and it appeared to freeze, but after about 2 minutes of waiting, it unfroze. ",
      "EditableFormat": "markdown",
      "HTML": "<p>If you are getting infinite loops check the Boolean logic that controls the loop. Make sure that there is a proper decrement or increment variable that controls how many times it loops.</p>\n<p>Also, make sure you don't have too many calculations that occur within that loop... as Quest doesn't like too many calculations... this can make it appear like the program has frozen, but in reality its just being excruciatingly slow. When I had just started out with quest I had made one that did like 500+ calculations within one loop, and it appeared to freeze, but after about 2 minutes of waiting, it unfroze.</p>\n\n",
      "PostDate": "2017-09-30T07:29:47.6300627Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3f460025-b018-4e40-bca2-f1c471b45013",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "\"Checking the logic\" is very hard if you can't get any messages out of it to find out what's going on.\r\n\r\n> The only way I know to debug an infinite loop is to print a message immediately before it executes and another immediately after.\r\n\r\nYes; standard debugging practice. But it's not helpful in Quest, because on the web version, all output appears to be queued up and sent as a batch when the script finishes. So if I'm in a situation where the script sometimes fails to complete, all I can know is \"it didn't finish this time\"; I can see what the different variables and data structures were prior to entering the loop if it works, but I can't find out anything about the dataset that caused it to get stuck.\r\n\r\n**If you really want to know what I screwed up…** (now that I found it). My random maze generator looks like (pseudocode):\r\n```\r\nwhile (there are rooms within the container not reachable from the start point) {\r\n  pick a reachable room A and an unreachable room B\r\n  pick a compass direction (I'll use north in this example)\r\n  make an exit going north from A to B\r\n  make an exit going south from B to A\r\n  if (A already had a north exit and B already had a south) {\r\n    change the destination of those exits (and their reverse counterparts):\r\n    the room that was north of A is now north of the room formerly south of B\r\n  }\r\n  else if (there's already a room north of A) {\r\n    pick an unreachable room C, which doesn't have a north exit\r\n    make north_of_A's south exit now point to C\r\n  }\r\n  else if (there's already a room south of B) {\r\n    pick a reachable room C, which doesn't have a south exit\r\n    make south_of_B's north exit now point to C\r\n  }\r\n}\r\n```\r\n(actually more complex than that, with more error checks against corner cases that could lead to it not terminating, but that's enough to give you some idea)\r\n\r\nThe algorithm as written looks like it could run forever; but it can't. The maths is pretty complex; but basically boils down to - the number of exits always increases or stays the same, and there's always a non-zero probability of it increasing until every room has 4 exits. Once all available exits are taken, the expectation of the change in number of reachable rooms is always positive; so as the number of iterations increases, the number of reachable rooms grows more than it falls.\r\n\r\nThe problem, then... I've got a function which changes the `to` of an exit, and the `parent` of the exit in the opposite direction. I'd messed up the logic, and assumed that `GetExitByLink (x.to, x.parent)` would always find an exit whose direction is the opposite of exit `x`. This isn't true if you're in one of the weird elf-magic loops where going north and south from a room takes you to the same place. And if it moves the wrong one, then the function responsible for \"filter this list of rooms to find the ones without a north exit\" starts returning a room which doesn't have a north exit, but can already be reached by going south from another room.\r\n\r\nIn this case, the loop isn't guaranteed to terminate; because the algorithm I used for determining what's \"reachable\" from the start room doesn't work on directed graphs. (It assumes that if I can get from A to B, I can also get from B to A).\r\n\r\nFiguring out that whole mess without being able to dump the state of the map when it went wrong was a real pain.",
      "EditableFormat": "markdown",
      "HTML": "<p>\"Checking the logic\" is very hard if you can't get any messages out of it to find out what's going on.</p>\n<blockquote>\n<p>The only way I know to debug an infinite loop is to print a message immediately before it executes and another immediately after.</p>\n</blockquote>\n<p>Yes; standard debugging practice. But it's not helpful in Quest, because on the web version, all output appears to be queued up and sent as a batch when the script finishes. So if I'm in a situation where the script sometimes fails to complete, all I can know is \"it didn't finish this time\"; I can see what the different variables and data structures were prior to entering the loop if it works, but I can't find out anything about the dataset that caused it to get stuck.</p>\n<p><strong>If you really want to know what I screwed up…</strong> (now that I found it). My random maze generator looks like (pseudocode):</p>\n<pre><code>while (there are rooms within the container not reachable from the start point) {\n  pick a reachable room A and an unreachable room B\n  pick a compass direction (I'll use north in this example)\n  make an exit going north from A to B\n  make an exit going south from B to A\n  if (A already had a north exit and B already had a south) {\n    change the destination of those exits (and their reverse counterparts):\n    the room that was north of A is now north of the room formerly south of B\n  }\n  else if (there's already a room north of A) {\n    pick an unreachable room C, which doesn't have a north exit\n    make north_of_A's south exit now point to C\n  }\n  else if (there's already a room south of B) {\n    pick a reachable room C, which doesn't have a south exit\n    make south_of_B's north exit now point to C\n  }\n}\n</code></pre>\n<p>(actually more complex than that, with more error checks against corner cases that could lead to it not terminating, but that's enough to give you some idea)</p>\n<p>The algorithm as written looks like it could run forever; but it can't. The maths is pretty complex; but basically boils down to - the number of exits always increases or stays the same, and there's always a non-zero probability of it increasing until every room has 4 exits. Once all available exits are taken, the expectation of the change in number of reachable rooms is always positive; so as the number of iterations increases, the number of reachable rooms grows more than it falls.</p>\n<p>The problem, then... I've got a function which changes the <code>to</code> of an exit, and the <code>parent</code> of the exit in the opposite direction. I'd messed up the logic, and assumed that <code>GetExitByLink (x.to, x.parent)</code> would always find an exit whose direction is the opposite of exit <code>x</code>. This isn't true if you're in one of the weird elf-magic loops where going north and south from a room takes you to the same place. And if it moves the wrong one, then the function responsible for \"filter this list of rooms to find the ones without a north exit\" starts returning a room which doesn't have a north exit, but can already be reached by going south from another room.</p>\n<p>In this case, the loop isn't guaranteed to terminate; because the algorithm I used for determining what's \"reachable\" from the start room doesn't work on directed graphs. (It assumes that if I can get from A to B, I can also get from B to A).</p>\n<p>Figuring out that whole mess without being able to dump the state of the map when it went wrong was a real pain.</p>\n\n",
      "PostDate": "2017-09-30T12:48:05.5962771Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "fad1c844-e7b3-4941-834a-e6ab917f927e",
      "UserId": 307193,
      "Username": "lordpalandus",
      "AvatarUrl": "https://secure.gravatar.com/avatar/637feacf8e8a52834eaa284e96f879bf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ahhh. I was assuming the game was done in the Windows desktop version... where it is significantly easier to debug infinite loops.",
      "EditableFormat": "markdown",
      "HTML": "<p>Ahhh. I was assuming the game was done in the Windows desktop version... where it is significantly easier to debug infinite loops.</p>\n\n",
      "PostDate": "2017-10-01T00:56:43.9470894Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c4d81769-15ed-47e4-b1b4-f3ab93117938",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "My new bidirectional exit model encapsulates this a whole lot better. My function `MakeExits` (same parameters as core `CreateBiExits`) now creates 2 exits in opposite directions, giving them an extra attribute, `reverse` linking to the other exit in the pair, and two scripts `changedto` and `changedparent` which ensure that if one exit is moved to a different room, the other comes with it. They also call a script attribute `changedexits` on the rooms connected by the exits, which it is useful because now my \"path\" and \"stream\" rooms can move their \"path end\" objects (scenery with inroomdescription) to make sure they're still in adjacent rooms when the shifting maze moves the exit around.",
      "EditableFormat": "markdown",
      "HTML": "<p>My new bidirectional exit model encapsulates this a whole lot better. My function <code>MakeExits</code> (same parameters as core <code>CreateBiExits</code>) now creates 2 exits in opposite directions, giving them an extra attribute, <code>reverse</code> linking to the other exit in the pair, and two scripts <code>changedto</code> and <code>changedparent</code> which ensure that if one exit is moved to a different room, the other comes with it. They also call a script attribute <code>changedexits</code> on the rooms connected by the exits, which it is useful because now my \"path\" and \"stream\" rooms can move their \"path end\" objects (scenery with inroomdescription) to make sure they're still in adjacent rooms when the shifting maze moves the exit around.</p>\n\n",
      "PostDate": "2017-10-01T09:57:25.5592026Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
