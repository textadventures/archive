{
  "Topic": {
    "TopicId": "lcwdmdg-qe60uav4-ozthg",
    "ForumId": "10",
    "Title": "Circular rooms?",
    "LastUpdated": "2020-01-16T08:06:56.078435Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "4669e262-cd25-440c-8b73-4d2d4bd92447",
      "UserId": 349948,
      "Username": "Harvelon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I am using the map in my adventure and I want to make a circular room but there doesn’t seem to be a option for that. Any help?",
      "EditableFormat": "markdown",
      "HTML": "<p>I am using the map in my adventure and I want to make a circular room but there doesn’t seem to be a option for that. Any help?</p>\n\n",
      "PostDate": "2020-01-16T08:06:56.078435Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5c950225-985f-4193-9d91-547b240c5dd2",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/vjdH3t6b.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Do you want the map function to draw circular rooms???\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Do you want the map function to draw circular rooms???</p>\n\n",
      "PostDate": "2020-01-17T07:18:10.3726558Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1cbd0708-467f-4987-ba50-906c5b9f1b70",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/vjdH3t6b.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "To the masters that want to check this out...\r\nQuest/Core/CoreEditorScriptsDrawing.alsx\r\nLine # 331\r\n```\r\n  <editor>\r\n    <appliesto>(function)Grid_DrawSquare</appliesto>\r\n    <display>Draw custom layer grid square</display>\r\n    <category>[EditorScriptsDrawingDrawing]</category>\r\n    <create>Grid_DrawSquare (\"\", 0, 0, 1, 1, \"\", \"White\")</create>\r\n    <add>[EditorScriptsDrawingDrawcustom]</add>\r\n    <advanced/>\r\n    <onlydisplayif>game.gridmap</onlydisplayif>\r\n```\r\nIf this draws the room box, could this be copied and edited to draw other shapes?\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>To the masters that want to check this out...<br>\nQuest/Core/CoreEditorScriptsDrawing.alsx<br>\nLine # 331</p>\n<pre><code>  &lt;editor&gt;\n    &lt;appliesto&gt;(function)Grid_DrawSquare&lt;/appliesto&gt;\n    &lt;display&gt;Draw custom layer grid square&lt;/display&gt;\n    &lt;category&gt;[EditorScriptsDrawingDrawing]&lt;/category&gt;\n    &lt;create&gt;Grid_DrawSquare (\"\", 0, 0, 1, 1, \"\", \"White\")&lt;/create&gt;\n    &lt;add&gt;[EditorScriptsDrawingDrawcustom]&lt;/add&gt;\n    &lt;advanced/&gt;\n    &lt;onlydisplayif&gt;game.gridmap&lt;/onlydisplayif&gt;\n</code></pre>\n<p>If this draws the room box, could this be copied and edited to draw other shapes?</p>\n\n",
      "PostDate": "2020-01-17T07:27:08.8363009Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "01cda0fd-02c6-49c5-9cd7-0322bce6d539",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/vjdH3t6b.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Or could this be done easer by drawing the room map, manually, using SVG???\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Or could this be done easer by drawing the room map, manually, using SVG???</p>\n\n",
      "PostDate": "2020-01-17T07:29:59.8081887Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f6750ee0-ecbc-4370-b84d-b08bd428853f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK, you'd need a bit of extra javascript.\r\nI'm writing this after skimming over grid.js; I'm not sure if these functions can be added later, or if `grid.js` is loaded within a specific frame.\r\n\r\nFirst, an actual circle-drawing function. Heavily based on drawBox\r\n```\r\ngridApi.drawCircle = function(x, y, z, r, border, borderWidth, fill) {\r\n  activateLayer(z);\r\n  // if this is the first room drawn, centre it.\r\n  if (firstBox) {\r\n    var offsetX = paper.view.center.x - x;\r\n    var offsetY = paper.view.center.y - y;\r\n    updateOffset(new Point(offsetX, offsetY));\r\n    firstBox = false;\r\n  }\r\n\r\n  var path = new Path.Circle(gridPoint(x, y), r);\r\n  path.closed = true;\r\n  if (borderWidth > 0) {\r\n    path.strokeColor = border;\r\n    path.strokeWidth = borderWidth;\r\n  }\r\n  path.fillColor = fill;\r\n  allPaths.push(path);\r\n};\r\n```\r\n\r\nThen to act as a buffer between Quest and Paper:\r\n```\r\nfunction Grid_DrawCircle(x, y, z, r, border, borderWidth, fill) {\r\n  if (!_canvasSupported) return;\r\n  gridApi.drawCircle(parseFloat(x), parseFloat(y), parseInt(z), parseFloat(r), border, parseInt(borderWidth), fill);\r\n}\r\n```\r\n\r\nThen on the Quest side, a function that will work out the coordinates of a circular room (as we've got the coords of the top left corner and a width and height; we need a centre and a radius.\r\n\r\nFor now I'll post a basic function so there's a first attempt here. If this works, then there are a few modifications that could be added later; like drawing ellipses if the width and length of the room aren't the same, and moving the endpoints of diagonal exits in by (1-1/√2) units so that they actually meet the circle.\r\n```\r\n<function name=\"Grid_DrawCircleRoom\" parameters=\"x, y, z, width, length, border, borderWidth, fill\">\r\n  // half the average of the width and length; best estimate for now\r\n  radius = (width + length)/4.0\r\n  x = x + width/2.0\r\n  y = y + length/2.0\r\n  JS.Grid_DrawCircle (x, y, z, radius, border, borderWidth, fill)\r\n</function>\r\n```\r\n\r\nThen to call this instead of just drawing a box, we'll need to add some lines to one of the core functions:\r\n<pre><code>  &lt;function name=\"Grid_DrawRoom\" parameters=\"room, redraw, playerobject\">\r\n    &lt;![CDATA[\r\n    if (room.grid_render) {\r\n      if (redraw or not Grid_GetRoomBooleanForPlayer(playerobject, room, \"grid_isdrawn\")) {\r\n\r\n        if (not room.parent = null) {\r\n          Grid_DrawRoom (room.parent, redraw, playerobject)\r\n        }\r\n\r\n<b style=\"display:block; border: 1px solid green;\">        if (not HasString (room, \"grid_shape\")) {\r\n          room.grid_shape = \"box\"\r\n        }\r\n        switch (room.gird_shape) {\r\n          case (\"box\") {</b>            JS.Grid_DrawBox(Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_width, room.grid_length, room.grid_border, room.grid_borderwidth, room.grid_fill, room.grid_bordersides)<b style=\"display:block; border: 1px solid green;\">          }\r\n          case (\"circle\") {\r\n            Grid_DrawCircleRoom (Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_width, room.grid_length, room.grid_border, room.grid_borderwidth, room.grid_fill)\r\n          }\r\n          case (\"label\") {\r\n            // allow rooms where only the label is drawn\r\n          }\r\n          default {\r\n            error (\"Unknown grid shape \"+room.grid_shape+\" for room \"+room.name)\r\n          }\r\n        }</b>\r\n        if (LengthOf(room.grid_label) > 0) {\r\n          label_x = Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\") + room.grid_width/2.0\r\n          label_y = (Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\") + room.grid_length/2.0) - 0.5\r\n          JS.Grid_DrawLabel(label_x, label_y, Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_label, room.grid_label_colour)\r\n        }\r\n\r\n        foreach (exit, AllExits()) {\r\n          if (exit.grid_render and exit.parent = room and exit.grid_length > 0) {\r\n            Grid_DrawLine (Grid_GetGridCoordinateForPlayer(game.pov, exit, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_x\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_y\"), game.mapexitcolour, game.mapexitwidth)\r\n          }\r\n        }\r\n\r\n        Grid_SetRoomBooleanForPlayer(playerobject, room, \"grid_isdrawn\", true)\r\n      }\r\n    }\r\n    ]]>\r\n  &lt;/function></code></pre>",
      "EditableFormat": "markdown",
      "HTML": "<p>OK, you'd need a bit of extra javascript.<br>\nI'm writing this after skimming over grid.js; I'm not sure if these functions can be added later, or if <code>grid.js</code> is loaded within a specific frame.</p>\n<p>First, an actual circle-drawing function. Heavily based on drawBox</p>\n<pre><code>gridApi.drawCircle = function(x, y, z, r, border, borderWidth, fill) {\n  activateLayer(z);\n  // if this is the first room drawn, centre it.\n  if (firstBox) {\n    var offsetX = paper.view.center.x - x;\n    var offsetY = paper.view.center.y - y;\n    updateOffset(new Point(offsetX, offsetY));\n    firstBox = false;\n  }\n\n  var path = new Path.Circle(gridPoint(x, y), r);\n  path.closed = true;\n  if (borderWidth &gt; 0) {\n    path.strokeColor = border;\n    path.strokeWidth = borderWidth;\n  }\n  path.fillColor = fill;\n  allPaths.push(path);\n};\n</code></pre>\n<p>Then to act as a buffer between Quest and Paper:</p>\n<pre><code>function Grid_DrawCircle(x, y, z, r, border, borderWidth, fill) {\n  if (!_canvasSupported) return;\n  gridApi.drawCircle(parseFloat(x), parseFloat(y), parseInt(z), parseFloat(r), border, parseInt(borderWidth), fill);\n}\n</code></pre>\n<p>Then on the Quest side, a function that will work out the coordinates of a circular room (as we've got the coords of the top left corner and a width and height; we need a centre and a radius.</p>\n<p>For now I'll post a basic function so there's a first attempt here. If this works, then there are a few modifications that could be added later; like drawing ellipses if the width and length of the room aren't the same, and moving the endpoints of diagonal exits in by (1-1/√2) units so that they actually meet the circle.</p>\n<pre><code>&lt;function name=\"Grid_DrawCircleRoom\" parameters=\"x, y, z, width, length, border, borderWidth, fill\"&gt;\n  // half the average of the width and length; best estimate for now\n  radius = (width + length)/4.0\n  x = x + width/2.0\n  y = y + length/2.0\n  JS.Grid_DrawCircle (x, y, z, radius, border, borderWidth, fill)\n&lt;/function&gt;\n</code></pre>\n<p>Then to call this instead of just drawing a box, we'll need to add some lines to one of the core functions:</p>\n<pre><code>  &lt;function name=\"Grid_DrawRoom\" parameters=\"room, redraw, playerobject\"&gt;\n    &lt;![CDATA[\n    if (room.grid_render) {\n      if (redraw or not Grid_GetRoomBooleanForPlayer(playerobject, room, \"grid_isdrawn\")) {\n\n        if (not room.parent = null) {\n          Grid_DrawRoom (room.parent, redraw, playerobject)\n        }\n\n<b style=\"display: block; border: 1px solid green\">        if (not HasString (room, \"grid_shape\")) {\n          room.grid_shape = \"box\"\n        }\n        switch (room.gird_shape) {\n          case (\"box\") {</b>            JS.Grid_DrawBox(Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_width, room.grid_length, room.grid_border, room.grid_borderwidth, room.grid_fill, room.grid_bordersides)<b style=\"display: block; border: 1px solid green\">          }\n          case (\"circle\") {\n            Grid_DrawCircleRoom (Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_width, room.grid_length, room.grid_border, room.grid_borderwidth, room.grid_fill)\n          }\n          case (\"label\") {\n            // allow rooms where only the label is drawn\n          }\n          default {\n            error (\"Unknown grid shape \"+room.grid_shape+\" for room \"+room.name)\n          }\n        }</b>\n        if (LengthOf(room.grid_label) &gt; 0) {\n          label_x = Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\") + room.grid_width/2.0\n          label_y = (Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\") + room.grid_length/2.0) - 0.5\n          JS.Grid_DrawLabel(label_x, label_y, Grid_GetGridCoordinateForPlayer(game.pov, room, \"z\"), room.grid_label, room.grid_label_colour)\n        }\n\n        foreach (exit, AllExits()) {\n          if (exit.grid_render and exit.parent = room and exit.grid_length &gt; 0) {\n            Grid_DrawLine (Grid_GetGridCoordinateForPlayer(game.pov, exit, \"x\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"y\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_x\"), Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_y\"), game.mapexitcolour, game.mapexitwidth)\n          }\n        }\n\n        Grid_SetRoomBooleanForPlayer(playerobject, room, \"grid_isdrawn\", true)\n      }\n    }\n    ]]&gt;\n  &lt;/function&gt;</code></pre>\n\n",
      "PostDate": "2020-01-17T10:30:21.5565571Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3f019f78-b892-4aeb-b0d1-c9a76b53123f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK… here's a quick attempt at a function to fix exit coords:\r\n\r\n```\r\n<function name=\"Grid_FixCircleExits\" parameters=\"room\">\r\n  x1 = Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\")\r\n  x2 = x1 + room.grid_width/2.0\r\n  y1 = Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\")\r\n  y2 = y1 + room.grid_height/2.0\r\n  r = (room.grid_width + room.grid_height)/4.0\r\n  x_offset = room.grid_width/2.0 - r/Sqrt(2)\r\n  y_offset = room.grid_length/2.0 - r/Sqrt(2)\r\n  ortho_offset = room.grid_width/2.0 - r\r\n\r\n  foreach (exit, AllExits()) {\r\n    if (exit.grid_render) {\r\n      if (exit.parent = room) {\r\n        exit_x = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"x\")\r\n        exit_y = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"y\")\r\n        if (DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"southeastdirection\")) {\r\n          if (exit_x = x2) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x - x_offset)\r\n          }\r\n        }\r\n        else if (DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"southwestdirection\")) {\r\n          if (exit_x = x1) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x + x_offset)\r\n          }\r\n        }\r\n        else if (ortho_offset <> 0) {\r\n          if (DoesInherit (exit, \"westdirection\")) {\r\n            if (exit_x = x1) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x + ortho_offset)\r\n            }\r\n          }\r\n          else if (DoesInherit (exit, \"eastdirection\")) {\r\n            if (exit_x = x2) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x - ortho_offset)\r\n            }\r\n          }\r\n        }\r\n        if (DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"southeastdirection\")) {\r\n          if (exit_y = y2) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y - y_offset)\r\n          }\r\n        }\r\n        else if (DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"northeastdirection\")) {\r\n          if (exit_y = y1) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y + y_offset)\r\n          }\r\n        }\r\n        else if (ortho_offset <> 0) {\r\n          if (DoesInherit (exit, \"southdirection\")) {\r\n            if (exit_y = y2) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y + ortho_offset)\r\n            }\r\n          }\r\n          else if (DoesInherit (exit, \"northdirection\")) {\r\n            if (exit_y = y1) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y - ortho_offset)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else if (exit.to = room) {\r\n        exit_x = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_x\")\r\n        exit_y = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_y\")\r\n        changed = false\r\n        if (DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"northwestdirection\")) {\r\n          if (exit_x = x2) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x - x_offset)\r\n            changed = true\r\n          }\r\n        }\r\n        else if (DoesInherit (exit, \"southeastdirection\") or DoesInherit (exit, \"northeastdirection\")) {\r\n          if (exit_x = x1) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x + x_offset)\r\n            changed = true\r\n          }\r\n        }\r\n        else if (ortho_offset <> 0) {\r\n          if (DoesInherit (exit, \"eastdirection\")) {\r\n            if (exit_x = x1) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x + ortho_offset)\r\n              changed = true\r\n            }\r\n          }\r\n          else if (DoesInherit (exit, \"westdirection\")) {\r\n            if (exit_x = x2) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x - ortho_offset)\r\n              changed = true\r\n            }\r\n          }\r\n        }\r\n\r\n        if (DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"northwestdirection\")) {\r\n          if (exit_y = y2) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y - y_offset)\r\n            changed = true\r\n          }\r\n        }\r\n        else if (DoesInherit (exit, \"southeastdirection\") or DoesInherit (exit, \"southwestdirection\")) {\r\n          if (exit_y = y1) {\r\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y + y_offset)\r\n            changed = true\r\n          }\r\n        }\r\n        else if (ortho_offset <> 0) {\r\n          if (DoesInherit (exit, \"northdirection\")) {\r\n            if (exit_y = y2) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y + ortho_offset)\r\n              changed = true\r\n            }\r\n          }\r\n          else if (DoesInherit (exit, \"southdirection\")) {\r\n            if (exit_y = y1) {\r\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y - ortho_offset)\r\n              changed = true\r\n            }\r\n          }\r\n        }\r\n\r\n        // If we change the *end* of an exit, there's a chance it's already been drawn\r\n        //   in this case, we setup a flag to redraw the map at the end of the turn, so we're not redrawing repeatedly\r\n        //   on games which pre-draw the map, or when loading a saved game\r\n        if (changed and Grid_GetRoomBooleanForPlayer(playerobject, exit.parent, \"grid_isdrawn\") {\r\n          Grid_RedrawAtEndOfTurn()\r\n        }\r\n      }\r\n    }\r\n  }\r\n</function>\r\n\r\n<function name=\"Grid_RedrawAtEndOfTurn\">\r\n  if (GetObject (\"gridredraw_turnscript\") = null) {\r\n    create turnscript (\"gridredraw_turnscript\")\r\n    gridredraw_turnscript.script => {\r\n      JS.Grid_ClearAllLayers()\r\n      Grid_Redraw()\r\n      destroy (this.name)\r\n    }\r\n  }\r\n  gridredraw_turnscript.enabled = true\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>OK… here's a quick attempt at a function to fix exit coords:</p>\n<pre><code>&lt;function name=\"Grid_FixCircleExits\" parameters=\"room\"&gt;\n  x1 = Grid_GetGridCoordinateForPlayer(game.pov, room, \"x\")\n  x2 = x1 + room.grid_width/2.0\n  y1 = Grid_GetGridCoordinateForPlayer(game.pov, room, \"y\")\n  y2 = y1 + room.grid_height/2.0\n  r = (room.grid_width + room.grid_height)/4.0\n  x_offset = room.grid_width/2.0 - r/Sqrt(2)\n  y_offset = room.grid_length/2.0 - r/Sqrt(2)\n  ortho_offset = room.grid_width/2.0 - r\n\n  foreach (exit, AllExits()) {\n    if (exit.grid_render) {\n      if (exit.parent = room) {\n        exit_x = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"x\")\n        exit_y = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"y\")\n        if (DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"southeastdirection\")) {\n          if (exit_x = x2) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x - x_offset)\n          }\n        }\n        else if (DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"southwestdirection\")) {\n          if (exit_x = x1) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x + x_offset)\n          }\n        }\n        else if (ortho_offset &lt;&gt; 0) {\n          if (DoesInherit (exit, \"westdirection\")) {\n            if (exit_x = x1) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x + ortho_offset)\n            }\n          }\n          else if (DoesInherit (exit, \"eastdirection\")) {\n            if (exit_x = x2) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"x\", exit_x - ortho_offset)\n            }\n          }\n        }\n        if (DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"southeastdirection\")) {\n          if (exit_y = y2) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y - y_offset)\n          }\n        }\n        else if (DoesInherit (exit, \"northwestdirection\") or DoesInherit (exit, \"northeastdirection\")) {\n          if (exit_y = y1) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y + y_offset)\n          }\n        }\n        else if (ortho_offset &lt;&gt; 0) {\n          if (DoesInherit (exit, \"southdirection\")) {\n            if (exit_y = y2) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y + ortho_offset)\n            }\n          }\n          else if (DoesInherit (exit, \"northdirection\")) {\n            if (exit_y = y1) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"y\", exit_y - ortho_offset)\n            }\n          }\n        }\n      }\n      else if (exit.to = room) {\n        exit_x = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_x\")\n        exit_y = Grid_GetGridCoordinateForPlayer(game.pov, exit, \"end_y\")\n        changed = false\n        if (DoesInherit (exit, \"southwestdirection\") or DoesInherit (exit, \"northwestdirection\")) {\n          if (exit_x = x2) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x - x_offset)\n            changed = true\n          }\n        }\n        else if (DoesInherit (exit, \"southeastdirection\") or DoesInherit (exit, \"northeastdirection\")) {\n          if (exit_x = x1) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x + x_offset)\n            changed = true\n          }\n        }\n        else if (ortho_offset &lt;&gt; 0) {\n          if (DoesInherit (exit, \"eastdirection\")) {\n            if (exit_x = x1) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x + ortho_offset)\n              changed = true\n            }\n          }\n          else if (DoesInherit (exit, \"westdirection\")) {\n            if (exit_x = x2) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_x\", exit_x - ortho_offset)\n              changed = true\n            }\n          }\n        }\n\n        if (DoesInherit (exit, \"northeastdirection\") or DoesInherit (exit, \"northwestdirection\")) {\n          if (exit_y = y2) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y - y_offset)\n            changed = true\n          }\n        }\n        else if (DoesInherit (exit, \"southeastdirection\") or DoesInherit (exit, \"southwestdirection\")) {\n          if (exit_y = y1) {\n            Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y + y_offset)\n            changed = true\n          }\n        }\n        else if (ortho_offset &lt;&gt; 0) {\n          if (DoesInherit (exit, \"northdirection\")) {\n            if (exit_y = y2) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y + ortho_offset)\n              changed = true\n            }\n          }\n          else if (DoesInherit (exit, \"southdirection\")) {\n            if (exit_y = y1) {\n              Grid_SetGridCoordinateForPlayer(game.pov, exit, \"end_y\", exit_y - ortho_offset)\n              changed = true\n            }\n          }\n        }\n\n        // If we change the *end* of an exit, there's a chance it's already been drawn\n        //   in this case, we setup a flag to redraw the map at the end of the turn, so we're not redrawing repeatedly\n        //   on games which pre-draw the map, or when loading a saved game\n        if (changed and Grid_GetRoomBooleanForPlayer(playerobject, exit.parent, \"grid_isdrawn\") {\n          Grid_RedrawAtEndOfTurn()\n        }\n      }\n    }\n  }\n&lt;/function&gt;\n\n&lt;function name=\"Grid_RedrawAtEndOfTurn\"&gt;\n  if (GetObject (\"gridredraw_turnscript\") = null) {\n    create turnscript (\"gridredraw_turnscript\")\n    gridredraw_turnscript.script =&gt; {\n      JS.Grid_ClearAllLayers()\n      Grid_Redraw()\n      destroy (this.name)\n    }\n  }\n  gridredraw_turnscript.enabled = true\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2020-01-17T11:19:49.4478133Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
