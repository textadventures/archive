{
  "Topic": {
    "TopicId": "4186",
    "ForumId": "10",
    "Title": "examine B....Which B do you mean?",
    "LastUpdated": "2014-02-13T12:41:07+00:00",
    "ReplyCount": 14
  },
  "Posts": [
    {
      "PostId": "27810",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "Quest (v5.3) has a nice player-friendly feature where if you examine xyz, all objects begining with those letters are displayed in a menu for the player to select.\n\nBut, is there any way of disabling this feature?\n\nIt tends to provide players with a kind of cheat for some puzzles which depend upon working out what is there to be examined by using lateral thinking, or finding a clue in the adventure.\n\nI've got around it a couple of ways in the past, but they're not very satisfactory:\n\nE.g. if the secret scenery object is a &quot;mirror&quot;...\n\n1. not making &quot;mirror&quot; a scenery object at all, but making &quot;examine mirror&quot; and &quot;x mirror&quot; commands in themselves [not great because player cannot shorten words...unless a very large number of commands are entered covering every possible combination of shortened forms]\n\n2. making additional scenery objects called &quot;m&quot;, &quot;mi&quot;, &quot;mir&quot;, &quot;mirr&quot;, mirro&quot; which provide the description &quot;You can't see that here&quot;. [That worked pretty well, but obviously is easier to do for short words!]\n\nCheers!",
      "EditableFormat": "bbcode",
      "HTML": "Quest (v5.3) has a nice player-friendly feature where if you examine xyz, all objects begining with those letters are displayed in a menu for the player to select.<br/><br/>But, is there any way of disabling this feature?<br/><br/>It tends to provide players with a kind of cheat for some puzzles which depend upon working out what is there to be examined by using lateral thinking, or finding a clue in the adventure.<br/><br/>I've got around it a couple of ways in the past, but they're not very satisfactory:<br/><br/>E.g. if the secret scenery object is a &quot;mirror&quot;...<br/><br/>1. not making &quot;mirror&quot; a scenery object at all, but making &quot;examine mirror&quot; and &quot;x mirror&quot; commands in themselves [not great because player cannot shorten words...unless a very large number of commands are entered covering every possible combination of shortened forms]<br/><br/>2. making additional scenery objects called &quot;m&quot;, &quot;mi&quot;, &quot;mir&quot;, &quot;mirr&quot;, mirro&quot; which provide the description &quot;You can't see that here&quot;. [That worked pretty well, but obviously is easier to do for short words!]<br/><br/>Cheers!",
      "PostDate": "2014-02-11T01:51:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27814",
      "UserId": 0,
      "Username": "Pertex",
      "UserAvatar": "5940_1369854251.gif",
      "UserGravatar": "4cc1e52f99452e841ecf4cbee9eadde9",
      "EditableText": "I do not understand that. If you have to use an object from which you can not find a hint in the game, then it's bad game design. And when the player takes the trouble to try all combinations of examine, it's admirable that he struggles with such a bad game. I would stop playing such a game immediately.\n\nBut if you really want to do something like that you could create an object with lots of aliases like a,b,c,d,e... and move it to the room the player is in.",
      "EditableFormat": "bbcode",
      "HTML": "I do not understand that. If you have to use an object from which you can not find a hint in the game, then it's bad game design. And when the player takes the trouble to try all combinations of examine, it's admirable that he struggles with such a bad game. I would stop playing such a game immediately.<br/><br/>But if you really want to do something like that you could create an object with lots of aliases like a,b,c,d,e... and move it to the room the player is in.",
      "PostDate": "2014-02-11T07:43:53+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27815",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "[quote=&quot;Pertex&quot;:x70mo5kw]I do not understand that. If you have to use an object from which you can not find a hint in the game, then it's bad game design. And when the player takes the trouble to try all combinations of examine, it's admirable that he struggles with such a bad game. I would stop playing such a game immediately.\n\nBut if you really want to do something like that you could create an object with lots of aliases like a,b,c,d,e... and move it to the room the player is in.[/quote:x70mo5kw]\n\nHi pertex,\n\nThat's a good idea. Thank you.\n\nBut I agree with your first sentence that you might not have understood exactly the situation I was talking about. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nI simply want players to avoid accidentally stumbling upon certain objects which they should have to use some wit and imagination (or indeed hints in the game) to think of - in the context of a puzzly type of game. \n\nI don't know what you were alluding to when you talked about &quot;trying all combinations&quot;. I was talking about the ability to produce a list of all examinable objects by using a single letter. I don't think that allowing players to find everything in a room by typing:\n\nx a\nx b\nx c\netc\n\n...is necessarily good game design - though it depends upon the style of game. In my case, it's sometimes good if the player actually knows what he's trying to examine, rather than just saying &quot;Now I shall see what this room contains that begins with B...&quot;\n\nI said myself that option #1 is NOT very satisfactory because it requires players to hit on precise combinations.\n\nThanks.\n\nEDIT: Option #1 is not satisfactory because it requires players to hit on precise combinations",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Pertex wrote:</cite>I do not understand that. If you have to use an object from which you can not find a hint in the game, then it's bad game design. And when the player takes the trouble to try all combinations of examine, it's admirable that he struggles with such a bad game. I would stop playing such a game immediately.<br/><br/>But if you really want to do something like that you could create an object with lots of aliases like a,b,c,d,e... and move it to the room the player is in.</blockquote><br/><br/>Hi pertex,<br/><br/>That's a good idea. Thank you.<br/><br/>But I agree with your first sentence that you might not have understood exactly the situation I was talking about. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>I simply want players to avoid accidentally stumbling upon certain objects which they should have to use some wit and imagination (or indeed hints in the game) to think of - in the context of a puzzly type of game. <br/><br/>I don't know what you were alluding to when you talked about &quot;trying all combinations&quot;. I was talking about the ability to produce a list of all examinable objects by using a single letter. I don't think that allowing players to find everything in a room by typing:<br/><br/>x a<br/>x b<br/>x c<br/>etc<br/><br/>...is necessarily good game design - though it depends upon the style of game. In my case, it's sometimes good if the player actually knows what he's trying to examine, rather than just saying &quot;Now I shall see what this room contains that begins with B...&quot;<br/><br/>I said myself that option #1 is NOT very satisfactory because it requires players to hit on precise combinations.<br/><br/>Thanks.<br/><br/>EDIT: Option #1 is not satisfactory because it requires players to hit on precise combinations",
      "PostDate": "2014-02-11T12:46:36+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27816",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "[quote=&quot;Pertex&quot;:cxamml8v]I do not understand that. If you have to use an object from which you can not find a hint in the game...[/quote:cxamml8v]\nI think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.\n\nHaving said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.\n\nThere is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:\n\n[code:cxamml8v]if (StartsWith(name, value)) {\n  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {\n    if (not ListContains(partialmatches, obj)) {\n      list add (partialmatches, obj)\n    }\n  }\n}[/code:cxamml8v]\n\n(The second &quot;if&quot; statement is the addition to the default code)\n\nIn this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Pertex wrote:</cite>I do not understand that. If you have to use an object from which you can not find a hint in the game...</blockquote><br/>I think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.<br/><br/>Having said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.<br/><br/>There is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:<br/><br/><pre><code>if (StartsWith(name, value)) {<br/>  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {<br/>    if (not ListContains(partialmatches, obj)) {<br/>      list add (partialmatches, obj)<br/>    }<br/>  }<br/>}</code></pre><br/><br/>(The second &quot;if&quot; statement is the addition to the default code)<br/><br/>In this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.",
      "PostDate": "2014-02-11T12:54:15+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27817",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "To expound...\n\nYou see there's a nice kind of puzzle where an object exists and can be examined, but the player might not think of doing so until he has received some hints or given it a lot of thought. They might miss out on the challenge of the puzzle if they accidentally find the object by simply trying to examine something else and end up with a menu containing that mysterious object\n\nI'll try a final example:\n\n&quot;You're in a room with silk curtains [and more description but a secret object not explicitly mentioned]&quot;\n\nExamine s\n\nWhich S do you want to examine:\n1) silk curtains\n2) secret object [[which you were supposed to only think of examining after you found a hint or solved some kind of clue, etc]]\n\nHope that explains that a desire to not have ALL objects pop up so easily is not necessarily bad game design. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "To expound...<br/><br/>You see there's a nice kind of puzzle where an object exists and can be examined, but the player might not think of doing so until he has received some hints or given it a lot of thought. They might miss out on the challenge of the puzzle if they accidentally find the object by simply trying to examine something else and end up with a menu containing that mysterious object<br/><br/>I'll try a final example:<br/><br/>&quot;You're in a room with silk curtains [and more description but a secret object not explicitly mentioned]&quot;<br/><br/>Examine s<br/><br/>Which S do you want to examine:<br/>1) silk curtains<br/>2) secret object [[which you were supposed to only think of examining after you found a hint or solved some kind of clue, etc]]<br/><br/>Hope that explains that a desire to not have ALL objects pop up so easily is not necessarily bad game design. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2014-02-11T13:00:36+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27818",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "[quote=&quot;Liam315&quot;:1n0khq4k][quote=&quot;Pertex&quot;:1n0khq4k]I do not understand that. If you have to use an object from which you can not find a hint in the game...[/quote:1n0khq4k]\nI think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.\n\nHaving said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.\n\nThere is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:\n\n[code:1n0khq4k]if (StartsWith(name, value)) {\n  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {\n    if (not ListContains(partialmatches, obj)) {\n      list add (partialmatches, obj)\n    }\n  }\n}[/code:1n0khq4k]\n\n(The second &quot;if&quot; statement is the addition to the default code)\n\nIn this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.[/quote:1n0khq4k]\n\nLiam,\n\nJust cross-posted with you. I think my second post explains the issue more clearly. Making the object invisible until a certain point is an option and something I do use, but for some purposes it's not appropriate. I might not want an object to be impossible to find, and then suddenly easy to find. I might want it to be available to find, but not explicitly stated, and have a number of clues guide the player to it.\n\nWith regards to your point about players not using the single letter examine as a &quot;cheat&quot;, you may be right that most don't do it, but it is done. The main problem I suppose is that it can happen by accident if there is something else in the room beginning with the same letter. The player only intends to examine the 'S'ilk, but suddenly discovers a 'S'ecret object, for example.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Liam315 wrote:</cite><blockquote><p><b>&quot;Pertex&quot;</b></p><p>I do not understand that. If you have to use an object from which you can not find a hint in the game...</blockquote><br/>I think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.<br/><br/>Having said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.<br/><br/>There is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:<br/><br/><pre><code>if (StartsWith(name, value)) {<br/>  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {<br/>    if (not ListContains(partialmatches, obj)) {<br/>      list add (partialmatches, obj)<br/>    }<br/>  }<br/>}</code></pre><br/><br/>(The second &quot;if&quot; statement is the addition to the default code)<br/><br/>In this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.</p></blockquote><br/><br/>Liam,<br/><br/>Just cross-posted with you. I think my second post explains the issue more clearly. Making the object invisible until a certain point is an option and something I do use, but for some purposes it's not appropriate. I might not want an object to be impossible to find, and then suddenly easy to find. I might want it to be available to find, but not explicitly stated, and have a number of clues guide the player to it.<br/><br/>With regards to your point about players not using the single letter examine as a &quot;cheat&quot;, you may be right that most don't do it, but it is done. The main problem I suppose is that it can happen by accident if there is something else in the room beginning with the same letter. The player only intends to examine the 'S'ilk, but suddenly discovers a 'S'ecret object, for example.",
      "PostDate": "2014-02-11T13:07:17+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27819",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "[quote=&quot;Liam315&quot;:b4qkshmo][quote=&quot;Pertex&quot;:b4qkshmo]I do not understand that. If you have to use an object from which you can not find a hint in the game...[/quote:b4qkshmo]\nI think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.\n\nHaving said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.\n\nThere is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:\n\n[code:b4qkshmo]if (StartsWith(name, value)) {\n  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {\n    if (not ListContains(partialmatches, obj)) {\n      list add (partialmatches, obj)\n    }\n  }\n}[/code:b4qkshmo]\n\n(The second &quot;if&quot; statement is the addition to the default code)\n\nIn this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.[/quote:b4qkshmo]\n\nYour solution using the Compare names function looks interesting. That you very much for that.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Liam315 wrote:</cite><blockquote><p><b>&quot;Pertex&quot;</b></p><p>I do not understand that. If you have to use an object from which you can not find a hint in the game...</blockquote><br/>I think it's more for if you examine one object more closely, it brings to the player's attention a second object etc. The room description mentions a painting, the painting description describes the hook it is hanging on, and the description of the hook contains some indication of what you can/need to do to solve the puzzle.<br/><br/>Having said that, I can't see players just walking into a room and trying to examine random letters on the off chance that they'll come across a &quot;secret&quot; item. You'd be better off making the object invisible to start with, and then triggering it to become visible when the player has done something correctly, e.g. look at a certain object.<br/><br/>There is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:<br/><br/><pre><code>if (StartsWith(name, value)) {<br/>  if (LengthOf(value) / LengthOf(name) &gt;= 0&#46;34) {<br/>    if (not ListContains(partialmatches, obj)) {<br/>      list add (partialmatches, obj)<br/>    }<br/>  }<br/>}</code></pre><br/><br/>(The second &quot;if&quot; statement is the addition to the default code)<br/><br/>In this case, the length of any input has to be greater than just over a third of the number of characters in the full name. So if the object was &quot;mirror&quot; it would match &quot;mirro&quot;, &quot;mirr&quot;, and &quot;mir&quot;, but not &quot;mi&quot; or &quot;m&quot;.</p></blockquote><br/><br/>Your solution using the Compare names function looks interesting. That you very much for that.",
      "PostDate": "2014-02-11T13:10:57+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27820",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "[quote=&quot;privateer&quot;:xdf5r67q]Your solution using the Compare names function looks interesting. That you very much for that.[/quote:xdf5r67q]\n\nThe code I wrote is just one of many possibilities utilizing that function. Above obviously affects all objects in the game, but you could create conditions for specific objects as well. For instance, putting the relevant &quot;secret&quot; objects into an object list and having two sets of matching criteria - The default settings for most objects, and a more specialized set of criteria for the objects on the list, or if there aren't that many, a set of criteria for each individual &quot;secret&quot; object.\n\nI posted something a while ago in the code samples section of the forum that's a modification of this function, whereby whole word matches are given preference over matches that contain that word as part of a longer word (e.g. if the input is &quot;farm&quot; and there are two objects &quot;farm&quot; and &quot;farmer&quot;, it will return the farm object because the whole word is matched). You could modify those criteria for the &quot;secret&quot; object list so that those never accept partial matches but only matches for a whole word within the name/alias or alt names.\n\nI don't know what level your understanding of the finer points of Quest coding is, but if you need a hand I'd be happy to help you out with crafting specifics to achieve what you need.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>privateer wrote:</cite>Your solution using the Compare names function looks interesting. That you very much for that.</blockquote><br/><br/>The code I wrote is just one of many possibilities utilizing that function. Above obviously affects all objects in the game, but you could create conditions for specific objects as well. For instance, putting the relevant &quot;secret&quot; objects into an object list and having two sets of matching criteria - The default settings for most objects, and a more specialized set of criteria for the objects on the list, or if there aren't that many, a set of criteria for each individual &quot;secret&quot; object.<br/><br/>I posted something a while ago in the code samples section of the forum that's a modification of this function, whereby whole word matches are given preference over matches that contain that word as part of a longer word (e.g. if the input is &quot;farm&quot; and there are two objects &quot;farm&quot; and &quot;farmer&quot;, it will return the farm object because the whole word is matched). You could modify those criteria for the &quot;secret&quot; object list so that those never accept partial matches but only matches for a whole word within the name/alias or alt names.<br/><br/>I don't know what level your understanding of the finer points of Quest coding is, but if you need a hand I'd be happy to help you out with crafting specifics to achieve what you need.",
      "PostDate": "2014-02-11T13:51:13+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27821",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "[quote=&quot;Liam315&quot;:33vnqylp][quote=&quot;privateer&quot;:33vnqylp]Your solution using the Compare names function looks interesting. That you very much for that.[/quote:33vnqylp]\n\nThe code I wrote is just one of many possibilities utilizing that function. Above obviously affects all objects in the game, but you could create conditions for specific objects as well. For instance, putting the relevant &quot;secret&quot; objects into an object list and having two sets of matching criteria - The default settings for most objects, and a more specialized set of criteria for the objects on the list, or if there aren't that many, a set of criteria for each individual &quot;secret&quot; object.\n\nI posted something a while ago in the code samples section of the forum that's a modification of this function, whereby whole word matches are given preference over matches that contain that word as part of a longer word (e.g. if the input is &quot;farm&quot; and there are two objects &quot;farm&quot; and &quot;farmer&quot;, it will return the farm object because the whole word is matched). You could modify those criteria for the &quot;secret&quot; object list so that those never accept partial matches but only matches for a whole word within the name/alias or alt names.\n\nI don't know what level your understanding of the finer points of Quest coding is, but if you need a hand I'd be happy to help you out with crafting specifics to achieve what you need.[/quote:33vnqylp]\n\nPerfect, thank you very much! I'm a GUI jockey at the moment, so I may well take you up on that offer in the future. For now I've just patched up the game with my imperfect option #2 since at least it prevents one of my most devilish puzzles being instantly exposed. (I was amazed to discover a player had found a certain secret object before accessing the part of the game with the hint. I put it down to exceptional lateral thinking, but now I think it was just a case of examining something else in the room that began with the same letter!)\n\nYour solution is much more elegant. Cheers!",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Liam315 wrote:</cite><blockquote><p><b>&quot;privateer&quot;</b></p><p>Your solution using the Compare names function looks interesting. That you very much for that.</blockquote><br/><br/>The code I wrote is just one of many possibilities utilizing that function. Above obviously affects all objects in the game, but you could create conditions for specific objects as well. For instance, putting the relevant &quot;secret&quot; objects into an object list and having two sets of matching criteria - The default settings for most objects, and a more specialized set of criteria for the objects on the list, or if there aren't that many, a set of criteria for each individual &quot;secret&quot; object.<br/><br/>I posted something a while ago in the code samples section of the forum that's a modification of this function, whereby whole word matches are given preference over matches that contain that word as part of a longer word (e.g. if the input is &quot;farm&quot; and there are two objects &quot;farm&quot; and &quot;farmer&quot;, it will return the farm object because the whole word is matched). You could modify those criteria for the &quot;secret&quot; object list so that those never accept partial matches but only matches for a whole word within the name/alias or alt names.<br/><br/>I don't know what level your understanding of the finer points of Quest coding is, but if you need a hand I'd be happy to help you out with crafting specifics to achieve what you need.</p></blockquote><br/><br/>Perfect, thank you very much! I'm a GUI jockey at the moment, so I may well take you up on that offer in the future. For now I've just patched up the game with my imperfect option #2 since at least it prevents one of my most devilish puzzles being instantly exposed. (I was amazed to discover a player had found a certain secret object before accessing the part of the game with the hint. I put it down to exceptional lateral thinking, but now I think it was just a case of examining something else in the room that began with the same letter!)<br/><br/>Your solution is much more elegant. Cheers!",
      "PostDate": "2014-02-11T14:18:03+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27825",
      "UserId": 0,
      "Username": "sgreig",
      "UserAvatar": null,
      "UserGravatar": "9117185af66d72729b195384e3a446f0",
      "EditableText": "I don't know how you would do it, but I would assume there's a way to edit the core functionality of Quest to just remove the popup list altogether as well. Pertex or Jaynabonne or Alex would know better about that than I would though.",
      "EditableFormat": "bbcode",
      "HTML": "I don't know how you would do it, but I would assume there's a way to edit the core functionality of Quest to just remove the popup list altogether as well. Pertex or Jaynabonne or Alex would know better about that than I would though.",
      "PostDate": "2014-02-11T18:20:52+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27831",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "You can completely get rid of the disambiguation menu by editing the function ResolveNameInternal. You'd go to the last top-level if/else block and replace the &quot;else&quot; script (the one that calls all the GenerateMenuChoices functions) with a simple message saying something like &quot;Multiple objects found, please be more specific.&quot; I'd probably advise against that though since I can see it being more frustrating for the player in a wider range of cases than it is helpful for the small set of situations you want to patch up.",
      "EditableFormat": "bbcode",
      "HTML": "You can completely get rid of the disambiguation menu by editing the function ResolveNameInternal. You'd go to the last top-level if/else block and replace the &quot;else&quot; script (the one that calls all the GenerateMenuChoices functions) with a simple message saying something like &quot;Multiple objects found, please be more specific.&quot; I'd probably advise against that though since I can see it being more frustrating for the player in a wider range of cases than it is helpful for the small set of situations you want to patch up.",
      "PostDate": "2014-02-12T03:30:52+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27838",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "Hi Liam et al,\n\nRE your idea below:\n\nLiam wrote,\n&quot;There is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:\n\nCode: Select allif (StartsWith(name, value)) {\n  if (LengthOf(value) / LengthOf(name) &gt;= 0.34) {\n    if (not ListContains(partialmatches, obj)) {\n      list add (partialmatches, obj)\n    }\n  }\n}&quot;\n\nI think something like that is the way forward for me. I tried Pertex's nice idea, but was surprised to find that it just adds the single-letter object to the list of objects in the disambiguation menu! The idea was good in theory in that Quest ought to recognise the letter as a complete object name and therefore not ask for disambiguation, but it seems Quest makes an exception for objects with single letter names.\n\nSo, I think my mission will be to implement your idea of having the game insist on longer input. Perhaps rather than insisting on a certain proportion of the total word, I could insist (as in the old days of Quill, etc) on a minimum of 4 letters for objects whose name is more than 4 letters long. Do you think that might be possible? For someone who rarely delves into the code view?\n\nMany thanks!",
      "EditableFormat": "bbcode",
      "HTML": "Hi Liam et al,<br/><br/>RE your idea below:<br/><br/>Liam wrote,<br/>&quot;There is a built in function within Quest called Compare names which you could also modify if you want to change the way object names are matched. You could do something where if the input is not of a certain length, it won't match it to an object. Something like:<br/><br/>Code: Select allif (StartsWith(name, value)) {<br/>  if (LengthOf(value) / LengthOf(name) &gt;= 0.34) {<br/>    if (not ListContains(partialmatches, obj)) {<br/>      list add (partialmatches, obj)<br/>    }<br/>  }<br/>}&quot;<br/><br/>I think something like that is the way forward for me. I tried Pertex's nice idea, but was surprised to find that it just adds the single-letter object to the list of objects in the disambiguation menu! The idea was good in theory in that Quest ought to recognise the letter as a complete object name and therefore not ask for disambiguation, but it seems Quest makes an exception for objects with single letter names.<br/><br/>So, I think my mission will be to implement your idea of having the game insist on longer input. Perhaps rather than insisting on a certain proportion of the total word, I could insist (as in the old days of Quill, etc) on a minimum of 4 letters for objects whose name is more than 4 letters long. Do you think that might be possible? For someone who rarely delves into the code view?<br/><br/>Many thanks!",
      "PostDate": "2014-02-13T00:23:58+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27840",
      "UserId": 0,
      "Username": "Liam315",
      "UserAvatar": null,
      "UserGravatar": "ded290a24d340d761d42c897d08111aa",
      "EditableText": "Yep, anything you want is possible! You don't even need to use the code view, but using the page <!-- m --><a class=\"postlink\" href=\"http://quest5.net/wiki/Category:All_Functions_and_Script_Commands\">http://quest5.net/wiki/Category:All_Fun ... t_Commands</a><!-- m --> in the wiki is extremely useful for finding functions to use in your expressions. The default options in the GUI dropdown menus can be somewhat limiting, but this list contains all the commands you will need to do just about anything using expressions.\n\nTo start with, I'll just explain how Quest goes about matching the input to an object:\n\nThere are 2 main default functions which I've mentioned already, ResolveNameInternal, and CompareNames. When Quest parses the player's input and decides on which word(s) is the object, it runs that part of the input through ResolveNameInternal. That function creates a list of every object in the current room, gets their aliases and alt names, and checks them one at a time against the input using CompareNames.\n\n[b:23u90sbb]Compare Names[/b:23u90sbb]\n[code:23u90sbb]\nif (name = value) {\n  if (not ListContains(fullmatches, obj)) {\n    list add (fullmatches, obj)\n  }\n}\nelse {\n  if (StartsWith(name, value)) {\n    if (not ListContains(partialmatches, obj)) {\n      list add (partialmatches, obj)\n    }\n  }\n  else {\n    // check if input matches the start of any word in the name\n    if (Instr(name, &quot; &quot; + value) &gt; 0) {\n      if (not ListContains(partialmatches, obj)) {\n        list add (partialmatches, obj)\n      }\n    }\n  }\n}\n[/code:23u90sbb]\n\nSo if you look at the default code, the first part sees if the player's input (described as the variable &quot;value&quot;) is an exact match for the name of the object (the variable described as &quot;name&quot;). Remember this function is run over for each individual name, alias, and alternate name that an object has, so the &quot;name&quot; variable can stand for any one of these. If it finds a match, the object is added to the fullmatches list which takes priority over any partial matches in the ResolveNameInternal function.\n\nIf it can't find an exact match, it moves on to the next part where you can see it checks if the object name (name) starts with the player's input (value), or if not, whether there are multiple words in the name that might start with the input. (Check the wiki for info on the StartsWith and Instr functions if you are not familiar with them.) The parts that say if (not ListContains(partialmatches, obj)) are there to make sure if one of the object's names is matched, it isn't added again if a second one of its names is also matched.\n\nThis second part is what you'll want to change and play around with to suit your needs if you're going to create a universal set of rules.\n\n[code:23u90sbb]\nif (name = value) {\n  if (not ListContains(fullmatches, obj)) {\n    list add (fullmatches, obj)\n  }\n}\nelse {\n  if (StartsWith(name, value)) {\n    if (LengthOf(name) &gt;= 4) {\n      if ((LengthOf(value) &gt;= 4)  and (not ListContains(partialmatches, obj))) {\n        list add (partialmatches, obj)\n      }\n    }\n    else {\n      if (not ListContains(partialmatches, obj)) {\n        list add (partialmatches, obj)\n      }\n    }\n  }\n  else {\n    // check if input matches the start of any word in the name\n    if (Instr(name, &quot; &quot; + value) &gt; 0) {\n      if (LengthOf(name) &gt;= 4) {\n        if ((LengthOf(value) &gt;= 4)  and (not ListContains(partialmatches, obj))) {\n          list add (partialmatches, obj)\n        }\n      }\n      else {\n        if (not ListContains(partialmatches, obj)) {\n          list add (partialmatches, obj)\n        }\n      }\n    }\n  }\n}\n[/code:23u90sbb]\n\nThis is just an example of one way to do it, there are countless ways you could order the logic (including some that would probably be neater and more concise) but this example requires that all names with 4 letters or more be matched to inputs that are also 4 letters or more. Names with 3 letters or less are still matched to a value of any length, although you could require an exact match by using LengthOf(name) = LengthOf(value) in the statements governing those.",
      "EditableFormat": "bbcode",
      "HTML": "Yep, anything you want is possible! You don't even need to use the code view, but using the page <!-- m --><a class=\"postlink\" href=\"http://quest5.net/wiki/Category:All_Functions_and_Script_Commands\">http://quest5.net/wiki/Category:All_Fun ... t_Commands</a><!-- m --> in the wiki is extremely useful for finding functions to use in your expressions. The default options in the GUI dropdown menus can be somewhat limiting, but this list contains all the commands you will need to do just about anything using expressions.<br/><br/>To start with, I'll just explain how Quest goes about matching the input to an object:<br/><br/>There are 2 main default functions which I've mentioned already, ResolveNameInternal, and CompareNames. When Quest parses the player's input and decides on which word(s) is the object, it runs that part of the input through ResolveNameInternal. That function creates a list of every object in the current room, gets their aliases and alt names, and checks them one at a time against the input using CompareNames.<br/><br/><span style=\"font-weight:bold;\">Compare Names</span><br/><pre><code><br/>if (name = value) {<br/>  if (not ListContains(fullmatches, obj)) {<br/>    list add (fullmatches, obj)<br/>  }<br/>}<br/>else {<br/>  if (StartsWith(name, value)) {<br/>    if (not ListContains(partialmatches, obj)) {<br/>      list add (partialmatches, obj)<br/>    }<br/>  }<br/>  else {<br/>    // check if input matches the start of any word in the name<br/>    if (Instr(name, &quot; &quot; + value) &gt; 0) {<br/>      if (not ListContains(partialmatches, obj)) {<br/>        list add (partialmatches, obj)<br/>      }<br/>    }<br/>  }<br/>}<br/></code></pre><br/><br/>So if you look at the default code, the first part sees if the player's input (described as the variable &quot;value&quot;) is an exact match for the name of the object (the variable described as &quot;name&quot;). Remember this function is run over for each individual name, alias, and alternate name that an object has, so the &quot;name&quot; variable can stand for any one of these. If it finds a match, the object is added to the fullmatches list which takes priority over any partial matches in the ResolveNameInternal function.<br/><br/>If it can't find an exact match, it moves on to the next part where you can see it checks if the object name (name) starts with the player's input (value), or if not, whether there are multiple words in the name that might start with the input. (Check the wiki for info on the StartsWith and Instr functions if you are not familiar with them.) The parts that say if (not ListContains(partialmatches, obj)) are there to make sure if one of the object's names is matched, it isn't added again if a second one of its names is also matched.<br/><br/>This second part is what you'll want to change and play around with to suit your needs if you're going to create a universal set of rules.<br/><br/><pre><code><br/>if (name = value) {<br/>  if (not ListContains(fullmatches, obj)) {<br/>    list add (fullmatches, obj)<br/>  }<br/>}<br/>else {<br/>  if (StartsWith(name, value)) {<br/>    if (LengthOf(name) &gt;= 4) {<br/>      if ((LengthOf(value) &gt;= 4)  and (not ListContains(partialmatches, obj))) {<br/>        list add (partialmatches, obj)<br/>      }<br/>    }<br/>    else {<br/>      if (not ListContains(partialmatches, obj)) {<br/>        list add (partialmatches, obj)<br/>      }<br/>    }<br/>  }<br/>  else {<br/>    // check if input matches the start of any word in the name<br/>    if (Instr(name, &quot; &quot; + value) &gt; 0) {<br/>      if (LengthOf(name) &gt;= 4) {<br/>        if ((LengthOf(value) &gt;= 4)  and (not ListContains(partialmatches, obj))) {<br/>          list add (partialmatches, obj)<br/>        }<br/>      }<br/>      else {<br/>        if (not ListContains(partialmatches, obj)) {<br/>          list add (partialmatches, obj)<br/>        }<br/>      }<br/>    }<br/>  }<br/>}<br/></code></pre><br/><br/>This is just an example of one way to do it, there are countless ways you could order the logic (including some that would probably be neater and more concise) but this example requires that all names with 4 letters or more be matched to inputs that are also 4 letters or more. Names with 3 letters or less are still matched to a value of any length, although you could require an exact match by using LengthOf(name) = LengthOf(value) in the statements governing those.",
      "PostDate": "2014-02-13T02:33:06+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27841",
      "UserId": 0,
      "Username": "Pertex",
      "UserAvatar": "5940_1369854251.gif",
      "UserGravatar": "4cc1e52f99452e841ecf4cbee9eadde9",
      "EditableText": "[quote=&quot;privateer&quot;:3hmtyrsi]\nI think something like that is the way forward for me. I tried Pertex's nice idea, but was surprised to find that it just adds the single-letter object to the list of objects in the disambiguation menu! The idea was good in theory in that Quest ought to recognise the letter as a complete object name and therefore not ask for disambiguation, but it seems Quest makes an exception for objects with single letter names.\n[/quote:3hmtyrsi]\nHmm? Could you post your  object which behaves in that way?",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>privateer wrote:</cite><br/>I think something like that is the way forward for me. I tried Pertex's nice idea, but was surprised to find that it just adds the single-letter object to the list of objects in the disambiguation menu! The idea was good in theory in that Quest ought to recognise the letter as a complete object name and therefore not ask for disambiguation, but it seems Quest makes an exception for objects with single letter names.<br/></blockquote><br/>Hmm? Could you post your  object which behaves in that way?",
      "PostDate": "2014-02-13T07:24:42+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "27842",
      "UserId": 0,
      "Username": "privateer",
      "UserAvatar": null,
      "UserGravatar": "31fc3fff3ae1be07ecddb38ce98b83c4",
      "EditableText": "Hi Pertex,\n\nYour idea actually works perfectly fine now. I had tested it before getting rid of the location-bound single-letter objects. When confronted by TWO similar single-letter objects, Quest displays ALL objects begining with that letter in the menu. But having deleted those it works as expected.\n\nI think you would not object to the final effect. All that has changed now is that the player gets a prompt when attempting to identify an object with a single letter instead of a (sometimes quite long) list of objects, some of which were not intended to be put on [i:1uku7gkd]obvious[/i:1uku7gkd] view.\n\nAnother example of why this implementation has been useful for me, aside from mysery object puzzles, is those objects which SHOULD be impossible to examine - like noises.\n\nE.g.\n\nThe sky is full of stars. You hear someone singing. [singing has to be an object so you can interact with it: &quot;listen to singing&quot;]\n\nExamine S [expecting to examine stars perhaps]\n\nWhich S?\n1 Stars\n2 Singing\n\nSo the awkwardness of being given &quot;singing&quot; as an examinable option, and then being told &quot;You can't see that&quot; (or something similarly logical) should you try.\n\nSo, all in all, your idea is a satisfactory solution. Thank you.",
      "EditableFormat": "bbcode",
      "HTML": "Hi Pertex,<br/><br/>Your idea actually works perfectly fine now. I had tested it before getting rid of the location-bound single-letter objects. When confronted by TWO similar single-letter objects, Quest displays ALL objects begining with that letter in the menu. But having deleted those it works as expected.<br/><br/>I think you would not object to the final effect. All that has changed now is that the player gets a prompt when attempting to identify an object with a single letter instead of a (sometimes quite long) list of objects, some of which were not intended to be put on <span style=\"font-style:italic;\">obvious</span> view.<br/><br/>Another example of why this implementation has been useful for me, aside from mysery object puzzles, is those objects which SHOULD be impossible to examine - like noises.<br/><br/>E.g.<br/><br/>The sky is full of stars. You hear someone singing. [singing has to be an object so you can interact with it: &quot;listen to singing&quot;]<br/><br/>Examine S [expecting to examine stars perhaps]<br/><br/>Which S?<br/>1 Stars<br/>2 Singing<br/><br/>So the awkwardness of being given &quot;singing&quot; as an examinable option, and then being told &quot;You can't see that&quot; (or something similarly logical) should you try.<br/><br/>So, all in all, your idea is a satisfactory solution. Thank you.",
      "PostDate": "2014-02-13T12:41:07+00:00",
      "LastEditDate": null
    }
  ]
}
