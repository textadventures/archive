{
  "Topic": {
    "TopicId": "2025",
    "ForumId": "10",
    "Title": "Quest 4.1 Beta is now available",
    "LastUpdated": "2009-05-25T22:42:59+01:00",
    "ReplyCount": 22
  },
  "Posts": [
    {
      "PostId": "16507",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "This weekend's second Quest release is the test version of our next upgrade, Quest 4.1 Beta.\n\n- Quest Pro users can download it from <!-- m --><a class=\"postlink\" href=\"http://www.axeuk.com/mydownloads\">http://www.axeuk.com/mydownloads</a><!-- m -->\n- If you're not a Quest Pro user, you can download the trial version from <!-- m --><a class=\"postlink\" href=\"http://www.axeuk.com/quest/quest410beta.exe\">http://www.axeuk.com/quest/quest410beta.exe</a><!-- m -->\n\nPlease note this version is intended for testing only - we strong recommend you keep backup copies of any game you're working on. We also recommend you install to a separate folder so you can keep your existing Quest installation.\n\nAlso please note that the documentation has not yet been updated.\n\nBelow is an overview of what's new. For further details, you can check the VERSIONS.TXT and VERSIONS-QDK.TXT files the folder where you installed Quest.\n\n[b:6xqyvxn0]Quest Packager[/b:6xqyvxn0] (part of Quest Pro only)\n\nThis is a new product that lets you create a setup EXE file for your game, so your users can install it just like any Windows application. No longer do you need to tell people to download Quest separately - you can just send them an EXE file that will install your game for you. This opens up the possibility of submitting your game to software download sites, greatly increasing the number of people you can reach!\n\n[b:6xqyvxn0]Quest[/b:6xqyvxn0]\n\n- Lockable exits\n- Exits are implemented as objects, so you can check their status using the Object Debugger.\n- You can now do &quot;for each exit in game/&lt;room&gt;&quot; to iterate through all exit objects.\n- You can now specify a script when using &quot;create exit&quot;.\n- You can now destroy directional exits e.g. &quot;destroy exit &lt;room1; northeast&gt;&quot;\n- QSG files no longer save redundant property and action information, so saving and loading games is now much more efficient.\n- For ASL 410 and later, the &quot;visited&quot; property for a room is now set only after the description for the room is printed, so you can print a different description if the player has visited the room before.\n- New error &quot;defaultwait&quot; lets you specify default prompt for the &quot;wait&quot; command.\n- Can now use &quot;for each room in game&quot; to get a list of rooms in the game.\n\nThe following bugs have been fixed:\n\n- objects overriding actions specified by more than one type wouldn't override correctly.\n- objects and rooms created via the &quot;create&quot; command didn't pick up the &quot;default&quot; and &quot;defaultroom&quot; types. This has been fixed only for ASL 410 and later to preserve backwards compatibility.\n\n[b:6xqyvxn0]QDK[/b:6xqyvxn0]\n\nQDK has had major internal changes, and has a cleaner look.\n\n- New toolbars\n- Word-processor style text editor is now used for editing room descriptions, text blocks, and &quot;print a message&quot; scripts.\n- Procedures, functions, timers, object types, status variables, synonyms, menus and resources are now accessed via the tree instead of the menus.\n- &quot;Back&quot; and &quot;Forward&quot; buttons on the toolbar\n- New exit editor for rooms combines the old &quot;Compass&quot; and &quot;Go to&quot; tabs, and allows for editing lockable exits.\n\nBecause QDK now uses some .NET 2.0 SP1 components, QDK no longer runs on Windows 98 or earlier. Windows 2000 or later is required to run QDK.\n\n[b:6xqyvxn0]Other changes[/b:6xqyvxn0]\n\nAs reported earlier, QuestNet Server is no longer part of Quest 4.1.\n\n[b:6xqyvxn0]Testing[/b:6xqyvxn0]\n\nAs this is a beta release, please be aware that you will almost certainly encounter bugs. Please do report any you find - please email me at <!-- e --><a href=\"mailto:alex@axeuk.com\">alex@axeuk.com</a><!-- e -->. As we have done with previous betas, I will be awarding the people who submit the most helpful bug reports with free Amazon vouchers. So please get testing and let me know your feedback!",
      "EditableFormat": "bbcode",
      "HTML": "This weekend's second Quest release is the test version of our next upgrade, Quest 4.1 Beta.<br/><br/>- Quest Pro users can download it from <!-- m --><a class=\"postlink\" href=\"http://www.axeuk.com/mydownloads\">http://www.axeuk.com/mydownloads</a><!-- m --><br/>- If you're not a Quest Pro user, you can download the trial version from <!-- m --><a class=\"postlink\" href=\"http://www.axeuk.com/quest/quest410beta.exe\">http://www.axeuk.com/quest/quest410beta.exe</a><!-- m --><br/><br/>Please note this version is intended for testing only - we strong recommend you keep backup copies of any game you're working on. We also recommend you install to a separate folder so you can keep your existing Quest installation.<br/><br/>Also please note that the documentation has not yet been updated.<br/><br/>Below is an overview of what's new. For further details, you can check the VERSIONS.TXT and VERSIONS-QDK.TXT files the folder where you installed Quest.<br/><br/><span style=\"font-weight:bold;\">Quest Packager</span> (part of Quest Pro only)<br/><br/>This is a new product that lets you create a setup EXE file for your game, so your users can install it just like any Windows application. No longer do you need to tell people to download Quest separately - you can just send them an EXE file that will install your game for you. This opens up the possibility of submitting your game to software download sites, greatly increasing the number of people you can reach!<br/><br/><span style=\"font-weight:bold;\">Quest</span><br/><br/>- Lockable exits<br/>- Exits are implemented as objects, so you can check their status using the Object Debugger.<br/>- You can now do &quot;for each exit in game/&lt;room&gt;&quot; to iterate through all exit objects.<br/>- You can now specify a script when using &quot;create exit&quot;.<br/>- You can now destroy directional exits e.g. &quot;destroy exit &lt;room1; northeast&gt;&quot;<br/>- QSG files no longer save redundant property and action information, so saving and loading games is now much more efficient.<br/>- For ASL 410 and later, the &quot;visited&quot; property for a room is now set only after the description for the room is printed, so you can print a different description if the player has visited the room before.<br/>- New error &quot;defaultwait&quot; lets you specify default prompt for the &quot;wait&quot; command.<br/>- Can now use &quot;for each room in game&quot; to get a list of rooms in the game.<br/><br/>The following bugs have been fixed:<br/><br/>- objects overriding actions specified by more than one type wouldn't override correctly.<br/>- objects and rooms created via the &quot;create&quot; command didn't pick up the &quot;default&quot; and &quot;defaultroom&quot; types. This has been fixed only for ASL 410 and later to preserve backwards compatibility.<br/><br/><span style=\"font-weight:bold;\">QDK</span><br/><br/>QDK has had major internal changes, and has a cleaner look.<br/><br/>- New toolbars<br/>- Word-processor style text editor is now used for editing room descriptions, text blocks, and &quot;print a message&quot; scripts.<br/>- Procedures, functions, timers, object types, status variables, synonyms, menus and resources are now accessed via the tree instead of the menus.<br/>- &quot;Back&quot; and &quot;Forward&quot; buttons on the toolbar<br/>- New exit editor for rooms combines the old &quot;Compass&quot; and &quot;Go to&quot; tabs, and allows for editing lockable exits.<br/><br/>Because QDK now uses some .NET 2.0 SP1 components, QDK no longer runs on Windows 98 or earlier. Windows 2000 or later is required to run QDK.<br/><br/><span style=\"font-weight:bold;\">Other changes</span><br/><br/>As reported earlier, QuestNet Server is no longer part of Quest 4.1.<br/><br/><span style=\"font-weight:bold;\">Testing</span><br/><br/>As this is a beta release, please be aware that you will almost certainly encounter bugs. Please do report any you find - please email me at <!-- e --><a href=\"mailto:alex@axeuk.com\">alex@axeuk.com</a><!-- e -->. As we have done with previous betas, I will be awarding the people who submit the most helpful bug reports with free Amazon vouchers. So please get testing and let me know your feedback!",
      "PostDate": "2009-04-26T18:03:46+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16508",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Really don't like the idea of exits as objects....\n\nBUT, we'll see how it pans out.",
      "EditableFormat": "bbcode",
      "HTML": "Really don't like the idea of exits as objects....<br/><br/>BUT, we'll see how it pans out.",
      "PostDate": "2009-04-26T22:04:26+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16511",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "I love the idea of exits as objects.  Was implementing my own exit objects already.  (This was doable even before 4.1, despite [url=http&#58;//www&#46;axeuk&#46;com/phpBB3/viewtopic&#46;php?f=6&amp;t=2017#p16505:2mixyhba]assertions to the contrary[/url:2mixyhba].)  \n\nIt is nice to define 'exit' object types and then let your exits inherit the different functionality.  Much better than having to code each individual exit separately.  Objects are better because they can have properties that define their state - in the case of an exit: open, closed, locked, unlocked, openable, lockable, etc.  If an exit isn't an object then you've got to use global variables, which for me causes no end of anxiety.   <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->  Just wondering if there is a default exit type that all exit objects will inherit (ie. defaultexit).  Off to read VERSIONS.TXT.",
      "EditableFormat": "bbcode",
      "HTML": "I love the idea of exits as objects.  Was implementing my own exit objects already.  (This was doable even before 4.1, despite <a href=\"http&#58;//www&#46;axeuk&#46;com/phpBB3/viewtopic&#46;php?f=6&amp;t=2017#p16505\" rel=\"nofollow\">assertions to the contrary</a>.)  <br/><br/>It is nice to define 'exit' object types and then let your exits inherit the different functionality.  Much better than having to code each individual exit separately.  Objects are better because they can have properties that define their state - in the case of an exit: open, closed, locked, unlocked, openable, lockable, etc.  If an exit isn't an object then you've got to use global variables, which for me causes no end of anxiety.   <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->  Just wondering if there is a default exit type that all exit objects will inherit (ie. defaultexit).  Off to read VERSIONS.TXT.",
      "PostDate": "2009-04-26T23:59:14+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16515",
      "UserId": 0,
      "Username": "Thanatos",
      "UserAvatar": "2160_1332681621.jpg",
      "UserGravatar": "c6621a24cf53876c4083bfb52afd2cc9",
      "EditableText": "As usual, bravo Alex.",
      "EditableFormat": "bbcode",
      "HTML": "As usual, bravo Alex.",
      "PostDate": "2009-04-27T03:38:39+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16520",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "I've now slightly updated the build to fix a number of bugs Overcat reported in QDK.",
      "EditableFormat": "bbcode",
      "HTML": "I've now slightly updated the build to fix a number of bugs Overcat reported in QDK.",
      "PostDate": "2009-04-28T20:06:16+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16521",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "An exit is not an object - it's a property of a room (ie, a room has an exit to the east).\nThe exit may have a DOOR - which is an object.\nThis object would hold the properties locks/closed/open/etc.\n\nPlus, this means that the exit properties will either have to have a special Quest type, or special actions/properties defined for it... Making exits different to all other objects (we're getting back into the territory of &quot;People are different to Objects&quot; again - which we moved away from for this very reason).\n\nI really don't see what the gain is with objects rather then properties/actions on the room itself (ie, a blank/null/empty exit property means no exit. Same with actions).\n\nIs this just because it's used as TADS and someone went &quot;oh, they're used over there&quot; ?",
      "EditableFormat": "bbcode",
      "HTML": "An exit is not an object - it's a property of a room (ie, a room has an exit to the east).<br/>The exit may have a DOOR - which is an object.<br/>This object would hold the properties locks/closed/open/etc.<br/><br/>Plus, this means that the exit properties will either have to have a special Quest type, or special actions/properties defined for it... Making exits different to all other objects (we're getting back into the territory of &quot;People are different to Objects&quot; again - which we moved away from for this very reason).<br/><br/>I really don't see what the gain is with objects rather then properties/actions on the room itself (ie, a blank/null/empty exit property means no exit. Same with actions).<br/><br/>Is this just because it's used as TADS and someone went &quot;oh, they're used over there&quot; ?",
      "PostDate": "2009-04-28T20:09:15+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16526",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "You can iterate over objects, for one.  Can't iterate over properties and actions (though that may change in the future).  For instance, you can now do this:\n\n[code:1pi2cee9]for each exit in room &lt;#quest&#46;currentroom#&gt; {\n    'do something\n}[/code:1pi2cee9]\n\nTo me it makes more sense to treat exits as objects.  I was assuming that exits would be implemented like this:\n\n[code:1pi2cee9]define exit &lt;North&gt;\n\nend define[/code:1pi2cee9]\nBut they're not implemented so.  They are still tags, like north &lt;gotoRoom&gt;, or north {}.  You can, however, add actions, properties, and I'm assuming types during run-time with:\n\n[code:1pi2cee9]property &lt;room&#46;north; SomeProperty&gt;\naction &lt;room&#46;north; SomeAction&gt;\ntype &lt;room&#46;north; SomeType&gt;[/code:1pi2cee9]\n\nThis is cool - but how do I add properties, actions, and types during design-time?  I don't think I can.",
      "EditableFormat": "bbcode",
      "HTML": "You can iterate over objects, for one.  Can't iterate over properties and actions (though that may change in the future).  For instance, you can now do this:<br/><br/><pre><code>for each exit in room &lt;#quest&#46;currentroom#&gt; {<br/>    'do something<br/>}</code></pre><br/><br/>To me it makes more sense to treat exits as objects.  I was assuming that exits would be implemented like this:<br/><br/><pre><code>define exit &lt;North&gt;<br/><br/>end define</code></pre><br/>But they're not implemented so.  They are still tags, like north &lt;gotoRoom&gt;, or north {}.  You can, however, add actions, properties, and I'm assuming types during run-time with:<br/><br/><pre><code>property &lt;room&#46;north; SomeProperty&gt;<br/>action &lt;room&#46;north; SomeAction&gt;<br/>type &lt;room&#46;north; SomeType&gt;</code></pre><br/><br/>This is cool - but how do I add properties, actions, and types during design-time?  I don't think I can.",
      "PostDate": "2009-04-28T20:48:08+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16527",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?\n- Sorry, that's the first thought that jumped in there.\n\nFor iterating through objects, you can always do some funky thing with #quest.doorways# and #quest.places# - but yes, iterating through exits is quite helpful.\n\n.. I don't quite understand the need for changing them to objects in order to achieve this feat though..\n[quote:158uylpq]I was assuming that exits would be implemented like this:[/quote:158uylpq]\nThat is introducing a new &quot;exit&quot; terminology.\nIE, a room is a sort of object (basically a container), a normal object is an object (can also contain other objects), an exit is a sort of... object that ... the player interacts in a specific way with.. to move from one room to another....\n\nSo I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).\n.. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?\n\nIf you would make them type &quot;unlock door&quot; - then isn't it much better to have the door as an object itself, which the exit relies on?",
      "EditableFormat": "bbcode",
      "HTML": "Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?<br/>- Sorry, that's the first thought that jumped in there.<br/><br/>For iterating through objects, you can always do some funky thing with #quest.doorways# and #quest.places# - but yes, iterating through exits is quite helpful.<br/><br/>.. I don't quite understand the need for changing them to objects in order to achieve this feat though..<br/><blockquote><p>I was assuming that exits would be implemented like this:</p></blockquote><br/>That is introducing a new &quot;exit&quot; terminology.<br/>IE, a room is a sort of object (basically a container), a normal object is an object (can also contain other objects), an exit is a sort of... object that ... the player interacts in a specific way with.. to move from one room to another....<br/><br/>So I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).<br/>.. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?<br/><br/>If you would make them type &quot;unlock door&quot; - then isn't it much better to have the door as an object itself, which the exit relies on?",
      "PostDate": "2009-04-28T21:46:57+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16529",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "[quote:3oh14qjr]Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?[/quote:3oh14qjr]\n\nThe best solution (for me) would be a 'for each object of type &lt;type&gt; in &lt;room&gt;/game'.  We can achieve the same effect ourselves with:\n\n[code:3oh14qjr]\nfor each object in game {\n    if type &lt;#quest&#46;thing#; Actor&gt; then {\n        'logic\n    }\n}[/code:3oh14qjr]\n\nBut I have the feeling that it would be faster if Quest did this behind the scenes.  And I don't mind 'for each object in...' looping over exits:  they should be objects, as far as I'm concerned.  \n\n[quote:3oh14qjr]So I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).[/quote:3oh14qjr]\n\nI think that's a darn good reason.  <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> \n\n[quote:3oh14qjr].. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?[/quote:3oh14qjr]\n\nThis is easily avoided by not giving your exits names such as 'north' and 'south', which, as far as I can see, you still must do with 4.1.  (You could name them whatever you want with the 'define exit &lt;ExitName&gt;' syntax.)  You can override Quest's default handling of travel with custom commands so that a player can still type 'n', or 'e'.  A property on each exit object can determine where the object sent the player.  I use a naming convention on the exit object itself because it's faster to see if an object with a given name exists in a room than it is to loop through all the objects for a specific property or type.  (ie. Cabin_North is the name of the north exit object in the room called 'Cabin'.  If Cabin_North is 'here', the player can travel north; if not, then they can't.)\n\nI can understand, however, how one would perceive an exit as a property of a location, rather than as an object.  We have 360 degrees of infinitely precise freedom in reality, whereas in games we've digitized motion:  directions are in discrete chunks.  (And so are the locations.)  Whether or not each of those directions is linked to an object (like a door) is, in my opinion, irrelevant as to whether the direction should be treated as an object in and of itself.  Moving somewhere, anywhere, involves a description of some sort, even if it just be 'east' or 'west'.  I think an exit object might allow better [i:3oh14qjr]programmatic control[/i:3oh14qjr] over the description and effects of movement.\n\nAs an example, consider NPC automation:\n\n[code:3oh14qjr]west {\n    if here &lt;BigRock&gt; then {\n        msg &lt;There's a big rock in the way!&gt;\n    }\n    else {\n        goto &lt;NextRoom&gt;\n    }\n}[/code:3oh14qjr]\n\nHow the heck is an NPC supposed to interact with that?  The exit script is referencing the object, so the NPC has no way of knowing the big rock is linked with going west.  Further, how do I tell who attempted to use the exit?  (Which might be important.)\n\nIf the exit is an object with properties and actions, I can make the NPC interact with the object.  The NPC can scrutinize the exit to see if they should even attempt to go that way.  They can also discover something about the exit that they couldn't possibly know before attempting to use it, and then respond to that discovery.  Additionally, all the logic for the behaviour of an exit object can stay with the exit, no matter if the player or an NPC attempts to use it.\n\nAs a final argument, why forbid an exit the inherent benefit of being an object?  Is anything gained by limiting an exit as a single property or script of a location?  I don't see it.  (Not to say there's nothing to see - just that I can't see it yet.)  You can always treat an object like a property, but you can't treat a property like an object (not easily, and not efficiently, anyway).  All that said, I'm still open to any further arguments as to why exits [i:3oh14qjr]shouldn't[/i:3oh14qjr] be objects.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?</p></blockquote><br/><br/>The best solution (for me) would be a 'for each object of type &lt;type&gt; in &lt;room&gt;/game'.  We can achieve the same effect ourselves with:<br/><br/><pre><code><br/>for each object in game {<br/>    if type &lt;#quest&#46;thing#; Actor&gt; then {<br/>        'logic<br/>    }<br/>}</code></pre><br/><br/>But I have the feeling that it would be faster if Quest did this behind the scenes.  And I don't mind 'for each object in...' looping over exits:  they should be objects, as far as I'm concerned.  <br/><br/><blockquote><p>So I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).</p></blockquote><br/><br/>I think that's a darn good reason.  <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> <br/><br/><blockquote><p>.. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?</p></blockquote><br/><br/>This is easily avoided by not giving your exits names such as 'north' and 'south', which, as far as I can see, you still must do with 4.1.  (You could name them whatever you want with the 'define exit &lt;ExitName&gt;' syntax.)  You can override Quest's default handling of travel with custom commands so that a player can still type 'n', or 'e'.  A property on each exit object can determine where the object sent the player.  I use a naming convention on the exit object itself because it's faster to see if an object with a given name exists in a room than it is to loop through all the objects for a specific property or type.  (ie. Cabin_North is the name of the north exit object in the room called 'Cabin'.  If Cabin_North is 'here', the player can travel north; if not, then they can't.)<br/><br/>I can understand, however, how one would perceive an exit as a property of a location, rather than as an object.  We have 360 degrees of infinitely precise freedom in reality, whereas in games we've digitized motion:  directions are in discrete chunks.  (And so are the locations.)  Whether or not each of those directions is linked to an object (like a door) is, in my opinion, irrelevant as to whether the direction should be treated as an object in and of itself.  Moving somewhere, anywhere, involves a description of some sort, even if it just be 'east' or 'west'.  I think an exit object might allow better <span style=\"font-style:italic;\">programmatic control</span> over the description and effects of movement.<br/><br/>As an example, consider NPC automation:<br/><br/><pre><code>west {<br/>    if here &lt;BigRock&gt; then {<br/>        msg &lt;There's a big rock in the way!&gt;<br/>    }<br/>    else {<br/>        goto &lt;NextRoom&gt;<br/>    }<br/>}</code></pre><br/><br/>How the heck is an NPC supposed to interact with that?  The exit script is referencing the object, so the NPC has no way of knowing the big rock is linked with going west.  Further, how do I tell who attempted to use the exit?  (Which might be important.)<br/><br/>If the exit is an object with properties and actions, I can make the NPC interact with the object.  The NPC can scrutinize the exit to see if they should even attempt to go that way.  They can also discover something about the exit that they couldn't possibly know before attempting to use it, and then respond to that discovery.  Additionally, all the logic for the behaviour of an exit object can stay with the exit, no matter if the player or an NPC attempts to use it.<br/><br/>As a final argument, why forbid an exit the inherent benefit of being an object?  Is anything gained by limiting an exit as a single property or script of a location?  I don't see it.  (Not to say there's nothing to see - just that I can't see it yet.)  You can always treat an object like a property, but you can't treat a property like an object (not easily, and not efficiently, anyway).  All that said, I'm still open to any further arguments as to why exits <span style=\"font-style:italic;\">shouldn't</span> be objects.",
      "PostDate": "2009-04-29T20:49:32+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16532",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "[quote=&quot;Overcat&quot;:2xcpmi6k][quote:2xcpmi6k]Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?[/quote:2xcpmi6k]\n\nThe best solution (for me) would be a 'for each object of type &lt;type&gt; in &lt;room&gt;/game'.  We can achieve the same effect ourselves with:[/quote:2xcpmi6k]\nWhat I mean is - if you want to remove all the objects from a room, someone blindly going &quot;for each object in &lt;room&gt; -&gt; move it to &lt;room3&gt;&quot; or some such coding muck up (kick north -&gt; you kick north far-far away).\nThis means you have to code AROUND exits being objects - rather then what is actually a pretty straight forward object interaction mechanism.\n\n[quote:2xcpmi6k][quote:2xcpmi6k]So I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).[/quote:2xcpmi6k]\n\nI think that's a darn good reason.  <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> [/quote:2xcpmi6k]\nWhich as I explained, exits are not objects.\nA &quot;door&quot; is an object in the way of an object, so is a board, so is a teleporter (the fact you need to supply energy to &quot;open&quot; the exit doesn't mean it IS an exit).\n... The exit is only something in two states.. Either it IS an exit, or it isn't. An &quot;exit&quot; can't be locked, or interacted with in any real way.\nOn the other hand, a door, wooden boards, bricks and morter. These can all be interacted with - or interact with the [b:2xcpmi6k]room[/b:2xcpmi6k] - to change the exit from one state to the other.\n\n[quote:2xcpmi6k][quote:2xcpmi6k].. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?[/quote:2xcpmi6k]\n\nThis is easily avoided by not giving your exits names such as 'north' and 'south', which, as far as I can see, you still must do with 4.1.  (You could name them whatever you want with the 'define exit &lt;ExitName&gt;' syntax.)  You can override Quest's default handling of travel with custom commands so that a player can still type 'n', or 'e'.  A property on each exit object can determine where the object sent the player.  I use a naming convention on the exit object itself because it's faster to see if an object with a given name exists in a room than it is to loop through all the objects for a specific property or type.  (ie. Cabin_North is the name of the north exit object in the room called 'Cabin'.  If Cabin_North is 'here', the player can travel north; if not, then they can't.)[/quote:2xcpmi6k]\nBut it still works no matter what you call it. &quot;widderkin&quot; or &quot;turnwise&quot; or [i:2xcpmi6k]anything[/i:2xcpmi6k].\nWhat you've now introduced above is:\n*) Overriding player movement\n*) Special treatment of the &lt;exit&gt; object type in ALL commands\n*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.\n*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.\n\nYou've just added complexity with no benefit (ie functionality) for what reason?\n\nI can imagine that you'd want a walk and a run action on the exit, so you have two different ways of going through it (and possibly more).\nBUT, you can code all of that through a procedure/function which your exit can call in ASL-400 (the proc/func would refer to the room/objects passed to it similar to the #quest.self# or #quest.thing# variables that aren't too well documented).\n.. I can actually see [i:2xcpmi6k]some[/i:2xcpmi6k] benefit from that - multiple actions against a [b:2xcpmi6k]direction[/b:2xcpmi6k]... But that can be easily mirrored in normal ASL-400.\nFrom what I can see you get the gain of interacting with exits like objects... Which as I said before, isn't actually true at all, and can be quite negative.\n\n[quote:2xcpmi6k]I can understand, however, how one would perceive an exit as a property of a location, rather than as an object.  We have 360 degrees of infinitely precise freedom in reality, whereas in games we've digitized motion:  directions are in discrete chunks.  (And so are the locations.)  Whether or not each of those directions is linked to an object (like a door) is, in my opinion, irrelevant as to whether the direction should be treated as an object in and of itself.  Moving somewhere, anywhere, involves a description of some sort, even if it just be 'east' or 'west'.  I think an exit object might allow better [i:2xcpmi6k]programmatic control[/i:2xcpmi6k] over the description and effects of movement.[/quote:2xcpmi6k]\nSorry - you seem to say you don't care if it's one way or the other with that, or am I not reading it right?\nAnd movement needing a &quot;description&quot;? A room, and object have numerous properties.. The desk is black. The room is wide and long.\nTrue, an exit can be large or tiny - but that's about it.\n\n[quote:2xcpmi6k]As an example, consider NPC automation:\n\n[code:2xcpmi6k]west {\n    if here &lt;BigRock&gt; then {\n        msg &lt;There's a big rock in the way!&gt;\n    }\n    else {\n        goto &lt;NextRoom&gt;\n    }\n}[/code:2xcpmi6k]\n\nHow the heck is an NPC supposed to interact with that?  The exit script is referencing the object, so the NPC has no way of knowing the big rock is linked with going west.  Further, how do I tell who attempted to use the exit?  (Which might be important.)\n\nIf the exit is an object with properties and actions, I can make the NPC interact with the object.  The NPC can scrutinize the exit to see if they should even attempt to go that way.  They can also discover something about the exit that they couldn't possibly know before attempting to use it, and then respond to that discovery.  Additionally, all the logic for the behaviour of an exit object can stay with the exit, no matter if the player or an NPC attempts to use it.[/quote:2xcpmi6k]\nSo instead of having that, you have:\n[code:2xcpmi6k]def obj &lt;west&gt;\n   action &lt;move&gt; if here &lt;stone&gt; then _\n      msg &lt;no way&gt; _\n   else _\n      goto &lt;next room&gt;\nend def[/code:2xcpmi6k]\n.... aaaaaand in what way can the NPC scrutinize this?\n.... You'd give it a SPECIAL action right? - like &quot;NPC&quot; - and have it return either the room or &quot;FALSE&quot; so that it can move into that room or see the exit cannot be traversed yet? (it's the first idea which seems pretty simple and logical to me)\n\nI would argue the exit would not currently exist.\nThe exit would be &quot;created&quot; once the rock was moved/destroyed.\nAll that would be left out is the player typing &quot;w&quot; or &quot;go west&quot; - which would return &quot;I cannot go there&quot; instead of the nicer &quot;there appears to be a rock in the way&quot;. Which you can have as the normal &quot;default&quot; exit script (ie west msg &lt;There's a big rock in the way&gt;).\nThe NPC would get to the room, use the properties to check all the exits (or go through the &quot;for each exit in&quot;) to pick an available room.\n\n[quote:2xcpmi6k]As a final argument, why forbid an exit the inherent benefit of being an object?  Is anything gained by limiting an exit as a single property or script of a location?  I don't see it.  (Not to say there's nothing to see - just that I can't see it yet.)  You can always treat an object like a property, but you can't treat a property like an object (not easily, and not efficiently, anyway).  All that said, I'm still open to any further arguments as to why exits [i:2xcpmi6k]shouldn't[/i:2xcpmi6k] be objects.[/quote:2xcpmi6k]\nYou close asking for any benefits of correcting exit usage in ASL-400 (I'm NOT saying that ASL410 is a mistake here.. I'm saying that exits are not treated as &quot;proper&quot; properties/actions in ASL-400).\nYou gain the fact that: Rooms are rooms (basically big objects) and objects are objects. Rather then treating Rooms as rooms, objects as objects, and objects as exits - or vice versa.\nYou gain the fact you don't need to code around properties actually being objects.\n\nYou say you're limiting an exit from interaction as an object, and that's entirely true - since exits aren't objects.\nYou also say treating properties as objects is near impossible - again true, since properties aren't objects.\nA property is a value (whatever this value is).\n\n.. The value of an &quot;exit&quot; is where it leads (and if you want to be picky how big it is).\nYou can change a property (the desk could be red, or yellow, the exit could move or point to another place) but you can never &quot;interact&quot; with an exit.\n\nI tried thinking of a hole, and plugging it up with a bolder... Or any exit being blocked by a large rock or anything.\nThat comes down to the bolder blocking up the hole itself - not the exit &quot;down&quot;.\nOr it would block the doorway, or cave, or path.\nAll of those would mean the boulder would have an action on it to block up the direction.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Overcat wrote:</cite><blockquote><p>Hmmm... Do you really want to iterate over an exit when you're doing a &quot;for each object in...&quot; loop?</blockquote><br/><br/>The best solution (for me) would be a 'for each object of type &lt;type&gt; in &lt;room&gt;/game'.  We can achieve the same effect ourselves with:</p></blockquote><br/>What I mean is - if you want to remove all the objects from a room, someone blindly going &quot;for each object in &lt;room&gt; -&gt; move it to &lt;room3&gt;&quot; or some such coding muck up (kick north -&gt; you kick north far-far away).<br/>This means you have to code AROUND exits being objects - rather then what is actually a pretty straight forward object interaction mechanism.<br/><br/><blockquote><p>[quote]So I get the feeling that treating exits as objects is to allow them to have a generic action (&quot;destruct&quot;, or &quot;unlock&quot;).</p></blockquote><br/><br/>I think that's a darn good reason.  <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> [/quote]<br/>Which as I explained, exits are not objects.<br/>A &quot;door&quot; is an object in the way of an object, so is a board, so is a teleporter (the fact you need to supply energy to &quot;open&quot; the exit doesn't mean it IS an exit).<br/>... The exit is only something in two states.. Either it IS an exit, or it isn't. An &quot;exit&quot; can't be locked, or interacted with in any real way.<br/>On the other hand, a door, wooden boards, bricks and morter. These can all be interacted with - or interact with the <span style=\"font-weight:bold;\">room</span> - to change the exit from one state to the other.<br/><br/><blockquote><p>[quote].. But would you really want people to type &quot;punch north&quot;, &quot;unlock east&quot; etc?</p></blockquote><br/><br/>This is easily avoided by not giving your exits names such as 'north' and 'south', which, as far as I can see, you still must do with 4.1.  (You could name them whatever you want with the 'define exit &lt;ExitName&gt;' syntax.)  You can override Quest's default handling of travel with custom commands so that a player can still type 'n', or 'e'.  A property on each exit object can determine where the object sent the player.  I use a naming convention on the exit object itself because it's faster to see if an object with a given name exists in a room than it is to loop through all the objects for a specific property or type.  (ie. Cabin_North is the name of the north exit object in the room called 'Cabin'.  If Cabin_North is 'here', the player can travel north; if not, then they can't.)[/quote]<br/>But it still works no matter what you call it. &quot;widderkin&quot; or &quot;turnwise&quot; or <span style=\"font-style:italic;\">anything</span>.<br/>What you've now introduced above is:<br/>*) Overriding player movement<br/>*) Special treatment of the &lt;exit&gt; object type in ALL commands<br/>*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.<br/>*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.<br/><br/>You've just added complexity with no benefit (ie functionality) for what reason?<br/><br/>I can imagine that you'd want a walk and a run action on the exit, so you have two different ways of going through it (and possibly more).<br/>BUT, you can code all of that through a procedure/function which your exit can call in ASL-400 (the proc/func would refer to the room/objects passed to it similar to the #quest.self# or #quest.thing# variables that aren't too well documented).<br/>.. I can actually see <span style=\"font-style:italic;\">some</span> benefit from that - multiple actions against a <span style=\"font-weight:bold;\">direction</span>... But that can be easily mirrored in normal ASL-400.<br/>From what I can see you get the gain of interacting with exits like objects... Which as I said before, isn't actually true at all, and can be quite negative.<br/><br/><blockquote><p>I can understand, however, how one would perceive an exit as a property of a location, rather than as an object.  We have 360 degrees of infinitely precise freedom in reality, whereas in games we've digitized motion:  directions are in discrete chunks.  (And so are the locations.)  Whether or not each of those directions is linked to an object (like a door) is, in my opinion, irrelevant as to whether the direction should be treated as an object in and of itself.  Moving somewhere, anywhere, involves a description of some sort, even if it just be 'east' or 'west'.  I think an exit object might allow better <span style=\"font-style:italic;\">programmatic control</span> over the description and effects of movement.</p></blockquote><br/>Sorry - you seem to say you don't care if it's one way or the other with that, or am I not reading it right?<br/>And movement needing a &quot;description&quot;? A room, and object have numerous properties.. The desk is black. The room is wide and long.<br/>True, an exit can be large or tiny - but that's about it.<br/><br/><blockquote><p>As an example, consider NPC automation:<br/><br/><pre><code>west {<br/>    if here &lt;BigRock&gt; then {<br/>        msg &lt;There's a big rock in the way!&gt;<br/>    }<br/>    else {<br/>        goto &lt;NextRoom&gt;<br/>    }<br/>}</code></pre><br/><br/>How the heck is an NPC supposed to interact with that?  The exit script is referencing the object, so the NPC has no way of knowing the big rock is linked with going west.  Further, how do I tell who attempted to use the exit?  (Which might be important.)<br/><br/>If the exit is an object with properties and actions, I can make the NPC interact with the object.  The NPC can scrutinize the exit to see if they should even attempt to go that way.  They can also discover something about the exit that they couldn't possibly know before attempting to use it, and then respond to that discovery.  Additionally, all the logic for the behaviour of an exit object can stay with the exit, no matter if the player or an NPC attempts to use it.</p></blockquote><br/>So instead of having that, you have:<br/><pre><code>def obj &lt;west&gt;<br/>   action &lt;move&gt; if here &lt;stone&gt; then _<br/>      msg &lt;no way&gt; _<br/>   else _<br/>      goto &lt;next room&gt;<br/>end def</code></pre><br/>.... aaaaaand in what way can the NPC scrutinize this?<br/>.... You'd give it a SPECIAL action right? - like &quot;NPC&quot; - and have it return either the room or &quot;FALSE&quot; so that it can move into that room or see the exit cannot be traversed yet? (it's the first idea which seems pretty simple and logical to me)<br/><br/>I would argue the exit would not currently exist.<br/>The exit would be &quot;created&quot; once the rock was moved/destroyed.<br/>All that would be left out is the player typing &quot;w&quot; or &quot;go west&quot; - which would return &quot;I cannot go there&quot; instead of the nicer &quot;there appears to be a rock in the way&quot;. Which you can have as the normal &quot;default&quot; exit script (ie west msg &lt;There's a big rock in the way&gt;).<br/>The NPC would get to the room, use the properties to check all the exits (or go through the &quot;for each exit in&quot;) to pick an available room.<br/><br/><blockquote><p>As a final argument, why forbid an exit the inherent benefit of being an object?  Is anything gained by limiting an exit as a single property or script of a location?  I don't see it.  (Not to say there's nothing to see - just that I can't see it yet.)  You can always treat an object like a property, but you can't treat a property like an object (not easily, and not efficiently, anyway).  All that said, I'm still open to any further arguments as to why exits <span style=\"font-style:italic;\">shouldn't</span> be objects.</p></blockquote><br/>You close asking for any benefits of correcting exit usage in ASL-400 (I'm NOT saying that ASL410 is a mistake here.. I'm saying that exits are not treated as &quot;proper&quot; properties/actions in ASL-400).<br/>You gain the fact that: Rooms are rooms (basically big objects) and objects are objects. Rather then treating Rooms as rooms, objects as objects, and objects as exits - or vice versa.<br/>You gain the fact you don't need to code around properties actually being objects.<br/><br/>You say you're limiting an exit from interaction as an object, and that's entirely true - since exits aren't objects.<br/>You also say treating properties as objects is near impossible - again true, since properties aren't objects.<br/>A property is a value (whatever this value is).<br/><br/>.. The value of an &quot;exit&quot; is where it leads (and if you want to be picky how big it is).<br/>You can change a property (the desk could be red, or yellow, the exit could move or point to another place) but you can never &quot;interact&quot; with an exit.<br/><br/>I tried thinking of a hole, and plugging it up with a bolder... Or any exit being blocked by a large rock or anything.<br/>That comes down to the bolder blocking up the hole itself - not the exit &quot;down&quot;.<br/>Or it would block the doorway, or cave, or path.<br/>All of those would mean the boulder would have an action on it to block up the direction.",
      "PostDate": "2009-04-30T02:03:33+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16533",
      "UserId": 0,
      "Username": "Freak",
      "UserAvatar": null,
      "UserGravatar": "325ed9ac125e00c9937be0d3aea0916d",
      "EditableText": "Just because something is represented in the game as an object doesn't mean it's necessarily an object in the room.  It's a common technique to have an object used solely for structuring data.",
      "EditableFormat": "bbcode",
      "HTML": "Just because something is represented in the game as an object doesn't mean it's necessarily an object in the room.  It's a common technique to have an object used solely for structuring data.",
      "PostDate": "2009-04-30T03:16:37+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16536",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "[quote:1fn4vb6a]What I mean is - if you want to remove all the objects from a room, someone blindly going &quot;for each object in &lt;room&gt; -&gt; move it to &lt;room3&gt;&quot; or some such coding muck up (kick north -&gt; you kick north far-far away).\nThis means you have to code AROUND exits being objects - rather then what is actually a pretty straight forward object interaction mechanism.[/quote:1fn4vb6a]\n\nI think it's pretty straight forward to &quot;code AROUND&quot; them.  It's not like you're circumnavigating the globe any time you want to avoid a certain kind of object.\n\n[quote:1fn4vb6a]Which as I explained, exits are not objects.\nA &quot;door&quot; is an object in the way of an object, so is a board, so is a teleporter (the fact you need to supply energy to &quot;open&quot; the exit doesn't mean it IS an exit).\n... The exit is only something in two states.. Either it IS an exit, or it isn't. An &quot;exit&quot; can't be locked, or interacted with in any real way.\nOn the other hand, a door, wooden boards, bricks and morter. These can all be interacted with - or interact with the room - to change the exit from one state to the other.[/quote:1fn4vb6a]\n\nI [i:1fn4vb6a]understand[/i:1fn4vb6a] that in [i:1fn4vb6a]real life[/i:1fn4vb6a] exits are not objects!  But in a coded representation of the real world, any [i:1fn4vb6a]concept[/i:1fn4vb6a] can be programmatically structured - in this case, an exit can be an object.  There seems to be a disconnect between what I mean by 'object' and what you mean by 'object'.  When I say 'object' I am speaking in a programming sense.  I can [i:1fn4vb6a]abstract[/i:1fn4vb6a] exits into a class (in ASL's case, a type), and then create instances of that class.  I can use the properties and actions defined by the exit type to mutate the instances into all the different kinds of exits I can think of - including exits that are just that: exits with no other noun than the direction (east, west, etc.)\n\nAs a parallel, I have an 'event' type in a library file that I use to define event objects.  Events are no more objects in the real world than are exits, but I still create them as programming objects.  Rather than coding all the different kinds of events that are possible wherever I need them, I create a single type and manipulate properties/actions to achieve the effects I want.\n\n[quote:1fn4vb6a][quote:1fn4vb6a]This is easily avoided...then they can't.)[/quote:1fn4vb6a]\nWhat you've now introduced above is:\n*) Overriding player movement\n*) Special treatment of the &lt;exit&gt; object type in ALL commands\n*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.\n*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.[/quote:1fn4vb6a]\n\nFirst off, overriding player movement doesn't take a lot of work, and it allows me to do what I want:  use exits as programming objects.  (The fact that I [i:1fn4vb6a]can[/i:1fn4vb6a] override movement is a good thing.  If folks are happy with the default way things work, then by all means.)  Secondly, you don't need to treat an exit object in a special way for 'ALL commands'.  Thirdly, excluding a specific type of object from a for each loop is not that much extra script, especially if you're organized.  Fourthly, the naming convention mentioned above was used before 4.1.  I haven't decided whether to keep doing it that way or not.  We'll see.\n\n[quote:1fn4vb6a]You've just added complexity with no benefit (ie functionality) for what reason?\n\nI can imagine that you'd want a walk and a run action on the exit, so you have two different ways of going through it (and possibly more).\nBUT, you can code all of that through a procedure/function which your exit can call in ASL-400 (the proc/func would refer to the room/objects passed to it similar to the #quest.self# or #quest.thing# variables that aren't too well documented).[/quote:1fn4vb6a]\n\nI see a lot of benefit.  If I haven't clearly explained what those benefits are in previous posts, then that is my fault.\n\n[quote:1fn4vb6a][quote:1fn4vb6a]I can understand...effects of movement.[/quote:1fn4vb6a]\n\nSorry - you seem to say you don't care if it's one way or the other with that, or am I not reading it right?\nAnd movement needing a &quot;description&quot;? A room, and object have numerous properties.. The desk is black. The room is wide and long.\nTrue, an exit can be large or tiny - but that's about it.[/quote:1fn4vb6a]\n\nNo - I care.  I was attempting to convey that I can understand how one would declare 'exits are not objects'.  But, that's because we're using the word 'object' in two different ways.\n\nExits can have all sorts of description involved with them.  A thin tree trunk over a fast-flowing river; a rope spanning a crevice; an open window; a magical portal; the mouth of a giant worm.  It makes more sense (to me) to have an exit object with properties/actions that determine what is reported to the player when they travel (or attempt to travel) in a certain direction.\n\nIt boils down to how you view the construction of the world behind the scenes.  One view is that you can move in any direction you want [i:1fn4vb6a]unless[/i:1fn4vb6a] an object exists to block the way.  Another view is that you can [i:1fn4vb6a]only[/i:1fn4vb6a] move in a direction if an object exists that [i:1fn4vb6a]allows[/i:1fn4vb6a] you to move that way.  In either case an object is the determining factor.  Exits are the objects that allow (or disallow) travel in any direction (even if you're standing in open space).  Those objects may become nouns (as in doors and windows), or they may not (as in when your moving across a desert.)  If I don't specifically script an object that allows travel in a particular direction, then travel in that direction is not possible.  I would still need yet other objects to disallow travel, however, like a dense brush or retaining wall.  In both of those cases I could get creative later and let the player travel via those objects by turning them into exits with a tiny bit of inherited code.   (The player could get a machete to hack through the brush or a ladder to scale the wall.)\n\n[quote:1fn4vb6a][code:1fn4vb6a]\ndef obj &lt;west&gt;\n   action &lt;move&gt; if here &lt;stone&gt; then _\n      msg &lt;no way&gt; _\n   else _\n      goto &lt;next room&gt;\nend def[/code:1fn4vb6a]\n\n.... aaaaaand in what way can the NPC scrutinize this?[/quote:1fn4vb6a]\n\nObviously that doesn't change anything.  Throw some standardized properties on the object and the NPC can determine whether or not they should attempt to use the exit.\n\n[quote:1fn4vb6a].... You'd give it a SPECIAL action right? - like &quot;NPC&quot; - and have it return either the room or &quot;FALSE&quot; so that it can move into that room or see the exit cannot be traversed yet? (it's the first idea which seems pretty simple and logical to me)[/quote:1fn4vb6a]\n\nThat could work.  But I still don't understand your seeming aversion to 'SPECIAL' code.  Your example here is no more special than declaring actions or properties on [i:1fn4vb6a]anything at all[/i:1fn4vb6a], which is a [i:1fn4vb6a]fundamental[/i:1fn4vb6a] part of ASL.\n\n[quote:1fn4vb6a]All that would be left out is the player typing &quot;w&quot; or &quot;go west&quot; - which would return &quot;I cannot go there&quot; instead of the nicer &quot;there appears to be a rock in the way&quot;. Which you can have as the normal &quot;default&quot; exit script (ie west msg &lt;There's a big rock in the way&gt;).\nThe NPC would get to the room, use the properties to check all the exits (or go through the &quot;for each exit in&quot;) to pick an available room.[/quote:1fn4vb6a]\n\nWhat if I want the NPC to automatically discover the rock and attempt to find a way around it?  In that method there is nothing to indicate that it may be possible to do something to get around the rock.\n\n[quote:1fn4vb6a]You close asking for any benefits of correcting exit usage in ASL-400 [/quote:1fn4vb6a]\n\nNo - I indicated I was open to reasons as to why exits [i:1fn4vb6a]shouldn't[/i:1fn4vb6a] be objects.  So far the main argument against exits implemented as objects seems to be cognitive dissonance.  Making an exit an object isn't 'more complicated' - just as making an event an object isn't more complicated.  It's just a natural programming technique, as Freak mentions here:\n\n[quote:1fn4vb6a]Just because something is represented in the game as an object doesn't mean it's necessarily an object in the room. It's a common technique to have an object used solely for structuring data.[/quote:1fn4vb6a]",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>What I mean is - if you want to remove all the objects from a room, someone blindly going &quot;for each object in &lt;room&gt; -&gt; move it to &lt;room3&gt;&quot; or some such coding muck up (kick north -&gt; you kick north far-far away).<br/>This means you have to code AROUND exits being objects - rather then what is actually a pretty straight forward object interaction mechanism.</p></blockquote><br/><br/>I think it's pretty straight forward to &quot;code AROUND&quot; them.  It's not like you're circumnavigating the globe any time you want to avoid a certain kind of object.<br/><br/><blockquote><p>Which as I explained, exits are not objects.<br/>A &quot;door&quot; is an object in the way of an object, so is a board, so is a teleporter (the fact you need to supply energy to &quot;open&quot; the exit doesn't mean it IS an exit).<br/>... The exit is only something in two states.. Either it IS an exit, or it isn't. An &quot;exit&quot; can't be locked, or interacted with in any real way.<br/>On the other hand, a door, wooden boards, bricks and morter. These can all be interacted with - or interact with the room - to change the exit from one state to the other.</p></blockquote><br/><br/>I <span style=\"font-style:italic;\">understand</span> that in <span style=\"font-style:italic;\">real life</span> exits are not objects!  But in a coded representation of the real world, any <span style=\"font-style:italic;\">concept</span> can be programmatically structured - in this case, an exit can be an object.  There seems to be a disconnect between what I mean by 'object' and what you mean by 'object'.  When I say 'object' I am speaking in a programming sense.  I can <span style=\"font-style:italic;\">abstract</span> exits into a class (in ASL's case, a type), and then create instances of that class.  I can use the properties and actions defined by the exit type to mutate the instances into all the different kinds of exits I can think of - including exits that are just that: exits with no other noun than the direction (east, west, etc.)<br/><br/>As a parallel, I have an 'event' type in a library file that I use to define event objects.  Events are no more objects in the real world than are exits, but I still create them as programming objects.  Rather than coding all the different kinds of events that are possible wherever I need them, I create a single type and manipulate properties/actions to achieve the effects I want.<br/><br/><blockquote><p>[quote]This is easily avoided...then they can't.)</p></blockquote><br/>What you've now introduced above is:<br/>*) Overriding player movement<br/>*) Special treatment of the &lt;exit&gt; object type in ALL commands<br/>*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.<br/>*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.[/quote]<br/><br/>First off, overriding player movement doesn't take a lot of work, and it allows me to do what I want:  use exits as programming objects.  (The fact that I <span style=\"font-style:italic;\">can</span> override movement is a good thing.  If folks are happy with the default way things work, then by all means.)  Secondly, you don't need to treat an exit object in a special way for 'ALL commands'.  Thirdly, excluding a specific type of object from a for each loop is not that much extra script, especially if you're organized.  Fourthly, the naming convention mentioned above was used before 4.1.  I haven't decided whether to keep doing it that way or not.  We'll see.<br/><br/><blockquote><p>You've just added complexity with no benefit (ie functionality) for what reason?<br/><br/>I can imagine that you'd want a walk and a run action on the exit, so you have two different ways of going through it (and possibly more).<br/>BUT, you can code all of that through a procedure/function which your exit can call in ASL-400 (the proc/func would refer to the room/objects passed to it similar to the #quest.self# or #quest.thing# variables that aren't too well documented).</p></blockquote><br/><br/>I see a lot of benefit.  If I haven't clearly explained what those benefits are in previous posts, then that is my fault.<br/><br/><blockquote><p>[quote]I can understand...effects of movement.</p></blockquote><br/><br/>Sorry - you seem to say you don't care if it's one way or the other with that, or am I not reading it right?<br/>And movement needing a &quot;description&quot;? A room, and object have numerous properties.. The desk is black. The room is wide and long.<br/>True, an exit can be large or tiny - but that's about it.[/quote]<br/><br/>No - I care.  I was attempting to convey that I can understand how one would declare 'exits are not objects'.  But, that's because we're using the word 'object' in two different ways.<br/><br/>Exits can have all sorts of description involved with them.  A thin tree trunk over a fast-flowing river; a rope spanning a crevice; an open window; a magical portal; the mouth of a giant worm.  It makes more sense (to me) to have an exit object with properties/actions that determine what is reported to the player when they travel (or attempt to travel) in a certain direction.<br/><br/>It boils down to how you view the construction of the world behind the scenes.  One view is that you can move in any direction you want <span style=\"font-style:italic;\">unless</span> an object exists to block the way.  Another view is that you can <span style=\"font-style:italic;\">only</span> move in a direction if an object exists that <span style=\"font-style:italic;\">allows</span> you to move that way.  In either case an object is the determining factor.  Exits are the objects that allow (or disallow) travel in any direction (even if you're standing in open space).  Those objects may become nouns (as in doors and windows), or they may not (as in when your moving across a desert.)  If I don't specifically script an object that allows travel in a particular direction, then travel in that direction is not possible.  I would still need yet other objects to disallow travel, however, like a dense brush or retaining wall.  In both of those cases I could get creative later and let the player travel via those objects by turning them into exits with a tiny bit of inherited code.   (The player could get a machete to hack through the brush or a ladder to scale the wall.)<br/><br/><blockquote><p><pre><code><br/>def obj &lt;west&gt;<br/>   action &lt;move&gt; if here &lt;stone&gt; then _<br/>      msg &lt;no way&gt; _<br/>   else _<br/>      goto &lt;next room&gt;<br/>end def</code></pre><br/><br/>.... aaaaaand in what way can the NPC scrutinize this?</p></blockquote><br/><br/>Obviously that doesn't change anything.  Throw some standardized properties on the object and the NPC can determine whether or not they should attempt to use the exit.<br/><br/><blockquote><p>.... You'd give it a SPECIAL action right? - like &quot;NPC&quot; - and have it return either the room or &quot;FALSE&quot; so that it can move into that room or see the exit cannot be traversed yet? (it's the first idea which seems pretty simple and logical to me)</p></blockquote><br/><br/>That could work.  But I still don't understand your seeming aversion to 'SPECIAL' code.  Your example here is no more special than declaring actions or properties on <span style=\"font-style:italic;\">anything at all</span>, which is a <span style=\"font-style:italic;\">fundamental</span> part of ASL.<br/><br/><blockquote><p>All that would be left out is the player typing &quot;w&quot; or &quot;go west&quot; - which would return &quot;I cannot go there&quot; instead of the nicer &quot;there appears to be a rock in the way&quot;. Which you can have as the normal &quot;default&quot; exit script (ie west msg &lt;There's a big rock in the way&gt;).<br/>The NPC would get to the room, use the properties to check all the exits (or go through the &quot;for each exit in&quot;) to pick an available room.</p></blockquote><br/><br/>What if I want the NPC to automatically discover the rock and attempt to find a way around it?  In that method there is nothing to indicate that it may be possible to do something to get around the rock.<br/><br/><blockquote><p>You close asking for any benefits of correcting exit usage in ASL-400 </p></blockquote><br/><br/>No - I indicated I was open to reasons as to why exits <span style=\"font-style:italic;\">shouldn't</span> be objects.  So far the main argument against exits implemented as objects seems to be cognitive dissonance.  Making an exit an object isn't 'more complicated' - just as making an event an object isn't more complicated.  It's just a natural programming technique, as Freak mentions here:<br/><br/><blockquote><p>Just because something is represented in the game as an object doesn't mean it's necessarily an object in the room. It's a common technique to have an object used solely for structuring data.</p></blockquote>",
      "PostDate": "2009-04-30T14:16:18+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16537",
      "UserId": 0,
      "Username": "Freak",
      "UserAvatar": null,
      "UserGravatar": "325ed9ac125e00c9937be0d3aea0916d",
      "EditableText": "Things are getting too abstract.\n\nOvercat, could you produce hypothetical code of a small game that would illustrate the usefulness of exit objects?\nAlso, is it possible to have some sort of intermediate, that has simple connections for the bulk of the connections, but allows using exit objects when needed?",
      "EditableFormat": "bbcode",
      "HTML": "Things are getting too abstract.<br/><br/>Overcat, could you produce hypothetical code of a small game that would illustrate the usefulness of exit objects?<br/>Also, is it possible to have some sort of intermediate, that has simple connections for the bulk of the connections, but allows using exit objects when needed?",
      "PostDate": "2009-04-30T18:45:24+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16538",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Note: I am trying to stop myself using caps to exaggerate words as it makes me sound smarmy and aggressive.\nMockery is very welcome <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nFirst : oops, I clicked Edit on your post Overcat - I hit back immediately but just incase it shows up.\n.. I didn't touch your post at all.\n\nSecondly: Freak, I'm well aware of the object construct for programming.\nI disagree that an object should be used for every individual piece of data though, and that it should be used specifically.\n\nThirdly, I'll reply to some of Overcats bits (since much of it is too-ing and fro-ing between us both as repetition).\n[quote:j43jbm3i]I think it's pretty straight forward to &quot;code AROUND&quot; them.  It's not like you're circumnavigating the globe any time you want to avoid a certain kind of object.[/quote:j43jbm3i]\nI'm not saying it isn't reletively [i:j43jbm3i]easy[/i:j43jbm3i] to do.\nI'm saying it's an added piece of now [b:j43jbm3i]needed[/b:j43jbm3i] work.\nYou've gone from &quot;opt-in&quot; to &quot;opt-out&quot;.\n\n[quote:j43jbm3i]I [i:j43jbm3i]understand[/i:j43jbm3i] that in [i:j43jbm3i]real life[/i:j43jbm3i] exits are not objects!  But in a coded representation of the real world, any [i:j43jbm3i]concept[/i:j43jbm3i] can be programmatically structured - in this case, an exit can be an object.  There seems to be a disconnect between what I mean by 'object' and what you mean by 'object'.  When I say 'object' I am speaking in a programming sense.  I can [i:j43jbm3i]abstract[/i:j43jbm3i] exits into a class (in ASL's case, a type), and then create instances of that class.  I can use the properties and actions defined by the exit type to mutate the instances into all the different kinds of exits I can think of - including exits that are just that: exits with no other noun than the direction (east, west, etc.)[/quote:j43jbm3i]\nWhat I mean by &quot;object&quot; is two fold:\na) Any Quest object (something in the room used for 'interaction' using #@object# etc.\nb) A 'thing' which holds more then one piece of information/function based around the &quot;properties/methods/functions&quot; of programming.\n\n[quote:j43jbm3i]As a parallel, I have an 'event' type in a library file that I use to define event objects.  Events are no more objects in the real world than are exits, but I still create them as programming objects.  Rather than coding all the different kinds of events that are possible wherever I need them, I create a single type and manipulate properties/actions to achieve the effects I want.[/quote:j43jbm3i]\nDon't quite see how that would work since events are not generic enough?\nI'm trying to think of &quot;events&quot; as storyline plot events which would print text, move objects about and possibly change object properties - not to mention events would have to be interchangable, the same &quot;event&quot; called from different places, and using different parameters.\nAnd I don't quite see how grouping all those separate parts into one group would make much sense - but I will continue to stew on it.\nI don't think we need discuss this part further.\n\n[quote:j43jbm3i][quote:j43jbm3i]What you've now introduced above is:\n*) Overriding player movement\n*) Special treatment of the &lt;exit&gt; object type in ALL commands\n*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.\n*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.[/quote:j43jbm3i]\n\nFirst off, overriding player movement doesn't take a lot of work, and it allows me to do what I want:  use exits as programming objects.  (The fact that I [i:j43jbm3i]can[/i:j43jbm3i] override movement is a good thing.  If folks are happy with the default way things work, then by all means.)  Secondly, you don't need to treat an exit object in a special way for 'ALL commands'.  Thirdly, excluding a specific type of object from a for each loop is not that much extra script, especially if you're organized.  Fourthly, the naming convention mentioned above was used before 4.1.  I haven't decided whether to keep doing it that way or not.  We'll see.[/quote:j43jbm3i]\nMy point was that it went from being able to, to a requirement.\nHow many different ways are there for interacting with objects?\nIn order to use the direction object, you need to code up how you use them (I haven't read the new docu so I don't know what standard 'interactions' are performed by Quest on the exit-objects, sorry).\nYou then need to change *ALL* &quot;command &lt;#command# #@objects#&gt; ...&quot; to &quot;command &lt;#command# #@object#&gt; if not type &lt;#object#;exit&gt; ...&quot; (can't remember if it's &quot;not type&quot;, or &quot;type not&quot;) - as any command you miss out could effect an exit in the most strangest way.\nAs I said before, the &quot;ease&quot; of checking, double checking, and triple checking is not in question here.\n\n\n[quote:j43jbm3i]Exits can have all sorts of description involved with them.  A thin tree trunk over a fast-flowing river; a rope spanning a crevice; an open window; a magical portal; the mouth of a giant worm.  It makes more sense (to me) to have an exit object with properties/actions that determine what is reported to the player when they travel (or attempt to travel) in a certain direction.[/quote:j43jbm3i]\nI would argue that a tree trunk is &quot;a room&quot;.\nIf it isn't a room by itself, then it would be part of the description of the room (I imagined a tunnel/air duct as a similar device to the tree).\n\nAgain, I see it coming back to player interaction with the exit object.\n\n[quote:j43jbm3i]It boils down to how you view the construction of the world behind the scenes.[/quote:j43jbm3i]\nYes I agree, I think you're combining an exit and object (rope, hole, tree, etc) in order for interact.\n\nSorry, haven't read the rest and really need to pop out.\nWill try to respond soon.\n\nSorry for the length of this (again) but am liking the argument <!-- s:P --><img src=\"{SMILIES_PATH}/icon_razz.gif\" alt=\":P\" title=\"Razz\" /><!-- s:P --> .",
      "EditableFormat": "bbcode",
      "HTML": "Note: I am trying to stop myself using caps to exaggerate words as it makes me sound smarmy and aggressive.<br/>Mockery is very welcome <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>First : oops, I clicked Edit on your post Overcat - I hit back immediately but just incase it shows up.<br/>.. I didn't touch your post at all.<br/><br/>Secondly: Freak, I'm well aware of the object construct for programming.<br/>I disagree that an object should be used for every individual piece of data though, and that it should be used specifically.<br/><br/>Thirdly, I'll reply to some of Overcats bits (since much of it is too-ing and fro-ing between us both as repetition).<br/><blockquote><p>I think it's pretty straight forward to &quot;code AROUND&quot; them.  It's not like you're circumnavigating the globe any time you want to avoid a certain kind of object.</p></blockquote><br/>I'm not saying it isn't reletively <span style=\"font-style:italic;\">easy</span> to do.<br/>I'm saying it's an added piece of now <span style=\"font-weight:bold;\">needed</span> work.<br/>You've gone from &quot;opt-in&quot; to &quot;opt-out&quot;.<br/><br/><blockquote><p>I <span style=\"font-style:italic;\">understand</span> that in <span style=\"font-style:italic;\">real life</span> exits are not objects!  But in a coded representation of the real world, any <span style=\"font-style:italic;\">concept</span> can be programmatically structured - in this case, an exit can be an object.  There seems to be a disconnect between what I mean by 'object' and what you mean by 'object'.  When I say 'object' I am speaking in a programming sense.  I can <span style=\"font-style:italic;\">abstract</span> exits into a class (in ASL's case, a type), and then create instances of that class.  I can use the properties and actions defined by the exit type to mutate the instances into all the different kinds of exits I can think of - including exits that are just that: exits with no other noun than the direction (east, west, etc.)</p></blockquote><br/>What I mean by &quot;object&quot; is two fold:<br/>a) Any Quest object (something in the room used for 'interaction' using #@object# etc.<br/>b) A 'thing' which holds more then one piece of information/function based around the &quot;properties/methods/functions&quot; of programming.<br/><br/><blockquote><p>As a parallel, I have an 'event' type in a library file that I use to define event objects.  Events are no more objects in the real world than are exits, but I still create them as programming objects.  Rather than coding all the different kinds of events that are possible wherever I need them, I create a single type and manipulate properties/actions to achieve the effects I want.</p></blockquote><br/>Don't quite see how that would work since events are not generic enough?<br/>I'm trying to think of &quot;events&quot; as storyline plot events which would print text, move objects about and possibly change object properties - not to mention events would have to be interchangable, the same &quot;event&quot; called from different places, and using different parameters.<br/>And I don't quite see how grouping all those separate parts into one group would make much sense - but I will continue to stew on it.<br/>I don't think we need discuss this part further.<br/><br/><blockquote><p>[quote]What you've now introduced above is:<br/>*) Overriding player movement<br/>*) Special treatment of the &lt;exit&gt; object type in ALL commands<br/>*) Special treatment of the &lt;exit&gt; object type for ALL object interactions - not just the ones the player wants to interact with but whatever you want to do automatically to objects too.<br/>*) Special naming convention which voids the benefit of the &quot;for each exit in &lt;room&gt;&quot; loop.</p></blockquote><br/><br/>First off, overriding player movement doesn't take a lot of work, and it allows me to do what I want:  use exits as programming objects.  (The fact that I <span style=\"font-style:italic;\">can</span> override movement is a good thing.  If folks are happy with the default way things work, then by all means.)  Secondly, you don't need to treat an exit object in a special way for 'ALL commands'.  Thirdly, excluding a specific type of object from a for each loop is not that much extra script, especially if you're organized.  Fourthly, the naming convention mentioned above was used before 4.1.  I haven't decided whether to keep doing it that way or not.  We'll see.[/quote]<br/>My point was that it went from being able to, to a requirement.<br/>How many different ways are there for interacting with objects?<br/>In order to use the direction object, you need to code up how you use them (I haven't read the new docu so I don't know what standard 'interactions' are performed by Quest on the exit-objects, sorry).<br/>You then need to change *ALL* &quot;command &lt;#command# #@objects#&gt; ...&quot; to &quot;command &lt;#command# #@object#&gt; if not type &lt;#object#;exit&gt; ...&quot; (can't remember if it's &quot;not type&quot;, or &quot;type not&quot;) - as any command you miss out could effect an exit in the most strangest way.<br/>As I said before, the &quot;ease&quot; of checking, double checking, and triple checking is not in question here.<br/><br/><br/><blockquote><p>Exits can have all sorts of description involved with them.  A thin tree trunk over a fast-flowing river; a rope spanning a crevice; an open window; a magical portal; the mouth of a giant worm.  It makes more sense (to me) to have an exit object with properties/actions that determine what is reported to the player when they travel (or attempt to travel) in a certain direction.</p></blockquote><br/>I would argue that a tree trunk is &quot;a room&quot;.<br/>If it isn't a room by itself, then it would be part of the description of the room (I imagined a tunnel/air duct as a similar device to the tree).<br/><br/>Again, I see it coming back to player interaction with the exit object.<br/><br/><blockquote><p>It boils down to how you view the construction of the world behind the scenes.</p></blockquote><br/>Yes I agree, I think you're combining an exit and object (rope, hole, tree, etc) in order for interact.<br/><br/>Sorry, haven't read the rest and really need to pop out.<br/>Will try to respond soon.<br/><br/>Sorry for the length of this (again) but am liking the argument <!-- s:P --><img src=\"{SMILIES_PATH}/icon_razz.gif\" alt=\":P\" title=\"Razz\" /><!-- s:P --> .",
      "PostDate": "2009-04-30T18:46:28+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16539",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "There's no need to worry, Paul! Exit objects are not in the same scope as regular objects. You don't need to worry about excluding them from &quot;for each&quot; loops or player commands - you can carry on using those as usual.\n\nIf you want to iterate through exit objects, use &quot;for each exit in &lt;room&gt;/game&quot;.\n\nFor commands, exit objects are only in scope for &quot;go (to)&quot;. Because exits are now objects, they automatically benefit from the existing disambiguation features, so you can use abbreviations - &quot;go sup&quot; works instead of having to type the full &quot;go to supermarket&quot;.\n\nThere's no &quot;define exit&quot; block in this version although I may well add that in Quest 4.2. This would add the possibility of specifying alt-names for exits and that sort of thing.\n\nWith exits the way they were in Quest 4.0, it would have been hard for me to add built-in locking functionality - where would the data go? How would you read whether an exit was locked? I could have added a new &quot;north.locked&quot; property to the room, but that's a bit inelegant, and what about non-directional &quot;go to&quot; exits, which didn't have corresponding properties at all? There really was no better way of implementing the functionality than to make exits become objects. That way they benefit from all the existing functionality - so there was no need to update the savegame format, no need to introduce a new mechanism for reading the state of the exit, etc.\n\nI'll write a proper blog post about the changes soon.",
      "EditableFormat": "bbcode",
      "HTML": "There's no need to worry, Paul! Exit objects are not in the same scope as regular objects. You don't need to worry about excluding them from &quot;for each&quot; loops or player commands - you can carry on using those as usual.<br/><br/>If you want to iterate through exit objects, use &quot;for each exit in &lt;room&gt;/game&quot;.<br/><br/>For commands, exit objects are only in scope for &quot;go (to)&quot;. Because exits are now objects, they automatically benefit from the existing disambiguation features, so you can use abbreviations - &quot;go sup&quot; works instead of having to type the full &quot;go to supermarket&quot;.<br/><br/>There's no &quot;define exit&quot; block in this version although I may well add that in Quest 4.2. This would add the possibility of specifying alt-names for exits and that sort of thing.<br/><br/>With exits the way they were in Quest 4.0, it would have been hard for me to add built-in locking functionality - where would the data go? How would you read whether an exit was locked? I could have added a new &quot;north.locked&quot; property to the room, but that's a bit inelegant, and what about non-directional &quot;go to&quot; exits, which didn't have corresponding properties at all? There really was no better way of implementing the functionality than to make exits become objects. That way they benefit from all the existing functionality - so there was no need to update the savegame format, no need to introduce a new mechanism for reading the state of the exit, etc.<br/><br/>I'll write a proper blog post about the changes soon.",
      "PostDate": "2009-04-30T20:45:37+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16540",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Thanks for clearing that up a bit Alex.\n.. I actually typed out a lot of how that would be the better way to approach it in my eyes (I just skimmed my post and saw I removed it... DOH!).\n\nThat gets rid of the whole exits-as-objects issue for me and simple allows you to add object functionality to the exit.\n\nI shall crawl back in my hole now <!-- s:P --><img src=\"{SMILIES_PATH}/icon_razz.gif\" alt=\":P\" title=\"Razz\" /><!-- s:P --> .",
      "EditableFormat": "bbcode",
      "HTML": "Thanks for clearing that up a bit Alex.<br/>.. I actually typed out a lot of how that would be the better way to approach it in my eyes (I just skimmed my post and saw I removed it... DOH!).<br/><br/>That gets rid of the whole exits-as-objects issue for me and simple allows you to add object functionality to the exit.<br/><br/>I shall crawl back in my hole now <!-- s:P --><img src=\"{SMILIES_PATH}/icon_razz.gif\" alt=\":P\" title=\"Razz\" /><!-- s:P --> .",
      "PostDate": "2009-04-30T22:41:51+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16541",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "from Freak:\n[quote:1vdedo9g]Overcat, could you produce hypothetical code of a small game that would illustrate the usefulness of exit objects?[/quote:1vdedo9g]\n\nSure.  I see them specifically useful for NPC interaction, so I'll make something with a wandering NPC.\n\n[quote:1vdedo9g]Also, is it possible to have some sort of intermediate, that has simple connections for the bulk of the connections, but allows using exit objects when needed?[/quote:1vdedo9g]\n\nYes.  I'll attempt to show that in the example.  I think you can do this by checking to see if the normal property for the exit has been defined for the room - if it has, you use it; if it hasn't, you check for an exit object that goes in that direction.\n\nfrom Paul:\n[quote:1vdedo9g]Note: I am trying to stop myself using caps to exaggerate words as it makes me sound smarmy and aggressive.\nMockery is very welcome.[/quote:1vdedo9g]\n\nYeah, it's always hard without voice inflection and facial expression to judge the tone of someone's message.  I hope I wasn't coming across as confrontational, either.\n\n[quote:1vdedo9g]Yes I agree, I think you're combining an exit and object (rope, hole, tree, etc) in order for interact.[/quote:1vdedo9g]\n\nYep.\n\n[quote:1vdedo9g]Sorry for the length of this (again) but am liking the argument.[/quote:1vdedo9g]\n\nMe too.  You're making good points that force me to think.  I don't mind being shown that I'm doing something the hard way!\n\nfrom Alex:\n[quote:1vdedo9g]Exit objects are not in the same scope as regular objects. You don't need to worry about excluding them from &quot;for each&quot; loops or player commands... [/quote:1vdedo9g]\n\nSweet.\n\nAlthough you wouldn't have had to exclude them from player commands anyway, even if they were in the same scope.  If you construct commands {} in the same fashion as verbs {}, objects will only respond to the commands if they have a corresponding action.\n\n[code:1vdedo9g]command &lt;someVerb #@object#&gt; {\n    if action &lt;#object#; someVerb&gt; then {\n        doaction &lt;#object#; someVerb&gt;\n    }\n    else {\n        msg &lt;You cannot someVerb #(object)&#58;prefix# #@object#&#46;&gt;\n    }\n}[/code:1vdedo9g]\n\nThis is a good way to go, I think: all the logic about the verb activity is stored on the object (and/or its type).  For commands with two nouns the same trick can be employed.  \n\nA useful way of building things:\n\n[code:1vdedo9g]define type &lt;punchable&gt;\n\n    action &lt;BeforePunch&gt; {\n\n        doaction &lt;$thisobject$; OnPunch&gt;\n    }\n\n    action &lt;OnPunch&gt; {\n\n        'code default functionality here\n        doaction &lt;$thisobject$; AfterPunch&gt;\n    }\n\n    action &lt;AfterPunch&gt; {\n    }\n\nend define\n\ndefine object &lt;NPC_RonBurgundy&gt; {\n\n    type &lt;punchable&gt;\n\nend define\n\ndefine game &lt;SomeGame&gt;\n\n    &#46;&#46;&#46;\n    verb &lt;punch&#58; BeforePunch&gt; msg &lt;You cannot punch #(quest&#46;lastobject)&#58;prefix# #quest&#46;lastobject#&#46;&gt;\n    &#46;&#46;&#46;\n\nend define[/code:1vdedo9g]\n\nThe BeforePunch action contains nothing but a pass to the default functionality in OnPunch, but it is there for &quot;gatekeep&quot; logic:  code that guards the normal functionality with extra conditionals (should particular objects require it).  The AfterPunch action similarly contains nothing, but is there for &quot;corollary&quot; logic:  code that runs as a result of the default functionality executing (should particular objects require it).\n\n[code:1vdedo9g]define object &lt;NPC_JuliaRoberts&gt; {\n\n    type &lt;punchable&gt;\n    action &lt;BeforePunch&gt; {\n\n        if (#player&#58;gender# &lt;&gt; female) then {\n            msg &lt;You wouldn't hit a lady&#46;&gt;\n        }\n        else {\n            doaction &lt;$thisobject$; OnPunch&gt;\n        }\n    }\n\nend define\n\ndefine object &lt;NPC_HomerSimpson&gt;\n\n    type &lt;punchable&gt;\n    action &lt;AfterPunch&gt; {\n\n        msg &lt;Homer&#58;  &quot;Doh!&quot;&gt;\n    }\n\nend define[/code:1vdedo9g]\n\nThen there's context:  punching items obviously has a different effect than punching actors, so:\n\n[code:1vdedo9g]define type &lt;item&gt;\n\n    take\n    type &lt;punchable&gt;\n    action &lt;OnPunch&gt; {\n\n        'other effects\n        doaction &lt;$thisobject$; AfterPunch&gt;\n    }\n\nend define\n\ndefine object &lt;apple&gt; {\n\n    type &lt;item&gt;\n\nend define[/code:1vdedo9g]\n\nStructuring things this way also allows you to map one verb to another, should the verbs be synonymous in a given context.  For instance, the player might attempt to &quot;turn&quot; a screw, which is definitely different than attempting to turn a valve:  the valve changes state, but the screw comes loose from whatever it was fastened into.  You may already have &quot;unscrew&quot; and &quot;turn&quot; verbs implemented, in which case it would be handy to just map the &quot;turn&quot; verb for the screw to the &quot;unscrew&quot; verb:\n\n[code:1vdedo9g]define object &lt;screw&gt; {\n\n    type &lt;unscrewable&gt;\n    action &lt;BeforeTurn&gt; {\n        doaction &lt;$thisobject$; BeforeUnscrew&gt;\n    }\n\nend define[/code:1vdedo9g]\n\n[quote:1vdedo9g]There's no &quot;define exit&quot; block in this version although I may well add that in Quest 4.2. This would add the possibility of specifying alt-names for exits and that sort of thing.[/quote:1vdedo9g]\n\nCool.  For 4.1 I still don't know how to add properties and actions to the exit object during design-time.  (Can do so at run-time).  Perhaps your blog post will elucidate.\n\nfrom Paul:\n[quote:1vdedo9g]That gets rid of the whole exits-as-objects issue for me and simple allows you to add object functionality to the exit.[/quote:1vdedo9g]\n\nWe both win!",
      "EditableFormat": "bbcode",
      "HTML": "from Freak:<br/><blockquote><p>Overcat, could you produce hypothetical code of a small game that would illustrate the usefulness of exit objects?</p></blockquote><br/><br/>Sure.  I see them specifically useful for NPC interaction, so I'll make something with a wandering NPC.<br/><br/><blockquote><p>Also, is it possible to have some sort of intermediate, that has simple connections for the bulk of the connections, but allows using exit objects when needed?</p></blockquote><br/><br/>Yes.  I'll attempt to show that in the example.  I think you can do this by checking to see if the normal property for the exit has been defined for the room - if it has, you use it; if it hasn't, you check for an exit object that goes in that direction.<br/><br/>from Paul:<br/><blockquote><p>Note: I am trying to stop myself using caps to exaggerate words as it makes me sound smarmy and aggressive.<br/>Mockery is very welcome.</p></blockquote><br/><br/>Yeah, it's always hard without voice inflection and facial expression to judge the tone of someone's message.  I hope I wasn't coming across as confrontational, either.<br/><br/><blockquote><p>Yes I agree, I think you're combining an exit and object (rope, hole, tree, etc) in order for interact.</p></blockquote><br/><br/>Yep.<br/><br/><blockquote><p>Sorry for the length of this (again) but am liking the argument.</p></blockquote><br/><br/>Me too.  You're making good points that force me to think.  I don't mind being shown that I'm doing something the hard way!<br/><br/>from Alex:<br/><blockquote><p>Exit objects are not in the same scope as regular objects. You don't need to worry about excluding them from &quot;for each&quot; loops or player commands... </p></blockquote><br/><br/>Sweet.<br/><br/>Although you wouldn't have had to exclude them from player commands anyway, even if they were in the same scope.  If you construct commands {} in the same fashion as verbs {}, objects will only respond to the commands if they have a corresponding action.<br/><br/><pre><code>command &lt;someVerb #@object#&gt; {<br/>    if action &lt;#object#; someVerb&gt; then {<br/>        doaction &lt;#object#; someVerb&gt;<br/>    }<br/>    else {<br/>        msg &lt;You cannot someVerb #(object)&#58;prefix# #@object#&#46;&gt;<br/>    }<br/>}</code></pre><br/><br/>This is a good way to go, I think: all the logic about the verb activity is stored on the object (and/or its type).  For commands with two nouns the same trick can be employed.  <br/><br/>A useful way of building things:<br/><br/><pre><code>define type &lt;punchable&gt;<br/><br/>    action &lt;BeforePunch&gt; {<br/><br/>        doaction &lt;$thisobject$; OnPunch&gt;<br/>    }<br/><br/>    action &lt;OnPunch&gt; {<br/><br/>        'code default functionality here<br/>        doaction &lt;$thisobject$; AfterPunch&gt;<br/>    }<br/><br/>    action &lt;AfterPunch&gt; {<br/>    }<br/><br/>end define<br/><br/>define object &lt;NPC_RonBurgundy&gt; {<br/><br/>    type &lt;punchable&gt;<br/><br/>end define<br/><br/>define game &lt;SomeGame&gt;<br/><br/>    &#46;&#46;&#46;<br/>    verb &lt;punch&#58; BeforePunch&gt; msg &lt;You cannot punch #(quest&#46;lastobject)&#58;prefix# #quest&#46;lastobject#&#46;&gt;<br/>    &#46;&#46;&#46;<br/><br/>end define</code></pre><br/><br/>The BeforePunch action contains nothing but a pass to the default functionality in OnPunch, but it is there for &quot;gatekeep&quot; logic:  code that guards the normal functionality with extra conditionals (should particular objects require it).  The AfterPunch action similarly contains nothing, but is there for &quot;corollary&quot; logic:  code that runs as a result of the default functionality executing (should particular objects require it).<br/><br/><pre><code>define object &lt;NPC_JuliaRoberts&gt; {<br/><br/>    type &lt;punchable&gt;<br/>    action &lt;BeforePunch&gt; {<br/><br/>        if (#player&#58;gender# &lt;&gt; female) then {<br/>            msg &lt;You wouldn't hit a lady&#46;&gt;<br/>        }<br/>        else {<br/>            doaction &lt;$thisobject$; OnPunch&gt;<br/>        }<br/>    }<br/><br/>end define<br/><br/>define object &lt;NPC_HomerSimpson&gt;<br/><br/>    type &lt;punchable&gt;<br/>    action &lt;AfterPunch&gt; {<br/><br/>        msg &lt;Homer&#58;  &quot;Doh!&quot;&gt;<br/>    }<br/><br/>end define</code></pre><br/><br/>Then there's context:  punching items obviously has a different effect than punching actors, so:<br/><br/><pre><code>define type &lt;item&gt;<br/><br/>    take<br/>    type &lt;punchable&gt;<br/>    action &lt;OnPunch&gt; {<br/><br/>        'other effects<br/>        doaction &lt;$thisobject$; AfterPunch&gt;<br/>    }<br/><br/>end define<br/><br/>define object &lt;apple&gt; {<br/><br/>    type &lt;item&gt;<br/><br/>end define</code></pre><br/><br/>Structuring things this way also allows you to map one verb to another, should the verbs be synonymous in a given context.  For instance, the player might attempt to &quot;turn&quot; a screw, which is definitely different than attempting to turn a valve:  the valve changes state, but the screw comes loose from whatever it was fastened into.  You may already have &quot;unscrew&quot; and &quot;turn&quot; verbs implemented, in which case it would be handy to just map the &quot;turn&quot; verb for the screw to the &quot;unscrew&quot; verb:<br/><br/><pre><code>define object &lt;screw&gt; {<br/><br/>    type &lt;unscrewable&gt;<br/>    action &lt;BeforeTurn&gt; {<br/>        doaction &lt;$thisobject$; BeforeUnscrew&gt;<br/>    }<br/><br/>end define</code></pre><br/><br/><blockquote><p>There's no &quot;define exit&quot; block in this version although I may well add that in Quest 4.2. This would add the possibility of specifying alt-names for exits and that sort of thing.</p></blockquote><br/><br/>Cool.  For 4.1 I still don't know how to add properties and actions to the exit object during design-time.  (Can do so at run-time).  Perhaps your blog post will elucidate.<br/><br/>from Paul:<br/><blockquote><p>That gets rid of the whole exits-as-objects issue for me and simple allows you to add object functionality to the exit.</p></blockquote><br/><br/>We both win!",
      "PostDate": "2009-05-01T12:47:24+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16542",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "[quote:rkqk8hd4]\nFor 4.1 I still don't know how to add properties and actions to the exit object during design-time. (Can do so at run-time). \n[/quote:rkqk8hd4]\n\nYou can't - and I can't think of a good way of doing so without a &quot;define exit&quot; block.\n\nUgly workaround would be to create a type for each exit and then apply the type to the exit at run-time. You could even loop through all exit objects in your startscript, and apply the type within the loop, perhaps.\n\nSince you can't apply properties and actions to exits in v4.0 anyway I don't think is a big issue for v4.1, is it? I can't think that adding properties and actions to an exit would be that common.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p><br/>For 4.1 I still don't know how to add properties and actions to the exit object during design-time. (Can do so at run-time). <br/></p></blockquote><br/><br/>You can't - and I can't think of a good way of doing so without a &quot;define exit&quot; block.<br/><br/>Ugly workaround would be to create a type for each exit and then apply the type to the exit at run-time. You could even loop through all exit objects in your startscript, and apply the type within the loop, perhaps.<br/><br/>Since you can't apply properties and actions to exits in v4.0 anyway I don't think is a big issue for v4.1, is it? I can't think that adding properties and actions to an exit would be that common.",
      "PostDate": "2009-05-01T13:43:03+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16543",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "[quote:2xy1t7wu]Ugly workaround would be to create a type for each exit and then apply the type to the exit at run-time. You could even loop through all exit objects in your startscript, and apply the type within the loop, perhaps.[/quote:2xy1t7wu]\n\nThought of that, but there's no way for me to automatically know which exit is supposed have certain properties/actions altered on the type for given effects.  The startscript would then have a big select case to manually modify each exit.  S'okay - will work something out!\n\n[quote:2xy1t7wu]Since you can't apply properties and actions to exits in v4.0 anyway I don't think is a big issue for v4.1, is it? I can't think that adding properties and actions to an exit would be that common.[/quote:2xy1t7wu]\n\nI admit, the number of users who like to script by hand seems to be dismally low.  But adding properties and actions to exits could [i:2xy1t7wu]become[/i:2xy1t7wu] common?    <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->  The more functionality ASL has, the easier it is to code up scripting libraries.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>Ugly workaround would be to create a type for each exit and then apply the type to the exit at run-time. You could even loop through all exit objects in your startscript, and apply the type within the loop, perhaps.</p></blockquote><br/><br/>Thought of that, but there's no way for me to automatically know which exit is supposed have certain properties/actions altered on the type for given effects.  The startscript would then have a big select case to manually modify each exit.  S'okay - will work something out!<br/><br/><blockquote><p>Since you can't apply properties and actions to exits in v4.0 anyway I don't think is a big issue for v4.1, is it? I can't think that adding properties and actions to an exit would be that common.</p></blockquote><br/><br/>I admit, the number of users who like to script by hand seems to be dismally low.  But adding properties and actions to exits could <span style=\"font-style:italic;\">become</span> common?    <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->  The more functionality ASL has, the easier it is to code up scripting libraries.",
      "PostDate": "2009-05-02T12:02:26+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16544",
      "UserId": 0,
      "Username": "paul_one",
      "UserAvatar": null,
      "UserGravatar": "fef8a1875028f4300bb683f29c432894",
      "EditableText": "Overcat - I think he means, instead of having one type - have many.\nSo type &lt;one&gt; would contain everything for exit &lt;one&gt;.\nType &lt;two&gt; would contain exit &lt;two&gt;.\n.. etc..",
      "EditableFormat": "bbcode",
      "HTML": "Overcat - I think he means, instead of having one type - have many.<br/>So type &lt;one&gt; would contain everything for exit &lt;one&gt;.<br/>Type &lt;two&gt; would contain exit &lt;two&gt;.<br/>.. etc..",
      "PostDate": "2009-05-02T13:15:01+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16545",
      "UserId": 0,
      "Username": "Overcat",
      "UserAvatar": null,
      "UserGravatar": "3958f867d73b44faed6e01f35e74c093",
      "EditableText": "[quote:17c0cnc9]Overcat - I think he means, instead of having one type - have many.\nSo type &lt;one&gt; would contain everything for exit &lt;one&gt;.\nType &lt;two&gt; would contain exit &lt;two&gt;.\n.. etc..[/quote:17c0cnc9]\n\nOh, I see.  So for SomeRoom.north, create a SomeRoom.north type?\n\n[code:17c0cnc9]startscript {\n      for each exit in game {\n            type &lt;#quest&#46;thing#; #quest&#46;thing#&gt;\n      }\n}[/code:17c0cnc9]\n\nOnly problem is if I've decided to use the default exit functionality for some of the exits, and therefore haven't defined a type by the same name, then I'll throw the error: &quot;ERROR: No such type 'SomeRoom.north'&quot;.  I guess that doesn't matter much for the final product, though.  Thanks!",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>Overcat - I think he means, instead of having one type - have many.<br/>So type &lt;one&gt; would contain everything for exit &lt;one&gt;.<br/>Type &lt;two&gt; would contain exit &lt;two&gt;.<br/>.. etc..</p></blockquote><br/><br/>Oh, I see.  So for SomeRoom.north, create a SomeRoom.north type?<br/><br/><pre><code>startscript {<br/>      for each exit in game {<br/>            type &lt;#quest&#46;thing#; #quest&#46;thing#&gt;<br/>      }<br/>}</code></pre><br/><br/>Only problem is if I've decided to use the default exit functionality for some of the exits, and therefore haven't defined a type by the same name, then I'll throw the error: &quot;ERROR: No such type 'SomeRoom.north'&quot;.  I guess that doesn't matter much for the final product, though.  Thanks!",
      "PostDate": "2009-05-02T17:36:48+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16627",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "I've updated the beta build to fix a number of issues that have been reported so far.\n\nThere are still a number of bugs I'm aware of which need to be looked at, so we're not at &quot;release candidate&quot; stage yet, but we're getting closer <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nI've updated the help file now (the tutorial still needs updating though).",
      "EditableFormat": "bbcode",
      "HTML": "I've updated the beta build to fix a number of issues that have been reported so far.<br/><br/>There are still a number of bugs I'm aware of which need to be looked at, so we're not at &quot;release candidate&quot; stage yet, but we're getting closer <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>I've updated the help file now (the tutorial still needs updating though).",
      "PostDate": "2009-05-25T19:29:01+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "16628",
      "UserId": 0,
      "Username": "Alex",
      "UserAvatar": null,
      "UserGravatar": "188b72c5e13327f4fde3989dca7d7d53",
      "EditableText": "I've just updated the build again - this build significantly improves the performance of saving/loading QSG files.\n\nIn my tests, &quot;Beyond Exile&quot; on textadventures.co.uk was taking several minutes to save and load - this was even after the earlier improvements I'd made to saving QSG files. In the latest build, saving is pretty much instant, and loading only takes a couple of seconds. Nice!\n\nI've also improved the performance of the CAS compiler when compiling large games.",
      "EditableFormat": "bbcode",
      "HTML": "I've just updated the build again - this build significantly improves the performance of saving/loading QSG files.<br/><br/>In my tests, &quot;Beyond Exile&quot; on textadventures.co.uk was taking several minutes to save and load - this was even after the earlier improvements I'd made to saving QSG files. In the latest build, saving is pretty much instant, and loading only takes a couple of seconds. Nice!<br/><br/>I've also improved the performance of the CAS compiler when compiling large games.",
      "PostDate": "2009-05-25T22:42:59+01:00",
      "LastEditDate": null
    }
  ]
}
