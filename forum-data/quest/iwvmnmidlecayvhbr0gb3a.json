{
  "Topic": {
    "TopicId": "iwvmnmidlecayvhbr0gb3a",
    "ForumId": "10",
    "Title": "hoping for help on how to get the 'attr' syntax to work with lists and dictionaries",
    "LastUpdated": "2018-02-28T13:48:03.0869544Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "448a1e0d-3015-4241-b741-0499e5653320",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(filler for getting my edited post, updated/posted)\r\n\r\n----------------\r\n\r\nThis 'attr' syntax/format is very convient (quick/easy typing/copy-paste/etc):\r\n\r\n```\r\n<attr name=\"NAME_OF_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\">CONTENT</attr>\r\n\r\n<attr name=\"NAME_OF_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\">\r\n  CONTENT\r\n</attr>\r\n```\r\n\r\n-----\r\n\r\nhowever, with the older versions of quest (does Pixie's new versions fix this?):\r\n\r\nit doesn't work with List and Dictionary Attributes, having to instead, use this much less convient syntax/format:\r\n\r\n```\r\n<NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE type=\"TYPE_OF_ATTRIBUTE\">\r\n  CONTENT (depends on Attribute Type): <value><value>, <item><key></key><value></value></item>, <item key=\"XXX\">SCRIPTING</item>\r\n</NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE>\r\n```\r\n\r\n-------\r\n\r\n**being able to do:**\r\n\r\n```\r\n<attr name=\"NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\">\r\n  CONTENT (depends on Attribute Type): <value><value>, <item><key></key><value></value></item>, <item key=\"XXX\">SCRIPTING</item>\r\n</attr>\r\n```\r\n\r\n**...would be so much better and appreciated...**\r\n\r\n------\r\n\r\ndoes anyone know how (if able) to get the 'attr' syntax/format to work for Lists/Dictionaries, if it's possible by altering the 'core' aslx code files, or is it within the 'C# and etc' coding?\r\n\r\nI'd very much like to do this, instead of having to change all of my lists/dictonaries (as I didn't realize the 'attr' syntax didn't work for them), and I really hate if I had to use the 'NAME_OF_ATTRIBUTE' instead of 'attr', as it's really messy and hard to read and has a ton of other very inconvient issues with it, compared to having the 'attr' syntax/format...\r\n\r\n------\r\n\r\nI'm just asking this now, before I start going through all of my lists/dictionaries to change them over to the inferior syntax/format, as opposed to hoping that it can be done and that someone will help with how to do it, to change the lists/dictionaries over to using the 'attr' syntax/fomat...\r\n\r\nI'll also try to see if I can figure it out myself too... but I'm not too confident in dealing with the core aslx and/or especially if it uses the 'C# or whatever'... as I've still not delved into learning 'C#' or whatever other coding it uses.",
      "EditableFormat": "markdown",
      "HTML": "<p>(filler for getting my edited post, updated/posted)</p>\n<hr>\n<p>This 'attr' syntax/format is very convient (quick/easy typing/copy-paste/etc):</p>\n<pre><code>&lt;attr name=\"NAME_OF_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\"&gt;CONTENT&lt;/attr&gt;\n\n&lt;attr name=\"NAME_OF_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\"&gt;\n  CONTENT\n&lt;/attr&gt;\n</code></pre>\n<hr>\n<p>however, with the older versions of quest (does Pixie's new versions fix this?):</p>\n<p>it doesn't work with List and Dictionary Attributes, having to instead, use this much less convient syntax/format:</p>\n<pre><code>&lt;NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE type=\"TYPE_OF_ATTRIBUTE\"&gt;\n  CONTENT (depends on Attribute Type): &lt;value&gt;&lt;value&gt;, &lt;item&gt;&lt;key&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/item&gt;, &lt;item key=\"XXX\"&gt;SCRIPTING&lt;/item&gt;\n&lt;/NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE&gt;\n</code></pre>\n<hr>\n<p><strong>being able to do:</strong></p>\n<pre><code>&lt;attr name=\"NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\"&gt;\n  CONTENT (depends on Attribute Type): &lt;value&gt;&lt;value&gt;, &lt;item&gt;&lt;key&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/item&gt;, &lt;item key=\"XXX\"&gt;SCRIPTING&lt;/item&gt;\n&lt;/attr&gt;\n</code></pre>\n<p><strong>...would be so much better and appreciated...</strong></p>\n<hr>\n<p>does anyone know how (if able) to get the 'attr' syntax/format to work for Lists/Dictionaries, if it's possible by altering the 'core' aslx code files, or is it within the 'C# and etc' coding?</p>\n<p>I'd very much like to do this, instead of having to change all of my lists/dictonaries (as I didn't realize the 'attr' syntax didn't work for them), and I really hate if I had to use the 'NAME_OF_ATTRIBUTE' instead of 'attr', as it's really messy and hard to read and has a ton of other very inconvient issues with it, compared to having the 'attr' syntax/format...</p>\n<hr>\n<p>I'm just asking this now, before I start going through all of my lists/dictionaries to change them over to the inferior syntax/format, as opposed to hoping that it can be done and that someone will help with how to do it, to change the lists/dictionaries over to using the 'attr' syntax/fomat...</p>\n<p>I'll also try to see if I can figure it out myself too... but I'm not too confident in dealing with the core aslx and/or especially if it uses the 'C# or whatever'... as I've still not delved into learning 'C#' or whatever other coding it uses.</p>\n\n",
      "PostDate": "2018-02-28T13:48:03.0869544Z",
      "LastEditDate": "2018-02-28T13:52:03.2921445Z",
      "link": null
    },
    {
      "PostId": "bd536a5f-14de-4197-8b40-0bda5e01584c",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have a feeling you cannot. Usually Quest will use the attribute name as the XML tag name, so:\r\n```\r\n<myattribute>Some text</myattribute>\r\n```\r\nIt only uses `attr` when there is a space in the name, because XML does not allow spaces in the tag name.\r\n```\r\n<attr=\"my attribute\">Some text</attr>\r\n```\r\nHowever, if you have a list of dictionary attribute with a space, you will get an error when you try to save the game. Why that should be I do not know... which does not really help, I guess.",
      "EditableFormat": "markdown",
      "HTML": "<p>I have a feeling you cannot. Usually Quest will use the attribute name as the XML tag name, so:</p>\n<pre><code>&lt;myattribute&gt;Some text&lt;/myattribute&gt;\n</code></pre>\n<p>It only uses <code>attr</code> when there is a space in the name, because XML does not allow spaces in the tag name.</p>\n<pre><code>&lt;attr=\"my attribute\"&gt;Some text&lt;/attr&gt;\n</code></pre>\n<p>However, if you have a list of dictionary attribute with a space, you will get an error when you try to save the game. Why that should be I do not know... which does not really help, I guess.</p>\n\n",
      "PostDate": "2018-02-28T15:24:07.3361327Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f45fe58f-0a0b-4121-9426-82f0ecb474f0",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">It only uses ```attr``` when there is a space in the name, because XML does not allow spaces in the tag name.\r\n\r\nI was recently wondering about that.\r\n\r\n---\r\nIn HK's example:\r\n\r\nCouldn't you just delete ```attr``` from each of the tags which are dictionaries or lists?\r\n\r\nIf so, you could use Find & Replace in code view, making sure to pay attention before replacing anything.\r\n\r\nfind:\r\n```<attr ```\r\nreplace with:\r\n\r\n```<```\r\n\r\n...well... You'd have to fool with removing the quotation marks from each dictionary (or list) name, too...",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>It only uses <code>attr</code> when there is a space in the name, because XML does not allow spaces in the tag name.</p>\n</blockquote>\n<p>I was recently wondering about that.</p>\n<hr>\n<p>In HK's example:</p>\n<p>Couldn't you just delete <code>attr</code> from each of the tags which are dictionaries or lists?</p>\n<p>If so, you could use Find &amp; Replace in code view, making sure to pay attention before replacing anything.</p>\n<p>find:<br>\n<code>&lt;attr</code><br>\nreplace with:</p>\n<p><code>&lt;</code></p>\n<p>...well... You'd have to fool with removing the quotation marks from each dictionary (or list) name, too...</p>\n\n",
      "PostDate": "2018-02-28T15:46:28.3504354Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bcb9f926-bf9d-4ee8-97c5-3fa393169c60",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@ KV:\r\n\r\nit's a bit of a pain, but I can do the work/pain and convert my code (there's a lot of code/lists/dictionaries... lots of compartmentalized/encapsulation, as separate files)\r\n\r\nthe bigger issue for myself, is that the 'attr' syntax/format is so much better, for a lot of various human-friendly usage reasons\r\n\r\n----------\r\n\r\nI'd prefer using the 'attr', but it looks like it won't be possible... as it's probably too connected/buried with whatever of the various internal coding of quest and/or other code languages/systems/softwares it issues (dll, that 'flee' code stuff, and etc)\r\n\r\n---------\r\n\r\n@ Pixie:\r\n\r\nthanks for the reply, I tried looking through the core aslx files as well as some of the source code, but couldn't find anything in my limited search attempt dealing with any code that deals with the syntax format structure\r\n\r\ndo you any chance possibly know of where it can be found? (and I can try to see if I could possibly figure out how to edit it... riiight, lol)) or is it using code with the dll files (can't remember if the source code is what's in the dll files or if they're different --- can't remember, need to go back and check --- dll files use assembly-like code)\r\n\r\nand I never knew the 'attr' was for enabled/handling having a space within the 'name' of the Element/xml tag, I just find it so much more useful, sighs.\r\n\r\n--------\r\n\r\nP.S.\r\n\r\non a totally separate note:\r\n\r\nI tried using this common style of syntax (on C++ at least, I think, and probably Java and Python, but not sure) that some people use as it can be easier for new people to understand it, but quest isn't programmed to handle it (using 'if' for the example):\r\n\r\n```\r\nif (XXX)\r\n{\r\n  // XXX\r\n}\r\nelse if (XXX)\r\n{\r\n  // XXX\r\n}\r\nelse\r\n  // XXX\r\n}\r\n```\r\n\r\nif I understand the error (did NOT do a very thorough job of testing), it needs the beginning curly brace on the same line as the 'if/else-if/else'",
      "EditableFormat": "markdown",
      "HTML": "<p>@ KV:</p>\n<p>it's a bit of a pain, but I can do the work/pain and convert my code (there's a lot of code/lists/dictionaries... lots of compartmentalized/encapsulation, as separate files)</p>\n<p>the bigger issue for myself, is that the 'attr' syntax/format is so much better, for a lot of various human-friendly usage reasons</p>\n<hr>\n<p>I'd prefer using the 'attr', but it looks like it won't be possible... as it's probably too connected/buried with whatever of the various internal coding of quest and/or other code languages/systems/softwares it issues (dll, that 'flee' code stuff, and etc)</p>\n<hr>\n<p>@ Pixie:</p>\n<p>thanks for the reply, I tried looking through the core aslx files as well as some of the source code, but couldn't find anything in my limited search attempt dealing with any code that deals with the syntax format structure</p>\n<p>do you any chance possibly know of where it can be found? (and I can try to see if I could possibly figure out how to edit it... riiight, lol)) or is it using code with the dll files (can't remember if the source code is what's in the dll files or if they're different --- can't remember, need to go back and check --- dll files use assembly-like code)</p>\n<p>and I never knew the 'attr' was for enabled/handling having a space within the 'name' of the Element/xml tag, I just find it so much more useful, sighs.</p>\n<hr>\n<p>P.S.</p>\n<p>on a totally separate note:</p>\n<p>I tried using this common style of syntax (on C++ at least, I think, and probably Java and Python, but not sure) that some people use as it can be easier for new people to understand it, but quest isn't programmed to handle it (using 'if' for the example):</p>\n<pre><code>if (XXX)\n{\n  // XXX\n}\nelse if (XXX)\n{\n  // XXX\n}\nelse\n  // XXX\n}\n</code></pre>\n<p>if I understand the error (did NOT do a very thorough job of testing), it needs the beginning curly brace on the same line as the 'if/else-if/else'</p>\n\n",
      "PostDate": "2018-02-28T19:04:50.3488207Z",
      "LastEditDate": "2018-02-28T19:15:49.8110454Z",
      "link": null
    },
    {
      "PostId": "30690eab-3005-4269-a800-5b524d1999e4",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I do not know where it is, but it will not be a .aslx file. I would presume in the C# code, but I have yet to come across any XML handlers.",
      "EditableFormat": "markdown",
      "HTML": "<p>I do not know where it is, but it will not be a .aslx file. I would presume in the C# code, but I have yet to come across any XML handlers.</p>\n\n",
      "PostDate": "2018-02-28T19:08:24.9515048Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c0690ebc-e0db-4ccf-b2f8-00250c39701d",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "is the 'C#' code, the source code, or something else? where do I find the 'C#' code (example of a file), if you know of any locations of it ???\r\n\r\n------\r\n\r\nah, okay, so the 'attr' usage is a 'xml' handler... at least now I know what I'm trying to find/look for, lol...",
      "EditableFormat": "markdown",
      "HTML": "<p>is the 'C#' code, the source code, or something else? where do I find the 'C#' code (example of a file), if you know of any locations of it ???</p>\n<hr>\n<p>ah, okay, so the 'attr' usage is a 'xml' handler... at least now I know what I'm trying to find/look for, lol...</p>\n\n",
      "PostDate": "2018-02-28T19:11:58.7298561Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "29232f49-98b0-47da-a201-2a4da6c5611e",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I don't exactly understand what you're trying to do.  (This is because you know what you're doing programming-wise, and I'm only just learning.)\r\n\r\nYou want to do this:\r\n```\r\n<attr name=\"NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\">\r\n  CONTENT (depends on Attribute Type): <value><value>, <item><key></key><value></value></item>, <item key=\"XXX\">SCRIPTING</item>\r\n</attr>\r\n```\r\n\r\nAs opposed to this:\r\n```\r\n<NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE type=\"TYPE_OF_ATTRIBUTE\">\r\n  CONTENT (depends on Attribute Type): <value><value>, <item><key></key><value></value></item>, <item key=\"XXX\">SCRIPTING</item>\r\n</NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE>\r\n```\r\n\r\n\r\n---\r\nThe only difference I see between the two is the ```attr``` tag VS the ```NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE``` tag.\r\n\r\n---\r\nAnyway, in WorldModel\\WorldModel\\GameLoader\\ElementLoaders.cs, starting at line 420, I found this, which I believe may be what you're looking for:\r\n\r\n<details>\r\n\r\n```\r\npublic override object Load(XmlReader reader, ref Element current)\r\n            {\r\n                string attribute = reader.Name;\r\n                if (attribute == \"attr\")\r\n                {\r\n                    attribute = reader.GetAttribute(\"name\");\r\n                }\r\n                string type = reader.GetAttribute(\"type\");\r\n\r\n                WorldModel.AddAttributeName(attribute);\r\n\r\n                if (type == null)\r\n                {\r\n                    string currentElementType = current.Fields.GetString(\"type\");\r\n                    if (string.IsNullOrEmpty(currentElementType))\r\n                    {\r\n                        // the type property is the object type, so is not set for other element types.\r\n                        currentElementType = current.Fields.GetString(\"elementtype\");\r\n                    }\r\n                    type = GameLoader.m_implicitTypes.Get(currentElementType, attribute);\r\n                }\r\n\r\n                // map old to new type names if necessary (but not in included library files)\r\n                if (type != null && WorldModel.Version <= WorldModelVersion.v530 && !current.MetaFields[MetaFieldDefinitions.Library] && s_legacyTypeMappings.ContainsKey(type))\r\n                {\r\n                    type = s_legacyTypeMappings[type];\r\n                }\r\n\r\n                if (type != null && GameLoader.ExtendedAttributeLoaders.ContainsKey(type))\r\n                {\r\n                    GameLoader.ExtendedAttributeLoaders[type].Load(reader, current);\r\n                }\r\n                else\r\n                {\r\n                    string value;\r\n\r\n                    try\r\n                    {\r\n                        value = GameLoader.GetTemplateContents(reader);\r\n                    }\r\n                    catch (XmlException)\r\n                    {\r\n                        RaiseError(string.Format(\"Error loading XML data for '{0}.{1}' - ensure that it contains no nested XML\", current.Name, attribute));\r\n                        return null;\r\n                    }\r\n\r\n                    if (type == null)\r\n                    {\r\n                        if (value.Length > 0)\r\n                        {\r\n                            type = \"string\";\r\n                        }\r\n                        else\r\n                        {\r\n                            type = \"boolean\";\r\n                        }\r\n                    }\r\n\r\n                    if (GameLoader.AttributeLoaders.ContainsKey(type))\r\n                    {\r\n                        GameLoader.AttributeLoaders[type].Load(current, attribute, value);\r\n                    }\r\n                    else\r\n                    {\r\n                        Element del;\r\n                        if (WorldModel.Elements.TryGetValue(ElementType.Delegate, type, out del))\r\n                        {\r\n                            Element proc = WorldModel.GetElementFactory(ElementType.Delegate).Create();\r\n                            proc.MetaFields[MetaFieldDefinitions.DelegateImplementation] = true;\r\n                            proc.Fields.LazyFields.AddScript(FieldDefinitions.Script.Property, value);\r\n                            current.Fields.Set(attribute, new DelegateImplementation(type, del, proc));\r\n                        }\r\n                        else\r\n                        {\r\n                            RaiseError(string.Format(\"Unrecognised attribute type '{0}' in '{1}.{2}'\", type, current.Name, attribute));\r\n                        }\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I don't exactly understand what you're trying to do.  (This is because you know what you're doing programming-wise, and I'm only just learning.)</p>\n<p>You want to do this:</p>\n<pre><code>&lt;attr name=\"NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE\" type=\"TYPE_OF_ATTRIBUTE\"&gt;\n  CONTENT (depends on Attribute Type): &lt;value&gt;&lt;value&gt;, &lt;item&gt;&lt;key&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/item&gt;, &lt;item key=\"XXX\"&gt;SCRIPTING&lt;/item&gt;\n&lt;/attr&gt;\n</code></pre>\n<p>As opposed to this:</p>\n<pre><code>&lt;NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE type=\"TYPE_OF_ATTRIBUTE\"&gt;\n  CONTENT (depends on Attribute Type): &lt;value&gt;&lt;value&gt;, &lt;item&gt;&lt;key&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/item&gt;, &lt;item key=\"XXX\"&gt;SCRIPTING&lt;/item&gt;\n&lt;/NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE&gt;\n</code></pre>\n<hr>\n<p>The only difference I see between the two is the <code>attr</code> tag VS the <code>NAME_OF_LIST_OR_DICTIONARY_ATTRIBUTE</code> tag.</p>\n<hr>\n<p>Anyway, in WorldModel\\WorldModel\\GameLoader\\ElementLoaders.cs, starting at line 420, I found this, which I believe may be what you're looking for:</p>\n<details>\n<pre><code>public override object Load(XmlReader reader, ref Element current)\n            {\n                string attribute = reader.Name;\n                if (attribute == \"attr\")\n                {\n                    attribute = reader.GetAttribute(\"name\");\n                }\n                string type = reader.GetAttribute(\"type\");\n\n                WorldModel.AddAttributeName(attribute);\n\n                if (type == null)\n                {\n                    string currentElementType = current.Fields.GetString(\"type\");\n                    if (string.IsNullOrEmpty(currentElementType))\n                    {\n                        // the type property is the object type, so is not set for other element types.\n                        currentElementType = current.Fields.GetString(\"elementtype\");\n                    }\n                    type = GameLoader.m_implicitTypes.Get(currentElementType, attribute);\n                }\n\n                // map old to new type names if necessary (but not in included library files)\n                if (type != null &amp;&amp; WorldModel.Version &lt;= WorldModelVersion.v530 &amp;&amp; !current.MetaFields[MetaFieldDefinitions.Library] &amp;&amp; s_legacyTypeMappings.ContainsKey(type))\n                {\n                    type = s_legacyTypeMappings[type];\n                }\n\n                if (type != null &amp;&amp; GameLoader.ExtendedAttributeLoaders.ContainsKey(type))\n                {\n                    GameLoader.ExtendedAttributeLoaders[type].Load(reader, current);\n                }\n                else\n                {\n                    string value;\n\n                    try\n                    {\n                        value = GameLoader.GetTemplateContents(reader);\n                    }\n                    catch (XmlException)\n                    {\n                        RaiseError(string.Format(\"Error loading XML data for '{0}.{1}' - ensure that it contains no nested XML\", current.Name, attribute));\n                        return null;\n                    }\n\n                    if (type == null)\n                    {\n                        if (value.Length &gt; 0)\n                        {\n                            type = \"string\";\n                        }\n                        else\n                        {\n                            type = \"boolean\";\n                        }\n                    }\n\n                    if (GameLoader.AttributeLoaders.ContainsKey(type))\n                    {\n                        GameLoader.AttributeLoaders[type].Load(current, attribute, value);\n                    }\n                    else\n                    {\n                        Element del;\n                        if (WorldModel.Elements.TryGetValue(ElementType.Delegate, type, out del))\n                        {\n                            Element proc = WorldModel.GetElementFactory(ElementType.Delegate).Create();\n                            proc.MetaFields[MetaFieldDefinitions.DelegateImplementation] = true;\n                            proc.Fields.LazyFields.AddScript(FieldDefinitions.Script.Property, value);\n                            current.Fields.Set(attribute, new DelegateImplementation(type, del, proc));\n                        }\n                        else\n                        {\n                            RaiseError(string.Format(\"Unrecognised attribute type '{0}' in '{1}.{2}'\", type, current.Name, attribute));\n                        }\n                    }\n                }\n                return null;\n            }\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-02-28T19:30:31.8956173Z",
      "LastEditDate": "2018-03-01T19:24:00.4688569Z",
      "link": null
    },
    {
      "PostId": "f73347f5-8ae1-4570-8046-b1a13a0fe58d",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I also found these in WorldModel\\WorldModel\\Functions\\ExpressionOwner.cs, starting at line 381:\r\n\r\n<details>\r\n\r\n```\r\n        public object DictionaryItem(/* IDictionary */ object obj, string key)\r\n        {\r\n            IDictionary dictionary = GetParameter<IDictionary>(obj, \"DictionaryItem\", \"dictionary\");\r\n            return dictionary[key];\r\n        }\r\n\r\n        public string StringDictionaryItem(/* IDictionary */ object obj, string key)\r\n        {\r\n            IDictionary dictionary = GetParameter<IDictionary>(obj, \"StringDictionaryItem\", \"dictionary\");\r\n            return dictionary[key] as string;\r\n        }\r\n\r\n        public Element ObjectDictionaryItem(/* IDictionary */ object obj, string key)\r\n        {\r\n            IDictionary dictionary = GetParameter<IDictionary>(obj, \"ObjectDictionaryItem\", \"dictionary\");\r\n            return dictionary[key] as Element;\r\n        }\r\n\r\n        public IScript ScriptDictionaryItem(/* IDictionary */ object obj, string key)\r\n        {\r\n            IDictionary dictionary = GetParameter<IDictionary>(obj, \"ScriptDictionaryItem\", \"dictionary\");\r\n            return dictionary[key] as IScript;\r\n        }\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I also found these in WorldModel\\WorldModel\\Functions\\ExpressionOwner.cs, starting at line 381:</p>\n<details>\n<pre><code>        public object DictionaryItem(/* IDictionary */ object obj, string key)\n        {\n            IDictionary dictionary = GetParameter&lt;IDictionary&gt;(obj, \"DictionaryItem\", \"dictionary\");\n            return dictionary[key];\n        }\n\n        public string StringDictionaryItem(/* IDictionary */ object obj, string key)\n        {\n            IDictionary dictionary = GetParameter&lt;IDictionary&gt;(obj, \"StringDictionaryItem\", \"dictionary\");\n            return dictionary[key] as string;\n        }\n\n        public Element ObjectDictionaryItem(/* IDictionary */ object obj, string key)\n        {\n            IDictionary dictionary = GetParameter&lt;IDictionary&gt;(obj, \"ObjectDictionaryItem\", \"dictionary\");\n            return dictionary[key] as Element;\n        }\n\n        public IScript ScriptDictionaryItem(/* IDictionary */ object obj, string key)\n        {\n            IDictionary dictionary = GetParameter&lt;IDictionary&gt;(obj, \"ScriptDictionaryItem\", \"dictionary\");\n            return dictionary[key] as IScript;\n        }\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-02-28T19:50:53.7266857Z",
      "LastEditDate": "2018-03-01T19:24:16.4355738Z",
      "link": null
    },
    {
      "PostId": "b6eae332-6bb6-4561-8586-31b2cd0ca9ce",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The first one, ElementLoaders.cs, is the right sort of thing, but I see nothing there that would cause this behaviour. That said, it does pass off the work to AttributeLoaders and it may be in them. Who knows where they are?\r\n\r\nThe stuff in ExpressionOwner.cs looks like the hard-coded functions used in Quest code.",
      "EditableFormat": "markdown",
      "HTML": "<p>The first one, ElementLoaders.cs, is the right sort of thing, but I see nothing there that would cause this behaviour. That said, it does pass off the work to AttributeLoaders and it may be in them. Who knows where they are?</p>\n<p>The stuff in ExpressionOwner.cs looks like the hard-coded functions used in Quest code.</p>\n\n",
      "PostDate": "2018-02-28T21:06:25.890443Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c8216dc0-d634-44f8-9651-09f1fcfa8778",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "**Edit:** This post isn't exactly wrong, but it isn't where the problem is. The loaders in `AttributeLoaders.cs` (analysed here) are the ones that work. See my next reply for a look into `ExtendedAttributeLoaders.cs`, which will parse `<attr name=\"foo\">` as an attribute named \"attr\", ignoring the `name=` bit.\r\n\r\nIn `WorldModel/WorldModel/GameLoader/AttributeLoaders.cs` there are a load of classes derived from `AttributeLoaderBase`. Each one has a `Load` function, which should parse the contents of a particular attribute type. For example:\r\n```\r\n        private class SimpleStringListLoader : AttributeLoaderBase\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"simplestringlist\"; }\r\n            }\r\n\r\n            public override void Load(Element element, string attribute, string value)\r\n            {\r\n                string[] values = GetValues(value);\r\n                element.Fields.Set(attribute, new QuestList<string>(values));\r\n            }\r\n\r\n            protected string[] GetValues(string value)\r\n            {\r\n                string[] values;\r\n                if (value.IndexOf(\"\\n\", StringComparison.Ordinal) >= 0)\r\n                {\r\n                    values = Utility.SplitIntoLines(value).ToArray();\r\n                }\r\n                else\r\n                {\r\n                    values = Utility.ListSplit(value);\r\n                }\r\n                return values;\r\n            }\r\n        }\r\n```\r\nthe `AppliesTo` method returns `\"simplestringlist\"`; so this class's `Load()` method will be called whenever Quest sees an `<attr name=\"whatever\" type=\"simplestringlist\">` or `<whatever type=\"simplestringlist\">`\r\n\r\nI don't really know C#; but I can't see anything that should make the `<attr>` work for only some of these types, unless these Load methods treat it oddly.",
      "EditableFormat": "markdown",
      "HTML": "<p><strong>Edit:</strong> This post isn't exactly wrong, but it isn't where the problem is. The loaders in <code>AttributeLoaders.cs</code> (analysed here) are the ones that work. See my next reply for a look into <code>ExtendedAttributeLoaders.cs</code>, which will parse <code>&lt;attr name=\"foo\"&gt;</code> as an attribute named \"attr\", ignoring the <code>name=</code> bit.</p>\n<p>In <code>WorldModel/WorldModel/GameLoader/AttributeLoaders.cs</code> there are a load of classes derived from <code>AttributeLoaderBase</code>. Each one has a <code>Load</code> function, which should parse the contents of a particular attribute type. For example:</p>\n<pre><code>        private class SimpleStringListLoader : AttributeLoaderBase\n        {\n            public override string AppliesTo\n            {\n                get { return \"simplestringlist\"; }\n            }\n\n            public override void Load(Element element, string attribute, string value)\n            {\n                string[] values = GetValues(value);\n                element.Fields.Set(attribute, new QuestList&lt;string&gt;(values));\n            }\n\n            protected string[] GetValues(string value)\n            {\n                string[] values;\n                if (value.IndexOf(\"\\n\", StringComparison.Ordinal) &gt;= 0)\n                {\n                    values = Utility.SplitIntoLines(value).ToArray();\n                }\n                else\n                {\n                    values = Utility.ListSplit(value);\n                }\n                return values;\n            }\n        }\n</code></pre>\n<p>the <code>AppliesTo</code> method returns <code>\"simplestringlist\"</code>; so this class's <code>Load()</code> method will be called whenever Quest sees an <code>&lt;attr name=\"whatever\" type=\"simplestringlist\"&gt;</code> or <code>&lt;whatever type=\"simplestringlist\"&gt;</code></p>\n<p>I don't really know C#; but I can't see anything that should make the <code>&lt;attr&gt;</code> work for only some of these types, unless these Load methods treat it oddly.</p>\n\n",
      "PostDate": "2018-02-28T22:28:06.9593461Z",
      "LastEditDate": "2018-03-01T00:19:31.6334657Z",
      "link": null
    },
    {
      "PostId": "4196b27b-f285-4d21-8e17-d4a7035ee166",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ouch ... I see the problem.\r\n\r\nFirst it checks for a loader in ExtendedAttributeLoaders; then it looks in AttributeLoaders.\r\n\r\nThe latter had a method: `Load(Element element, String attribute, String value)`. This parses value (converting it to a string, list, int, or whatever) and then pretty much calls the C# function that lies behind `set(element, attribute, value)`.\r\n\r\nThe former, on the other hand, has a method `Load(XmlReader reader, Element current)`. It can use the methods of the XmlReader object to access nested XML tags within the value; for example the `<item><key></key><value></value></item>` syntax mentioned above. *but* some of these loaders use `reader.Name` to determine the name of the attribute to add to the object specified by `element`.\r\nIn this case, `reader.Name` will be `\"attr\"`.\r\n\r\nSo, in the file `WorldModel/WorldModel/GameLoader/ExtendedAttributeLoaders.cs`, it has:\r\n```\r\n       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(currentXmlElementName, result);\r\n            }\r\n```\r\nbut it should should be:\r\n```\r\n       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                string attributeName = reader.GetAttribute(\"name\");\r\n                if (attributeName == null) {\r\n                  attributeName = currentXmlElementName;\r\n                }\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\r\n            }\r\n```\r\nand the same for the other classes in that file.",
      "EditableFormat": "markdown",
      "HTML": "<p>Ouch ... I see the problem.</p>\n<p>First it checks for a loader in ExtendedAttributeLoaders; then it looks in AttributeLoaders.</p>\n<p>The latter had a method: <code>Load(Element element, String attribute, String value)</code>. This parses value (converting it to a string, list, int, or whatever) and then pretty much calls the C# function that lies behind <code>set(element, attribute, value)</code>.</p>\n<p>The former, on the other hand, has a method <code>Load(XmlReader reader, Element current)</code>. It can use the methods of the XmlReader object to access nested XML tags within the value; for example the <code>&lt;item&gt;&lt;key&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/item&gt;</code> syntax mentioned above. <em>but</em> some of these loaders use <code>reader.Name</code> to determine the name of the attribute to add to the object specified by <code>element</code>.<br>\nIn this case, <code>reader.Name</code> will be <code>\"attr\"</code>.</p>\n<p>So, in the file <code>WorldModel/WorldModel/GameLoader/ExtendedAttributeLoaders.cs</code>, it has:</p>\n<pre><code>       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(currentXmlElementName, result);\n            }\n</code></pre>\n<p>but it should should be:</p>\n<pre><code>       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                string attributeName = reader.GetAttribute(\"name\");\n                if (attributeName == null) {\n                  attributeName = currentXmlElementName;\n                }\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\n            }\n</code></pre>\n<p>and the same for the other classes in that file.</p>\n\n",
      "PostDate": "2018-02-28T23:36:28.7731486Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "84047cfc-1150-4e1e-a824-df27232d2bb3",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Note: Two ways to do the same thing:\r\n```\r\n    string attributeName = reader.GetAttribute(\"name\");\r\n    if (attributeName == null) {\r\n      attributeName = currentXmlElementName;\r\n    }\r\n```\r\nor\r\n```\r\n    string attributeName = currentXmlElementName;\r\n    if (attributeName == \"attr\") {\r\n      attributeName = reader.GetAttribute(\"name\");\r\n    }\r\n```\r\n\r\nBoth will cause annoying and hard to diagnose bugs in some crcumstances.\r\nThe former has a problem with `<someattribute name=\"somethingelse\">`\r\nThe latter will break on `<attr name=\"attr\">` (which from a cursory glance, I think might get turned into just `<attr>` in a saved game)\r\n\r\nI figured that the former will only happen if you're editing the XML. The latter could happen in a save game if the game allows you to name an attribute \"attr\". So I went for the one that's least likely to occur in some unexpecting user's game.\r\n\r\nHowever, as far as I can tell, Quest's existing code uses the latter.",
      "EditableFormat": "markdown",
      "HTML": "<p>Note: Two ways to do the same thing:</p>\n<pre><code>    string attributeName = reader.GetAttribute(\"name\");\n    if (attributeName == null) {\n      attributeName = currentXmlElementName;\n    }\n</code></pre>\n<p>or</p>\n<pre><code>    string attributeName = currentXmlElementName;\n    if (attributeName == \"attr\") {\n      attributeName = reader.GetAttribute(\"name\");\n    }\n</code></pre>\n<p>Both will cause annoying and hard to diagnose bugs in some crcumstances.<br>\nThe former has a problem with <code>&lt;someattribute name=\"somethingelse\"&gt;</code><br>\nThe latter will break on <code>&lt;attr name=\"attr\"&gt;</code> (which from a cursory glance, I think might get turned into just <code>&lt;attr&gt;</code> in a saved game)</p>\n<p>I figured that the former will only happen if you're editing the XML. The latter could happen in a save game if the game allows you to name an attribute \"attr\". So I went for the one that's least likely to occur in some unexpecting user's game.</p>\n<p>However, as far as I can tell, Quest's existing code uses the latter.</p>\n\n",
      "PostDate": "2018-02-28T23:47:32.4531841Z",
      "LastEditDate": "2018-02-28T23:57:07.3964701Z",
      "link": null
    },
    {
      "PostId": "97b1e038-021d-4e31-bfa2-a0770f867cce",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That makes sense, mrangel.\r\n\r\nSo, it's probably best to leave it be?",
      "EditableFormat": "markdown",
      "HTML": "<p>That makes sense, mrangel.</p>\n<p>So, it's probably best to leave it be?</p>\n\n",
      "PostDate": "2018-03-01T05:44:50.4535573Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8dcb1ee1-5738-4fde-88b8-044fea091d06",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "thanks to all of you for the work with trying to help me, I can barely understand the coding, but had/having a hard time in understand what its doing in terms of its design structure (as it's ambigious/abstract for each part/section of its code sections), jumping/branching around the encapsulation/modules, and etc, so your posts were very helpful, wish I could have figured/found/understood all that stuff out that you guys were able to, sighs, I still got a long ways to go with learning to code/program, sighs) ... I'll see if I can figure out how to deal with the bugs (presumably having to trace down all of the interconnections with the part of the code mrangel, pixie, and KV found)...",
      "EditableFormat": "markdown",
      "HTML": "<p>thanks to all of you for the work with trying to help me, I can barely understand the coding, but had/having a hard time in understand what its doing in terms of its design structure (as it's ambigious/abstract for each part/section of its code sections), jumping/branching around the encapsulation/modules, and etc, so your posts were very helpful, wish I could have figured/found/understood all that stuff out that you guys were able to, sighs, I still got a long ways to go with learning to code/program, sighs) ... I'll see if I can figure out how to deal with the bugs (presumably having to trace down all of the interconnections with the part of the code mrangel, pixie, and KV found)...</p>\n\n",
      "PostDate": "2018-03-01T09:54:46.0206343Z",
      "LastEditDate": "2018-03-01T09:56:10.185332Z",
      "link": null
    },
    {
      "PostId": "0f922a40-5010-45c1-9159-c9a7b5170417",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "There is a perhaps related issue that if you call an attribute \"object\" (and certain other names too), when the game is saved, it saves as:\r\n```\r\n<object>Some text</object>\r\n```\r\nWhen it then loads the game, it treats that as an object, rather than as an attribute called object. Is there a way we can sort all these issues (and still be backwards compatible?)",
      "EditableFormat": "markdown",
      "HTML": "<p>There is a perhaps related issue that if you call an attribute \"object\" (and certain other names too), when the game is saved, it saves as:</p>\n<pre><code>&lt;object&gt;Some text&lt;/object&gt;\n</code></pre>\n<p>When it then loads the game, it treats that as an object, rather than as an attribute called object. Is there a way we can sort all these issues (and still be backwards compatible?)</p>\n\n",
      "PostDate": "2018-03-01T09:54:46.3487599Z",
      "LastEditDate": "2018-03-01T09:55:15.4553791Z",
      "link": null
    },
    {
      "PostId": "8dac11db-8dbe-40fd-a877-9587eef721a1",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(Edit: This was written in response to KV's post; seems some other replies arrived while I was typing)\r\nI see no reason not to change it.\r\n\r\nIt's just that in the course of looking through this, I've seen what looks like an existing problem. The save functions will generate `<attributename type=\"type\">` elements for any attribute whose name is purely alphabetical. Even if the attribute name is \"attr\", \"object\", \"exit\", or something else that is an actual XML element. I've not tested it yet, but I'd be very surprised if that didn't end up with those attributes disappearing when you load a saved game.\r\n\r\nHas anyone tried this? If it behaves sanely,I'd be very interested to find out what I missed.",
      "EditableFormat": "markdown",
      "HTML": "<p>(Edit: This was written in response to KV's post; seems some other replies arrived while I was typing)<br>\nI see no reason not to change it.</p>\n<p>It's just that in the course of looking through this, I've seen what looks like an existing problem. The save functions will generate <code>&lt;attributename type=\"type\"&gt;</code> elements for any attribute whose name is purely alphabetical. Even if the attribute name is \"attr\", \"object\", \"exit\", or something else that is an actual XML element. I've not tested it yet, but I'd be very surprised if that didn't end up with those attributes disappearing when you load a saved game.</p>\n<p>Has anyone tried this? If it behaves sanely,I'd be very interested to find out what I missed.</p>\n\n",
      "PostDate": "2018-03-01T10:07:16.50701Z",
      "LastEditDate": "2018-03-01T10:19:05.773126Z",
      "link": null
    },
    {
      "PostId": "09496b78-c4b9-4e6d-84a2-2580e931b15a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Pixie:\r\nI've been looking into that.\r\nI've suggested code above to make `<attr name=\"whatever\">` syntax work for all types, including the ones that contain XML (dictionaries etc).\r\n\r\nI would then suggest modifying `WorldModel/WorldModel/GameLoader/FieldSaver.cs` …\r\nThe code:\r\n```\r\n        private abstract class FieldSaverBase : IFieldSaver\r\n        {\r\n            public abstract Type AppliesTo { get; }\r\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\r\n\r\n            private static Regex s_regex = new Regex(\"^[A-Za-z0-9]*$\");\r\n\r\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\r\n            {\r\n                if (!s_regex.IsMatch(attribute))\r\n                {\r\n                    // For attribute names with spaces or accented characters, we output\r\n                    //      <attr name=\"my attribute\" ... />\r\n                    writer.WriteStartElement(\"attr\");\r\n                    writer.WriteAttributeString(\"name\", attribute);\r\n                }\r\n                else\r\n                {\r\n                    // For attribute names without spaces, we output\r\n                    //      <myattribute ... />\r\n                    writer.WriteStartElement(attribute);\r\n                }\r\n```\r\nTwo possible suggestions.\r\n1: Always use `<attr>` (but keep recognising the other style when loading, for legacy compatibility)\r\n```\r\n        private abstract class FieldSaverBase : IFieldSaver\r\n        {\r\n            public abstract Type AppliesTo { get; }\r\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\r\n\r\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\r\n            {\r\n                // Now we always output\r\n                //      <attr name=\"my attribute\" ... />\r\n                writer.WriteStartElement(\"attr\");\r\n                writer.WriteAttributeString(\"name\", attribute);\r\n```\r\n2: specifically use `<attr>` for names that have specific meaning\r\n```\r\n        private abstract class FieldSaverBase : IFieldSaver\r\n        {\r\n            public abstract Type AppliesTo { get; }\r\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\r\n\r\n            // regex now matches attribute names that should be saved in <attr> form\r\n            private static Regex s_regex = new Regex(\"[^A-Za-z0-9]|attr|object|exit|command\");\r\n\r\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\r\n            {\r\n                // Note that I removed the ! from this expression\r\n                if (s_regex.IsMatch(attribute))\r\n                {\r\n                    // For attribute names with spaces or accented characters, we output\r\n                    //      <attr name=\"my attribute\" ... />\r\n                    writer.WriteStartElement(\"attr\");\r\n                    writer.WriteAttributeString(\"name\", attribute);\r\n                }\r\n                else\r\n                {\r\n                    // For attribute names without spaces, we output\r\n                    //      <myattribute ... />\r\n                    writer.WriteStartElement(attribute);\r\n                }\r\n```\r\n(I know my regex is heavy handed. But I cannot see a problem with using `<attr name=\"whatever\">` in cases that aren't strictly necessary)",
      "EditableFormat": "markdown",
      "HTML": "<p>Pixie:<br>\nI've been looking into that.<br>\nI've suggested code above to make <code>&lt;attr name=\"whatever\"&gt;</code> syntax work for all types, including the ones that contain XML (dictionaries etc).</p>\n<p>I would then suggest modifying <code>WorldModel/WorldModel/GameLoader/FieldSaver.cs</code> …<br>\nThe code:</p>\n<pre><code>        private abstract class FieldSaverBase : IFieldSaver\n        {\n            public abstract Type AppliesTo { get; }\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\n\n            private static Regex s_regex = new Regex(\"^[A-Za-z0-9]*$\");\n\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\n            {\n                if (!s_regex.IsMatch(attribute))\n                {\n                    // For attribute names with spaces or accented characters, we output\n                    //      &lt;attr name=\"my attribute\" ... /&gt;\n                    writer.WriteStartElement(\"attr\");\n                    writer.WriteAttributeString(\"name\", attribute);\n                }\n                else\n                {\n                    // For attribute names without spaces, we output\n                    //      &lt;myattribute ... /&gt;\n                    writer.WriteStartElement(attribute);\n                }\n</code></pre>\n<p>Two possible suggestions.<br>\n1: Always use <code>&lt;attr&gt;</code> (but keep recognising the other style when loading, for legacy compatibility)</p>\n<pre><code>        private abstract class FieldSaverBase : IFieldSaver\n        {\n            public abstract Type AppliesTo { get; }\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\n\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\n            {\n                // Now we always output\n                //      &lt;attr name=\"my attribute\" ... /&gt;\n                writer.WriteStartElement(\"attr\");\n                writer.WriteAttributeString(\"name\", attribute);\n</code></pre>\n<p>2: specifically use <code>&lt;attr&gt;</code> for names that have specific meaning</p>\n<pre><code>        private abstract class FieldSaverBase : IFieldSaver\n        {\n            public abstract Type AppliesTo { get; }\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\n\n            // regex now matches attribute names that should be saved in &lt;attr&gt; form\n            private static Regex s_regex = new Regex(\"[^A-Za-z0-9]|attr|object|exit|command\");\n\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\n            {\n                // Note that I removed the ! from this expression\n                if (s_regex.IsMatch(attribute))\n                {\n                    // For attribute names with spaces or accented characters, we output\n                    //      &lt;attr name=\"my attribute\" ... /&gt;\n                    writer.WriteStartElement(\"attr\");\n                    writer.WriteAttributeString(\"name\", attribute);\n                }\n                else\n                {\n                    // For attribute names without spaces, we output\n                    //      &lt;myattribute ... /&gt;\n                    writer.WriteStartElement(attribute);\n                }\n</code></pre>\n<p>(I know my regex is heavy handed. But I cannot see a problem with using <code>&lt;attr name=\"whatever\"&gt;</code> in cases that aren't strictly necessary)</p>\n\n",
      "PostDate": "2018-03-01T10:17:04.8016672Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bb771395-e220-4758-8bcf-cdd5b26e274a",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have Quest open in Visual Studio.\r\n\r\nSomebody tell me what to change, and I will test things out. ",
      "EditableFormat": "markdown",
      "HTML": "<p>I have Quest open in Visual Studio.</p>\n<p>Somebody tell me what to change, and I will test things out.</p>\n\n",
      "PostDate": "2018-03-01T16:13:27.6253278Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bcc42107-0a35-44b9-aee9-a28b02119354",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "While we're at it, maybe we could add things like:\r\n\r\n```\r\nint = 0\r\nint++\r\n\r\nmyString = \"Hello\"\r\nmyString += \", world!\"\r\n```\r\n\r\n---\r\nIf not, this is not a big deal.  It would be quite a luxury, though; wouldn't it?",
      "EditableFormat": "markdown",
      "HTML": "<p>While we're at it, maybe we could add things like:</p>\n<pre><code>int = 0\nint++\n\nmyString = \"Hello\"\nmyString += \", world!\"\n</code></pre>\n<hr>\n<p>If not, this is not a big deal.  It would be quite a luxury, though; wouldn't it?</p>\n\n",
      "PostDate": "2018-03-01T16:14:41.6273143Z",
      "LastEditDate": "2018-03-01T16:15:56.6272351Z",
      "link": null
    },
    {
      "PostId": "7d936679-77fa-45f0-b9a7-5b3e97356838",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@KV:\r\nIn `WorldModel/WorldModel/GameLoader/ExtendedAttributeLoaders.cs`\r\nthere are several classes that start off looking like:\r\n```\r\n  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(currentXmlElementName, result);\r\n            }\r\n```\r\n\r\nto fix the issue mentioned at the top of this thread, you will want to change those to:\r\n```\r\n  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                string attributeName = reader.GetAttribute(\"name\");\r\n                if ((currentXmlElementName != \"attr\") || (attributeName == null)) {\r\n                  attributeName = currentXmlElementName;\r\n                }\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\r\n            }\r\n```\r\n(each of them has a different line where it assigns something to `result`, which is the line that doesn't need changing in this example)\r\n\r\nFor fixing attributes named \"attr\", \"object\", \"exit\" etc (has anyone actually tested that? I only said that looking at the code, I would expect it to mess up the XML in a saved game) is a more complex issue, so we can deal with that as stage 2.",
      "EditableFormat": "markdown",
      "HTML": "<p>@KV:<br>\nIn <code>WorldModel/WorldModel/GameLoader/ExtendedAttributeLoaders.cs</code><br>\nthere are several classes that start off looking like:</p>\n<pre><code>  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(currentXmlElementName, result);\n            }\n</code></pre>\n<p>to fix the issue mentioned at the top of this thread, you will want to change those to:</p>\n<pre><code>  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                string attributeName = reader.GetAttribute(\"name\");\n                if ((currentXmlElementName != \"attr\") || (attributeName == null)) {\n                  attributeName = currentXmlElementName;\n                }\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\n            }\n</code></pre>\n<p>(each of them has a different line where it assigns something to <code>result</code>, which is the line that doesn't need changing in this example)</p>\n<p>For fixing attributes named \"attr\", \"object\", \"exit\" etc (has anyone actually tested that? I only said that looking at the code, I would expect it to mess up the XML in a saved game) is a more complex issue, so we can deal with that as stage 2.</p>\n\n",
      "PostDate": "2018-03-01T16:23:47.3579299Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "dfff8a1d-ca2a-4665-b170-11a5e7602936",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I changed the bit in ExtendedAttributeLoaders.cs to this:\r\n\r\n<details>\r\n\r\n```\r\n       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                string attributeName = reader.GetAttribute(\"name\");\r\n                if (attributeName == null) {\r\n                  attributeName = currentXmlElementName;\r\n                }\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\r\n            }\r\n```\r\n\r\n---\r\nThen, I changed the bit in FieldSaver.cs to this:\r\n\r\n```\r\nprivate abstract class FieldSaverBase : IFieldSaver\r\n        {\r\n            public abstract Type AppliesTo { get; }\r\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\r\n\r\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\r\n            {\r\n                // Now we always output\r\n                //      <attr name=\"my attribute\" ... />\r\n                writer.WriteStartElement(\"attr\");\r\n                writer.WriteAttributeString(\"name\", attribute);\r\n```\r\n\r\n</details>\r\n\r\n---\r\nThis code works now (and Quest does not alter the code in code view after reloading the game file):\r\n\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.7.6634.18786-->\r\n<asl version=\"550\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Dict Attr Tester\">\r\n    <attr name=\"gameid\">deb81fec-d0ec-41d7-8335-c9395e60b7ba</attr>\r\n    <attr name=\"version\">1.0</attr>\r\n    <attr name=\"firstpublished\">2018</attr>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <attr name=\"enter\" type=\"script\">\r\n      invoke(ScriptDictionaryItem(player.myDict,\"one\"))\r\n    </attr>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <attr name=\"myDict\" type=\"scriptdictionary\">\r\n        <item key=\"one\">msg(\"One\")</item>\r\n      </attr>\r\n    </object>\r\n  </object>\r\n</asl>\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I changed the bit in ExtendedAttributeLoaders.cs to this:</p>\n<details>\n<pre><code>       private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                string attributeName = reader.GetAttribute(\"name\");\n                if (attributeName == null) {\n                  attributeName = currentXmlElementName;\n                }\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\n            }\n</code></pre>\n<hr>\n<p>Then, I changed the bit in FieldSaver.cs to this:</p>\n<pre><code>private abstract class FieldSaverBase : IFieldSaver\n        {\n            public abstract Type AppliesTo { get; }\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\n\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\n            {\n                // Now we always output\n                //      &lt;attr name=\"my attribute\" ... /&gt;\n                writer.WriteStartElement(\"attr\");\n                writer.WriteAttributeString(\"name\", attribute);\n</code></pre>\n</details>\n<hr>\n<p>This code works now (and Quest does not alter the code in code view after reloading the game file):</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.7.6634.18786--&gt;\n&lt;asl version=\"550\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Dict Attr Tester\"&gt;\n    &lt;attr name=\"gameid\"&gt;deb81fec-d0ec-41d7-8335-c9395e60b7ba&lt;/attr&gt;\n    &lt;attr name=\"version\"&gt;1.0&lt;/attr&gt;\n    &lt;attr name=\"firstpublished\"&gt;2018&lt;/attr&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;attr name=\"enter\" type=\"script\"&gt;\n      invoke(ScriptDictionaryItem(player.myDict,\"one\"))\n    &lt;/attr&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;attr name=\"myDict\" type=\"scriptdictionary\"&gt;\n        &lt;item key=\"one\"&gt;msg(\"One\")&lt;/item&gt;\n      &lt;/attr&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2018-03-01T16:35:29.8871555Z",
      "LastEditDate": "2018-03-01T19:25:33.763413Z",
      "link": null
    },
    {
      "PostId": "61926e9d-fcb9-430b-8dc6-8ab410fad690",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Well, the game worked, but I got this when I ran the tests in VS:\r\n\r\n```\r\nTest Failed - Run Walkthrough\r\n\r\nMessage: Assert.IsTrue failed.Initialisation failed.\r\n```\r\n\r\n---\r\nI tried to run the tests a second time, because I've seen a test fail once, but pass 100 times afterwards.\r\n\r\nThis test fails.\r\n\r\nI'm going to try one of the alternative codes mrangel posted now.",
      "EditableFormat": "markdown",
      "HTML": "<p>Well, the game worked, but I got this when I ran the tests in VS:</p>\n<pre><code>Test Failed - Run Walkthrough\n\nMessage: Assert.IsTrue failed.Initialisation failed.\n</code></pre>\n<hr>\n<p>I tried to run the tests a second time, because I've seen a test fail once, but pass 100 times afterwards.</p>\n<p>This test fails.</p>\n<p>I'm going to try one of the alternative codes mrangel posted now.</p>\n\n",
      "PostDate": "2018-03-01T16:50:48.7590034Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ec72d11e-c045-48e7-ba21-04e3309322a7",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ah.\r\n\r\nmrangel posted while I was writing a post, and I missed it.\r\n\r\nTrying the last thing he posted now.\r\n\r\n(Undoing the change to FieldSaver.cs for now, too.)",
      "EditableFormat": "markdown",
      "HTML": "<p>Ah.</p>\n<p>mrangel posted while I was writing a post, and I missed it.</p>\n<p>Trying the last thing he posted now.</p>\n<p>(Undoing the change to FieldSaver.cs for now, too.)</p>\n\n",
      "PostDate": "2018-03-01T16:59:02.2858423Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "45ef0b5b-784f-4197-99b1-8137a7dae36d",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Okay...\r\n\r\nI undid the previous changes.\r\n\r\nThen, I only changed the existing code in  ExtendedAttributeLoaders.cs (starting at line 64) to this:\r\n\r\n<details>\r\n\r\n```\r\n  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"scriptdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                string currentXmlElementName = reader.Name;\r\n                string attributeName = reader.GetAttribute(\"name\");\r\n                if ((currentXmlElementName != \"attr\") || (attributeName == null)) {\r\n                  attributeName = currentXmlElementName;\r\n                }\r\n                Dictionary<string, string> result = LoadScriptDictionary(reader, current, currentXmlElementName);\r\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\r\n            }\r\n```\r\n\r\n</details>\r\n\r\n\r\n---\r\nNow, all the tests pass, and the example game still works.\r\n\r\nThe only thing:\r\n\r\nQuest changes the code when reloading the game now.\r\n\r\n...but you can still input the code as it is in the first version of this example game I posted.\r\n\r\nIt will just change it to this:\r\n\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.7.6634.20080-->\r\n<asl version=\"550\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Dict Attr Tester\">\r\n    <gameid>deb81fec-d0ec-41d7-8335-c9395e60b7ba</gameid>\r\n    <version>1.0</version>\r\n    <firstpublished>2018</firstpublished>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <enter type=\"script\">\r\n      invoke (ScriptDictionaryItem(player.myDict,\"one\"))\r\n    </enter>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <myDict type=\"scriptdictionary\">\r\n        <item key=\"one\">\r\n          msg (\"One\")\r\n        </item>\r\n      </myDict>\r\n    </object>\r\n  </object>\r\n</asl>\r\n```\r\n\r\n</details>\r\n\r\n---\r\nThe change to FieldSaver.cs was what kept Quest from changing the code around on reload.\r\n\r\nI'm going to try mrangel's alternate method to see if that will pass the tests.\r\n\r\n---\r\n>there are several classes that start off looking like:\r\n\r\nI don't see any more, but I'm still looking.\r\n\r\n---\r\n>For fixing attributes named \"attr\", \"object\", \"exit\" etc (has anyone actually tested that? \r\n\r\nI didn't test it, but Pixie has mentioned it a few times, so I take that as gospel.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Okay...</p>\n<p>I undid the previous changes.</p>\n<p>Then, I only changed the existing code in  ExtendedAttributeLoaders.cs (starting at line 64) to this:</p>\n<details>\n<pre><code>  private class ScriptDictionaryLoader : ExtendedAttributeLoaderBase, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"scriptdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                string currentXmlElementName = reader.Name;\n                string attributeName = reader.GetAttribute(\"name\");\n                if ((currentXmlElementName != \"attr\") || (attributeName == null)) {\n                  attributeName = currentXmlElementName;\n                }\n                Dictionary&lt;string, string&gt; result = LoadScriptDictionary(reader, current, currentXmlElementName);\n                current.Fields.LazyFields.AddScriptDictionary(attributeName, result);\n            }\n</code></pre>\n</details>\n<hr>\n<p>Now, all the tests pass, and the example game still works.</p>\n<p>The only thing:</p>\n<p>Quest changes the code when reloading the game now.</p>\n<p>...but you can still input the code as it is in the first version of this example game I posted.</p>\n<p>It will just change it to this:</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.7.6634.20080--&gt;\n&lt;asl version=\"550\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Dict Attr Tester\"&gt;\n    &lt;gameid&gt;deb81fec-d0ec-41d7-8335-c9395e60b7ba&lt;/gameid&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;firstpublished&gt;2018&lt;/firstpublished&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;enter type=\"script\"&gt;\n      invoke (ScriptDictionaryItem(player.myDict,\"one\"))\n    &lt;/enter&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;myDict type=\"scriptdictionary\"&gt;\n        &lt;item key=\"one\"&gt;\n          msg (\"One\")\n        &lt;/item&gt;\n      &lt;/myDict&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n<hr>\n<p>The change to FieldSaver.cs was what kept Quest from changing the code around on reload.</p>\n<p>I'm going to try mrangel's alternate method to see if that will pass the tests.</p>\n<hr>\n<blockquote>\n<p>there are several classes that start off looking like:</p>\n</blockquote>\n<p>I don't see any more, but I'm still looking.</p>\n<hr>\n<blockquote>\n<p>For fixing attributes named \"attr\", \"object\", \"exit\" etc (has anyone actually tested that?</p>\n</blockquote>\n<p>I didn't test it, but Pixie has mentioned it a few times, so I take that as gospel.</p>\n\n",
      "PostDate": "2018-03-01T17:21:11.2897401Z",
      "LastEditDate": "2018-03-01T19:26:59.0108128Z",
      "link": null
    },
    {
      "PostId": "20e454ac-3bac-4331-8dff-1c4cfb7dd041",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Now, I have changed the bit in FieldSaver.cs (starting at line 100) to this:\r\n\r\n<details>\r\n\r\n```\r\nprivate abstract class FieldSaverBase : IFieldSaver\r\n        {\r\n            public abstract Type AppliesTo { get; }\r\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\r\n\r\n            // regex now matches attribute names that should be saved in <attr> form\r\n            private static Regex s_regex = new Regex(\"[^A-Za-z0-9]|attr|object|exit|command\");\r\n\r\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\r\n            {\r\n                // Note that I removed the ! from this expression\r\n                if (s_regex.IsMatch(attribute))\r\n                {\r\n                    // For attribute names with spaces or accented characters, we output\r\n                    //      <attr name=\"my attribute\" ... />\r\n                    writer.WriteStartElement(\"attr\");\r\n                    writer.WriteAttributeString(\"name\", attribute);\r\n                }\r\n                else\r\n                {\r\n                    // For attribute names without spaces, we output\r\n                    //      <myattribute ... />\r\n                    writer.WriteStartElement(attribute);\r\n                }\r\n```\r\n\r\n</details>\r\n\r\n---\r\nThis passes all the tests in VS.\r\n\r\nAND, it doesn't delete (or change) the attribute I named ```object```.\r\n\r\nIt doesn't do the string dictionary correctly, but this is because I need to find the other bits that need changing in ExtendedAttributeLoaders.cs .  (The string dictionary loader code is not the same as the script dictionary loader.)\r\n\r\n---\r\nThis is what it changes my example game's code to after reloading (note: the string dictionary was once named \"stringDict\"):\r\n\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.7.6634.20567-->\r\n<asl version=\"550\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Dict Attr Tester\">\r\n    <gameid>deb81fec-d0ec-41d7-8335-c9395e60b7ba</gameid>\r\n    <version>1.0</version>\r\n    <firstpublished>2018</firstpublished>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <beforeenter type=\"script\">\r\n      msg (player.object)\r\n    </beforeenter>\r\n    <enter type=\"script\">\r\n      invoke (ScriptDictionaryItem(player.myDict,\"one\"))\r\n    </enter>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <attr type=\"stringdictionary\">\r\n        <item>\r\n          <key>first</key>\r\n          <value>This is first.</value>\r\n        </item>\r\n      </attr>\r\n      <myDict type=\"scriptdictionary\">\r\n        <item key=\"one\">\r\n          msg (\"One\")\r\n        </item>\r\n      </myDict>\r\n      <attr name=\"object\">TEST</attr>\r\n    </object>\r\n  </object>\r\n</asl>\r\n```\r\n\r\n</details>\r\n\r\n---\r\n<span style=\"display:none;\">FILLER</span>",
      "EditableFormat": "markdown",
      "HTML": "<p>Now, I have changed the bit in FieldSaver.cs (starting at line 100) to this:</p>\n<details>\n<pre><code>private abstract class FieldSaverBase : IFieldSaver\n        {\n            public abstract Type AppliesTo { get; }\n            public abstract void Save(GameXmlWriter writer, Element element, string attribute, object value);\n\n            // regex now matches attribute names that should be saved in &lt;attr&gt; form\n            private static Regex s_regex = new Regex(\"[^A-Za-z0-9]|attr|object|exit|command\");\n\n            protected void WriteAttribute(GameXmlWriter writer, Element element, string attribute, string type, string value)\n            {\n                // Note that I removed the ! from this expression\n                if (s_regex.IsMatch(attribute))\n                {\n                    // For attribute names with spaces or accented characters, we output\n                    //      &lt;attr name=\"my attribute\" ... /&gt;\n                    writer.WriteStartElement(\"attr\");\n                    writer.WriteAttributeString(\"name\", attribute);\n                }\n                else\n                {\n                    // For attribute names without spaces, we output\n                    //      &lt;myattribute ... /&gt;\n                    writer.WriteStartElement(attribute);\n                }\n</code></pre>\n</details>\n<hr>\n<p>This passes all the tests in VS.</p>\n<p>AND, it doesn't delete (or change) the attribute I named <code>object</code>.</p>\n<p>It doesn't do the string dictionary correctly, but this is because I need to find the other bits that need changing in ExtendedAttributeLoaders.cs .  (The string dictionary loader code is not the same as the script dictionary loader.)</p>\n<hr>\n<p>This is what it changes my example game's code to after reloading (note: the string dictionary was once named \"stringDict\"):</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.7.6634.20567--&gt;\n&lt;asl version=\"550\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Dict Attr Tester\"&gt;\n    &lt;gameid&gt;deb81fec-d0ec-41d7-8335-c9395e60b7ba&lt;/gameid&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;firstpublished&gt;2018&lt;/firstpublished&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;beforeenter type=\"script\"&gt;\n      msg (player.object)\n    &lt;/beforeenter&gt;\n    &lt;enter type=\"script\"&gt;\n      invoke (ScriptDictionaryItem(player.myDict,\"one\"))\n    &lt;/enter&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;attr type=\"stringdictionary\"&gt;\n        &lt;item&gt;\n          &lt;key&gt;first&lt;/key&gt;\n          &lt;value&gt;This is first.&lt;/value&gt;\n        &lt;/item&gt;\n      &lt;/attr&gt;\n      &lt;myDict type=\"scriptdictionary\"&gt;\n        &lt;item key=\"one\"&gt;\n          msg (\"One\")\n        &lt;/item&gt;\n      &lt;/myDict&gt;\n      &lt;attr name=\"object\"&gt;TEST&lt;/attr&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n<hr>\n<p><span style=\"display: none\">FILLER</span></p>\n\n",
      "PostDate": "2018-03-01T17:41:37.1341096Z",
      "LastEditDate": "2018-03-01T19:28:31.1107225Z",
      "link": null
    },
    {
      "PostId": "c0150a1c-10e1-42f0-8f03-4fc8a7a494ca",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm thinking these are the three classes that need to be fixed:\r\n\r\n```\r\nprivate class StringDictionaryLoader : DictionaryLoaderBase<string>, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"stringdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                var result = LoadDictionary(reader, current.Name);\r\n                current.Fields.Set(reader.Name, new QuestDictionary<string>(result));\r\n            }\r\n```\r\n\r\n```\r\nprivate class ObjectDictionaryLoader : DictionaryLoaderBase<string>, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"objectdictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                var result = LoadDictionary(reader, current.Name);\r\n                current.Fields.LazyFields.AddObjectDictionary(reader.Name, result);\r\n            }\r\n```\r\n\r\n```\r\nprivate class DictionaryLoader : DictionaryLoaderBase<object>, IValueLoader\r\n        {\r\n            public override string AppliesTo\r\n            {\r\n                get { return \"dictionary\"; }\r\n            }\r\n\r\n            public override void Load(XmlReader reader, Element current)\r\n            {\r\n                var result = LoadDictionary(reader, current.Name);\r\n                current.Fields.Set(reader.Name, new QuestDictionary<object>(result));\r\n            }\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm thinking these are the three classes that need to be fixed:</p>\n<pre><code>private class StringDictionaryLoader : DictionaryLoaderBase&lt;string&gt;, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"stringdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                var result = LoadDictionary(reader, current.Name);\n                current.Fields.Set(reader.Name, new QuestDictionary&lt;string&gt;(result));\n            }\n</code></pre>\n<pre><code>private class ObjectDictionaryLoader : DictionaryLoaderBase&lt;string&gt;, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"objectdictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                var result = LoadDictionary(reader, current.Name);\n                current.Fields.LazyFields.AddObjectDictionary(reader.Name, result);\n            }\n</code></pre>\n<pre><code>private class DictionaryLoader : DictionaryLoaderBase&lt;object&gt;, IValueLoader\n        {\n            public override string AppliesTo\n            {\n                get { return \"dictionary\"; }\n            }\n\n            public override void Load(XmlReader reader, Element current)\n            {\n                var result = LoadDictionary(reader, current.Name);\n                current.Fields.Set(reader.Name, new QuestDictionary&lt;object&gt;(result));\n            }\n</code></pre>\n\n",
      "PostDate": "2018-03-01T17:44:34.237444Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0b5b90a5-5a12-493c-a4d8-e4de54cfdca2",
      "UserId": 247325,
      "Username": "hegemonkhan",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a96cf34d8d97c57de38f54ee22b1759b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "wow, you guys are awesome! thanks for all the work and help you've done with this matter. When I got the time (been a bit busy), I'll study, follow, and learn closely the part of quest code that you guys helped with all of that stuff, as I want to understand how the quest code is working a bit, along with how you fixed it, and etc.\r\n\r\n-------------------\r\n\r\n@ KV:\r\n\r\nMy interest was in preserving and having/using the 'attr' (for Lists and Dictionaries), as that was what my topic was about doing.\r\n\r\nso if it is being altered by quest back away to the 'non-attr' syntax, then that defeats the whole point, lol",
      "EditableFormat": "markdown",
      "HTML": "<p>wow, you guys are awesome! thanks for all the work and help you've done with this matter. When I got the time (been a bit busy), I'll study, follow, and learn closely the part of quest code that you guys helped with all of that stuff, as I want to understand how the quest code is working a bit, along with how you fixed it, and etc.</p>\n<hr>\n<p>@ KV:</p>\n<p>My interest was in preserving and having/using the 'attr' (for Lists and Dictionaries), as that was what my topic was about doing.</p>\n<p>so if it is being altered by quest back away to the 'non-attr' syntax, then that defeats the whole point, lol</p>\n\n",
      "PostDate": "2018-03-01T18:30:42.3674216Z",
      "LastEditDate": "2018-03-01T18:32:16.1194522Z",
      "link": null
    },
    {
      "PostId": "8ae3168d-3e8e-4e95-8ffb-b65bc5df3bc9",
      "UserId": 318253,
      "Username": "K.V.",
      "AvatarUrl": "https://i.imgur.com/mBf7TBeb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That's what I was thinking, HK.\r\n\r\nThe [first bit of code mrangel posted for FieldSaver.cs](http://textadventures.co.uk/forum/quest/topic/iwvmnmidlecayvhbr0gb3a/hoping-for-help-on-how-to-get-the-attr-syntax-to-work-with-lists-and-dictionari#09496b78-c4b9-4e6d-84a2-2580e931b15a) did just that.\r\n\r\nIt even saved the enter script I set up in the GUI as:\r\n```\r\n<attr name=\"enter\" type=\"script\">\r\n  // Scripting\r\n</attr>\r\n```\r\n\r\n\r\n...but that code made the walkthrough test in Visual Studio fail.  (I may have just needed to alter some other code, to make it all work together.)",
      "EditableFormat": "markdown",
      "HTML": "<p>That's what I was thinking, HK.</p>\n<p>The <a href=\"http://textadventures.co.uk/forum/quest/topic/iwvmnmidlecayvhbr0gb3a/hoping-for-help-on-how-to-get-the-attr-syntax-to-work-with-lists-and-dictionari#09496b78-c4b9-4e6d-84a2-2580e931b15a\">first bit of code mrangel posted for FieldSaver.cs</a> did just that.</p>\n<p>It even saved the enter script I set up in the GUI as:</p>\n<pre><code>&lt;attr name=\"enter\" type=\"script\"&gt;\n  // Scripting\n&lt;/attr&gt;\n</code></pre>\n<p>...but that code made the walkthrough test in Visual Studio fail.  (I may have just needed to alter some other code, to make it all work together.)</p>\n\n",
      "PostDate": "2018-03-01T18:56:30.9111528Z",
      "LastEditDate": "2018-03-01T19:30:50.1567529Z",
      "link": null
    },
    {
      "PostId": "b9dd44ef-5589-4e06-a5ea-868455f5df0d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> ..but that code made the walkthrough test in Visual Studio fail.\r\n\r\nI expect that it's failing because the test explicitly expects it to save some attributes in the \"non-attr\" form; if games actually run fine, then it might mean that the test is checking for something it doesn't need to.\r\n\r\n> I'm thinking these are the three classes that need to be fixed:\r\n\r\nFrom a quick skim-read through ExtendedAttributeLoaders, it looks like the classes that need to be changed are:\r\n* ScriptDictionaryLoader\r\n* StringListLoader\r\n* ListLoader\r\n* StringDictionaryLoader\r\n* ObjectDictionaryLoader\r\n* DictionaryLoader\r\n\r\nThe lines that need to be changed are:\r\n* `current.Fields.LazyFields.Add`(Type)`(currentXmlElementName, `(some data)`)`\r\n* `current.Fields.LazyFields.Add`(Type)`(reader.Name, `(some data)`)`\r\n* `current.Fields.Set(reader.Name, `(some data)`)`\r\n\r\nIn each case replacing either `currentXmlElementName` or `reader.Name` with a new variable, and adding the code to deduce that variable before the XML is parsed.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>..but that code made the walkthrough test in Visual Studio fail.</p>\n</blockquote>\n<p>I expect that it's failing because the test explicitly expects it to save some attributes in the \"non-attr\" form; if games actually run fine, then it might mean that the test is checking for something it doesn't need to.</p>\n<blockquote>\n<p>I'm thinking these are the three classes that need to be fixed:</p>\n</blockquote>\n<p>From a quick skim-read through ExtendedAttributeLoaders, it looks like the classes that need to be changed are:</p>\n<ul>\n<li>ScriptDictionaryLoader</li>\n<li>StringListLoader</li>\n<li>ListLoader</li>\n<li>StringDictionaryLoader</li>\n<li>ObjectDictionaryLoader</li>\n<li>DictionaryLoader</li>\n</ul>\n<p>The lines that need to be changed are:</p>\n<ul>\n<li><code>current.Fields.LazyFields.Add</code>(Type)<code>(currentXmlElementName,</code>(some data)<code>)</code></li>\n<li><code>current.Fields.LazyFields.Add</code>(Type)<code>(reader.Name,</code>(some data)<code>)</code></li>\n<li><code>current.Fields.Set(reader.Name,</code>(some data)<code>)</code></li>\n</ul>\n<p>In each case replacing either <code>currentXmlElementName</code> or <code>reader.Name</code> with a new variable, and adding the code to deduce that variable before the XML is parsed.</p>\n\n",
      "PostDate": "2018-03-02T12:15:19.6470044Z",
      "LastEditDate": "2018-03-02T12:21:44.8027441Z",
      "link": null
    }
  ]
}
