{
  "Topic": {
    "TopicId": "gp4izvy0i0ccycofmcahuq",
    "ForumId": "10",
    "Title": "help fixing an error and help making cat behaviour?",
    "LastUpdated": "2020-09-27T11:09:49.3847455Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "ce84db80-c93a-46f6-b1bf-99037544c07e",
      "UserId": 491162,
      "Username": "TiberianEuanOfficialYT",
      "AvatarUrl": "https://i.imgur.com/NJd0KELb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "https://snipboard.io/JxAfmL.jpg\r\nLook above at the link.\r\n\r\n(PS: I solved the error, just need cat script.)",
      "EditableFormat": "markdown",
      "HTML": "<p>https://snipboard.io/JxAfmL.jpg<br>\nLook above at the link.</p>\n<p>(PS: I solved the error, just need cat script.)</p>\n\n",
      "PostDate": "2020-09-27T11:09:49.3847455Z",
      "LastEditDate": "2020-09-27T11:25:20.4068254Z",
      "link": null
    },
    {
      "PostId": "2852a96d-fee8-4760-98e7-b54201702395",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The cat should be a fairly simple turnscript. My usual approach is to work from the top down; taking the most general case first.\r\n\r\nI'll do this step by step rather than throwing a block of code at you, because hopefully that makes it easier to understand for the purpose of fixing problems.\r\n\r\nSo…\r\n\r\n> *and not move to other rooms while being held by the player*\r\n\r\nYou probably don't need to worry about this. Most NPC movement scripts just look for exits in the current room. If the cat's current room is the inventory, there aren't any exits there, so it won't move.\r\n\r\n> *i need it to walk around the ship too*\r\n\r\nThis is simple enough. First, find an exit from the room the cat is currently in:\r\n```\r\nexit = PickOneUnlockedExit (cat.parent)\r\n```\r\nThen we need to check if the exit is valid. If the player is holding the cat, or if all the exits are locked, then `exit` will be `null`. We need to check that before moving the cat:\r\n```\r\nexit = PickOneUnlockedExit (cat.parent)\r\nif (not exit = null and HasObject (exit, \"to\")) {\r\n  MoveObject (cat, exit.to)\r\n}\r\n```\r\nThe exit's `to` attribute points to the room on the other side. I check that `to` exists before moving, because it's possible to have an exit that doesn't go anywhere and runs a script instead, and you don't want the cat to follow these.\r\n\r\nHowever, at this point I have a thought. In my experience, cats tend to spend a lot of time sitting in front of closed doors, waiting for someone to open them. So maybe it would be better to have the cat pick an exit at random, and then if that exit is closed, don't move. That's an easy change to make:\r\n```\r\nexit = PickOneExit (cat.parent)\r\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\r\n  MoveObject (cat, exit.to)\r\n}\r\n```\r\nIf you want the cat to only go through certain doors, or you want to make the cat only move every other turn or something, you could add an extra `and` expression to that line\r\n\r\nWith most NPCs, you would also want to tell the player if a someone has moved into or out of the room they're in. Cats can be quiet, so you might not want this (the cat will just appear in the sidebar), but I'll assume you do.\r\n\r\nSo, you want to check if the cat is in the player's room, and if the destination is the player's room. Something like:\r\n```\r\nexit = PickOneExit (cat.parent)\r\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\r\n  if (cat.parent = game.pov.parent) {\r\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\r\n  }\r\n  if (exit.to = game.pov.parent) {\r\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\r\n  }\r\n  MoveObject (cat, exit.to)\r\n}\r\n```\r\n(I'm assuming you know the names of the rooms. Using `GetDisplayAlias (exit)` to get something like \"north\" would be another alternative, depending on the atmosphere you want to create)\r\n\r\n> *follow the player at random*\r\n\r\nActually following the player ends up being more complex than you think. However, there's an easier way – just give the cat a higher chance of walking into the room where the player is if they're in adjacent rooms. This could be as simple as:\r\n\r\n<pre><code>exit = PickOneExit (cat.parent)\r\n<b>if (RandomChance (75)) {\r\n  follow = GetExitByLink (cat.parent, game.pov.parent)\r\n  if (TypeOf (follow) = \"string\") {\r\n    exit = GetObject (follow)\r\n  }\r\n}</b>\r\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\r\n  if (cat.parent = game.pov.parent) {\r\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\r\n  }\r\n  if (exit.to = game.pov.parent) {\r\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\r\n  }\r\n  MoveObject (cat, exit.to)\r\n}</code></pre>\r\n`GetExitByLink` finds an exit between two rooms if there is one. If the exit exists, it returns the *name* of the exit, which we can use `GetObject` on to get the actual exit. If there is no exit between those rooms, it returns `null`. so we check that the returned value is a string before doing anything with it.\r\n\r\n> *take the items\r\nand not take items in the same room as the player*\r\n\r\nYou can put this in the same turnscript. You can put it before or after the cat moves. Or if you don't want the cat to move and pick up an object and move on the same turn, you could use an 'else' clause.\r\n\r\nI'll use the object's `take` attribute, which says whether it can be picked up. If you want to have a separate attribute to determine what objects the cat can pick up, just use that instead.\r\n```\r\nif (RandomChance (35)) {\r\n  objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n  list remove (objects, cat)\r\n  obj = PickOneObject (objects)\r\n  MoveObject (obj, cat)\r\n  cat.hidechildren = true\r\n}\r\n```\r\nI'd suggest making the cat a \"Surface\" (On the 'Container' tab), which means that the player can take objects away from it, and can see what it's holding by looking at it. In this case, `hidechildren` causes the object(s) in the cat to be hidden until the player looks at it.\r\n\r\nYou can change the description for an object's contents on the container tab somewhere, so that instead of \"Containing:\" it says \"Carrying:\" or \"Playing with:\" once the player has looked at it.\r\n\r\n> *after some time it should drop the item in the room it's in*\r\n\r\nThat's simple enough. If the cat can only hold one item, then I'd give it a simple percentage chance of either picking up or dropping an object (use the same dice roll for both, it's more efficient).\r\n\r\nSo it would look like:\r\n<pre><code>if (RandomChance (35)) {\r\n<b>  objectheld = PickOneObject (GetDirectChildren(cat))\r\n  if (objectheld = null) {</b>\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n    }\r\n<b>  }\r\n  else {\r\n    MoveObject (objectheld, cat.parent)\r\n  }</b>\r\n}</code></pre>\r\n\r\nIf you want to use different probabilities, you could just rearrange that a little:\r\n```\r\nobjectheld = PickOneObject (GetDirectChildren(cat))\r\nif (objectheld = null) {\r\n  // chance of picking up:\r\n  if (RandomChance (35)) {\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n    }\r\n  }\r\n}\r\nelse {\r\n  // chance of dropping\r\n  if (RandomChance (20)) {\r\n    MoveObject (objectheld, cat.parent)\r\n  }\r\n}\r\n```\r\n\r\n> *not take items in the same room as the player*\r\n\r\nThat's simple enough. I'll assume that you also don't want it to take items from the player if they're carrying the cat. So I use `Contains` (which is faster than most of the Scope functions) to check if the cat is in the player's room. This includes cases when the cat is in the room, the cat is in the inventory, or the cat is in a box in the same room, whether or not the box is closed)\r\n<pre><code><b>if (not Contains (game.pov.parent, cat)) {</b>\r\n  objectheld = PickOneObject (GetDirectChildren(cat))\r\n  if (objectheld = null) {\r\n    // chance of picking up:\r\n    if (RandomChance (35)) {\r\n      objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n      if (ListCount (objects) > 1) {\r\n        list remove (objects, cat)\r\n        obj = PickOneObject (objects)\r\n        MoveObject (obj, cat)\r\n        cat.hidechildren = true\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    // chance of dropping\r\n    if (RandomChance (20)) {\r\n      MoveObject (objectheld, cat.parent)\r\n    }\r\n  }\r\n<b>}</b></code></pre>\r\nIf the cat can drop objects near the player but not pick them up, you could just move the if statement around.\r\nBut if the cat is being carried and drops an item, you probably want to let the player know, so it would become:\r\n<pre><code>objectheld = PickOneObject (GetDirectChildren(cat))\r\nif (objectheld = null) {\r\n  // chance of picking up:\r\n  if (<b>not Contains (game.pov.parent, cat) and </b>RandomChance (35)) {\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n    }\r\n  }\r\n}\r\nelse {\r\n  // chance of dropping\r\n  if (RandomChance (20)) {\r\n<b>    if (cat.parent = game.pov) {\r\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\r\n      MoveObject (objectheld, game.pov.parent)\r\n    }\r\n    else {</b>\r\n      MoveObject (objectheld, cat.parent)\r\n    <b>}</b>\r\n  }\r\n}</code></pre>\r\n\r\n\r\n\r\n> *the player should not be able to see the object for a while until they step on it or look at their cat*\r\n\r\nNot entirely sure what you mean by 'step on it'. Do you mean that after the cat drops the object, it continues to be hidden for some length of time? I'd probably do that by making the object into scenery temporarily.\r\n\r\nI'd add 2 lines after the cat drops an object:\r\n```\r\nobjectheld.scenery = true\r\nobjectheld.lost = true\r\n```\r\nThen add a section to the beginning of the turnscript that lets the player 'find' these objects again. Something like:\r\n```\r\nrandomobj = PickOneObject (GetDirectChildren (game.pov.parent))\r\nif (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\r\n  msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\r\n  randomobj.scenery = false\r\n  randomobj.lost = false\r\n}\r\n```\r\nThis picks an object in the same room as the player, and if it's lost finds it again. It means that the more stuff is in a room, the longer it takes to find something by  chance.\r\n\r\nIf you want to make it a little easier on the player, you could make it so that when they deliberately look around the room (by typing `look`) they find any objects the cat has been playing with. Adding something like this to the beginning of the turnscript:\r\n```\r\nif (game.pov.currentcommandpattern = look) {\r\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\r\n  if (ListCount (found) > 0) {\r\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\r\n    foreach (obj, found) {\r\n      obj.lost = false\r\n      obj.scenery = false\r\n    }\r\n  }\r\n}\r\n```\r\n(Using `game.pov.currentcommandpattern` is a weird way for a turnscript to find out the last command that the player used. In this case, it's a relatively easy way to do things)\r\n\r\nYou could also add a little tweak to change the message when the player takes the object from the cat. Because the cat currently won't pick up objects that run a script when they are taken, you could add one like this (modifying the 'pick up/drop' part of the cat's script):\r\n<pre><code>objectheld = PickOneObject (GetDirectChildren(cat))\r\nif (objectheld = null) {\r\n  // chance of picking up:\r\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n      <b>obj.take => {\r\n        this.take = true\r\n        if (RandomChance (30)) {\r\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\r\n          MoveObjectHere (obj)\r\n          obj.lost = true\r\n          obj.scenery = true\r\n        }\r\n        else {\r\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\r\n          AddToInventory (this)\r\n        }\r\n      }</b>\r\n    }\r\n  }\r\n}\r\nelse {\r\n  // chance of dropping\r\n  if (RandomChance (20)) {\r\n    if (cat.parent = game.pov) {\r\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\r\n      MoveObject (objectheld, game.pov.parent)\r\n    }\r\n    else {\r\n      MoveObject (objectheld, cat.parent)\r\n      objectheld.lost = true\r\n      objectheld.scenery = true\r\n<b>      objectheld.take = true</b>\r\n    }\r\n  }\r\n}</code></pre>\r\n\r\nSo with all those bits, you'd have a turnscript whose script is:\r\n```\r\nif (game.pov.currentcommandpattern = look) {\r\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\r\n  if (ListCount (found) > 0) {\r\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\r\n    foreach (obj, found) {\r\n      obj.lost = false\r\n      obj.scenery = false\r\n    }\r\n  }\r\n}\r\nelse {\r\n  randomobj = PickOneObject (GetDirectChildren (game.pov.parent))\r\n  if (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\r\n    msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\r\n    randomobj.scenery = false\r\n    randomobj.lost = false\r\n  }\r\n}\r\n\r\nexit = PickOneExit (cat.parent)\r\nif (RandomChance (75)) {\r\n  follow = GetExitByLink (cat.parent, game.pov.parent)\r\n  if (TypeOf (follow) = \"string\") {\r\n    exit = GetObject (follow)\r\n  }\r\n}\r\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\r\n  if (cat.parent = game.pov.parent) {\r\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\r\n  }\r\n  if (exit.to = game.pov.parent) {\r\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\r\n  }\r\n  MoveObject (cat, exit.to)\r\n}\r\n\r\nobjectheld = PickOneObject (GetDirectChildren(cat))\r\nif (objectheld = null) {\r\n  // chance of picking up:\r\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n      obj.take => {\r\n        this.take = true\r\n        if (RandomChance (30)) {\r\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\r\n          MoveObjectHere (obj)\r\n          obj.lost = true\r\n          obj.scenery = true\r\n        }\r\n        else {\r\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\r\n          AddToInventory (this)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nelse {\r\n  // chance of dropping\r\n  if (RandomChance (20)) {\r\n    if (cat.parent = game.pov) {\r\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\r\n      MoveObject (objectheld, game.pov.parent)\r\n    }\r\n    else {\r\n      MoveObject (objectheld, cat.parent)\r\n      objectheld.lost = true\r\n      objectheld.scenery = true\r\n      objectheld.take = true\r\n    }\r\n  }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>The cat should be a fairly simple turnscript. My usual approach is to work from the top down; taking the most general case first.</p>\n<p>I'll do this step by step rather than throwing a block of code at you, because hopefully that makes it easier to understand for the purpose of fixing problems.</p>\n<p>So…</p>\n<blockquote>\n<p><em>and not move to other rooms while being held by the player</em></p>\n</blockquote>\n<p>You probably don't need to worry about this. Most NPC movement scripts just look for exits in the current room. If the cat's current room is the inventory, there aren't any exits there, so it won't move.</p>\n<blockquote>\n<p><em>i need it to walk around the ship too</em></p>\n</blockquote>\n<p>This is simple enough. First, find an exit from the room the cat is currently in:</p>\n<pre><code>exit = PickOneUnlockedExit (cat.parent)\n</code></pre>\n<p>Then we need to check if the exit is valid. If the player is holding the cat, or if all the exits are locked, then <code>exit</code> will be <code>null</code>. We need to check that before moving the cat:</p>\n<pre><code>exit = PickOneUnlockedExit (cat.parent)\nif (not exit = null and HasObject (exit, \"to\")) {\n  MoveObject (cat, exit.to)\n}\n</code></pre>\n<p>The exit's <code>to</code> attribute points to the room on the other side. I check that <code>to</code> exists before moving, because it's possible to have an exit that doesn't go anywhere and runs a script instead, and you don't want the cat to follow these.</p>\n<p>However, at this point I have a thought. In my experience, cats tend to spend a lot of time sitting in front of closed doors, waiting for someone to open them. So maybe it would be better to have the cat pick an exit at random, and then if that exit is closed, don't move. That's an easy change to make:</p>\n<pre><code>exit = PickOneExit (cat.parent)\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\n  MoveObject (cat, exit.to)\n}\n</code></pre>\n<p>If you want the cat to only go through certain doors, or you want to make the cat only move every other turn or something, you could add an extra <code>and</code> expression to that line</p>\n<p>With most NPCs, you would also want to tell the player if a someone has moved into or out of the room they're in. Cats can be quiet, so you might not want this (the cat will just appear in the sidebar), but I'll assume you do.</p>\n<p>So, you want to check if the cat is in the player's room, and if the destination is the player's room. Something like:</p>\n<pre><code>exit = PickOneExit (cat.parent)\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\n  if (cat.parent = game.pov.parent) {\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\n  }\n  if (exit.to = game.pov.parent) {\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\n  }\n  MoveObject (cat, exit.to)\n}\n</code></pre>\n<p>(I'm assuming you know the names of the rooms. Using <code>GetDisplayAlias (exit)</code> to get something like \"north\" would be another alternative, depending on the atmosphere you want to create)</p>\n<blockquote>\n<p><em>follow the player at random</em></p>\n</blockquote>\n<p>Actually following the player ends up being more complex than you think. However, there's an easier way – just give the cat a higher chance of walking into the room where the player is if they're in adjacent rooms. This could be as simple as:</p>\n<pre><code>exit = PickOneExit (cat.parent)\n<b>if (RandomChance (75)) {\n  follow = GetExitByLink (cat.parent, game.pov.parent)\n  if (TypeOf (follow) = \"string\") {\n    exit = GetObject (follow)\n  }\n}</b>\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\n  if (cat.parent = game.pov.parent) {\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\n  }\n  if (exit.to = game.pov.parent) {\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\n  }\n  MoveObject (cat, exit.to)\n}</code></pre>\n<p><code>GetExitByLink</code> finds an exit between two rooms if there is one. If the exit exists, it returns the <em>name</em> of the exit, which we can use <code>GetObject</code> on to get the actual exit. If there is no exit between those rooms, it returns <code>null</code>. so we check that the returned value is a string before doing anything with it.</p>\n<blockquote>\n<p><em>take the items<br>\nand not take items in the same room as the player</em></p>\n</blockquote>\n<p>You can put this in the same turnscript. You can put it before or after the cat moves. Or if you don't want the cat to move and pick up an object and move on the same turn, you could use an 'else' clause.</p>\n<p>I'll use the object's <code>take</code> attribute, which says whether it can be picked up. If you want to have a separate attribute to determine what objects the cat can pick up, just use that instead.</p>\n<pre><code>if (RandomChance (35)) {\n  objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n  list remove (objects, cat)\n  obj = PickOneObject (objects)\n  MoveObject (obj, cat)\n  cat.hidechildren = true\n}\n</code></pre>\n<p>I'd suggest making the cat a \"Surface\" (On the 'Container' tab), which means that the player can take objects away from it, and can see what it's holding by looking at it. In this case, <code>hidechildren</code> causes the object(s) in the cat to be hidden until the player looks at it.</p>\n<p>You can change the description for an object's contents on the container tab somewhere, so that instead of \"Containing:\" it says \"Carrying:\" or \"Playing with:\" once the player has looked at it.</p>\n<blockquote>\n<p><em>after some time it should drop the item in the room it's in</em></p>\n</blockquote>\n<p>That's simple enough. If the cat can only hold one item, then I'd give it a simple percentage chance of either picking up or dropping an object (use the same dice roll for both, it's more efficient).</p>\n<p>So it would look like:</p>\n<pre><code>if (RandomChance (35)) {\n<b>  objectheld = PickOneObject (GetDirectChildren(cat))\n  if (objectheld = null) {</b>\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n    }\n<b>  }\n  else {\n    MoveObject (objectheld, cat.parent)\n  }</b>\n}</code></pre>\n<p>If you want to use different probabilities, you could just rearrange that a little:</p>\n<pre><code>objectheld = PickOneObject (GetDirectChildren(cat))\nif (objectheld = null) {\n  // chance of picking up:\n  if (RandomChance (35)) {\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n    }\n  }\n}\nelse {\n  // chance of dropping\n  if (RandomChance (20)) {\n    MoveObject (objectheld, cat.parent)\n  }\n}\n</code></pre>\n<blockquote>\n<p><em>not take items in the same room as the player</em></p>\n</blockquote>\n<p>That's simple enough. I'll assume that you also don't want it to take items from the player if they're carrying the cat. So I use <code>Contains</code> (which is faster than most of the Scope functions) to check if the cat is in the player's room. This includes cases when the cat is in the room, the cat is in the inventory, or the cat is in a box in the same room, whether or not the box is closed)</p>\n<pre><code><b>if (not Contains (game.pov.parent, cat)) {</b>\n  objectheld = PickOneObject (GetDirectChildren(cat))\n  if (objectheld = null) {\n    // chance of picking up:\n    if (RandomChance (35)) {\n      objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n      if (ListCount (objects) &gt; 1) {\n        list remove (objects, cat)\n        obj = PickOneObject (objects)\n        MoveObject (obj, cat)\n        cat.hidechildren = true\n      }\n    }\n  }\n  else {\n    // chance of dropping\n    if (RandomChance (20)) {\n      MoveObject (objectheld, cat.parent)\n    }\n  }\n<b>}</b></code></pre>\n<p>If the cat can drop objects near the player but not pick them up, you could just move the if statement around.<br>\nBut if the cat is being carried and drops an item, you probably want to let the player know, so it would become:</p>\n<pre><code>objectheld = PickOneObject (GetDirectChildren(cat))\nif (objectheld = null) {\n  // chance of picking up:\n  if (<b>not Contains (game.pov.parent, cat) and </b>RandomChance (35)) {\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n    }\n  }\n}\nelse {\n  // chance of dropping\n  if (RandomChance (20)) {\n<b>    if (cat.parent = game.pov) {\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\n      MoveObject (objectheld, game.pov.parent)\n    }\n    else {</b>\n      MoveObject (objectheld, cat.parent)\n    <b>}</b>\n  }\n}</code></pre>\n<blockquote>\n<p><em>the player should not be able to see the object for a while until they step on it or look at their cat</em></p>\n</blockquote>\n<p>Not entirely sure what you mean by 'step on it'. Do you mean that after the cat drops the object, it continues to be hidden for some length of time? I'd probably do that by making the object into scenery temporarily.</p>\n<p>I'd add 2 lines after the cat drops an object:</p>\n<pre><code>objectheld.scenery = true\nobjectheld.lost = true\n</code></pre>\n<p>Then add a section to the beginning of the turnscript that lets the player 'find' these objects again. Something like:</p>\n<pre><code>randomobj = PickOneObject (GetDirectChildren (game.pov.parent))\nif (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\n  msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\n  randomobj.scenery = false\n  randomobj.lost = false\n}\n</code></pre>\n<p>This picks an object in the same room as the player, and if it's lost finds it again. It means that the more stuff is in a room, the longer it takes to find something by  chance.</p>\n<p>If you want to make it a little easier on the player, you could make it so that when they deliberately look around the room (by typing <code>look</code>) they find any objects the cat has been playing with. Adding something like this to the beginning of the turnscript:</p>\n<pre><code>if (game.pov.currentcommandpattern = look) {\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\n  if (ListCount (found) &gt; 0) {\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\n    foreach (obj, found) {\n      obj.lost = false\n      obj.scenery = false\n    }\n  }\n}\n</code></pre>\n<p>(Using <code>game.pov.currentcommandpattern</code> is a weird way for a turnscript to find out the last command that the player used. In this case, it's a relatively easy way to do things)</p>\n<p>You could also add a little tweak to change the message when the player takes the object from the cat. Because the cat currently won't pick up objects that run a script when they are taken, you could add one like this (modifying the 'pick up/drop' part of the cat's script):</p>\n<pre><code>objectheld = PickOneObject (GetDirectChildren(cat))\nif (objectheld = null) {\n  // chance of picking up:\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n      <b>obj.take =&gt; {\n        this.take = true\n        if (RandomChance (30)) {\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\n          MoveObjectHere (obj)\n          obj.lost = true\n          obj.scenery = true\n        }\n        else {\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\n          AddToInventory (this)\n        }\n      }</b>\n    }\n  }\n}\nelse {\n  // chance of dropping\n  if (RandomChance (20)) {\n    if (cat.parent = game.pov) {\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\n      MoveObject (objectheld, game.pov.parent)\n    }\n    else {\n      MoveObject (objectheld, cat.parent)\n      objectheld.lost = true\n      objectheld.scenery = true\n<b>      objectheld.take = true</b>\n    }\n  }\n}</code></pre>\n<p>So with all those bits, you'd have a turnscript whose script is:</p>\n<pre><code>if (game.pov.currentcommandpattern = look) {\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\n  if (ListCount (found) &gt; 0) {\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\n    foreach (obj, found) {\n      obj.lost = false\n      obj.scenery = false\n    }\n  }\n}\nelse {\n  randomobj = PickOneObject (GetDirectChildren (game.pov.parent))\n  if (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\n    msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\n    randomobj.scenery = false\n    randomobj.lost = false\n  }\n}\n\nexit = PickOneExit (cat.parent)\nif (RandomChance (75)) {\n  follow = GetExitByLink (cat.parent, game.pov.parent)\n  if (TypeOf (follow) = \"string\") {\n    exit = GetObject (follow)\n  }\n}\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\n  if (cat.parent = game.pov.parent) {\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\n  }\n  if (exit.to = game.pov.parent) {\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\n  }\n  MoveObject (cat, exit.to)\n}\n\nobjectheld = PickOneObject (GetDirectChildren(cat))\nif (objectheld = null) {\n  // chance of picking up:\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n      obj.take =&gt; {\n        this.take = true\n        if (RandomChance (30)) {\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\n          MoveObjectHere (obj)\n          obj.lost = true\n          obj.scenery = true\n        }\n        else {\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\n          AddToInventory (this)\n        }\n      }\n    }\n  }\n}\nelse {\n  // chance of dropping\n  if (RandomChance (20)) {\n    if (cat.parent = game.pov) {\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\n      MoveObject (objectheld, game.pov.parent)\n    }\n    else {\n      MoveObject (objectheld, cat.parent)\n      objectheld.lost = true\n      objectheld.scenery = true\n      objectheld.take = true\n    }\n  }\n}\n</code></pre>\n\n",
      "PostDate": "2020-09-27T14:38:29.765961Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "65c5bfae-ed21-40c9-833f-1d68cb3b2831",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Edit:\r\nI realise that using scenery like this might result in some odd behaviour. If the cat plays with an object then puts it back in the same room, then the player picks it up by typing the command (because they knew where they left it and didn't notice that it was missing from the list), they'll be able to clear the `scenery` flag but the `lost` flag will still be there.\r\n\r\nIn this case, it might be advantageous to use the `take` script again to clear up any confusion:\r\n```\r\nif (game.pov.currentcommandpattern = look) {\r\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\r\n  if (ListCount (found) > 0) {\r\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\r\n    foreach (obj, found) {\r\n      obj.lost = false\r\n      obj.scenery = false\r\n      obj.take = true\r\n    }\r\n  }\r\n}\r\nelse {\r\n  randomobj = PickOneObject (GetDirectChildren (game.pov.parent))\r\n  if (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\r\n    msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\r\n    randomobj.scenery = false\r\n    randomobj.lost = false\r\n    randomobj.take = true\r\n  }\r\n}\r\n\r\nexit = PickOneExit (cat.parent)\r\nif (RandomChance (75)) {\r\n  follow = GetExitByLink (cat.parent, game.pov.parent)\r\n  if (TypeOf (follow) = \"string\") {\r\n    exit = GetObject (follow)\r\n  }\r\n}\r\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\r\n  if (cat.parent = game.pov.parent) {\r\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\r\n  }\r\n  if (exit.to = game.pov.parent) {\r\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\r\n  }\r\n  MoveObject (cat, exit.to)\r\n}\r\n\r\nobjectheld = PickOneObject (GetDirectChildren(cat))\r\nif (objectheld = null) {\r\n  // chance of picking up:\r\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\r\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\r\n    if (ListCount (objects) > 1) {\r\n      list remove (objects, cat)\r\n      obj = PickOneObject (objects)\r\n      MoveObject (obj, cat)\r\n      cat.hidechildren = true\r\n      obj.take => {\r\n        if (RandomChance (30)) {\r\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\r\n          MoveObjectHere (obj)\r\n          this.lost = true\r\n          this.scenery = true\r\n          this.take => {\r\n            if (RandomChance (80)) {\r\n              msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\r\n              this.lost = false\r\n              this.scenery = false\r\n              this.take = true\r\n              AddToInventory (this)\r\n            }\r\n            else {\r\n              msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\r\n          AddToInventory (this)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nelse {\r\n  // chance of dropping\r\n  if (RandomChance (20)) {\r\n    if (cat.parent = game.pov) {\r\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\r\n      MoveObject (objectheld, game.pov.parent)\r\n    }\r\n    else {\r\n      MoveObject (objectheld, cat.parent)\r\n    }\r\n    objectheld.lost = true\r\n    objectheld.scenery = true\r\n    objectheld.take => {\r\n      if (RandomChance (80)) {\r\n        msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\r\n        this.lost = false\r\n        this.scenery = false\r\n        this.take = true\r\n        AddToInventory (this)\r\n      }\r\n      else {\r\n        msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI've also got thoughts about cats and their tendency to climb into any open boxes they see, which would make the script a little more complex. Let me know if you'd like to try that.",
      "EditableFormat": "markdown",
      "HTML": "<p>Edit:<br>\nI realise that using scenery like this might result in some odd behaviour. If the cat plays with an object then puts it back in the same room, then the player picks it up by typing the command (because they knew where they left it and didn't notice that it was missing from the list), they'll be able to clear the <code>scenery</code> flag but the <code>lost</code> flag will still be there.</p>\n<p>In this case, it might be advantageous to use the <code>take</code> script again to clear up any confusion:</p>\n<pre><code>if (game.pov.currentcommandpattern = look) {\n  found = FilterByAttribute (ScopeVisible(), \"lost\", true)\n  if (ListCount (found) &gt; 0) {\n    msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\n    foreach (obj, found) {\n      obj.lost = false\n      obj.scenery = false\n      obj.take = true\n    }\n  }\n}\nelse {\n  randomobj = PickOneObject (GetDirectChildren (game.pov.parent))\n  if (not randomobj = null and GetBoolean (randomobj, \"lost\")) {\n    msg (\"You almost trip over \" + GetDisplayName (randomobj) + \" that your cat has left lying around.\")\n    randomobj.scenery = false\n    randomobj.lost = false\n    randomobj.take = true\n  }\n}\n\nexit = PickOneExit (cat.parent)\nif (RandomChance (75)) {\n  follow = GetExitByLink (cat.parent, game.pov.parent)\n  if (TypeOf (follow) = \"string\") {\n    exit = GetObject (follow)\n  }\n}\nif (not exit = null and HasObject (exit, \"to\") and not GetBoolean (exit, \"locked\")) {\n  if (cat.parent = game.pov.parent) {\n    msg (\"The cat wanders off to the \" + GetDisplayAlias (exit.to) + \".\")\n  }\n  if (exit.to = game.pov.parent) {\n    msg (\"Your {object:cat} walks in from the \" + GetDisplayAlias (cat.parent) + \".\")\n  }\n  MoveObject (cat, exit.to)\n}\n\nobjectheld = PickOneObject (GetDirectChildren(cat))\nif (objectheld = null) {\n  // chance of picking up:\n  if (not Contains (game.pov.parent, cat) and RandomChance (35)) {\n    objects = FilterByAttribute (GetDirectChildren (cat.parent), \"take\", true)\n    if (ListCount (objects) &gt; 1) {\n      list remove (objects, cat)\n      obj = PickOneObject (objects)\n      MoveObject (obj, cat)\n      cat.hidechildren = true\n      obj.take =&gt; {\n        if (RandomChance (30)) {\n          msg (\"You try to take the {object:\" + this.name + \"}, but the {object:cat} bats it into the far corner of the room.\")\n          MoveObjectHere (obj)\n          this.lost = true\n          this.scenery = true\n          this.take =&gt; {\n            if (RandomChance (80)) {\n              msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\n              this.lost = false\n              this.scenery = false\n              this.take = true\n              AddToInventory (this)\n            }\n            else {\n              msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\n            }\n          }\n        }\n        else {\n          msg (\"With some effort, you persuade the {object:cat} to let go of {cat.possessive} toy.\")\n          AddToInventory (this)\n        }\n      }\n    }\n  }\n}\nelse {\n  // chance of dropping\n  if (RandomChance (20)) {\n    if (cat.parent = game.pov) {\n      msg (\"The cat spits out something, and you look down in time to see \" + GetDisplayName(objectheld) + \" hit the floor.\")\n      MoveObject (objectheld, game.pov.parent)\n    }\n    else {\n      MoveObject (objectheld, cat.parent)\n    }\n    objectheld.lost = true\n    objectheld.scenery = true\n    objectheld.take =&gt; {\n      if (RandomChance (80)) {\n        msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\n        this.lost = false\n        this.scenery = false\n        this.take = true\n        AddToInventory (this)\n      }\n      else {\n        msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\n      }\n    }\n  }\n}\n</code></pre>\n<p>I've also got thoughts about cats and their tendency to climb into any open boxes they see, which would make the script a little more complex. Let me know if you'd like to try that.</p>\n\n",
      "PostDate": "2020-09-27T15:13:49.492177Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "7428d861-24d8-4b26-994f-d3b3e50fefe8",
      "UserId": 432182,
      "Username": "Mataeus",
      "AvatarUrl": "https://i.imgur.com/67NYu7hb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I can't believe you wrote that entire thing for the developer. That's above and beyond! ",
      "EditableFormat": "markdown",
      "HTML": "<p>I can't believe you wrote that entire thing for the developer. That's above and beyond!</p>\n\n",
      "PostDate": "2020-09-27T16:42:56.6744789Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "78e46f54-45aa-4c3d-af1d-00043bae2229",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Now I'm looking at the 'getting into boxes' thing.\r\n\r\nThink it might be interesting to give some objects a 'cat behaviour' thing. Like, you can give objects a verb that the cat can use.\r\n\r\nSo the cat picks an object at random in the room it ends the turn in.\r\n\r\nIf that object has a 'catdoes' verb, run the script. If it's a message, print the message only if the player is in the room. So you can have the cat scratching at things, or sniffing things, which has no effect but gives the player a sense that the cat is a real thing.\r\n\r\nOtherwise, if the object is an open box (or a surface) the cat gets in/on it.\r\n\r\nOtherwise, if the object can be taken, the cat isn't carrying anything, and the player isn't present, the cat picks it up.\r\n\r\nIf you have a verb that you don't want the player to use (makes it easier in the editor, especially using the web editor), you can put something like `dictionary remove (game.verbattributeslookup, \"catdoes\")`, `list remove (game.verbattributes, \"catdoes\")`, and `destroy (\"catdoes\")` in the start script to remove that verb at the start of the game.",
      "EditableFormat": "markdown",
      "HTML": "<p>Now I'm looking at the 'getting into boxes' thing.</p>\n<p>Think it might be interesting to give some objects a 'cat behaviour' thing. Like, you can give objects a verb that the cat can use.</p>\n<p>So the cat picks an object at random in the room it ends the turn in.</p>\n<p>If that object has a 'catdoes' verb, run the script. If it's a message, print the message only if the player is in the room. So you can have the cat scratching at things, or sniffing things, which has no effect but gives the player a sense that the cat is a real thing.</p>\n<p>Otherwise, if the object is an open box (or a surface) the cat gets in/on it.</p>\n<p>Otherwise, if the object can be taken, the cat isn't carrying anything, and the player isn't present, the cat picks it up.</p>\n<p>If you have a verb that you don't want the player to use (makes it easier in the editor, especially using the web editor), you can put something like <code>dictionary remove (game.verbattributeslookup, \"catdoes\")</code>, <code>list remove (game.verbattributes, \"catdoes\")</code>, and <code>destroy (\"catdoes\")</code> in the start script to remove that verb at the start of the game.</p>\n\n",
      "PostDate": "2020-09-28T13:29:28.540373Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b1a92992-82b4-4279-a42d-d5ca11c8d5c7",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Here's a revised cat turnscript. A little different, but this is probably how I'd do it if it were my game.\r\n\r\n<details><summary>Click here for code</summary>\r\nNOTE: This was written off the top of my head on the forum, not tested, and I haven't tried it in Quest. So there may be typos. May also be logic errors, especially as my mum walked into the room and started rearranging the furniture behind me about twenty minutes ago.\r\nIf you need help making it work, let me know.\r\n\r\nEDIT: Modified to include the part about letting the player find stuff the cat has hidden. Now, it will find any objects that the player has typed the name of in their command, anything that somehow got into the inventory without being found, as well as testing one random object in the room. Using the \"look\" command will still find everything.\r\n\r\n```\r\nresult = \"\"\r\nobject = cat\r\nparams = NewDictionary()\r\n\r\n// check if the player is messing with the cat\r\ncat.interact = Contains (game.pov, cat)\r\nif (HasAttribute(game.pov, \"currentcommandresolvedobjects\")) {\r\n  if (ListContains (game.pov.currentcommandresolvedobjects, cat)) {\r\n    cat.interact = true\r\n  }\r\n}\r\nelse {\r\n  game.pov.currentcommandresolvedobjects = NewObjectList()\r\n}\r\ndictionary add (params, \"interact\", cat.interact)\r\n\r\n// first, the stuff for finding objects that the cat has hidden\r\nif (game.pov.currentcommandpattern = look) {\r\n  found = ScopeVisible()\r\n}\r\nelse {\r\n  found = ListCombine (ScopeInventory(), game.pov.currentcommandresolvedobjects)\r\n  list add(found, PickOneObject (GetDirectChildren (game.pov.parent)))\r\n  list add(found, PickOneObject (ScopeReachableNotHeld()))\r\n}\r\nfound  = ListCompact (found)\r\nfound  = FilterByAttribute (found, \"lost\", true)\r\nshowfound = NewObjectList()\r\nif (ListCount (found) > 0) {\r\n  foreach (obj, found) {\r\n    obj.lost = false\r\n    obj.scenery = false\r\n    obj.take = true\r\n    if (GetBoolean (obj, \"visible\") and not Contains (game.pov, obj)) {\r\n      list add (showfound, obj)\r\n    }\r\n  }\r\n}\r\nif (ListCount (found) > 0) {\r\n  msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\r\n}\r\n\r\n// Only have the cat do stuff if it's awake\r\nif (HasInt (cat, \"sleeping\")) {\r\n  cat.sleeping = cat.sleeping - GetRandomInt (-3, 12)\r\n  // cat has more chance of waking up if the player used a command on it\r\n  if (cat.interact) {\r\n    if (game.pov.currentcommandpattern = lookat) {\r\n      cat.sleeping = cat.sleeping - GetRandomInt (0,5)\r\n    }\r\n    else {\r\n      cat.sleeping = cat.sleeping - GetRandomInt (15,25)\r\n      cat.startled = true\r\n    }\r\n  }\r\n  else if (GetBoolean (cat, \"startled\") and RandomChance (20)) {\r\n    cat.startled = false\r\n  }\r\n  if (cat.sleeping < 0) {\r\n    cat.sleeping = null\r\n    if (Contains (game.pov.parent, cat)) {\r\n      result = cat.wakemessage\r\n    }\r\n  }\r\n}\r\nelse if (HasObject (cat, \"parent\")) {\r\n  // cat is awake and has not been RemoveObject'ed\r\n\r\n  // First, we get a list of everything the cat could interact with\r\n  objects = ListCombine (GetDirectChildren(cat.parent), ScopeExitsForRoom(cat.parent))\r\n  list add (objects, cat.parent)\r\n  if (HasObject (cat, \"carrying\")) {\r\n    list add (objects, cat.carrying)\r\n    list add (objects, cat.carrying)\r\n  }\r\n  options = NewStringList()\r\n  foreach (obj, objects) {\r\n    if (HasString (obj, \"catactions\")) {\r\n      obj.catactions = Split (obj.catactions)\r\n    }\r\n    if (HasScript (obj, \"catactions\")) {\r\n      list add (options, obj.name + \":catactions\")\r\n    }\r\n    else if (HasAttribute (obj, \"catactions\") and GetBoolean (obj, \"visible\")) {\r\n      if (not ListContains (obj.catactions, \"ignore\")) {\r\n        foreach (action, obj.catactions) {\r\n          digits = 0\r\n          while (IsInt (Left (action, digits))) digits = digits + 1\r\n          if (digits = 0) {\r\n            count = 1\r\n          }\r\n          else {\r\n            count = ToInt (Left (action, digits))\r\n            action = Mid (action, digits + 1)\r\n          }\r\n          list add (options, obj.name + \":\" + action)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // choose an action, and split it up into action and messages\r\n  action = PickOneString (options)\r\n  parts = TSplit(action + \":::\")\r\n  action = Trim(ListItem (parts, 0))\r\n  object = ListItem (parts, 0)\r\n  list remove (parts, object)\r\n  object = GetObject (object)\r\n  if (action = \"\") {\r\n    list remove (parts, \"\")\r\n  }\r\n  if (IsRegexpMatch(\"^(go|carry|message|sleep\\d*)$\", action) or HasScript (object, action) or HasString (object, action)) {\r\n    list remove (parts, action)\r\n  }\r\n  else if (DoesInherit (object, \"defaultexit\") or DoesInherit (object, \"container_base\")) {\r\n    action = \"go\"\r\n  }\r\n  else if (GetBoolean (object, \"take\") or GetBoolean (object, \"drop\") or object = cat.carrying) {\r\n    action = \"take\"\r\n  }\r\n  else {\r\n    action = \"message\"\r\n  }\r\n  mesg = ListItem (parts, 0)\r\n  failmsg = ListItem (parts, 1)\r\n  dictionary add (params,  \"action\", action)\r\n  dictionary add (params,  \"message\", mesg)\r\n  dictionary add (params,  \"failmessage\", failmsg)\r\n  cat.here = Contains (cat.parent, game.pov)\r\n  cat.seen = ListContains (ScopeVisible(), cat)\r\n  dictionary add (params,  \"here\", cat.here)\r\n  dictionary add (params,  \"seen\", cat.seen)\r\n  dictionary add (params,  \"carrying\", cat.carrying)\r\n\r\n  // Now we actually do the thing\r\n  switch (action) {\r\n    case (\"go\") {\r\n      if (DoesInherit (object, \"defaultexit\")) {\r\n        if (GetBoolean (object, \"locked\") or not HasObject (object, \"to\")) {\r\n          if (Contains (game.pov.parent, cat) or game.pov.parent = object.to) {\r\n            result = failmsg\r\n          }\r\n        }\r\n        else {\r\n          if (Contains (game.pov.parent, cat) or game.pov.parent = object.to) {\r\n            result = mesg\r\n          }\r\n          cat.parent = object.to\r\n        }\r\n      }\r\n      else {\r\n        // it's a container\r\n        if (GetBoolean (object, \"isopen\")) {\r\n          if (Contains (game.pov.parent, cat)) {\r\n            result = mesg\r\n          }\r\n          if (Contains (object, cat)) {\r\n            cat.parent = object.parent\r\n          }\r\n          else {\r\n            cat.parent = object\r\n          }\r\n        }\r\n        else if (Contains (game.pov.parent, cat)) {\r\n          result = failmesg\r\n        }\r\n      }\r\n    }\r\n    case (\"carry\") {\r\n      if (object = cat.carrying) {\r\n        if (cat.parent = game.pov) {\r\n          if (ListCount (parts) > 2) {\r\n            result = ListItem (parts, 2)\r\n          else {\r\n            result = mesg\r\n          }\r\n          MoveObject (object, game.pov.parent)\r\n        }\r\n        else {\r\n          MoveObject (object, cat.parent)\r\n          if (Contains (game.pov.parent, cat)) {\r\n            result = mesg\r\n          }\r\n        }\r\n        cat.carrying = null\r\n        object.lost = true\r\n        object.scenery = true\r\n        object.take => {\r\n          if (RandomChance (80)) {\r\n            msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\r\n            this.lost = false\r\n            this.scenery = false\r\n            this.take = true\r\n            AddToInventory (this)\r\n          }\r\n          else {\r\n            msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\r\n          }\r\n        }\r\n      }\r\n      else if (HasObject (cat, \"carrying\")) {\r\n        // cat is carrying something else\r\n        if (Contains (game.pov.parent, cat) and ListCount (parts) > 3) {\r\n          result = ListItem (parts, 3)\r\n        }\r\n      }\r\n      else if (ListContains (ScopeVisible(), cat)) {\r\n        result = failmsg\r\n      }\r\n      else if (GetBoolean (object, \"take\")) {\r\n        // picked up an item\r\n        cat.carrying = object\r\n      }\r\n    }\r\n    case (\"sleep\") {\r\n      if (ListContains (ScopeVisible(), cat)) {\r\n        result = mesg\r\n        cat.sleeping = 80\r\n        cat.wakemessage = failmsg\r\n        cat.startled = false\r\n      }\r\n    }\r\n    case (\"message\") {\r\n      if (Contains (game.pov.parent, cat)) {\r\n        result = mesg\r\n      }\r\n      else {\r\n        result = failmsg\r\n      }\r\n    }\r\n    default {\r\n      result = GetAttribute (object, action)\r\n    }\r\n  }\r\n}\r\n\r\n// And show the result\r\nswitch (TypeOf(result)) {\r\n  case (\"string\") {\r\n    if (LengthOf (result) > 0) {\r\n      game.text_processor_this = object\r\n      game.text_processor_variables = params\r\n      result = Trim (ProcessText (result))\r\n      if (LengthOf (result) > 0) {\r\n        msg (result)\r\n      }\r\n    }\r\n  }\r\n  case (\"script\") {\r\n    dictionary add (params, \"this\", object)\r\n    invoke (result, params)\r\n  }\r\n}\r\n```\r\n</details>\r\n\r\nThis assumes that each object the cat can interact with has an attribute `catactions`, which can either be a script, string, or stringlist. Default options, such as \"the cat paces around the room\" or \"the cat has fallen asleep in the doorway\" can be added to the cat itself, or the room. In the case of a string or stringlist, the format is something like: `action:message:failmessage`\r\n\r\nFor example, `3go:The cat wanders through the door {either here:to the kitchen:from the lounge}.:You can {either seen:see:hear} your cat scrabbling at the closed {either here:kitchen:lounge} door, eager to get through.`\r\n\r\nActions can be `go` (exits and containers), `carry` (which the player never sees, so the message is the cat dropping the item. The failmessage is if it can't pick up while the player is watching; the 3rd and 4th messages are for if it drops an item while being carried, or if it examines an item while already carrying something else), `message` (display a message if the player is in the room; the second message is for if the player isn't present, so you can have the cat making noise), `sleep` (the fail message is for when it wakes up), or the name of a script attribute on the object. If there's a number stuck to the beginning of the action, like `6sleep`, that makes the action 6 times more likely to be chosen.\r\n\r\nIf the action is omitted, we'll assume `go` for exits and containers, `carry` for moveable objects, and `message` otherwise.\r\n\r\nAdding `ignore` to an objects action list will cause the cat to ignore that object completely.\r\n\r\nThe attribute `cat.here` (or the parameter `here`) can be used in the text processor to check if the cat was in the same room as the player at the start of its action. This will be false if the cat is trying to go through a door into the player's current room, or is trying to get out of a box.\r\n\r\nSimilarly, you can use `cat.startled` in the wake-up message to see if the cat woke prematurely because the player disturbed it.",
      "EditableFormat": "markdown",
      "HTML": "<p>Here's a revised cat turnscript. A little different, but this is probably how I'd do it if it were my game.</p>\n<details><summary>Click here for code</summary>\nNOTE: This was written off the top of my head on the forum, not tested, and I haven't tried it in Quest. So there may be typos. May also be logic errors, especially as my mum walked into the room and started rearranging the furniture behind me about twenty minutes ago.\nIf you need help making it work, let me know.\n<p>EDIT: Modified to include the part about letting the player find stuff the cat has hidden. Now, it will find any objects that the player has typed the name of in their command, anything that somehow got into the inventory without being found, as well as testing one random object in the room. Using the \"look\" command will still find everything.</p>\n<pre><code>result = \"\"\nobject = cat\nparams = NewDictionary()\n\n// check if the player is messing with the cat\ncat.interact = Contains (game.pov, cat)\nif (HasAttribute(game.pov, \"currentcommandresolvedobjects\")) {\n  if (ListContains (game.pov.currentcommandresolvedobjects, cat)) {\n    cat.interact = true\n  }\n}\nelse {\n  game.pov.currentcommandresolvedobjects = NewObjectList()\n}\ndictionary add (params, \"interact\", cat.interact)\n\n// first, the stuff for finding objects that the cat has hidden\nif (game.pov.currentcommandpattern = look) {\n  found = ScopeVisible()\n}\nelse {\n  found = ListCombine (ScopeInventory(), game.pov.currentcommandresolvedobjects)\n  list add(found, PickOneObject (GetDirectChildren (game.pov.parent)))\n  list add(found, PickOneObject (ScopeReachableNotHeld()))\n}\nfound  = ListCompact (found)\nfound  = FilterByAttribute (found, \"lost\", true)\nshowfound = NewObjectList()\nif (ListCount (found) &gt; 0) {\n  foreach (obj, found) {\n    obj.lost = false\n    obj.scenery = false\n    obj.take = true\n    if (GetBoolean (obj, \"visible\") and not Contains (game.pov, obj)) {\n      list add (showfound, obj)\n    }\n  }\n}\nif (ListCount (found) &gt; 0) {\n  msg (\"While you are looking around, you find \" + FormatList (found, \", \", \", and\", \"\") + \" lying around on the floor.\")\n}\n\n// Only have the cat do stuff if it's awake\nif (HasInt (cat, \"sleeping\")) {\n  cat.sleeping = cat.sleeping - GetRandomInt (-3, 12)\n  // cat has more chance of waking up if the player used a command on it\n  if (cat.interact) {\n    if (game.pov.currentcommandpattern = lookat) {\n      cat.sleeping = cat.sleeping - GetRandomInt (0,5)\n    }\n    else {\n      cat.sleeping = cat.sleeping - GetRandomInt (15,25)\n      cat.startled = true\n    }\n  }\n  else if (GetBoolean (cat, \"startled\") and RandomChance (20)) {\n    cat.startled = false\n  }\n  if (cat.sleeping &lt; 0) {\n    cat.sleeping = null\n    if (Contains (game.pov.parent, cat)) {\n      result = cat.wakemessage\n    }\n  }\n}\nelse if (HasObject (cat, \"parent\")) {\n  // cat is awake and has not been RemoveObject'ed\n\n  // First, we get a list of everything the cat could interact with\n  objects = ListCombine (GetDirectChildren(cat.parent), ScopeExitsForRoom(cat.parent))\n  list add (objects, cat.parent)\n  if (HasObject (cat, \"carrying\")) {\n    list add (objects, cat.carrying)\n    list add (objects, cat.carrying)\n  }\n  options = NewStringList()\n  foreach (obj, objects) {\n    if (HasString (obj, \"catactions\")) {\n      obj.catactions = Split (obj.catactions)\n    }\n    if (HasScript (obj, \"catactions\")) {\n      list add (options, obj.name + \":catactions\")\n    }\n    else if (HasAttribute (obj, \"catactions\") and GetBoolean (obj, \"visible\")) {\n      if (not ListContains (obj.catactions, \"ignore\")) {\n        foreach (action, obj.catactions) {\n          digits = 0\n          while (IsInt (Left (action, digits))) digits = digits + 1\n          if (digits = 0) {\n            count = 1\n          }\n          else {\n            count = ToInt (Left (action, digits))\n            action = Mid (action, digits + 1)\n          }\n          list add (options, obj.name + \":\" + action)\n        }\n      }\n    }\n  }\n\n  // choose an action, and split it up into action and messages\n  action = PickOneString (options)\n  parts = TSplit(action + \":::\")\n  action = Trim(ListItem (parts, 0))\n  object = ListItem (parts, 0)\n  list remove (parts, object)\n  object = GetObject (object)\n  if (action = \"\") {\n    list remove (parts, \"\")\n  }\n  if (IsRegexpMatch(\"^(go|carry|message|sleep\\d*)$\", action) or HasScript (object, action) or HasString (object, action)) {\n    list remove (parts, action)\n  }\n  else if (DoesInherit (object, \"defaultexit\") or DoesInherit (object, \"container_base\")) {\n    action = \"go\"\n  }\n  else if (GetBoolean (object, \"take\") or GetBoolean (object, \"drop\") or object = cat.carrying) {\n    action = \"take\"\n  }\n  else {\n    action = \"message\"\n  }\n  mesg = ListItem (parts, 0)\n  failmsg = ListItem (parts, 1)\n  dictionary add (params,  \"action\", action)\n  dictionary add (params,  \"message\", mesg)\n  dictionary add (params,  \"failmessage\", failmsg)\n  cat.here = Contains (cat.parent, game.pov)\n  cat.seen = ListContains (ScopeVisible(), cat)\n  dictionary add (params,  \"here\", cat.here)\n  dictionary add (params,  \"seen\", cat.seen)\n  dictionary add (params,  \"carrying\", cat.carrying)\n\n  // Now we actually do the thing\n  switch (action) {\n    case (\"go\") {\n      if (DoesInherit (object, \"defaultexit\")) {\n        if (GetBoolean (object, \"locked\") or not HasObject (object, \"to\")) {\n          if (Contains (game.pov.parent, cat) or game.pov.parent = object.to) {\n            result = failmsg\n          }\n        }\n        else {\n          if (Contains (game.pov.parent, cat) or game.pov.parent = object.to) {\n            result = mesg\n          }\n          cat.parent = object.to\n        }\n      }\n      else {\n        // it's a container\n        if (GetBoolean (object, \"isopen\")) {\n          if (Contains (game.pov.parent, cat)) {\n            result = mesg\n          }\n          if (Contains (object, cat)) {\n            cat.parent = object.parent\n          }\n          else {\n            cat.parent = object\n          }\n        }\n        else if (Contains (game.pov.parent, cat)) {\n          result = failmesg\n        }\n      }\n    }\n    case (\"carry\") {\n      if (object = cat.carrying) {\n        if (cat.parent = game.pov) {\n          if (ListCount (parts) &gt; 2) {\n            result = ListItem (parts, 2)\n          else {\n            result = mesg\n          }\n          MoveObject (object, game.pov.parent)\n        }\n        else {\n          MoveObject (object, cat.parent)\n          if (Contains (game.pov.parent, cat)) {\n            result = mesg\n          }\n        }\n        cat.carrying = null\n        object.lost = true\n        object.scenery = true\n        object.take =&gt; {\n          if (RandomChance (80)) {\n            msg (\"You manage to find the \" + GetDisplayAlias (this) + \" where the cat had left it.\")\n            this.lost = false\n            this.scenery = false\n            this.take = true\n            AddToInventory (this)\n          }\n          else {\n            msg (\"The \" + GetDiaplayAlias (this) + \" isn't anywhere to be seen. The cat must have moved it, and you might need to {command:look} around to find it.\")\n          }\n        }\n      }\n      else if (HasObject (cat, \"carrying\")) {\n        // cat is carrying something else\n        if (Contains (game.pov.parent, cat) and ListCount (parts) &gt; 3) {\n          result = ListItem (parts, 3)\n        }\n      }\n      else if (ListContains (ScopeVisible(), cat)) {\n        result = failmsg\n      }\n      else if (GetBoolean (object, \"take\")) {\n        // picked up an item\n        cat.carrying = object\n      }\n    }\n    case (\"sleep\") {\n      if (ListContains (ScopeVisible(), cat)) {\n        result = mesg\n        cat.sleeping = 80\n        cat.wakemessage = failmsg\n        cat.startled = false\n      }\n    }\n    case (\"message\") {\n      if (Contains (game.pov.parent, cat)) {\n        result = mesg\n      }\n      else {\n        result = failmsg\n      }\n    }\n    default {\n      result = GetAttribute (object, action)\n    }\n  }\n}\n\n// And show the result\nswitch (TypeOf(result)) {\n  case (\"string\") {\n    if (LengthOf (result) &gt; 0) {\n      game.text_processor_this = object\n      game.text_processor_variables = params\n      result = Trim (ProcessText (result))\n      if (LengthOf (result) &gt; 0) {\n        msg (result)\n      }\n    }\n  }\n  case (\"script\") {\n    dictionary add (params, \"this\", object)\n    invoke (result, params)\n  }\n}\n</code></pre>\n</details>\n<p>This assumes that each object the cat can interact with has an attribute <code>catactions</code>, which can either be a script, string, or stringlist. Default options, such as \"the cat paces around the room\" or \"the cat has fallen asleep in the doorway\" can be added to the cat itself, or the room. In the case of a string or stringlist, the format is something like: <code>action:message:failmessage</code></p>\n<p>For example, <code>3go:The cat wanders through the door {either here:to the kitchen:from the lounge}.:You can {either seen:see:hear} your cat scrabbling at the closed {either here:kitchen:lounge} door, eager to get through.</code></p>\n<p>Actions can be <code>go</code> (exits and containers), <code>carry</code> (which the player never sees, so the message is the cat dropping the item. The failmessage is if it can't pick up while the player is watching; the 3rd and 4th messages are for if it drops an item while being carried, or if it examines an item while already carrying something else), <code>message</code> (display a message if the player is in the room; the second message is for if the player isn't present, so you can have the cat making noise), <code>sleep</code> (the fail message is for when it wakes up), or the name of a script attribute on the object. If there's a number stuck to the beginning of the action, like <code>6sleep</code>, that makes the action 6 times more likely to be chosen.</p>\n<p>If the action is omitted, we'll assume <code>go</code> for exits and containers, <code>carry</code> for moveable objects, and <code>message</code> otherwise.</p>\n<p>Adding <code>ignore</code> to an objects action list will cause the cat to ignore that object completely.</p>\n<p>The attribute <code>cat.here</code> (or the parameter <code>here</code>) can be used in the text processor to check if the cat was in the same room as the player at the start of its action. This will be false if the cat is trying to go through a door into the player's current room, or is trying to get out of a box.</p>\n<p>Similarly, you can use <code>cat.startled</code> in the wake-up message to see if the cat woke prematurely because the player disturbed it.</p>\n\n",
      "PostDate": "2020-09-30T14:10:51.9191727Z",
      "LastEditDate": "2020-09-30T14:50:08.2664131Z",
      "link": null
    }
  ]
}
