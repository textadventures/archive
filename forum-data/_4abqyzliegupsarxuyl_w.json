{
  "Topic": {
    "TopicId": "_4abqyzliegupsarxuyl_w",
    "ForumId": "10",
    "Title": "Making the parser more flexible",
    "LastUpdated": "2018-10-09T14:35:20.5811881Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "4779a67a-6f4b-4c39-8ef5-49544d020a05",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Another thought here.\r\n\r\nThis would be a big tweak, but it just occurred to me.\r\n\r\n`put 'gorillas in the mist' DVD in jack in the box`\r\n\r\nNeither greedy nor non-greedy patterns will allow that. But I think I can see a way it could be done.\r\nI'm thinking of a function, `GetAllCommandMatches ()`, which returns a list. Each element in the list is a dictionary with values for 'command', 'object1', and 'object2'. (In the case of multiple commands having patterns that match the same player input, they would be ordered by match strength)\r\n\r\nThe parser could then loop over the list, matching the \"object1\" and \"object2\" strings to objects in scope, and accept the first one where object1 and object2 are both sane object names.\r\n\r\nIt would need a lot of fiddling around with the details, but it basically comes down to:\r\n1. Modify the pattern. After each named match, add a second part. `(?=(?<afterobject1>.*$))`.\r\n    * This causes Populate to provide a string \"afterobject1\" which contains everything after the string that's in \"object1\"\r\n2. Repeat the match, but with the regex modified again. Between object1 and afterobject1 patterns, you add `\"(?!\" + Join (previous_afterobject1_values, \"$|\") + \"$)\"`\r\n     * This forces the regex to match any way of splitting up the string that isn't the same as the previous one.\r\n3. Repeat until you get a non-match",
      "EditableFormat": "markdown",
      "HTML": "<p>Another thought here.</p>\n<p>This would be a big tweak, but it just occurred to me.</p>\n<p><code>put 'gorillas in the mist' DVD in jack in the box</code></p>\n<p>Neither greedy nor non-greedy patterns will allow that. But I think I can see a way it could be done.<br>\nI'm thinking of a function, <code>GetAllCommandMatches ()</code>, which returns a list. Each element in the list is a dictionary with values for 'command', 'object1', and 'object2'. (In the case of multiple commands having patterns that match the same player input, they would be ordered by match strength)</p>\n<p>The parser could then loop over the list, matching the \"object1\" and \"object2\" strings to objects in scope, and accept the first one where object1 and object2 are both sane object names.</p>\n<p>It would need a lot of fiddling around with the details, but it basically comes down to:</p>\n<ol>\n<li>Modify the pattern. After each named match, add a second part. <code>(?=(?&lt;afterobject1&gt;.*$))</code>.\n<ul>\n<li>This causes Populate to provide a string \"afterobject1\" which contains everything after the string that's in \"object1\"</li>\n</ul>\n</li>\n<li>Repeat the match, but with the regex modified again. Between object1 and afterobject1 patterns, you add <code>\"(?!\" + Join (previous_afterobject1_values, \"$|\") + \"$)\"</code>\n<ul>\n<li>This forces the regex to match any way of splitting up the string that isn't the same as the previous one.</li>\n</ul>\n</li>\n<li>Repeat until you get a non-match</li>\n</ol>\n\n",
      "PostDate": "2018-10-09T14:35:20.5811881Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "eb6b7686-d638-4c58-b843-31c611070aeb",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That is a good idea, but besides the coding, it would mean updating every command pattern across  over a dozen languages, so it may not be happening soon, unless anyone wants to do a fork and do it themselves?",
      "EditableFormat": "markdown",
      "HTML": "<p>That is a good idea, but besides the coding, it would mean updating every command pattern across  over a dozen languages, so it may not be happening soon, unless anyone wants to do a fork and do it themselves?</p>\n\n",
      "PostDate": "2018-10-10T09:01:02.8978682Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "fa8fbe15-5101-4bc7-9e89-f5f27fe555df",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "No it wouldn't. The changes to the patterns would have to be made programatically, because you're changing the regex at each iteration of the match. It would be a slightly ugly piece of code, because you would have to effectively split the pattern on the `)` that corresponds to each `(?<`; so you'd have to walk through the string character by character to find them. But I don't think that should be a problem. You'd end up with a list in which each element is either a string (part of the pattern) or a dictionary containing the name of the parameter that ends here. Then loop over that list putting it back together into a pattern, with the extra bits in.\r\n\r\nObviously, that's likely to be an expensive operation; but it only needs to be done once for each pattern.\r\nTo make it more efficient, you could add a flag on commands specifying if it's necessary to use this method.",
      "EditableFormat": "markdown",
      "HTML": "<p>No it wouldn't. The changes to the patterns would have to be made programatically, because you're changing the regex at each iteration of the match. It would be a slightly ugly piece of code, because you would have to effectively split the pattern on the <code>)</code> that corresponds to each <code>(?&lt;</code>; so you'd have to walk through the string character by character to find them. But I don't think that should be a problem. You'd end up with a list in which each element is either a string (part of the pattern) or a dictionary containing the name of the parameter that ends here. Then loop over that list putting it back together into a pattern, with the extra bits in.</p>\n<p>Obviously, that's likely to be an expensive operation; but it only needs to be done once for each pattern.<br>\nTo make it more efficient, you could add a flag on commands specifying if it's necessary to use this method.</p>\n\n",
      "PostDate": "2018-10-10T09:19:01.9919895Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d0aeeef0-407f-4e7d-9507-c7291887d91d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I really need to cut my coding time down so I'm not staring at this for more than an hour at a time. So I'll try to come up with an implementation one function at a time.\r\n\r\n```\r\n<function name=\"SplitRegexParts\" parameters=\"pattern\" type=\"stringlist\">\r\n  result = NewStringList()\r\n  stack = NewList()\r\n  i = 0\r\n  building = \"\"\r\n  while (i < LengthOf(pattern)) {\r\n    i = i + 1\r\n    char = Mid (pattern, i, 1)\r\n    if (char = \"\\\\\") {\r\n      char = Mid (pattern, i, 2)\r\n      i = i + 1\r\n    }\r\n    building = building + char\r\n    if (char = \"(\") {\r\n      // is there a neater way to add an element to the beginning of a list?\r\n      push = NewList()\r\n      list add (push, IsRegexMatch (\"^\\\\(\\\\?<\\\\w+>\", Mid (pattern, i), \"startswithnamedsubgroup\"))\r\n      stack = ListCombine (push, stack)\r\n    }\r\n    else if (char = \")\") {\r\n      if (ListCount (stack) = 0) {\r\n        error (\"Unmatched ')' in regular expression\")\r\n      }\r\n      isPattern = ListItem (stack, 0)\r\n      list remove (stack, isPattern)\r\n      if (isPattern) {\r\n        if (Mid (pattern, i) = \")$\") {\r\n          i = i + 2\r\n          building = building + \"$\"\r\n        }\r\n        list add (result, building)\r\n        building = \"\"\r\n      }\r\n    }\r\n  }\r\n  if (not building = \"\") {\r\n    list add (result, building)\r\n  }\r\n  if (not EndsWith (pattern, \"$\")) {\r\n    list add (result, \"\")\r\n  }\r\n  if (not ListCount (stack) = 0) {\r\n    error (\"Unmatched '(' in regular expression\")\r\n  }\r\n  return (result)\r\n</function>\r\n```\r\nThis should split up a regular expression at the points where the extra `(?=(?<afterobject1>.*$))` clauses need to be added.\r\nFor example, it you gave it `\"^put (?<object1>.+) (in|on) (?<object2>.+)$\"`, it should return a stringlist with 2 elements, (`\"^put (?<object1>.+)\"` and `\" (in|on) (?<object2>.+)$\"`)\r\n\r\nThe extra regexen I mentioned earlier can be added between the elements in this string (but not at the end), to identify the point at which the break matched, and force it to break at different points.",
      "EditableFormat": "markdown",
      "HTML": "<p>I really need to cut my coding time down so I'm not staring at this for more than an hour at a time. So I'll try to come up with an implementation one function at a time.</p>\n<pre><code>&lt;function name=\"SplitRegexParts\" parameters=\"pattern\" type=\"stringlist\"&gt;\n  result = NewStringList()\n  stack = NewList()\n  i = 0\n  building = \"\"\n  while (i &lt; LengthOf(pattern)) {\n    i = i + 1\n    char = Mid (pattern, i, 1)\n    if (char = \"\\\\\") {\n      char = Mid (pattern, i, 2)\n      i = i + 1\n    }\n    building = building + char\n    if (char = \"(\") {\n      // is there a neater way to add an element to the beginning of a list?\n      push = NewList()\n      list add (push, IsRegexMatch (\"^\\\\(\\\\?&lt;\\\\w+&gt;\", Mid (pattern, i), \"startswithnamedsubgroup\"))\n      stack = ListCombine (push, stack)\n    }\n    else if (char = \")\") {\n      if (ListCount (stack) = 0) {\n        error (\"Unmatched ')' in regular expression\")\n      }\n      isPattern = ListItem (stack, 0)\n      list remove (stack, isPattern)\n      if (isPattern) {\n        if (Mid (pattern, i) = \")$\") {\n          i = i + 2\n          building = building + \"$\"\n        }\n        list add (result, building)\n        building = \"\"\n      }\n    }\n  }\n  if (not building = \"\") {\n    list add (result, building)\n  }\n  if (not EndsWith (pattern, \"$\")) {\n    list add (result, \"\")\n  }\n  if (not ListCount (stack) = 0) {\n    error (\"Unmatched '(' in regular expression\")\n  }\n  return (result)\n&lt;/function&gt;\n</code></pre>\n<p>This should split up a regular expression at the points where the extra <code>(?=(?&lt;afterobject1&gt;.*$))</code> clauses need to be added.<br>\nFor example, it you gave it <code>\"^put (?&lt;object1&gt;.+) (in|on) (?&lt;object2&gt;.+)$\"</code>, it should return a stringlist with 2 elements, (<code>\"^put (?&lt;object1&gt;.+)\"</code> and <code>\" (in|on) (?&lt;object2&gt;.+)$\"</code>)</p>\n<p>The extra regexen I mentioned earlier can be added between the elements in this string (but not at the end), to identify the point at which the break matched, and force it to break at different points.</p>\n\n",
      "PostDate": "2018-10-10T13:17:17.8663145Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b19be171-01db-4320-8c75-3499dce00c6d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Actually, I'm probably an idiot. You could achieve the same effect by splitting on the string `\"(?<\"`, at the cost of slightly reduced efficiency for the final expression.",
      "EditableFormat": "markdown",
      "HTML": "<p>Actually, I'm probably an idiot. You could achieve the same effect by splitting on the string <code>\"(?&lt;\"</code>, at the cost of slightly reduced efficiency for the final expression.</p>\n\n",
      "PostDate": "2018-10-10T13:27:37.176765Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "390b9dce-0fd7-43af-8a05-5a7115fe900e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "And if you ever needed proof that anxiety can fry your brain… what was I even thinking of?\r\n\r\n<details><summary>Really bad code</summary>\r\nOK… that makes the whole thing a bit simpler, especially was we don't really need to track which \"after\" variable (let's call them \"split\" because they're no longer after) belongs to which real parameter.\r\n\r\n```\r\n<function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\">\r\n  results = NewList()\r\n  if (not IsRegexMatch (pattern, input)) {\r\n    return (results)\r\n  }\r\n  // TODO - split pattern into parts\r\n  // make an (empty) list of found options for each split part\r\n  // pseudocode follows\r\n  current_subpattern = ListCount (patternparts) - 1\r\n  while (current_subpattern > 0 or (current_subpattern = 0 and not StartsWith(pattern, \"^\"))) {\r\n    // TODO - build an expression based on the current found parts\r\n    if (IsRegexMatch (currentexpression, input)) {\r\n      // TODO - run Populate; split results into split-subpatterns and actual-subpatterns\r\n      // TODO - if the actual subpatterns don't match a set in results, add them\r\n      // TODO - add the split subpattern value equal to current_subpattern to the current expression\r\n      //   or while there isn't one, decrement current_subpattern\r\n    }\r\n    else {\r\n      // remove all previous matches from current_subpattern and later\r\n      current_subpattern = current_subpattern - 1\r\n    }\r\n  }\r\n  return (result)\r\n</function>\r\n```\r\nI'm not feeling so great today. I know there's stupid mistakes in there, I just can't think straight. Will edit later.\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>And if you ever needed proof that anxiety can fry your brain… what was I even thinking of?</p>\n<details><summary>Really bad code</summary>\nOK… that makes the whole thing a bit simpler, especially was we don't really need to track which \"after\" variable (let's call them \"split\" because they're no longer after) belongs to which real parameter.\n<pre><code>&lt;function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\"&gt;\n  results = NewList()\n  if (not IsRegexMatch (pattern, input)) {\n    return (results)\n  }\n  // TODO - split pattern into parts\n  // make an (empty) list of found options for each split part\n  // pseudocode follows\n  current_subpattern = ListCount (patternparts) - 1\n  while (current_subpattern &gt; 0 or (current_subpattern = 0 and not StartsWith(pattern, \"^\"))) {\n    // TODO - build an expression based on the current found parts\n    if (IsRegexMatch (currentexpression, input)) {\n      // TODO - run Populate; split results into split-subpatterns and actual-subpatterns\n      // TODO - if the actual subpatterns don't match a set in results, add them\n      // TODO - add the split subpattern value equal to current_subpattern to the current expression\n      //   or while there isn't one, decrement current_subpattern\n    }\n    else {\n      // remove all previous matches from current_subpattern and later\n      current_subpattern = current_subpattern - 1\n    }\n  }\n  return (result)\n&lt;/function&gt;\n</code></pre>\n<p>I'm not feeling so great today. I know there's stupid mistakes in there, I just can't think straight. Will edit later.</p>\n</details>\n\n",
      "PostDate": "2018-10-10T13:55:58.2267961Z",
      "LastEditDate": "2018-10-11T23:33:19.8000839Z",
      "link": null
    },
    {
      "PostId": "24734cf7-538c-4950-83f3-6a5a8ef6ec83",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I wonder if this is any better:\r\n\r\n```\r\n<function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\">\r\n  results = NewList\r\n  if (not IsRegexMatch (pattern, input)) {\r\n    return (results)\r\n  }\r\n  excludes = NewDictionary()\r\n  currentpattern = pattern\r\n  patternparts = Split (pattern, \"(?<\")\r\n  while (true) {\r\n    matchparts = Populate (currentpattern, input)\r\n    newsplits = \"*END*\"\r\n    newresult = NewStringDictionary()\r\n    foreach (key, matchparts) {\r\n      if (StartsWith (key, \"split\")) {\r\n        newsplits = key + \";\" + newsplits\r\n      }\r\n      else {\r\n        dictionary add (newresult, key, DictionaryItem (matchparts, key))\r\n      }\r\n    }\r\n    list add (results, newresult)\r\n    newsplits = Split (newsplits)\r\n    currentpattern = \"^(?!.)x\"\r\n    while (not IsRegexMatch (currentpattern, input)) {\r\n      key = ListItem (newsplits, 0)\r\n      if (key = \"*END*\") {\r\n        return (results)\r\n      }\r\n      else if (not DictionaryContains (excludes, key)) {\r\n        lst = NewStringList()\r\n        dictionary add (excludes, key, lst)\r\n      }\r\n      else {\r\n        lst = DictionaryItem (excludes, key)\r\n      }\r\n      if (ListContains (lst, DictionaryItem (matchparts, key))) {\r\n        dictionary remove (excludes, key)\r\n        list remove (newsplits, key)\r\n        currentpattern = \"^(?!.)x\"\r\n      }\r\n      else {\r\n        list add (lst, EscapeRegex (DictionaryItem (matchparts, key)))\r\n        currentpattern = \"\"\r\n        partname = \"split\"+i\r\n        for (i, 0, ListCount (patternparts) - 1) {\r\n          if (i > 0 or not StartsWith (pattern, \"^\")) {\r\n            if (DictionaryContains (excludes, partname)) {\r\n              excl = DictionaryItem (excludes, partname)\r\n              excl = Join (excl, \"|\")\r\n              if (not excl = \"\") {\r\n                currentpattern = currentpattern + \"(?!\" + excl + \")\"\r\n              }\r\n            }\r\n            currentpattern = currentpattern + \"(?=(?<\" + partname + \">.*$))\"\r\n          }\r\n          piece = ListItem (patternparts, i)\r\n          if (i > 0 and not piece = \"\") {\r\n            currentpattern = currentpattern + \"(?<\"\r\n          }\r\n          currentpattern = currentpattern + piece\r\n        }\r\n      }\r\n    }\r\n  }\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I wonder if this is any better:</p>\n<pre><code>&lt;function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\"&gt;\n  results = NewList\n  if (not IsRegexMatch (pattern, input)) {\n    return (results)\n  }\n  excludes = NewDictionary()\n  currentpattern = pattern\n  patternparts = Split (pattern, \"(?&lt;\")\n  while (true) {\n    matchparts = Populate (currentpattern, input)\n    newsplits = \"*END*\"\n    newresult = NewStringDictionary()\n    foreach (key, matchparts) {\n      if (StartsWith (key, \"split\")) {\n        newsplits = key + \";\" + newsplits\n      }\n      else {\n        dictionary add (newresult, key, DictionaryItem (matchparts, key))\n      }\n    }\n    list add (results, newresult)\n    newsplits = Split (newsplits)\n    currentpattern = \"^(?!.)x\"\n    while (not IsRegexMatch (currentpattern, input)) {\n      key = ListItem (newsplits, 0)\n      if (key = \"*END*\") {\n        return (results)\n      }\n      else if (not DictionaryContains (excludes, key)) {\n        lst = NewStringList()\n        dictionary add (excludes, key, lst)\n      }\n      else {\n        lst = DictionaryItem (excludes, key)\n      }\n      if (ListContains (lst, DictionaryItem (matchparts, key))) {\n        dictionary remove (excludes, key)\n        list remove (newsplits, key)\n        currentpattern = \"^(?!.)x\"\n      }\n      else {\n        list add (lst, EscapeRegex (DictionaryItem (matchparts, key)))\n        currentpattern = \"\"\n        partname = \"split\"+i\n        for (i, 0, ListCount (patternparts) - 1) {\n          if (i &gt; 0 or not StartsWith (pattern, \"^\")) {\n            if (DictionaryContains (excludes, partname)) {\n              excl = DictionaryItem (excludes, partname)\n              excl = Join (excl, \"|\")\n              if (not excl = \"\") {\n                currentpattern = currentpattern + \"(?!\" + excl + \")\"\n              }\n            }\n            currentpattern = currentpattern + \"(?=(?&lt;\" + partname + \"&gt;.*$))\"\n          }\n          piece = ListItem (patternparts, i)\n          if (i &gt; 0 and not piece = \"\") {\n            currentpattern = currentpattern + \"(?&lt;\"\n          }\n          currentpattern = currentpattern + piece\n        }\n      }\n    }\n  }\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2018-10-12T02:39:31.0576596Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4c5fc2e3-8524-421f-abcd-8850d617852f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I wonder if this is any better:\r\n\r\n```\r\n<function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\">\r\n  results = NewList\r\n  if (not IsRegexMatch (pattern, input)) {\r\n    return (results)\r\n  }\r\n  excludes = NewDictionary()\r\n  currentpattern = pattern\r\n  patternparts = Split (pattern, \"(?<\")\r\n  while (true) {\r\n    matchparts = Populate (currentpattern, input)\r\n    newsplits = \"*END*\"\r\n    newresult = NewStringDictionary()\r\n    foreach (key, matchparts) {\r\n      if (StartsWith (key, \"split\")) {\r\n        newsplits = key + \";\" + newsplits\r\n      }\r\n      else {\r\n        dictionary add (newresult, key, DictionaryItem (matchparts, key))\r\n      }\r\n    }\r\n    list add (results, newresult)\r\n    newsplits = Split (newsplits)\r\n    currentpattern = \"^(?!.)x\"\r\n    while (not IsRegexMatch (currentpattern, input)) {\r\n      key = ListItem (newsplits, 0)\r\n      if (key = \"*END*\") {\r\n        return (results)\r\n      }\r\n      else if (not DictionaryContains (excludes, key)) {\r\n        lst = NewStringList()\r\n        dictionary add (excludes, key, lst)\r\n      }\r\n      else {\r\n        lst = DictionaryItem (excludes, key)\r\n      }\r\n      if (ListContains (lst, DictionaryItem (matchparts, key))) {\r\n        dictionary remove (excludes, key)\r\n        list remove (newsplits, key)\r\n        currentpattern = \"^(?!.)x\"\r\n      }\r\n      else {\r\n        list add (lst, EscapeRegex (DictionaryItem (matchparts, key)))\r\n        currentpattern = \"\"\r\n        partname = \"split\"+i\r\n        for (i, 0, ListCount (patternparts) - 1) {\r\n          if (i > 0 or not StartsWith (pattern, \"^\")) {\r\n            if (DictionaryContains (excludes, partname)) {\r\n              excl = DictionaryItem (excludes, partname)\r\n              excl = Join (excl, \"|\")\r\n              if (not excl = \"\") {\r\n                currentpattern = currentpattern + \"(?!\" + excl + \")\"\r\n              }\r\n            }\r\n            currentpattern = currentpattern + \"(?=(?<\" + partname + \">.*$))\"\r\n          }\r\n          piece = ListItem (patternparts, i)\r\n          if (i > 0 and not piece = \"\") {\r\n            currentpattern = currentpattern + \"(?<\"\r\n          }\r\n          currentpattern = currentpattern + piece\r\n        }\r\n      }\r\n    }\r\n  }\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I wonder if this is any better:</p>\n<pre><code>&lt;function name=\"GetPopulateVariants\" type=\"list\" parameters=\"pattern, input\"&gt;\n  results = NewList\n  if (not IsRegexMatch (pattern, input)) {\n    return (results)\n  }\n  excludes = NewDictionary()\n  currentpattern = pattern\n  patternparts = Split (pattern, \"(?&lt;\")\n  while (true) {\n    matchparts = Populate (currentpattern, input)\n    newsplits = \"*END*\"\n    newresult = NewStringDictionary()\n    foreach (key, matchparts) {\n      if (StartsWith (key, \"split\")) {\n        newsplits = key + \";\" + newsplits\n      }\n      else {\n        dictionary add (newresult, key, DictionaryItem (matchparts, key))\n      }\n    }\n    list add (results, newresult)\n    newsplits = Split (newsplits)\n    currentpattern = \"^(?!.)x\"\n    while (not IsRegexMatch (currentpattern, input)) {\n      key = ListItem (newsplits, 0)\n      if (key = \"*END*\") {\n        return (results)\n      }\n      else if (not DictionaryContains (excludes, key)) {\n        lst = NewStringList()\n        dictionary add (excludes, key, lst)\n      }\n      else {\n        lst = DictionaryItem (excludes, key)\n      }\n      if (ListContains (lst, DictionaryItem (matchparts, key))) {\n        dictionary remove (excludes, key)\n        list remove (newsplits, key)\n        currentpattern = \"^(?!.)x\"\n      }\n      else {\n        list add (lst, EscapeRegex (DictionaryItem (matchparts, key)))\n        currentpattern = \"\"\n        partname = \"split\"+i\n        for (i, 0, ListCount (patternparts) - 1) {\n          if (i &gt; 0 or not StartsWith (pattern, \"^\")) {\n            if (DictionaryContains (excludes, partname)) {\n              excl = DictionaryItem (excludes, partname)\n              excl = Join (excl, \"|\")\n              if (not excl = \"\") {\n                currentpattern = currentpattern + \"(?!\" + excl + \")\"\n              }\n            }\n            currentpattern = currentpattern + \"(?=(?&lt;\" + partname + \"&gt;.*$))\"\n          }\n          piece = ListItem (patternparts, i)\n          if (i &gt; 0 and not piece = \"\") {\n            currentpattern = currentpattern + \"(?&lt;\"\n          }\n          currentpattern = currentpattern + piece\n        }\n      }\n    }\n  }\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2018-10-12T02:42:02.1902142Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b85b301a-68c4-4833-94ff-80143f5e89d1",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The Pixie, can you remove buy and purchase from the basic commands, so I can use and change them in my games again?\r\n...worth a shot.",
      "EditableFormat": "markdown",
      "HTML": "<p>The Pixie, can you remove buy and purchase from the basic commands, so I can use and change them in my games again?<br>\n...worth a shot.</p>\n\n",
      "PostDate": "2018-10-12T02:51:42.7019877Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3956dc6c-206e-4b93-8732-aed53aa4c382",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Just thought... with this, you could also do patterns like:\r\n```\r\n^ask( (?<object_npc>.+))? about ((?<object_topic>.+)|(?<text_topic>.+))$\r\n```\r\n\r\nI think I see a potential edge case here, but I can't work out any examples that would actually trigger it.\r\n\r\nBut basically, `GetPopulateVariants` in this case would return a two-membered list:\r\n\r\n1. stringdictionary\r\n    * `object_npc`: `\"bob\"`\r\n    * `object_topic`: `\"his garden\"`\r\n2. stringdictionary\r\n    * `object_npc`: `\"bob\"`\r\n    * `text_topic`: `\"his garden\"`\r\n\r\nIf \"his garden\" is an object, it's passed to the ask command as an object. If it can't be resolved, it gets passed as a text parameter. Because the parser would take the first variant in which all the `object*` and `exit*` parameters can be resolved.\r\n\r\nAnd now you've got me thinking about how you'd do the scope for an \"ask about (object)\" command. Presumably the scope for the second object should include all objects the player has seen. How would you track that?\r\nEasy: have the backdrop scope script do `game.seenobjects = ListCompact (ListCombine (game.seenobjects, items))`.\r\nThen you have an ask command that will easily work with objects with alternate aliases, and incomplete names, and will allow the player to ask about anything they've seen.",
      "EditableFormat": "markdown",
      "HTML": "<p>Just thought... with this, you could also do patterns like:</p>\n<pre><code>^ask( (?&lt;object_npc&gt;.+))? about ((?&lt;object_topic&gt;.+)|(?&lt;text_topic&gt;.+))$\n</code></pre>\n<p>I think I see a potential edge case here, but I can't work out any examples that would actually trigger it.</p>\n<p>But basically, <code>GetPopulateVariants</code> in this case would return a two-membered list:</p>\n<ol>\n<li>stringdictionary\n<ul>\n<li><code>object_npc</code>: <code>\"bob\"</code></li>\n<li><code>object_topic</code>: <code>\"his garden\"</code></li>\n</ul>\n</li>\n<li>stringdictionary\n<ul>\n<li><code>object_npc</code>: <code>\"bob\"</code></li>\n<li><code>text_topic</code>: <code>\"his garden\"</code></li>\n</ul>\n</li>\n</ol>\n<p>If \"his garden\" is an object, it's passed to the ask command as an object. If it can't be resolved, it gets passed as a text parameter. Because the parser would take the first variant in which all the <code>object*</code> and <code>exit*</code> parameters can be resolved.</p>\n<p>And now you've got me thinking about how you'd do the scope for an \"ask about (object)\" command. Presumably the scope for the second object should include all objects the player has seen. How would you track that?<br>\nEasy: have the backdrop scope script do <code>game.seenobjects = ListCompact (ListCombine (game.seenobjects, items))</code>.<br>\nThen you have an ask command that will easily work with objects with alternate aliases, and incomplete names, and will allow the player to ask about anything they've seen.</p>\n\n",
      "PostDate": "2018-10-13T21:30:46.2431478Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
