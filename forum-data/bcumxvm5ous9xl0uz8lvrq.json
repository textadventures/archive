{
  "Topic": {
    "TopicId": "bcumxvm5ous9xl0uz8lvrq",
    "ForumId": "10",
    "Title": "Another Parser Modification Question",
    "LastUpdated": "2021-04-24T01:54:26.1695197Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "6ec377eb-6c62-4fea-b17c-679145f2f66d",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hello.\r\n\r\nThe game I am porting has parser errors like so:\r\n\r\n**GET MACGUFFIN**\r\n```\r\nI don't know the word \"macguffin\".\r\n```\r\n\r\n---\r\n**FOO LAMP**\r\n```\r\nI don't know the word \"foo\".\r\n```\r\n\r\n---\r\n**GET SOUTH**\r\n```\r\nYou used the word \"south\" in a way I don't understand.\r\n```\r\n\r\n---\r\n(In this example, the foobar exists, but is not in scope.)\r\n**GET FOOBAR**\r\n```\r\nYou can't see any foobar here!\r\n```\r\n\r\n---\r\nI got the first two working fairly easily.  I think I can do the last one with little thought required, but that third one is stumping me.\r\n\r\n**GET SOUTH**\r\n```\r\nYou used the word \"south\" in a way that I don't understand.\r\n```\r\n\r\n**GET GET**\r\n```\r\nYou used the word \"get\" in a way that I don't understand.\r\n```\r\n\r\n---\r\nOh, and if **lamp** is an object anywhere in the game:\r\n\r\n**LAMP**\r\n```\r\nThere was no verb in that sentence!\r\n```\r\n\r\n**LAMP LAMP**\r\n```\r\nThere was no verb in that sentence!\r\n```\r\n\r\n---\r\nAll in all, it looks like I need to:\r\n\r\n1. check if the first word would return an object if the parser tried to match it to an object in order to:\r\n    - return \"You can't see any **object** here!\"\r\n    - return \"There was no verb in that sentence!\"\r\n\r\n2. make sure an unresolved object is not a command's verb or a direction in order to:\r\n    - return 'You used the word \"**text**\" in a way that I don't understand.'\r\n\r\nI'm going to take a 30 minute break before messing with this, and I'll come back to see if anyone already had any quick fixes for anything before getting back to work on it.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hello.</p>\n<p>The game I am porting has parser errors like so:</p>\n<p><strong>GET MACGUFFIN</strong></p>\n<pre><code>I don't know the word \"macguffin\".\n</code></pre>\n<hr>\n<p><strong>FOO LAMP</strong></p>\n<pre><code>I don't know the word \"foo\".\n</code></pre>\n<hr>\n<p><strong>GET SOUTH</strong></p>\n<pre><code>You used the word \"south\" in a way I don't understand.\n</code></pre>\n<hr>\n<p>(In this example, the foobar exists, but is not in scope.)<br>\n<strong>GET FOOBAR</strong></p>\n<pre><code>You can't see any foobar here!\n</code></pre>\n<hr>\n<p>I got the first two working fairly easily.  I think I can do the last one with little thought required, but that third one is stumping me.</p>\n<p><strong>GET SOUTH</strong></p>\n<pre><code>You used the word \"south\" in a way that I don't understand.\n</code></pre>\n<p><strong>GET GET</strong></p>\n<pre><code>You used the word \"get\" in a way that I don't understand.\n</code></pre>\n<hr>\n<p>Oh, and if <strong>lamp</strong> is an object anywhere in the game:</p>\n<p><strong>LAMP</strong></p>\n<pre><code>There was no verb in that sentence!\n</code></pre>\n<p><strong>LAMP LAMP</strong></p>\n<pre><code>There was no verb in that sentence!\n</code></pre>\n<hr>\n<p>All in all, it looks like I need to:</p>\n<ol>\n<li>\n<p>check if the first word would return an object if the parser tried to match it to an object in order to:</p>\n<ul>\n<li>return \"You can't see any <strong>object</strong> here!\"</li>\n<li>return \"There was no verb in that sentence!\"</li>\n</ul>\n</li>\n<li>\n<p>make sure an unresolved object is not a command's verb or a direction in order to:</p>\n<ul>\n<li>return 'You used the word \"<strong>text</strong>\" in a way that I don't understand.'</li>\n</ul>\n</li>\n</ol>\n<p>I'm going to take a 30 minute break before messing with this, and I'll come back to see if anyone already had any quick fixes for anything before getting back to work on it.</p>\n\n",
      "PostDate": "2021-04-24T01:54:26.1695197Z",
      "LastEditDate": "2021-04-24T05:10:22.1309584Z",
      "link": null
    },
    {
      "PostId": "1b83596e-3462-4540-9bd4-8f779d91f099",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The code so far:\r\n\r\n```\r\n  <function name=\"HandleSingleCommand\" parameters=\"command\"><![CDATA[\r\n    if (LCase(command) = \"again\" or LCase(command) = \"g\") {\r\n      // First handle AGAIN\r\n      if (not game.pov.currentcommand = null) {\r\n        HandleSingleCommand (game.pov.currentcommand)\r\n      }\r\n      else {\r\n        msg (\"There is nothing to repeat.\")\r\n      }\r\n    }\r\n    else {\r\n      // Check through all commands for any that match\r\n      candidates = NewObjectList()\r\n      foreach (cmd, ScopeCommands()) {\r\n        if (IsRegexMatch(cmd.pattern, command, cmd.name)) {\r\n          list add (candidates, cmd)\r\n        }\r\n      }\r\n      maxstrength = -1\r\n      thiscommand = null\r\n      // Pick the best match\r\n      foreach (candidate, candidates) {\r\n        strength = GetMatchStrength(candidate.pattern, command, candidate.name)\r\n        // favour commands defined later, so an author can override a library command...\r\n        if (strength >= maxstrength) {\r\n          // ... except if the command defined later (candidate) has no parent, and the current best\r\n          // match (thiscommand) does have a parent. We want to favour any commands defined in rooms\r\n          // over global candidates.\r\n          skip = false\r\n          if (thiscommand <> null) {\r\n            if (thiscommand.parent <> null and candidate.parent = null) {\r\n              skip = true\r\n            }\r\n          }\r\n          if (not skip) {\r\n            thiscommand = candidate\r\n            maxstrength = strength\r\n          }\r\n        }\r\n      }\r\n      if (thiscommand = null) {\r\n        if (HasScript(game, \"unresolvedcommandhandler\")) {\r\n          params = NewDictionary()\r\n          dictionary add (params, \"command\", command)\r\n          do (game, \"unresolvedcommandhandler\", params)\r\n        }\r\n        else {\r\n          // Infocom style mod\r\n          if (game.pov.parent.dark) {\r\n            msg (\"It's too dark to see!\")\r\n          }\r\n          else {\r\n            // msg (\"HandleSingleCommand\")\r\n            handled = ObjectExists(command)\r\n            if (handled) {\r\n              // Make sure there is actually no verb, not just the first word!\r\n              commandArray = Split(command, \" \")\r\n              verbExists = false\r\n              foreach (cmd, commandArray) {\r\n                verbExists = ActionExists(cmd)\r\n              }\r\n              if (verbExists) {\r\n                msg (\"That sentence isn't one I recognise.\")\r\n              }\r\n              else {\r\n                msg (\"There was no verb in that sentence!\")\r\n              }\r\n            }\r\n            else {\r\n              // Replacing old Infocom text:\r\n              // msg (\"I don't know the word \\\"\" + Split(command,\" \")[0] + \"\\\".\")\r\n              // ...with...\r\n              msg (\"I don't know how to \\\"\" + Split(command,\" \")[0] + \"\\\".\")\r\n            }\r\n          }\r\n          // msg (Template(\"UnrecognisedCommand\"))\r\n        }\r\n        HandleNextCommandQueueItem\r\n      }\r\n      else {\r\n        varlist = Populate(thiscommand.pattern, command, thiscommand.name)\r\n        HandleSingleCommandPattern (command, thiscommand, varlist)\r\n      }\r\n    }\r\n  ]]></function>\r\n  <function name=\"UnresolvedCommand\" parameters=\"objectname, varname\"><![CDATA[\r\n    // TO DO: Update names below, we don't need these two variables\r\n    unresolvedobject = objectname\r\n    unresolvedkey = varname\r\n    if (HasString(game.pov.currentcommandpattern, \"unresolved\")) {\r\n      if (ListCount(game.pov.currentcommandvarlist) > 1) {\r\n        msg (game.pov.currentcommandpattern.unresolved + \" (\" + unresolvedobject + \")\")\r\n      }\r\n      else {\r\n        msg (game.pov.currentcommandpattern.unresolved)\r\n      }\r\n    }\r\n    else if (HasScript(game.pov.currentcommandpattern, \"unresolved\")) {\r\n      do (game.pov.currentcommandpattern, \"unresolved\", QuickParams(\"object\", unresolvedobject, \"key\", unresolvedkey))\r\n    }\r\n    else {\r\n      // Infocom style mod\r\n      if (Instr(unresolvedobject, \" \") > 0) {\r\n        unresolvedobject = Split(unresolvedobject, \" \")[0]\r\n      }\r\n      if (game.pov.parent.dark) {\r\n        msg (\"It's too dark to see!\")\r\n      }\r\n      else {\r\n        handled = ObjectExists(unresolvedobject)\r\n        if (handled) {\r\n          msg (\"You can't see any \" + unresolvedobject + \" here!\")\r\n        }\r\n        else {\r\n          // sort through command patterns' verbs AND directions\r\n          // msg (\"UnresolvedCommand\")\r\n          handled = ActionExists(unresolvedobject)\r\n          if (handled) {\r\n            msg (\"You used the word \\\"\" + unresolvedobject + \"\\\" in a way I don't understand.\")\r\n          }\r\n          else {\r\n            msg (\"I don't know the word \\\"\" + unresolvedobject + \"\\\".\")\r\n          }\r\n        }\r\n      }\r\n    }\r\n    game.unresolvedcommand = game.pov.currentcommandpattern\r\n    game.unresolvedcommandvarlist = game.pov.currentcommandvarlist\r\n    game.unresolvedcommandkey = unresolvedkey\r\n  ]]></function>\r\n  <function name=\"ObjectExists\" parameters=\"o\" type=\"boolean\">\r\n    handled = false\r\n    foreach (obj, AllObjects()) {\r\n      if (Left(LCase(obj.name),6) = Left(LCase(o),6)) {\r\n        handled = true\r\n      }\r\n      if (not handled and HasAttribute(obj, \"alt\")) {\r\n        foreach (altname, obj.alt) {\r\n          if (Left(LCase(altname),6) = Left(LCase(o),6)) {\r\n            handled = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return (handled)\r\n  </function>\r\n  <function name=\"ActionExists\" parameters=\"s\" type=\"boolean\"><![CDATA[\r\n    exists = false\r\n    // foreach (cmd, AllCommands()) {\r\n      // if (IsRegExMatch(cmd.pattern, s)) {\r\n        // exists = true\r\n        // }\r\n      // }\r\n    foreach (cmd, AllCommands()) {\r\n      pattern = Left(cmd.pattern, Instr(cmd.pattern, \" \"))\r\n      pattern = Trim(pattern)\r\n      if (EndsWith(pattern,\"(\")) {\r\n        // msg (\"WINNER\")\r\n        // msg(LengthOf(pattern))\r\n        pattern = Left(pattern,LengthOf(pattern)-1)\r\n      }\r\n      // msg (pattern)\r\n      if (LengthOf(pattern)>0 and IsRegExMatch(pattern, s)) {\r\n        exists = true\r\n        // msg (\"<code>\"+pattern+\"</code>\")\r\n      }\r\n      if (not exists) {\r\n        // Check directions (not in, out, up,or down)\r\n        pattern = \"^(north|east|south|west|northeast|northwest|southeast|southwest|n|e|s|w|ne|nw|se|sw)$\"\r\n        exists = IsRegExMatch(pattern,s)\r\n      }\r\n    }\r\n    return (exists)\r\n  ]]></function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>The code so far:</p>\n<pre><code>  &lt;function name=\"HandleSingleCommand\" parameters=\"command\"&gt;&lt;![CDATA[\n    if (LCase(command) = \"again\" or LCase(command) = \"g\") {\n      // First handle AGAIN\n      if (not game.pov.currentcommand = null) {\n        HandleSingleCommand (game.pov.currentcommand)\n      }\n      else {\n        msg (\"There is nothing to repeat.\")\n      }\n    }\n    else {\n      // Check through all commands for any that match\n      candidates = NewObjectList()\n      foreach (cmd, ScopeCommands()) {\n        if (IsRegexMatch(cmd.pattern, command, cmd.name)) {\n          list add (candidates, cmd)\n        }\n      }\n      maxstrength = -1\n      thiscommand = null\n      // Pick the best match\n      foreach (candidate, candidates) {\n        strength = GetMatchStrength(candidate.pattern, command, candidate.name)\n        // favour commands defined later, so an author can override a library command...\n        if (strength &gt;= maxstrength) {\n          // ... except if the command defined later (candidate) has no parent, and the current best\n          // match (thiscommand) does have a parent. We want to favour any commands defined in rooms\n          // over global candidates.\n          skip = false\n          if (thiscommand &lt;&gt; null) {\n            if (thiscommand.parent &lt;&gt; null and candidate.parent = null) {\n              skip = true\n            }\n          }\n          if (not skip) {\n            thiscommand = candidate\n            maxstrength = strength\n          }\n        }\n      }\n      if (thiscommand = null) {\n        if (HasScript(game, \"unresolvedcommandhandler\")) {\n          params = NewDictionary()\n          dictionary add (params, \"command\", command)\n          do (game, \"unresolvedcommandhandler\", params)\n        }\n        else {\n          // Infocom style mod\n          if (game.pov.parent.dark) {\n            msg (\"It's too dark to see!\")\n          }\n          else {\n            // msg (\"HandleSingleCommand\")\n            handled = ObjectExists(command)\n            if (handled) {\n              // Make sure there is actually no verb, not just the first word!\n              commandArray = Split(command, \" \")\n              verbExists = false\n              foreach (cmd, commandArray) {\n                verbExists = ActionExists(cmd)\n              }\n              if (verbExists) {\n                msg (\"That sentence isn't one I recognise.\")\n              }\n              else {\n                msg (\"There was no verb in that sentence!\")\n              }\n            }\n            else {\n              // Replacing old Infocom text:\n              // msg (\"I don't know the word \\\"\" + Split(command,\" \")[0] + \"\\\".\")\n              // ...with...\n              msg (\"I don't know how to \\\"\" + Split(command,\" \")[0] + \"\\\".\")\n            }\n          }\n          // msg (Template(\"UnrecognisedCommand\"))\n        }\n        HandleNextCommandQueueItem\n      }\n      else {\n        varlist = Populate(thiscommand.pattern, command, thiscommand.name)\n        HandleSingleCommandPattern (command, thiscommand, varlist)\n      }\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"UnresolvedCommand\" parameters=\"objectname, varname\"&gt;&lt;![CDATA[\n    // TO DO: Update names below, we don't need these two variables\n    unresolvedobject = objectname\n    unresolvedkey = varname\n    if (HasString(game.pov.currentcommandpattern, \"unresolved\")) {\n      if (ListCount(game.pov.currentcommandvarlist) &gt; 1) {\n        msg (game.pov.currentcommandpattern.unresolved + \" (\" + unresolvedobject + \")\")\n      }\n      else {\n        msg (game.pov.currentcommandpattern.unresolved)\n      }\n    }\n    else if (HasScript(game.pov.currentcommandpattern, \"unresolved\")) {\n      do (game.pov.currentcommandpattern, \"unresolved\", QuickParams(\"object\", unresolvedobject, \"key\", unresolvedkey))\n    }\n    else {\n      // Infocom style mod\n      if (Instr(unresolvedobject, \" \") &gt; 0) {\n        unresolvedobject = Split(unresolvedobject, \" \")[0]\n      }\n      if (game.pov.parent.dark) {\n        msg (\"It's too dark to see!\")\n      }\n      else {\n        handled = ObjectExists(unresolvedobject)\n        if (handled) {\n          msg (\"You can't see any \" + unresolvedobject + \" here!\")\n        }\n        else {\n          // sort through command patterns' verbs AND directions\n          // msg (\"UnresolvedCommand\")\n          handled = ActionExists(unresolvedobject)\n          if (handled) {\n            msg (\"You used the word \\\"\" + unresolvedobject + \"\\\" in a way I don't understand.\")\n          }\n          else {\n            msg (\"I don't know the word \\\"\" + unresolvedobject + \"\\\".\")\n          }\n        }\n      }\n    }\n    game.unresolvedcommand = game.pov.currentcommandpattern\n    game.unresolvedcommandvarlist = game.pov.currentcommandvarlist\n    game.unresolvedcommandkey = unresolvedkey\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"ObjectExists\" parameters=\"o\" type=\"boolean\"&gt;\n    handled = false\n    foreach (obj, AllObjects()) {\n      if (Left(LCase(obj.name),6) = Left(LCase(o),6)) {\n        handled = true\n      }\n      if (not handled and HasAttribute(obj, \"alt\")) {\n        foreach (altname, obj.alt) {\n          if (Left(LCase(altname),6) = Left(LCase(o),6)) {\n            handled = true\n          }\n        }\n      }\n    }\n    return (handled)\n  &lt;/function&gt;\n  &lt;function name=\"ActionExists\" parameters=\"s\" type=\"boolean\"&gt;&lt;![CDATA[\n    exists = false\n    // foreach (cmd, AllCommands()) {\n      // if (IsRegExMatch(cmd.pattern, s)) {\n        // exists = true\n        // }\n      // }\n    foreach (cmd, AllCommands()) {\n      pattern = Left(cmd.pattern, Instr(cmd.pattern, \" \"))\n      pattern = Trim(pattern)\n      if (EndsWith(pattern,\"(\")) {\n        // msg (\"WINNER\")\n        // msg(LengthOf(pattern))\n        pattern = Left(pattern,LengthOf(pattern)-1)\n      }\n      // msg (pattern)\n      if (LengthOf(pattern)&gt;0 and IsRegExMatch(pattern, s)) {\n        exists = true\n        // msg (\"&lt;code&gt;\"+pattern+\"&lt;/code&gt;\")\n      }\n      if (not exists) {\n        // Check directions (not in, out, up,or down)\n        pattern = \"^(north|east|south|west|northeast|northwest|southeast|southwest|n|e|s|w|ne|nw|se|sw)$\"\n        exists = IsRegExMatch(pattern,s)\n      }\n    }\n    return (exists)\n  ]]&gt;&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2021-04-24T05:09:44.5815863Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5c8d1c9d-b4d3-4bab-ac1d-18c10a2e45af",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "#### TODO\r\n\r\nI seem to have everything handled, except...\r\n\r\nIn the original game, if (say) there is a ball and a bucket:\r\n\r\n**PUT BALL IN BUCKET**\r\n\r\n**BALL PUT IN BUCKET**\r\n\r\nBoth of those will put the ball in the bucket.\r\n\r\n(I wonder if the parser is rearranging text, or if the PUT IN command has a pattern to match ```PUT <OBJECT1> IN <OBJECT2>``` as well as ```<OBJECT1> PUT IN <OBJECT2>```.  Probably the latter, but I don't know.)\r\n\r\n---\r\n**BALL PUT**\r\n\r\nThis will ask \"What do you want to put the ball in?\"\r\n\r\n---\r\n**BALL BUCKET PUT**\r\n\r\nThis will say \"That sentence isn't one I recognise.\"\r\n*(I've got this one handled already.)*\r\n\r\n",
      "EditableFormat": "markdown",
      "HTML": "<h4>TODO</h4>\n<p>I seem to have everything handled, except...</p>\n<p>In the original game, if (say) there is a ball and a bucket:</p>\n<p><strong>PUT BALL IN BUCKET</strong></p>\n<p><strong>BALL PUT IN BUCKET</strong></p>\n<p>Both of those will put the ball in the bucket.</p>\n<p>(I wonder if the parser is rearranging text, or if the PUT IN command has a pattern to match <code>PUT &lt;OBJECT1&gt; IN &lt;OBJECT2&gt;</code> as well as <code>&lt;OBJECT1&gt; PUT IN &lt;OBJECT2&gt;</code>.  Probably the latter, but I don't know.)</p>\n<hr>\n<p><strong>BALL PUT</strong></p>\n<p>This will ask \"What do you want to put the ball in?\"</p>\n<hr>\n<p><strong>BALL BUCKET PUT</strong></p>\n<p>This will say \"That sentence isn't one I recognise.\"<br>\n<em>(I've got this one handled already.)</em></p>\n\n",
      "PostDate": "2021-04-24T05:22:17.2387631Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4462827f-f820-4c15-9698-8fd2d35d5934",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Out of curiosity, how does it respond to \"put ball bucket\"? Or \"put in bucket ball\"? \"in bucket put ball\"? \"ball in bucket\"?\r\n\r\nLooking at the examples you gave, I'm wondering if it's using some kind of grammar system rather than just patterns; in which case it might be simpler to rewrite `HandleSingleCommand` to split the command into a list of words, identify each of those as nouns or verbs, and compare the number of nouns/prepositions to the command's requirements.",
      "EditableFormat": "markdown",
      "HTML": "<p>Out of curiosity, how does it respond to \"put ball bucket\"? Or \"put in bucket ball\"? \"in bucket put ball\"? \"ball in bucket\"?</p>\n<p>Looking at the examples you gave, I'm wondering if it's using some kind of grammar system rather than just patterns; in which case it might be simpler to rewrite <code>HandleSingleCommand</code> to split the command into a list of words, identify each of those as nouns or verbs, and compare the number of nouns/prepositions to the command's requirements.</p>\n\n",
      "PostDate": "2021-04-24T12:31:34.0746537Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e2d7972f-a0cb-45cc-ae79-0ae38c86caa3",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "All four of those were met with:\r\n\r\n```\r\nThat sentence isn't one I recognise.\r\n```\r\n\r\n---\r\nI was thinking the same thing about the grammar system, though. (In fact, I'm still thinking it.)",
      "EditableFormat": "markdown",
      "HTML": "<p>All four of those were met with:</p>\n<pre><code>That sentence isn't one I recognise.\n</code></pre>\n<hr>\n<p>I was thinking the same thing about the grammar system, though. (In fact, I'm still thinking it.)</p>\n\n",
      "PostDate": "2021-04-24T13:26:00.9157187Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "337c296a-99f6-4052-94a1-b75b428f6488",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Found the syntax stuff for PUT.  It seems the patterns all use the word \"put\", then all the synonyms for \"put\" are listed separately -- much like an object and its aliases.  Pretty smart.\r\n\r\n```\r\n<SYNTAX PUT OBJECT (HELD MANY) IN OBJECT = V-PUT PRE-PUT>\r\n<SYNTAX PUT OBJECT (HELD MANY) AT OBJECT = V-PUT-IN-FRONT PRE-GIVE>\r\n<SYNTAX PUT OBJECT (HELD MANY) BEFORE OBJECT = V-PUT-IN-FRONT PRE-GIVE>\r\n<SYNTAX PUT OBJECT (HELD MANY) DOWN OBJECT = V-PUT-ON PRE-PUT>\r\n<SYNTAX PUT OBJECT (HELD MANY) ON OBJECT = V-PUT-ON PRE-PUT>\r\n<SYNTAX PUT OBJECT (HELD MANY) AROUND OBJECT = V-PUT-ON PRE-PUT>\r\n<SYNTAX PUT OBJECT (HELD MANY) OVER OBJECT = V-PUT-ON PRE-PUT>\r\n<SYNTAX PUT OBJECT (HELD MANY) ACROSS OBJECT = V-PUT-ON PRE-PUT>\r\n<SYNTAX PUT DOWN OBJECT (HELD MANY HAVE) = V-DROP PRE-DROP>\r\n<SYNTAX PUT OBJECT UNDER OBJECT = V-PUT-UNDER> \r\n<SYNTAX PUT ON OBJECT (FIND WEARBIT) (HAVE) = V-WEAR>\r\n<SYNTAX PUT OBJECT BEHIND OBJECT = V-PUT-BEHIND>\r\n<SYNONYM PUT STUFF INSERT PLACE LAY>\r\n```\r\n\r\n---\r\nLooks like the parser searches the lists of synonyms from the commands' syntax to find the VERBs in the player's input. Then it finds the object(s).\r\n\r\nSo, my guess was wrong.  (Good thing I didn't gamble any extra time on it. Ha ha!)\r\n\r\n---\r\n**EDIT**\r\n\r\nAlso, I'm feeling kind of like a jerk.\r\n\r\nI've been trying to find ways for one function to check through all the command patterns for verbs. I thought of just adding an attribute to each command which was a list comprised of the verb and its synonyms, but thought, 'nah. Too much work.'\r\n\r\nWell, now I see that the people who wrote the classics took the time to include the list of synonyms for each action. So, gosh darn it, I'm gonna do that , too!",
      "EditableFormat": "markdown",
      "HTML": "<p>Found the syntax stuff for PUT.  It seems the patterns all use the word \"put\", then all the synonyms for \"put\" are listed separately -- much like an object and its aliases.  Pretty smart.</p>\n<pre><code>&lt;SYNTAX PUT OBJECT (HELD MANY) IN OBJECT = V-PUT PRE-PUT&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) AT OBJECT = V-PUT-IN-FRONT PRE-GIVE&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) BEFORE OBJECT = V-PUT-IN-FRONT PRE-GIVE&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) DOWN OBJECT = V-PUT-ON PRE-PUT&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) ON OBJECT = V-PUT-ON PRE-PUT&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) AROUND OBJECT = V-PUT-ON PRE-PUT&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) OVER OBJECT = V-PUT-ON PRE-PUT&gt;\n&lt;SYNTAX PUT OBJECT (HELD MANY) ACROSS OBJECT = V-PUT-ON PRE-PUT&gt;\n&lt;SYNTAX PUT DOWN OBJECT (HELD MANY HAVE) = V-DROP PRE-DROP&gt;\n&lt;SYNTAX PUT OBJECT UNDER OBJECT = V-PUT-UNDER&gt; \n&lt;SYNTAX PUT ON OBJECT (FIND WEARBIT) (HAVE) = V-WEAR&gt;\n&lt;SYNTAX PUT OBJECT BEHIND OBJECT = V-PUT-BEHIND&gt;\n&lt;SYNONYM PUT STUFF INSERT PLACE LAY&gt;\n</code></pre>\n<hr>\n<p>Looks like the parser searches the lists of synonyms from the commands' syntax to find the VERBs in the player's input. Then it finds the object(s).</p>\n<p>So, my guess was wrong.  (Good thing I didn't gamble any extra time on it. Ha ha!)</p>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>Also, I'm feeling kind of like a jerk.</p>\n<p>I've been trying to find ways for one function to check through all the command patterns for verbs. I thought of just adding an attribute to each command which was a list comprised of the verb and its synonyms, but thought, 'nah. Too much work.'</p>\n<p>Well, now I see that the people who wrote the classics took the time to include the list of synonyms for each action. So, gosh darn it, I'm gonna do that , too!</p>\n\n",
      "PostDate": "2021-04-24T13:38:57.2555234Z",
      "LastEditDate": "2021-04-24T13:48:46.9701711Z",
      "link": null
    },
    {
      "PostId": "028a9471-20aa-49e1-baba-0562eae6576a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmm… in those cases, I would probably build 3 lists of words (objects, verbs, other) or a dictionary mapping words onto \"verb\", \"noun\", \"other\"\r\n\r\nThen HandleSingleCommand would split the command into words, and look them up. If it finds a verb, it makes note of it. If it finds an unknown word, it can report [I don't know the word \"foo\".] and finish. No need for a load of regex comparisons.\r\n\r\nAfter the loop finishes, if a verb hasn't been found, it can report [There was no verb in that sentence!] and end - again, saving a lot of string comparisons.\r\n\r\nIf you have a command that has a verb in it and no unknown words, you can look it up as normal, with the message \"That sentence isn't one I recognise.\" if it doesn't match.\r\n\r\nThen ResolveName can also use the same lists. It looks up the word it's been given in the list first to see what type it is.\r\n* noun → Look up the object as normal. If not found, report \"You can't see any foobar here!\"\r\n* verb/other → Report [You used the word \"get\" in a way that I don't understand.]\r\n\r\n<hr/>\r\n\r\nActually… a more efficient way to do it might be having a dictionary of objects, dictionary of verbs, dictionary of verbs, and list of other words ('in', 'the', 'it', etc). Most of these could be assembled by looping over AllObjects, AllExits, and AllCommands on startup.\r\n\r\nThe dictionary keys could be the first six letters of the word, and the value an objectlist. That way, HandleSingleCommand has a list of commands which use that verb (for example, \"look\" could point to look, lookat, and lookdir), so it doesn't need to try the pattern for every command in the game. Saves time by making an index. And ResolveName doesn't need to do all the complex matching; it just looks at the objects in the list, and checks if any of them are in scope.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmm… in those cases, I would probably build 3 lists of words (objects, verbs, other) or a dictionary mapping words onto \"verb\", \"noun\", \"other\"</p>\n<p>Then HandleSingleCommand would split the command into words, and look them up. If it finds a verb, it makes note of it. If it finds an unknown word, it can report [I don't know the word \"foo\".] and finish. No need for a load of regex comparisons.</p>\n<p>After the loop finishes, if a verb hasn't been found, it can report [There was no verb in that sentence!] and end - again, saving a lot of string comparisons.</p>\n<p>If you have a command that has a verb in it and no unknown words, you can look it up as normal, with the message \"That sentence isn't one I recognise.\" if it doesn't match.</p>\n<p>Then ResolveName can also use the same lists. It looks up the word it's been given in the list first to see what type it is.</p>\n<ul>\n<li>noun → Look up the object as normal. If not found, report \"You can't see any foobar here!\"</li>\n<li>verb/other → Report [You used the word \"get\" in a way that I don't understand.]</li>\n</ul>\n<hr>\n<p>Actually… a more efficient way to do it might be having a dictionary of objects, dictionary of verbs, dictionary of verbs, and list of other words ('in', 'the', 'it', etc). Most of these could be assembled by looping over AllObjects, AllExits, and AllCommands on startup.</p>\n<p>The dictionary keys could be the first six letters of the word, and the value an objectlist. That way, HandleSingleCommand has a list of commands which use that verb (for example, \"look\" could point to look, lookat, and lookdir), so it doesn't need to try the pattern for every command in the game. Saves time by making an index. And ResolveName doesn't need to do all the complex matching; it just looks at the objects in the list, and checks if any of them are in scope.</p>\n\n",
      "PostDate": "2021-04-24T16:10:17.535179Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "64f2fe4c-65ad-4369-9a12-a71e986988c7",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I was thinking about adding a ```synonyms``` string list attribute to each verb/command.  A dictionary definitely sounds a little easier than that.",
      "EditableFormat": "markdown",
      "HTML": "<p>I was thinking about adding a <code>synonyms</code> string list attribute to each verb/command.  A dictionary definitely sounds a little easier than that.</p>\n\n",
      "PostDate": "2021-04-24T18:15:16.5448458Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d76af4a8-79f6-412d-a603-a3e8434760a6",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Oh, I found some unexpected behavior.\r\n\r\nI have a **thing** object. SYNONYMS: **thing**, **gift**, **aunt's**\r\n\r\nI can **EXAMINE AUNT'S BUTT**, and it examines the thing.\r\n\r\nIn the real game, however:\r\n<output style=\"font-family:monospace\">\\>examine aunt's butt\r\nI don't know the word \"butt\".\r\n</output>\r\n\r\nI tried to break it down by splitting at spaces (if they existed) and running each word back through ```CompareNames``` with a ```foreach```, but that made the game freeze up.\r\n\r\nHrmm...",
      "EditableFormat": "markdown",
      "HTML": "<p>Oh, I found some unexpected behavior.</p>\n<p>I have a <strong>thing</strong> object. SYNONYMS: <strong>thing</strong>, <strong>gift</strong>, <strong>aunt's</strong></p>\n<p>I can <strong>EXAMINE AUNT'S BUTT</strong>, and it examines the thing.</p>\n<p>In the real game, however:<br>\n<output style=\"font-family: monospace\">&gt;examine aunt's butt<br>\nI don't know the word \"butt\".<br>\n</output></p>\n<p>I tried to break it down by splitting at spaces (if they existed) and running each word back through <code>CompareNames</code> with a <code>foreach</code>, but that made the game freeze up.</p>\n<p>Hrmm...</p>\n\n",
      "PostDate": "2021-04-24T20:00:04.9244186Z",
      "LastEditDate": "2021-04-24T20:25:07.9369262Z",
      "link": null
    },
    {
      "PostId": "4c5a5362-76e7-4b11-ae61-780f8e69fb8e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> I don't know the word \"butt\".\r\n\r\nThat's the response I would expect for the method I described. Do you want it to ignore the extra word? I assumed that the existence of an \"I don't know the word\" message implies that unknown words will cause an error.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I don't know the word \"butt\".</p>\n</blockquote>\n<p>That's the response I would expect for the method I described. Do you want it to ignore the extra word? I assumed that the existence of an \"I don't know the word\" message implies that unknown words will cause an error.</p>\n\n",
      "PostDate": "2021-04-24T21:48:30.0523036Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9874daba-67da-4ff9-b6cf-14e7874c383f",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I must have missed something. I'll look at it again.\r\n\r\nThe way I've got it, it seems to replace ```\" \"``` with ```\"\"```, which combines all the words.  So, ```aunt's butt```:\r\n\r\n```\r\naunt'sbutt\r\n123456789\r\n\r\n// This becomes:\r\n\r\naunt's\r\n\r\n```\r\n\r\n---\r\nEven **aunt's zzzz zz z zzz** would end up being read as ```aunt's``` the way I've got it.\r\n\r\nI started off listening to Black Sabbath, see, and I was coding well then.\r\n\r\n...but, ever since The Doors came on, I've been just kinda starin' at the screen, ya' know?\r\n\r\nI think I'll take a break and come back and reread your posts before I get back into it.",
      "EditableFormat": "markdown",
      "HTML": "<p>I must have missed something. I'll look at it again.</p>\n<p>The way I've got it, it seems to replace <code>\" \"</code> with <code>\"\"</code>, which combines all the words.  So, <code>aunt's butt</code>:</p>\n<pre><code>aunt'sbutt\n123456789\n\n// This becomes:\n\naunt's\n\n</code></pre>\n<hr>\n<p>Even <strong>aunt's zzzz zz z zzz</strong> would end up being read as <code>aunt's</code> the way I've got it.</p>\n<p>I started off listening to Black Sabbath, see, and I was coding well then.</p>\n<p>...but, ever since The Doors came on, I've been just kinda starin' at the screen, ya' know?</p>\n<p>I think I'll take a break and come back and reread your posts before I get back into it.</p>\n\n",
      "PostDate": "2021-04-24T22:14:46.1359942Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "a17ca4a3-8a5d-44a2-ad0a-130b79ce54d5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I hadn't noticed your code; we must have been typing at the same time earlier.\r\n\r\nFirst thing I notice:\r\n```\r\n              verbExists = false\r\n              foreach (cmd, commandArray) {\r\n                verbExists = ActionExists(cmd)\r\n              }\r\n```\r\nThis tests if the *last* word is a verb.\r\nYou probably want either:\r\n```\r\n              verbExists = false\r\n              foreach (cmd, commandArray) {\r\n                verbExists = verbExists or ActionExists(cmd)\r\n              }\r\n```\r\nor:\r\n```\r\n              verbExists = false\r\n              foreach (cmd, commandArray) {\r\n                if (ActionExists(cmd)) {\r\n                  verbExists = true\r\n                }\r\n              }\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I hadn't noticed your code; we must have been typing at the same time earlier.</p>\n<p>First thing I notice:</p>\n<pre><code>              verbExists = false\n              foreach (cmd, commandArray) {\n                verbExists = ActionExists(cmd)\n              }\n</code></pre>\n<p>This tests if the <em>last</em> word is a verb.<br>\nYou probably want either:</p>\n<pre><code>              verbExists = false\n              foreach (cmd, commandArray) {\n                verbExists = verbExists or ActionExists(cmd)\n              }\n</code></pre>\n<p>or:</p>\n<pre><code>              verbExists = false\n              foreach (cmd, commandArray) {\n                if (ActionExists(cmd)) {\n                  verbExists = true\n                }\n              }\n</code></pre>\n\n",
      "PostDate": "2021-04-25T00:36:35.0290985Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "a0a9a2fa-cf8c-4da5-923a-8df66d999bb3",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Here's a rough guess at how I'd do this.\r\n\r\nI'm assuming `game.object_words`, `game.verb_words`, and `game.exit_words` are dictionaries. The key is the lowercased first 6 letters of the word; the value is an objectlist containing matching objects. Meanwhile, `game.other_words` is just a stringlist of words like \"again\", \"him\", \"it\", \"the\", \"to\", \"and\", etc. Words that are neither objects nor verbs, but may appear in a command.\r\n\r\nFor those objects, I'm assuming that we treat each word separately. So an object with a two-word name appears on both lists.\r\n\r\nHandleSingleCommand:\r\n```\r\ncommands = NewObjectList()\r\nvalid = true\r\nforeach (word, Split(LCase(command), \" \")) {\r\n  if (valid) {\r\n    token = Left(word, 6)\r\n    while (DictionaryContains (game.synonyms, token)) {\r\n      token = DictionaryItem (game.synonyms, token)\r\n    }\r\n    if (DictionaryContains (game.verb_words, token)) {\r\n      nonefound = true\r\n      foreach (cmd, DictionaryItem (game.verb_words, token)) {\r\n        if (cmd.parent = null or cmd.parent = game.pov.parent) {\r\n          list add (commands, cmd)\r\n          nonefound = false\r\n        }\r\n      }\r\n      if (nonefound) {\r\n        msg (\"I cannot \"+word+\" here.\")\r\n        valid = false\r\n      }\r\n    }\r\n    else if (not (DictionaryContains (game.object_words, token) or DictionaryContains (game.exit_words, token) or ListContains (game.other_words, token))) {\r\n      msg (\"I don't know the word \\\"\" + word + \"\\\".\")\r\n      valid = false\r\n    }\r\n  }\r\n}\r\nif (valid and ListCount (commands) = 0) {\r\n  msg (\"There was no verb in that sentence!\")\r\n  valid = false\r\n}\r\nif (valid) {\r\n  // Do the usual HandleSingleCommand stuff here\r\n  //   but… we can use the objectlist 'commands' created above\r\n  //   instead of ScopeCommands(), which should be more efficient\r\n  // If we can't resolve the command, we should display:\r\n  //     msg (\"That sentence isn't one I recognise.\")\r\n  // as the other options would have prevented us reaching this point.\r\n}\r\n```\r\n\r\nAnd then ResolveNameFromList can be a bit simpler.\r\n* Look up the value it was given in object_words or exit_words as appropriate\r\n    * If it isn't there, `msg (\"You used the word \\\"\" + value + \"\\\" in a way I don't understand.\")`\r\n    * If `value` is multiple words, loop over them removing from consideration any objects that don't match all of them.\r\n* We have a list of valid objects. Remove any that aren't in `scope`.\r\n* If there's none left, it's time to say `msg (\"You can't see any \" + value + \" here.\")`\r\n* If there's more than one object, do the disambiguation thing.",
      "EditableFormat": "markdown",
      "HTML": "<p>Here's a rough guess at how I'd do this.</p>\n<p>I'm assuming <code>game.object_words</code>, <code>game.verb_words</code>, and <code>game.exit_words</code> are dictionaries. The key is the lowercased first 6 letters of the word; the value is an objectlist containing matching objects. Meanwhile, <code>game.other_words</code> is just a stringlist of words like \"again\", \"him\", \"it\", \"the\", \"to\", \"and\", etc. Words that are neither objects nor verbs, but may appear in a command.</p>\n<p>For those objects, I'm assuming that we treat each word separately. So an object with a two-word name appears on both lists.</p>\n<p>HandleSingleCommand:</p>\n<pre><code>commands = NewObjectList()\nvalid = true\nforeach (word, Split(LCase(command), \" \")) {\n  if (valid) {\n    token = Left(word, 6)\n    while (DictionaryContains (game.synonyms, token)) {\n      token = DictionaryItem (game.synonyms, token)\n    }\n    if (DictionaryContains (game.verb_words, token)) {\n      nonefound = true\n      foreach (cmd, DictionaryItem (game.verb_words, token)) {\n        if (cmd.parent = null or cmd.parent = game.pov.parent) {\n          list add (commands, cmd)\n          nonefound = false\n        }\n      }\n      if (nonefound) {\n        msg (\"I cannot \"+word+\" here.\")\n        valid = false\n      }\n    }\n    else if (not (DictionaryContains (game.object_words, token) or DictionaryContains (game.exit_words, token) or ListContains (game.other_words, token))) {\n      msg (\"I don't know the word \\\"\" + word + \"\\\".\")\n      valid = false\n    }\n  }\n}\nif (valid and ListCount (commands) = 0) {\n  msg (\"There was no verb in that sentence!\")\n  valid = false\n}\nif (valid) {\n  // Do the usual HandleSingleCommand stuff here\n  //   but… we can use the objectlist 'commands' created above\n  //   instead of ScopeCommands(), which should be more efficient\n  // If we can't resolve the command, we should display:\n  //     msg (\"That sentence isn't one I recognise.\")\n  // as the other options would have prevented us reaching this point.\n}\n</code></pre>\n<p>And then ResolveNameFromList can be a bit simpler.</p>\n<ul>\n<li>Look up the value it was given in object_words or exit_words as appropriate\n<ul>\n<li>If it isn't there, <code>msg (\"You used the word \\\"\" + value + \"\\\" in a way I don't understand.\")</code></li>\n<li>If <code>value</code> is multiple words, loop over them removing from consideration any objects that don't match all of them.</li>\n</ul>\n</li>\n<li>We have a list of valid objects. Remove any that aren't in <code>scope</code>.</li>\n<li>If there's none left, it's time to say <code>msg (\"You can't see any \" + value + \" here.\")</code></li>\n<li>If there's more than one object, do the disambiguation thing.</li>\n</ul>\n\n",
      "PostDate": "2021-04-25T01:17:39.9734748Z",
      "LastEditDate": "2021-04-25T01:45:46.914692Z",
      "link": null
    },
    {
      "PostId": "c0f01e7b-5baf-4f34-be23-35f476911195",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I wasn't thinking about everything correctly.\r\n\r\nI (guess I) was thinking ```CompareNames``` would stop the process if a value didn't match anything, but I was being utterly foolish.\r\n\r\nI realized this whilst reading that last code you posted.\r\n\r\nWith ```CompareNames```, it starts ```false```.  If it finds one match (just one), it becomes ```true```.\r\n\r\nDur!\r\n\r\nYou're starting off ```true``` and if one word isn't matched, it kicks it back as ```false```, but it will search through all the aliases and synonyms listed, leaving it ```false``` is nothing is found in the end.\r\n\r\nWell played, sir.  At least one of us was thinking clearly. :)",
      "EditableFormat": "markdown",
      "HTML": "<p>I wasn't thinking about everything correctly.</p>\n<p>I (guess I) was thinking <code>CompareNames</code> would stop the process if a value didn't match anything, but I was being utterly foolish.</p>\n<p>I realized this whilst reading that last code you posted.</p>\n<p>With <code>CompareNames</code>, it starts <code>false</code>.  If it finds one match (just one), it becomes <code>true</code>.</p>\n<p>Dur!</p>\n<p>You're starting off <code>true</code> and if one word isn't matched, it kicks it back as <code>false</code>, but it will search through all the aliases and synonyms listed, leaving it <code>false</code> is nothing is found in the end.</p>\n<p>Well played, sir.  At least one of us was thinking clearly. :)</p>\n\n",
      "PostDate": "2021-04-26T14:27:35.8380386Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "adbc247a-46b7-42d7-8b78-a3254efe02c3",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Well, I've decided against using all the code I've added to make it match the first six characters.\r\n\r\nThat was a limitation back then (as we were already aware), and I just found an interview with the man who wrote the game I'm porting in which he complains about that particular limitation.  It pissed him off. He would have liked to have been able to have a smart-ass response for *every word* entered by the player -- not just the first 6 letters of each.\r\n\r\nSo, I'm losing all the bits concerning 6 characters.  It has to mach a full word (or phrase) or no match.  It still doesn't search each word within a phrase to match just one word.\r\n\r\nAlso, I adjusted \"I don't know the word ____.\" Now, if there is a space in the string, it will print \"I don't know the **phrase** ___.\"\r\n\r\n---\r\nI was having fun porting the game to Quest 5 up until I started messing with all this.\r\n\r\n---\r\nHere's a question:  When porting something old to Quest, is it more fitting to leave Quest's basic functionality (like the parser) intact so it behaves as Quest users expect, or to modify nearly everything to make the game behave as it originally did?\r\n\r\n**EDIT**\r\n\r\n...because, if I'm truly replicating this, **X** will not be understood; the player will have to type out **EXAMINE** or **LOOK AT**.  I don't think anyone would appreciate that very much.",
      "EditableFormat": "markdown",
      "HTML": "<p>Well, I've decided against using all the code I've added to make it match the first six characters.</p>\n<p>That was a limitation back then (as we were already aware), and I just found an interview with the man who wrote the game I'm porting in which he complains about that particular limitation.  It pissed him off. He would have liked to have been able to have a smart-ass response for <em>every word</em> entered by the player -- not just the first 6 letters of each.</p>\n<p>So, I'm losing all the bits concerning 6 characters.  It has to mach a full word (or phrase) or no match.  It still doesn't search each word within a phrase to match just one word.</p>\n<p>Also, I adjusted \"I don't know the word ____.\" Now, if there is a space in the string, it will print \"I don't know the <strong>phrase</strong> ___.\"</p>\n<hr>\n<p>I was having fun porting the game to Quest 5 up until I started messing with all this.</p>\n<hr>\n<p>Here's a question:  When porting something old to Quest, is it more fitting to leave Quest's basic functionality (like the parser) intact so it behaves as Quest users expect, or to modify nearly everything to make the game behave as it originally did?</p>\n<p><strong>EDIT</strong></p>\n<p>...because, if I'm truly replicating this, <strong>X</strong> will not be understood; the player will have to type out <strong>EXAMINE</strong> or <strong>LOOK AT</strong>.  I don't think anyone would appreciate that very much.</p>\n\n",
      "PostDate": "2021-04-26T15:18:53.2809079Z",
      "LastEditDate": "2021-04-26T15:27:32.5552046Z",
      "link": null
    },
    {
      "PostId": "7d11005f-559e-4587-8ba7-579219735c2d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Here's a question: When porting something old to Quest, is it more fitting to leave Quest's basic functionality (like the parser) intact so it behaves as Quest users expect, or to modify nearly everything to make the game behave as it originally did?\r\n\r\nI think that someone who's used to the original game should be able to get through it in the same way; but someone who's used to Quest shouldn't find features missing. So… add features to match the original, but don't take anything away.\r\n\r\nLike for my *Circus* and *The Time Machine* remakes, I added alternatives to some of the commands (so \"put rock in lever\" is a synonym for \"wedge lever\", \"give fish to dolphin\" is a synonym for \"feed dolphin\", and \"use cable on terminals\" is a synonym for \"short terminals\". And other examples where it felt a bit guess-the-verb, I added alternatives like \"switch off\" and \"turn on\" so that operating a flashlight doesn't require you to think of the verbs \"illuminate\" and \"extinguish\". More controversially, I decided it was appropriate to add descriptions in case you want to examine an object,\r\n\r\nI think it's nice being able to play a game in the way it was originally; but in some cases I think it's better for the game to work in an intuitive way. So I always made sure that if you treat the game like its 13KB original, it will behave like you expect; *but* if you play it assuming Quest conventions, it will still do what you expect\r\n\r\n(One more example: \"You can see a panel.\" What kind of panel is it? Is it a control panel? A piece of a wall? It turns out to be an access panel that you could force open to enter the lab, but the only way to discover this is by typing \"lever panel\" while holding a crowbar. I think that's something that should have been changed, because it's a clue that would have been obvious to the character in the game, but in the original it was hidden from the player. I don't like \"idiot plots\" in games, when the memory or resolution issues that game rise to them no longer apply)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Here's a question: When porting something old to Quest, is it more fitting to leave Quest's basic functionality (like the parser) intact so it behaves as Quest users expect, or to modify nearly everything to make the game behave as it originally did?</p>\n</blockquote>\n<p>I think that someone who's used to the original game should be able to get through it in the same way; but someone who's used to Quest shouldn't find features missing. So… add features to match the original, but don't take anything away.</p>\n<p>Like for my <em>Circus</em> and <em>The Time Machine</em> remakes, I added alternatives to some of the commands (so \"put rock in lever\" is a synonym for \"wedge lever\", \"give fish to dolphin\" is a synonym for \"feed dolphin\", and \"use cable on terminals\" is a synonym for \"short terminals\". And other examples where it felt a bit guess-the-verb, I added alternatives like \"switch off\" and \"turn on\" so that operating a flashlight doesn't require you to think of the verbs \"illuminate\" and \"extinguish\". More controversially, I decided it was appropriate to add descriptions in case you want to examine an object,</p>\n<p>I think it's nice being able to play a game in the way it was originally; but in some cases I think it's better for the game to work in an intuitive way. So I always made sure that if you treat the game like its 13KB original, it will behave like you expect; <em>but</em> if you play it assuming Quest conventions, it will still do what you expect</p>\n<p>(One more example: \"You can see a panel.\" What kind of panel is it? Is it a control panel? A piece of a wall? It turns out to be an access panel that you could force open to enter the lab, but the only way to discover this is by typing \"lever panel\" while holding a crowbar. I think that's something that should have been changed, because it's a clue that would have been obvious to the character in the game, but in the original it was hidden from the player. I don't like \"idiot plots\" in games, when the memory or resolution issues that game rise to them no longer apply)</p>\n\n",
      "PostDate": "2021-04-26T17:33:44.508907Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "09492713-7329-4290-a099-8d63c57675f1",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Dave Lebling has referred to this more than once:\r\n\r\n![flowchart-image](https://user-images.githubusercontent.com/30656341/116145567-1957da00-a6a3-11eb-96d1-5036199a9299.png)\r\n\r\n---\r\n> I think that someone who's used to the original game should be able to get through it in the same way; but someone who's used to Quest shouldn't find features missing. So… add features to match the original, but don't take anything away.\r\n\r\nThat's a good goal.",
      "EditableFormat": "markdown",
      "HTML": "<p>Dave Lebling has referred to this more than once:</p>\n<p><img src=\"https://user-images.githubusercontent.com/30656341/116145567-1957da00-a6a3-11eb-96d1-5036199a9299.png\" alt=\"flowchart-image\"></p>\n<hr>\n<blockquote>\n<p>I think that someone who's used to the original game should be able to get through it in the same way; but someone who's used to Quest shouldn't find features missing. So… add features to match the original, but don't take anything away.</p>\n</blockquote>\n<p>That's a good goal.</p>\n\n",
      "PostDate": "2021-04-26T21:23:06.9173701Z",
      "LastEditDate": "2021-04-26T21:23:43.1422913Z",
      "link": null
    },
    {
      "PostId": "8eda9ab4-e5ca-4446-9f63-d52f020a21c3",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is not unlike what I'm doing.\r\n\r\nhttps://github.com/historicalsource/hitchhikersguide\r\n\r\nSpecifically:\r\n\r\nhttps://github.com/historicalsource/hitchhikersguide/blob/master/parser.zil\r\n\r\nand:\r\n\r\nhttps://github.com/historicalsource/hitchhikersguide/blob/master/syntax.zil\r\n\r\n...and maybe this too:\r\n\r\nhttps://github.com/historicalsource/hitchhikersguide/blob/master/verbs.zil",
      "EditableFormat": "markdown",
      "HTML": "<p>This is not unlike what I'm doing.</p>\n<p>https://github.com/historicalsource/hitchhikersguide</p>\n<p>Specifically:</p>\n<p>https://github.com/historicalsource/hitchhikersguide/blob/master/parser.zil</p>\n<p>and:</p>\n<p>https://github.com/historicalsource/hitchhikersguide/blob/master/syntax.zil</p>\n<p>...and maybe this too:</p>\n<p>https://github.com/historicalsource/hitchhikersguide/blob/master/verbs.zil</p>\n\n",
      "PostDate": "2021-04-26T23:35:27.9895344Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0a674d9f-c95b-40fd-b92f-558955417ae7",
      "UserId": 5574,
      "Username": "R2T1",
      "AvatarUrl": "http://i.imgur.com/32ogfqMb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "With the various games I have \"ported/translated\" from the original,  I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.",
      "EditableFormat": "markdown",
      "HTML": "<p>With the various games I have \"ported/translated\" from the original,  I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.</p>\n\n",
      "PostDate": "2021-04-27T05:44:24.3520993Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9a390fc9-f493-491e-a50d-8acc089904b9",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "**UPDATE**\r\n\r\nRejoice!\r\n\r\nI wanted to port the SOLID-GOLD EDITION in the beginning, but couldn't find that source code.\r\n\r\n...but now I've found it!  And guess what?  The solid-gold edition doesn't allow the player to input just the first 6 characters. Whole words are required (just like I prefer it, and now I see why).\r\n\r\nSo, ha ha!  Hoo hoo!  I don't have to mess with that part now.\r\n\r\nThe solid-gold editions are the definitive releases, after all.\r\n\r\n---\r\n>  I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.\r\n\r\nSame approach suggested by mrangel.\r\n\r\nIf both of you suggest the same thing, it sounds like it's definitely the way to go!",
      "EditableFormat": "markdown",
      "HTML": "<p><strong>UPDATE</strong></p>\n<p>Rejoice!</p>\n<p>I wanted to port the SOLID-GOLD EDITION in the beginning, but couldn't find that source code.</p>\n<p>...but now I've found it!  And guess what?  The solid-gold edition doesn't allow the player to input just the first 6 characters. Whole words are required (just like I prefer it, and now I see why).</p>\n<p>So, ha ha!  Hoo hoo!  I don't have to mess with that part now.</p>\n<p>The solid-gold editions are the definitive releases, after all.</p>\n<hr>\n<blockquote>\n<p>I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.</p>\n</blockquote>\n<p>Same approach suggested by mrangel.</p>\n<p>If both of you suggest the same thing, it sounds like it's definitely the way to go!</p>\n\n",
      "PostDate": "2021-04-29T22:23:14.3952814Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9b30109b-a4d6-47e6-b630-f91f7d05de58",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@mrangel\r\n\r\nhttps://textadventures.co.uk/forum/quest/topic/bcumxvm5ous9xl0uz8lvrq/another-parser-modification-question#a0a9a2fa-cf8c-4da5-923a-8df66d999bb3\r\n\r\nThat's sort of what I want to do.\r\n\r\nTake the \"attack\" command, for instance. I usually make it so the following words all attack: attack,hit,kick,slap,kill,push,shove\r\n\r\nSo, for my attack command, I'll have a stringlist of synonyms including all those words.  Each command has a ```synonyms``` attribute with a string list of its synonyms. Each synonym is a single word (no prepositions).\r\n\r\nThe attack command still has a normal pattern attribute.\r\n\r\nThat's a bad example.\r\n\r\nHow about \"go\".  I'd say we should include: go, walk, proceed, run,  step\r\n\r\nThose are the synonyms.\r\n\r\nThe pattern: ```^(go|walk|proceed|run|step)( (to|towards)|) (?<exit>.*)$```\r\n\r\nI'd also add a prepositions string list attribute to this command: to, towards\r\n\r\nWALK TOWARDS THE NORTH\r\n\r\nQuest handles the \"THE\" already, but I'd have another string list attribute somewhere including all the articles.\r\n\r\nWith those additions, Quest will know every word that's in its vocabulary.  (The object names and altnames are already handled.)",
      "EditableFormat": "markdown",
      "HTML": "<p>@mrangel</p>\n<p>https://textadventures.co.uk/forum/quest/topic/bcumxvm5ous9xl0uz8lvrq/another-parser-modification-question#a0a9a2fa-cf8c-4da5-923a-8df66d999bb3</p>\n<p>That's sort of what I want to do.</p>\n<p>Take the \"attack\" command, for instance. I usually make it so the following words all attack: attack,hit,kick,slap,kill,push,shove</p>\n<p>So, for my attack command, I'll have a stringlist of synonyms including all those words.  Each command has a <code>synonyms</code> attribute with a string list of its synonyms. Each synonym is a single word (no prepositions).</p>\n<p>The attack command still has a normal pattern attribute.</p>\n<p>That's a bad example.</p>\n<p>How about \"go\".  I'd say we should include: go, walk, proceed, run,  step</p>\n<p>Those are the synonyms.</p>\n<p>The pattern: <code>^(go|walk|proceed|run|step)( (to|towards)|) (?&lt;exit&gt;.*)$</code></p>\n<p>I'd also add a prepositions string list attribute to this command: to, towards</p>\n<p>WALK TOWARDS THE NORTH</p>\n<p>Quest handles the \"THE\" already, but I'd have another string list attribute somewhere including all the articles.</p>\n<p>With those additions, Quest will know every word that's in its vocabulary.  (The object names and altnames are already handled.)</p>\n\n",
      "PostDate": "2021-05-06T23:49:18.6271492Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "029031e5-e0fa-411d-b921-349f49eba3a8",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@Artoo\r\n\r\n> With the various games I have \"ported/translated\" from the original, I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.\r\n\r\nWhat about misspellings and such?  Leave 'em or fix 'em?",
      "EditableFormat": "markdown",
      "HTML": "<p>@Artoo</p>\n<blockquote>\n<p>With the various games I have \"ported/translated\" from the original, I allow all the current functions/facilites that are used in the APP I am using while ensuring that all verb-noun combinations in the original will work in the new version.</p>\n</blockquote>\n<p>What about misspellings and such?  Leave 'em or fix 'em?</p>\n\n",
      "PostDate": "2021-05-06T23:53:00.9768437Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "78e13cf8-0079-4e25-b58c-17f5d109b1ee",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Makes sense.\r\nWith the code I'd shown above, I'm assuming global dictionaries for each word type. But there's no reason you couldn't have a startup script to collate them:\r\n```\r\ngame.object_words = NewDictionary()\r\ngame.verb_words = NewDictionary()\r\ngame.exit_words = NewDictionary()\r\ngame.other_words = Split(\"the;a;an;of;in;\")\r\nforeach (cmd, AllCommands()) {\r\n  if (HasAttribute (cmd, \"synonyms\")) {\r\n    foreach (word, cmd.synonyms) {\r\n      if (not DictionaryContains (game.verb_words, verb)) {\r\n        dictionary add (game.verb_words, verb, NewObjectList())\r\n      }\r\n      list = DictionaryItem (game.verb_words, verb)\r\n      if (not ListContains (list, cmd)) {\r\n        list add (list, cmd)\r\n      }\r\n    }\r\n  }\r\n  if (HasAttribute (cmd, \"prepositions\")) {\r\n    foreach (word, cmd.preopsitions) {\r\n      if (not ListContains (game.other_words, word)) {\r\n        list add (game.other_words, word)\r\n      }\r\n    }\r\n  }\r\n}\r\nforeach (obj, AllObjects()) {\r\n  words = Split (LCase (GetDisplayAlias (obj)), \" \")\r\n  if (HasAttribute (obj, \"alt\")) {\r\n    foreach (alias, obj.alt) {\r\n      foreach (word, Split (LCase (alias), \" \")) {\r\n        if (not ListContains (words, word)) {\r\n          list add (words, word)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  foreach (word, words) {\r\n    if (not DictionaryContains (game.object_words, word)) {\r\n      dictionary add (game.object_words, word, NewObjectList())\r\n    }\r\n    list = DictionaryItem (game.object_words, word)\r\n    if (not ListContains (list, obj)) {\r\n      list add (list, obj)\r\n    }\r\n  }\r\n}\r\nforeach (obj, AllExits()) {\r\n  words = Split (LCase (GetDisplayAlias (obj)), \" \")\r\n  if (HasAttribute (obj, \"alt\")) {\r\n    foreach (alias, obj.alt) {\r\n      foreach (word, Split (LCase (alias), \" \")) {\r\n        if (not ListContains (words, word)) {\r\n          list add (words, word)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  foreach (word, words) {\r\n    if (not DictionaryContains (game.exit_words, verb)) {\r\n      dictionary add (game.exit_words, verb, NewObjectList())\r\n    }\r\n    list = DictionaryItem (game.exit_words, word)\r\n    if (not ListContains (list, obj)) {\r\n      list add (list, obj)\r\n    }\r\n  }\r\n}\r\n```\r\nSo that it's easy for parser to look up a list of all commands that contain this particular verb-word. Means that rather than comparing the entered command against the pattern of *every* command, we have a pre-generated list of commands that it could match. Smaller number of comparisons, so more efficient (if using a little more memory to store the lookup table). And if it doesn't match a regexp, we know that it's a case of the words being in the wrong order, not an unknown word.",
      "EditableFormat": "markdown",
      "HTML": "<p>Makes sense.<br>\nWith the code I'd shown above, I'm assuming global dictionaries for each word type. But there's no reason you couldn't have a startup script to collate them:</p>\n<pre><code>game.object_words = NewDictionary()\ngame.verb_words = NewDictionary()\ngame.exit_words = NewDictionary()\ngame.other_words = Split(\"the;a;an;of;in;\")\nforeach (cmd, AllCommands()) {\n  if (HasAttribute (cmd, \"synonyms\")) {\n    foreach (word, cmd.synonyms) {\n      if (not DictionaryContains (game.verb_words, verb)) {\n        dictionary add (game.verb_words, verb, NewObjectList())\n      }\n      list = DictionaryItem (game.verb_words, verb)\n      if (not ListContains (list, cmd)) {\n        list add (list, cmd)\n      }\n    }\n  }\n  if (HasAttribute (cmd, \"prepositions\")) {\n    foreach (word, cmd.preopsitions) {\n      if (not ListContains (game.other_words, word)) {\n        list add (game.other_words, word)\n      }\n    }\n  }\n}\nforeach (obj, AllObjects()) {\n  words = Split (LCase (GetDisplayAlias (obj)), \" \")\n  if (HasAttribute (obj, \"alt\")) {\n    foreach (alias, obj.alt) {\n      foreach (word, Split (LCase (alias), \" \")) {\n        if (not ListContains (words, word)) {\n          list add (words, word)\n        }\n      }\n    }\n  }\n  foreach (word, words) {\n    if (not DictionaryContains (game.object_words, word)) {\n      dictionary add (game.object_words, word, NewObjectList())\n    }\n    list = DictionaryItem (game.object_words, word)\n    if (not ListContains (list, obj)) {\n      list add (list, obj)\n    }\n  }\n}\nforeach (obj, AllExits()) {\n  words = Split (LCase (GetDisplayAlias (obj)), \" \")\n  if (HasAttribute (obj, \"alt\")) {\n    foreach (alias, obj.alt) {\n      foreach (word, Split (LCase (alias), \" \")) {\n        if (not ListContains (words, word)) {\n          list add (words, word)\n        }\n      }\n    }\n  }\n  foreach (word, words) {\n    if (not DictionaryContains (game.exit_words, verb)) {\n      dictionary add (game.exit_words, verb, NewObjectList())\n    }\n    list = DictionaryItem (game.exit_words, word)\n    if (not ListContains (list, obj)) {\n      list add (list, obj)\n    }\n  }\n}\n</code></pre>\n<p>So that it's easy for parser to look up a list of all commands that contain this particular verb-word. Means that rather than comparing the entered command against the pattern of <em>every</em> command, we have a pre-generated list of commands that it could match. Smaller number of comparisons, so more efficient (if using a little more memory to store the lookup table). And if it doesn't match a regexp, we know that it's a case of the words being in the wrong order, not an unknown word.</p>\n\n",
      "PostDate": "2021-05-07T00:54:20.4829616Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b08f0744-47b6-40ed-b3bc-6755ff2d4c25",
      "UserId": 5574,
      "Username": "R2T1",
      "AvatarUrl": "http://i.imgur.com/32ogfqMb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I usually fix spelling / grammar unless it is germane to the story. (ie. a pirate speaking or a gangster)",
      "EditableFormat": "markdown",
      "HTML": "<p>I usually fix spelling / grammar unless it is germane to the story. (ie. a pirate speaking or a gangster)</p>\n\n",
      "PostDate": "2021-05-07T05:44:30.0759991Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "51f21371-8c37-4847-834b-94931cb38839",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@mrangel\r\n\r\nThat looks pretty good!\r\n\r\nThanks!\r\n\r\n---\r\n@R2\r\n\r\nCool.\r\n\r\nAlso, just to be sure everyone agrees:\r\n\r\ntil - until\r\n'til - until\r\ntill - an action not unlike digging\r\n\r\nJust making sure \"till\" isn't an acceptable form of \"until\".",
      "EditableFormat": "markdown",
      "HTML": "<p>@mrangel</p>\n<p>That looks pretty good!</p>\n<p>Thanks!</p>\n<hr>\n<p>@R2</p>\n<p>Cool.</p>\n<p>Also, just to be sure everyone agrees:</p>\n<p>til - until<br>\n'til - until<br>\ntill - an action not unlike digging</p>\n<p>Just making sure \"till\" isn't an acceptable form of \"until\".</p>\n\n",
      "PostDate": "2021-05-07T06:00:14.8313505Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5133bc21-6a82-4532-bcae-64120d50656e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It might also be useful having synonym-words and verb-words as separate things. Verb words are recognised by each command's pattern; synonym words are stored in a dictionary so that the parser will try <code style=\"margin-right: -0.3em\">Replace</code>ing if necessary to get a match. For commands with quite complex patterns, it could be useful to have a separate substitution dictionary as the first step.",
      "EditableFormat": "markdown",
      "HTML": "<p>It might also be useful having synonym-words and verb-words as separate things. Verb words are recognised by each command's pattern; synonym words are stored in a dictionary so that the parser will try <code style=\"margin-right: -0.3em\">Replace</code>ing if necessary to get a match. For commands with quite complex patterns, it could be useful to have a separate substitution dictionary as the first step.</p>\n\n",
      "PostDate": "2021-05-07T08:13:35.2139085Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d0e40cb1-1ca4-4037-90b6-2384b5d90de1",
      "UserId": 5574,
      "Username": "R2T1",
      "AvatarUrl": "http://i.imgur.com/32ogfqMb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "til is short for until but both mean till. Until is usually used to begin a sentence.\r\n\r\ntill can be a verb - to till the ground\r\n                     a noun - He put the customer's money in the till\r\n     or a preposition or conjunction - as late as or up to a time.  - till the time when...\r\nThese definitions are from the Collins English Dictionary and the Oxford Dictionary.\r\n\r\nIsn't English wonderful!",
      "EditableFormat": "markdown",
      "HTML": "<p>til is short for until but both mean till. Until is usually used to begin a sentence.</p>\n<p>till can be a verb - to till the ground<br>\na noun - He put the customer's money in the till<br>\nor a preposition or conjunction - as late as or up to a time.  - till the time when...<br>\nThese definitions are from the Collins English Dictionary and the Oxford Dictionary.</p>\n<p>Isn't English wonderful!</p>\n\n",
      "PostDate": "2021-05-07T09:29:56.4081672Z",
      "LastEditDate": "2021-05-07T09:30:34.8655957Z",
      "link": null
    },
    {
      "PostId": "27385cba-24f0-43cc-8e4d-915d5daf480d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yeah, it seems that until can be shortened to either \"til\" or \"till\". Not sure if that's a regional variation.",
      "EditableFormat": "markdown",
      "HTML": "<p>Yeah, it seems that until can be shortened to either \"til\" or \"till\". Not sure if that's a regional variation.</p>\n\n",
      "PostDate": "2021-05-07T11:06:10.8637178Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
