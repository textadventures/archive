{
  "Topic": {
    "TopicId": "qp8y8nvylew398l9ylbl6a",
    "ForumId": "15",
    "Title": "Quest 6 tips : unveil the map of a region with an item",
    "LastUpdated": "2021-06-13T13:02:16.247901Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "ce1253e5-6dab-4081-bbd9-99eed528ae10",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I am trying to replicate the game mechanic of displaying the complete map of a region when the player gets their hands on a map, like in early survival horror games.\r\n\r\nHere is how I managed it.\r\nPlease note that my method uses the taking of the item, but this is also doable with the examine command and a flag in the item.\r\n\r\n**Step 1 - Your map item**\r\n```\r\ncreateItem(\"b1Map\", TAKEABLE(), {\r\n  loc: \"cellA\",\r\n  alias: \"basement map\",\r\n  examine: \"A map of the basement. It is labeled \\\"B1 - Detention\\\"\",\r\n  afterMove: function(toLoc, fromLoc) {\r\n    msg(\"You note the locations.\")\r\n    map.update();\r\n  }\r\n})\r\n```\r\n**Step 2 - Setting preparations**\r\n```\r\nsettings.mapShowNotVisited = false\r\nsettings.mapGetStartingLocations = function() {\r\n  const start1 = w.cellA\r\n  start1.mapX = 0\r\n  start1.mapY = 0\r\n  start1.mapZ = 0\r\n  start1.mapRegion = 0\r\n  return [start1]\r\n}\r\nsettings.maps = {0 : \"b1Map\"}\r\n```\r\n_settings.maps_ is a dictionary with the mapRegion number as key, and the name of the map item as value.\r\n\r\n**Step 3 - Customize mapUpdate to check for the map**\r\n```\r\n// Draw the map\r\n// It collects all the SVG in five lists, which are effectively layers.\r\n// This means all the exits appear in one layer, all the labels in another\r\n// and so labels are always on top of exits\r\nmap.update = function() {\r\n  // grab the current room region and level. If the room is missing either, give up now!\r\n  const level = w[player.loc].mapZ\r\n  const region = w[player.loc].mapRegion\r\n  if (level === undefined || region === undefined) return\r\n  if (w[player.loc].mapIgnore) return\r\n\r\n  // Search for a map item corresponding to the current region.\r\n  const mapItem = w[settings.maps[region]];\r\n  \r\n  // Stuff gets put in any of several layers, which will be displayed in this order\r\n  const lists = {}\r\n  for (let el of map.layers) lists[el.name] = ['', '<g id=\"otherLevels-layer\" ' + el.attrs + '>']\r\n\r\n  // Loop through every room\r\n  for (let key in w) {\r\n    const room = w[key]\r\n    // Do not map if in another region (if region is true, the room can handle it)\r\n    // Only show if visited unless mapShowNotVisited or the player has the map of the region\r\n    if (room.mapRegion !== region && room.mapRegion !== true) continue\r\n    if ((mapItem === undefined || mapItem.loc !== player.name) && !settings.mapShowNotVisited && !room.visited) continue\r\n    // Call mapDraw on the room if it has that, otherwise the default version\r\n    (room.mapDraw ? room : map).mapDraw(lists, region, level, room)\r\n  }\r\n\r\n  // Add it all together\r\n  const result = settings.mapDefs ? settings.mapDefs() : []\r\n  for (let key in lists) {\r\n    for (let el of lists[key]) result.push(el)\r\n    result.push('</g>')\r\n  }\r\n  //console.log(result)\r\n  if (settings.mapExtras) result.push(...settings.mapExtras())\r\n  result.push(settings.mapMarker ? settings.mapMarker(w[player.loc]) : map.marker(w[player.loc].mapX, w[player.loc].mapY))\r\n\r\n  // Centre the view on the player, and draw it\r\n  const x = w[player.loc].mapX - settings.mapWidth/2\r\n  const y = -settings.mapHeight/2 + w[player.loc].mapY\r\n  draw(settings.mapWidth, settings.mapHeight, result, {destination:'quest-map', x:x, y:y})\r\n}\r\n```\r\n\r\nWhy am I using a specific dictionary ? Because iterating over the keys of a dictionary is time-consuming, while getting a specific value with the corresponding key is near-instantaneous. So we spare ourselves from doing two loops inside the _world_ dictionary.",
      "EditableFormat": "markdown",
      "HTML": "<p>I am trying to replicate the game mechanic of displaying the complete map of a region when the player gets their hands on a map, like in early survival horror games.</p>\n<p>Here is how I managed it.<br>\nPlease note that my method uses the taking of the item, but this is also doable with the examine command and a flag in the item.</p>\n<p><strong>Step 1 - Your map item</strong></p>\n<pre><code>createItem(\"b1Map\", TAKEABLE(), {\n  loc: \"cellA\",\n  alias: \"basement map\",\n  examine: \"A map of the basement. It is labeled \\\"B1 - Detention\\\"\",\n  afterMove: function(toLoc, fromLoc) {\n    msg(\"You note the locations.\")\n    map.update();\n  }\n})\n</code></pre>\n<p><strong>Step 2 - Setting preparations</strong></p>\n<pre><code>settings.mapShowNotVisited = false\nsettings.mapGetStartingLocations = function() {\n  const start1 = w.cellA\n  start1.mapX = 0\n  start1.mapY = 0\n  start1.mapZ = 0\n  start1.mapRegion = 0\n  return [start1]\n}\nsettings.maps = {0 : \"b1Map\"}\n</code></pre>\n<p><em>settings.maps</em> is a dictionary with the mapRegion number as key, and the name of the map item as value.</p>\n<p><strong>Step 3 - Customize mapUpdate to check for the map</strong></p>\n<pre><code>// Draw the map\n// It collects all the SVG in five lists, which are effectively layers.\n// This means all the exits appear in one layer, all the labels in another\n// and so labels are always on top of exits\nmap.update = function() {\n  // grab the current room region and level. If the room is missing either, give up now!\n  const level = w[player.loc].mapZ\n  const region = w[player.loc].mapRegion\n  if (level === undefined || region === undefined) return\n  if (w[player.loc].mapIgnore) return\n\n  // Search for a map item corresponding to the current region.\n  const mapItem = w[settings.maps[region]];\n  \n  // Stuff gets put in any of several layers, which will be displayed in this order\n  const lists = {}\n  for (let el of map.layers) lists[el.name] = ['', '&lt;g id=\"otherLevels-layer\" ' + el.attrs + '&gt;']\n\n  // Loop through every room\n  for (let key in w) {\n    const room = w[key]\n    // Do not map if in another region (if region is true, the room can handle it)\n    // Only show if visited unless mapShowNotVisited or the player has the map of the region\n    if (room.mapRegion !== region &amp;&amp; room.mapRegion !== true) continue\n    if ((mapItem === undefined || mapItem.loc !== player.name) &amp;&amp; !settings.mapShowNotVisited &amp;&amp; !room.visited) continue\n    // Call mapDraw on the room if it has that, otherwise the default version\n    (room.mapDraw ? room : map).mapDraw(lists, region, level, room)\n  }\n\n  // Add it all together\n  const result = settings.mapDefs ? settings.mapDefs() : []\n  for (let key in lists) {\n    for (let el of lists[key]) result.push(el)\n    result.push('&lt;/g&gt;')\n  }\n  //console.log(result)\n  if (settings.mapExtras) result.push(...settings.mapExtras())\n  result.push(settings.mapMarker ? settings.mapMarker(w[player.loc]) : map.marker(w[player.loc].mapX, w[player.loc].mapY))\n\n  // Centre the view on the player, and draw it\n  const x = w[player.loc].mapX - settings.mapWidth/2\n  const y = -settings.mapHeight/2 + w[player.loc].mapY\n  draw(settings.mapWidth, settings.mapHeight, result, {destination:'quest-map', x:x, y:y})\n}\n</code></pre>\n<p>Why am I using a specific dictionary ? Because iterating over the keys of a dictionary is time-consuming, while getting a specific value with the corresponding key is near-instantaneous. So we spare ourselves from doing two loops inside the <em>world</em> dictionary.</p>\n\n",
      "PostDate": "2021-06-13T13:02:16.247901Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
