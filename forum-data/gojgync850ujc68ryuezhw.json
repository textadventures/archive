{
  "Topic": {
    "TopicId": "gojgync850ujc68ryuezhw",
    "ForumId": "20",
    "Title": "Does my JS LinkedList class look right?",
    "LastUpdated": "2021-06-08T12:44:30.1764092Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "f27f57ca-cfb5-450f-b12b-25908dceace1",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm trying to fully comprehend all I can concerning linked lists.\r\n\r\nTo do that, I decided making them (and making them work) in JS would be my best route.\r\n\r\nI want to make sure no one sees any major flaws or careless mistakes (or pure dumbassery) in my code.\r\n\r\n<details>\r\n\r\n```\r\n// Javascript Linked Lists v0.6\r\n\r\n//ListNode class - for internal use (mostly)\r\nclass ListNode {\r\n    constructor (value, next = null) {\r\n        this.value = value;\r\n        this.next = next;\r\n    }\r\n}\r\n\r\nclass LinkedList {\r\n    constructor (head = null) {\r\n        this.head = head;\r\n        this.length = 0;\r\n    }\r\n    add(el) {\r\n        let node = typeof el.value !== 'undefined' ? el : new ListNode(el);\r\n        if (typeof node.next === 'undefined'){\r\n            node.next = null;\r\n        }\r\n        let previous, current;\r\n        if (this.head === null){\r\n            node.previous = null;\r\n            this.head = node;\r\n        } else {\r\n            current = this.head;\r\n            while(current.next) {\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            node.previous = current;\r\n            current.next = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    remove(val) {\r\n        let current = this.head;\r\n        let previous;\r\n        if (current.value === val){\r\n            this.head = current.next;\r\n        } else {\r\n            while (current.value !== val){\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            previous.next = current.next;\r\n        }\r\n        this.length--;\r\n    }\r\n    clear() {\r\n        this.head = null;\r\n    }\r\n    first() {\r\n        return this.head;\r\n    }\r\n    next() {\r\n        return this.head.next;\r\n    }\r\n    last() {\r\n        let lastNode = this.head\r\n        if (lastNode){\r\n            while (lastNode.next) {\r\n                lastNode = lastNode.next;\r\n            }\r\n        }\r\n        return lastNode;\r\n    }\r\n    pop(){\r\n        let node = this.last();\r\n        this.remove(node.value);\r\n        this.length--;\r\n        return node;\r\n    }\r\n    shift() {\r\n        let node = this.head;\r\n        this.remove (node.value)\r\n        this.length--;\r\n        return node;\r\n    }\r\n    unshift(val) {\r\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\r\n        let current = this.head;\r\n        node.next = current;\r\n        node.previous = null;\r\n        this.head = node;\r\n        this.length++;\r\n        return this.length;\r\n    }\r\n    addToHead(val) {\r\n        return this.unshift(val);\r\n    }\r\n    indexOf(val){\r\n        let current = this.head;\r\n        let i = -1;\r\n        while (current) {\r\n            i++;\r\n            if (current.value === val){\r\n                return i;\r\n            }\r\n            current = current.next;\r\n        }\r\n        return -1;\r\n    }\r\n    contains(val) {\r\n        return this.indexOf(val) > -1;\r\n    }\r\n    elementAt(i){\r\n        let current = this.head;\r\n        let count = 0;\r\n        while (count < i){\r\n            count++;\r\n            current = current.next;\r\n        }\r\n        return current.value;\r\n    }\r\n    addAt(ind, val){\r\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\r\n        let current = this.head;\r\n        let previous;\r\n        let currentIndex = 0;\r\n        if (ind > this.length){\r\n            return false;\r\n        }\r\n        if (ind === 0){\r\n            node.next = current;\r\n            node.previous = null;\r\n            this.head = node\r\n        } else {\r\n            while (currentIndex < ind){\r\n                currentIndex++;\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            node.next = current;\r\n            node.previous = previous;\r\n            previous.next = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeAt(index){\r\n        let current = this.head;\r\n        let previous;\r\n        let currentIndex = 0;\r\n        if (index < 0 || index >= this.length){\r\n            return null;\r\n        }\r\n        if (index === 0){\r\n            this.head = current.next;\r\n        } else {\r\n            while (currentIndex < index){\r\n                currentIndex++;\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            previous.next = current.next;\r\n        }\r\n        this.length--;\r\n        return current.value;\r\n    }\r\n    count() {\r\n        return this.length;\r\n    }\r\n    isEmpty() {\r\n        return this.length === 0;\r\n    }\r\n    print(current = this.head) {\r\n        if (current){\r\n            console.log (current.value)\r\n        } else {\r\n            return;\r\n        }\r\n        this.print(current.next)\r\n    }\r\n}\r\n```\r\n\r\n---\r\n```\r\n// create a linked list\r\nlet list = new LinkedList();\r\nlet a = \"a\";\r\nlet b = \"b\";\r\nlist.add(a)\r\nlist.add(b)\r\nlist.add(\"c\")\r\nlet d = new ListNode(\"d\");\r\nlist.add(\"e\")\r\nlist.addAt(3, d)\r\n```\r\n\r\n---\r\n![image](https://user-images.githubusercontent.com/30656341/121087433-0eb45880-c7aa-11eb-80af-c6c353df8240.png)\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm trying to fully comprehend all I can concerning linked lists.</p>\n<p>To do that, I decided making them (and making them work) in JS would be my best route.</p>\n<p>I want to make sure no one sees any major flaws or careless mistakes (or pure dumbassery) in my code.</p>\n<details>\n<pre><code>// Javascript Linked Lists v0.6\n\n//ListNode class - for internal use (mostly)\nclass ListNode {\n    constructor (value, next = null) {\n        this.value = value;\n        this.next = next;\n    }\n}\n\nclass LinkedList {\n    constructor (head = null) {\n        this.head = head;\n        this.length = 0;\n    }\n    add(el) {\n        let node = typeof el.value !== 'undefined' ? el : new ListNode(el);\n        if (typeof node.next === 'undefined'){\n            node.next = null;\n        }\n        let previous, current;\n        if (this.head === null){\n            node.previous = null;\n            this.head = node;\n        } else {\n            current = this.head;\n            while(current.next) {\n                previous = current;\n                current = current.next;\n            }\n            node.previous = current;\n            current.next = node;\n        }\n        this.length++;\n    }\n    remove(val) {\n        let current = this.head;\n        let previous;\n        if (current.value === val){\n            this.head = current.next;\n        } else {\n            while (current.value !== val){\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.length--;\n    }\n    clear() {\n        this.head = null;\n    }\n    first() {\n        return this.head;\n    }\n    next() {\n        return this.head.next;\n    }\n    last() {\n        let lastNode = this.head\n        if (lastNode){\n            while (lastNode.next) {\n                lastNode = lastNode.next;\n            }\n        }\n        return lastNode;\n    }\n    pop(){\n        let node = this.last();\n        this.remove(node.value);\n        this.length--;\n        return node;\n    }\n    shift() {\n        let node = this.head;\n        this.remove (node.value)\n        this.length--;\n        return node;\n    }\n    unshift(val) {\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\n        let current = this.head;\n        node.next = current;\n        node.previous = null;\n        this.head = node;\n        this.length++;\n        return this.length;\n    }\n    addToHead(val) {\n        return this.unshift(val);\n    }\n    indexOf(val){\n        let current = this.head;\n        let i = -1;\n        while (current) {\n            i++;\n            if (current.value === val){\n                return i;\n            }\n            current = current.next;\n        }\n        return -1;\n    }\n    contains(val) {\n        return this.indexOf(val) &gt; -1;\n    }\n    elementAt(i){\n        let current = this.head;\n        let count = 0;\n        while (count &lt; i){\n            count++;\n            current = current.next;\n        }\n        return current.value;\n    }\n    addAt(ind, val){\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\n        let current = this.head;\n        let previous;\n        let currentIndex = 0;\n        if (ind &gt; this.length){\n            return false;\n        }\n        if (ind === 0){\n            node.next = current;\n            node.previous = null;\n            this.head = node\n        } else {\n            while (currentIndex &lt; ind){\n                currentIndex++;\n                previous = current;\n                current = current.next;\n            }\n            node.next = current;\n            node.previous = previous;\n            previous.next = node;\n        }\n        this.length++;\n    }\n    removeAt(index){\n        let current = this.head;\n        let previous;\n        let currentIndex = 0;\n        if (index &lt; 0 || index &gt;= this.length){\n            return null;\n        }\n        if (index === 0){\n            this.head = current.next;\n        } else {\n            while (currentIndex &lt; index){\n                currentIndex++;\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.length--;\n        return current.value;\n    }\n    count() {\n        return this.length;\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    print(current = this.head) {\n        if (current){\n            console.log (current.value)\n        } else {\n            return;\n        }\n        this.print(current.next)\n    }\n}\n</code></pre>\n<hr>\n<pre><code>// create a linked list\nlet list = new LinkedList();\nlet a = \"a\";\nlet b = \"b\";\nlist.add(a)\nlist.add(b)\nlist.add(\"c\")\nlet d = new ListNode(\"d\");\nlist.add(\"e\")\nlist.addAt(3, d)\n</code></pre>\n<hr>\n<p><img src=\"https://user-images.githubusercontent.com/30656341/121087433-0eb45880-c7aa-11eb-80af-c6c353df8240.png\" alt=\"image\"></p>\n</details>\n\n",
      "PostDate": "2021-06-08T12:44:30.1764092Z",
      "LastEditDate": "2021-06-09T23:14:14.82539Z",
      "link": null
    },
    {
      "PostId": "99410d26-c678-4509-b37b-81dc82e463aa",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Looks right.\r\nAlthough the `last` method is a little inefficient; in many applications, it's common to give the list object references to both the first and last nodes.\r\n\r\nAlso, what does this give you?\r\n```\r\nlet list = new LinkedList();\r\nlist.add(\"foo\")\r\nlist.add(\"bar\")\r\nlist.add(\"baz\")\r\nlist.add(list.next())\r\nfor (i=0 ; i<10 ; i++) {\r\n  console.log (list.shift().value)\r\n}\r\nconsole.log(\"Length: \" + list.length);\r\n```\r\n\r\nIt looks like some of your functions give the nodes a `previous` property, but this isn't used. Also, your `length` variable can easily get confused; because `add` increments it without checking if the added element is a ListNode which already has a `next`.\r\n\r\nJavascript nerds would say that any list class should be `Enumerable` so that you can use it with foreach/map/grep/etc; but I think that's more complexity than you need.",
      "EditableFormat": "markdown",
      "HTML": "<p>Looks right.<br>\nAlthough the <code>last</code> method is a little inefficient; in many applications, it's common to give the list object references to both the first and last nodes.</p>\n<p>Also, what does this give you?</p>\n<pre><code>let list = new LinkedList();\nlist.add(\"foo\")\nlist.add(\"bar\")\nlist.add(\"baz\")\nlist.add(list.next())\nfor (i=0 ; i&lt;10 ; i++) {\n  console.log (list.shift().value)\n}\nconsole.log(\"Length: \" + list.length);\n</code></pre>\n<p>It looks like some of your functions give the nodes a <code>previous</code> property, but this isn't used. Also, your <code>length</code> variable can easily get confused; because <code>add</code> increments it without checking if the added element is a ListNode which already has a <code>next</code>.</p>\n<p>Javascript nerds would say that any list class should be <code>Enumerable</code> so that you can use it with foreach/map/grep/etc; but I think that's more complexity than you need.</p>\n\n",
      "PostDate": "2021-06-09T09:18:02.1047795Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f9116348-4dcc-4164-872e-2beccca7c3f1",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Also, what does this give you?\r\n\r\nRuh roh!\r\n\r\nI done been overlooking stuff!\r\n\r\nFirst, I got an infinite loop (because I failed to add code to make sure there was something to shift).\r\n\r\nNow, my length is ```-16```. Hehehe.\r\n\r\nWhat, oh what, have I done? (I'll be right back!)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Also, what does this give you?</p>\n</blockquote>\n<p>Ruh roh!</p>\n<p>I done been overlooking stuff!</p>\n<p>First, I got an infinite loop (because I failed to add code to make sure there was something to shift).</p>\n<p>Now, my length is <code>-16</code>. Hehehe.</p>\n<p>What, oh what, have I done? (I'll be right back!)</p>\n\n",
      "PostDate": "2021-06-09T15:23:31.007759Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "93ee3104-90a9-42c0-a067-1e1bd8d6eeef",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "You might want to look at some sort of unit testing. At its simplest, have a function that uses your code is different ways and tests the end result is what you think it should be. There are also unit testing frameworks, but that might be overkill here. It is a good habit to unit test code like this.",
      "EditableFormat": "markdown",
      "HTML": "<p>You might want to look at some sort of unit testing. At its simplest, have a function that uses your code is different ways and tests the end result is what you think it should be. There are also unit testing frameworks, but that might be overkill here. It is a good habit to unit test code like this.</p>\n\n",
      "PostDate": "2021-06-09T15:37:59.7503384Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f9307c40-5caf-4cd1-83ad-8b8cf91ea9c9",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hrmm... I don't know what I've done, but I apparently lack the concentration required to troubleshoot it right now.\r\n\r\nI shall return, though -- either with a \"fix\" or with questions.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hrmm... I don't know what I've done, but I apparently lack the concentration required to troubleshoot it right now.</p>\n<p>I shall return, though -- either with a \"fix\" or with questions.</p>\n\n",
      "PostDate": "2021-06-09T16:32:16.994546Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5ccd1c86-664e-4007-bffe-3b829f0c38b6",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> You might want to look at some sort of unit testing.\r\n\r\nAh, I posted that last post without refreshing the page and didn't see this.\r\n\r\nIt does sound a like a good idea.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>You might want to look at some sort of unit testing.</p>\n</blockquote>\n<p>Ah, I posted that last post without refreshing the page and didn't see this.</p>\n<p>It does sound a like a good idea.</p>\n\n",
      "PostDate": "2021-06-09T16:34:27.2571381Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c4e86598-b549-4281-93d2-1d50f8621c48",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> First, I got an infinite loop (because I failed to add code to make sure there was something to shift).\r\n\r\nI suspect you ended up with an infinite loop because the list has two elements whose `next` properties point to each other :)\r\n\r\nLISP-style lists can handle this, because you can have lists that merge. It just means that you can't loop over them, because infinite lists exist. And, of course, the `length` property isn't meaningful.\r\n\r\nBut most list libraries use a double-linked list (DLL), where each element has both `next` and `prev` properties.\r\nWhen your `add` function comes to add a new element `node` after an existing element `previous`, you would do something like:\r\n\r\n```\r\nif (node.prev) {\r\n  node.prev.next = node.next;\r\n}\r\nif (node.next) {\r\n  node.next.prev = node.prev;\r\n}\r\nnode.next = previous.next;\r\nif (previous.next) {\r\n  previous.next.prev = node;\r\n}\r\nprevious.next = node;\r\nnode.prev = previous;\r\n```\r\nwhich removes `node` from any list it's previously been in.\r\n\r\nOr, depending on how you're going to use it, you might allow the node and all its successors to be moved as a unit. But in this case, it might be a good idea to check that the added node isn't already in *this* list; for which you would probably need a reference to the list object.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>First, I got an infinite loop (because I failed to add code to make sure there was something to shift).</p>\n</blockquote>\n<p>I suspect you ended up with an infinite loop because the list has two elements whose <code>next</code> properties point to each other :)</p>\n<p>LISP-style lists can handle this, because you can have lists that merge. It just means that you can't loop over them, because infinite lists exist. And, of course, the <code>length</code> property isn't meaningful.</p>\n<p>But most list libraries use a double-linked list (DLL), where each element has both <code>next</code> and <code>prev</code> properties.<br>\nWhen your <code>add</code> function comes to add a new element <code>node</code> after an existing element <code>previous</code>, you would do something like:</p>\n<pre><code>if (node.prev) {\n  node.prev.next = node.next;\n}\nif (node.next) {\n  node.next.prev = node.prev;\n}\nnode.next = previous.next;\nif (previous.next) {\n  previous.next.prev = node;\n}\nprevious.next = node;\nnode.prev = previous;\n</code></pre>\n<p>which removes <code>node</code> from any list it's previously been in.</p>\n<p>Or, depending on how you're going to use it, you might allow the node and all its successors to be moved as a unit. But in this case, it might be a good idea to check that the added node isn't already in <em>this</em> list; for which you would probably need a reference to the list object.</p>\n\n",
      "PostDate": "2021-06-09T17:04:24.5953047Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5be1c21b-a5e5-4a23-9b43-a855b01c9278",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Okay, I still have to read most of the stuff posted after the first example that threw me for an infinite loop.\r\n\r\nHere's that code (slightly modified, so as to avoid an error):\r\n\r\n```\r\nlist = new LinkedList();\r\nlist.add(\"foo\")\r\nlist.add(\"bar\")\r\nlist.add(\"baz\")\r\nlist.add(list.next())\r\nfor (i=0 ; i<10 ; i++) {\r\n  console.log (list.shift()?.value) // added the question mark to avoid an error when the list is empty\r\n}                                      \r\nconsole.log(\"Length: \" + list.length);\r\n```\r\n\r\n\r\n---\r\nOUTPUT\r\n\r\n```\r\nfoo debugger eval code:7:11\r\nbar debugger eval code:7:11\r\nbaz debugger eval code:7:11\r\nbar debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nundefined debugger eval code:7:11\r\nLength: 0\r\n```\r\n\r\n---\r\nLinked Lists v0.7\r\n\r\n<details>\r\n\r\n```\r\n// Javascript Linked Lists v0.7\r\n\r\n//ListNode class - for internal use (mostly)\r\nclass ListNode {\r\n    constructor (value, next = null) {\r\n        this.value = value;\r\n        this.next = next;\r\n    }\r\n}\r\n\r\nclass LinkedList {\r\n    constructor (head = null) {\r\n        this.head = head;\r\n        this.length = 0;\r\n    }\r\n    add(el) {\r\n        let node = typeof el.value !== 'undefined' ? {value: el.value} : new ListNode(el);\r\n        //if (typeof node.next === 'undefined'){\r\n            node.next = null;\r\n        //}\r\n        let previous, current;\r\n        if (this.head === null){\r\n            node.previous = null;\r\n            this.head = node;\r\n        } else {\r\n            current = this.head;\r\n            while(current.next) {\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            node.previous = current;\r\n            current.next = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    remove(val) {\r\n        let current = this.head;\r\n        let previous;\r\n        if (current.value === val){\r\n            this.head = current.next;\r\n        } else {\r\n            while (current.value !== val){\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            previous.next = current.next;\r\n        }\r\n        this.length--;\r\n    }\r\n    clear() {\r\n        this.head = null;\r\n    }\r\n    first() {\r\n        return this.head;\r\n    }\r\n    next() {\r\n        return this.head.next;\r\n    }\r\n    last() {\r\n        let lastNode = this.head\r\n        if (lastNode){\r\n            while (lastNode.next) {\r\n                lastNode = lastNode.next;\r\n            }\r\n        }\r\n        return lastNode;\r\n    }\r\n    pop(){\r\n        let node = this.last();\r\n        this.remove(node.value);\r\n        this.length--;\r\n        return node;\r\n    }\r\n    shift() {\r\n        if (!this.head){\r\n            return null;\r\n        }\r\n        let node = this.head;\r\n        this.head = this.head.next;\r\n        this.length--;\r\n        return node;\r\n    }\r\n    unshift(val) {\r\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\r\n        let current = this.head;\r\n        node.next = current;\r\n        node.previous = null;\r\n        this.head = node\r\n        this.length++;\r\n        return this.length;\r\n    }\r\n    addToHead(val) {\r\n        return this.unshift(val);\r\n    }\r\n    indexOf(val){\r\n        let current = this.head;\r\n        let i = -1;\r\n        while (current) {\r\n            i++;\r\n            if (current.value === val){\r\n                return i;\r\n            }\r\n            current = current.next;\r\n        }\r\n        return -1;\r\n    }\r\n    contains(val) {\r\n        return this.indexOf(val) > -1;\r\n    }\r\n    elementAt(i){\r\n        let current = this.head;\r\n        let count = 0;\r\n        while (count < i){\r\n            count++;\r\n            current = current.next;\r\n        }\r\n        return current.value;\r\n    }\r\n    addAt(ind, val){\r\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\r\n        let current = this.head;\r\n        let previous;\r\n        let currentIndex = 0;\r\n        if (ind > this.length){\r\n            return false;\r\n        }\r\n        if (ind === 0){\r\n            node.next = current;\r\n            node.previous = null;\r\n            this.head = node\r\n        } else {\r\n            while (currentIndex < ind){\r\n                currentIndex++;\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            node.next = current;\r\n            node.previous = previous;\r\n            previous.next = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeAt(index){\r\n        let current = this.head;\r\n        let previous;\r\n        let currentIndex = 0;\r\n        if (index < 0 || index >= this.length){\r\n            return null;\r\n        }\r\n        if (index === 0){\r\n            this.head = current.next;\r\n        } else {\r\n            while (currentIndex < index){\r\n                currentIndex++;\r\n                previous = current;\r\n                current = current.next;\r\n            }\r\n            previous.next = current.next;\r\n        }\r\n        this.length--;\r\n        return current.value;\r\n    }\r\n    count() {\r\n        return this.length;\r\n    }\r\n    isEmpty() {\r\n        return this.length === 0;\r\n    }\r\n    print(current = this.head) {\r\n        if (current){\r\n            console.log (current.value)\r\n        } else {\r\n            return;\r\n        }\r\n        this.print(current.next)\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n---\r\nNow I shall scroll up and read everything after that code first appeared. I've surely got more fish to fry.",
      "EditableFormat": "markdown",
      "HTML": "<p>Okay, I still have to read most of the stuff posted after the first example that threw me for an infinite loop.</p>\n<p>Here's that code (slightly modified, so as to avoid an error):</p>\n<pre><code>list = new LinkedList();\nlist.add(\"foo\")\nlist.add(\"bar\")\nlist.add(\"baz\")\nlist.add(list.next())\nfor (i=0 ; i&lt;10 ; i++) {\n  console.log (list.shift()?.value) // added the question mark to avoid an error when the list is empty\n}                                      \nconsole.log(\"Length: \" + list.length);\n</code></pre>\n<hr>\n<p>OUTPUT</p>\n<pre><code>foo debugger eval code:7:11\nbar debugger eval code:7:11\nbaz debugger eval code:7:11\nbar debugger eval code:7:11\nundefined debugger eval code:7:11\nundefined debugger eval code:7:11\nundefined debugger eval code:7:11\nundefined debugger eval code:7:11\nundefined debugger eval code:7:11\nundefined debugger eval code:7:11\nLength: 0\n</code></pre>\n<hr>\n<p>Linked Lists v0.7</p>\n<details>\n<pre><code>// Javascript Linked Lists v0.7\n\n//ListNode class - for internal use (mostly)\nclass ListNode {\n    constructor (value, next = null) {\n        this.value = value;\n        this.next = next;\n    }\n}\n\nclass LinkedList {\n    constructor (head = null) {\n        this.head = head;\n        this.length = 0;\n    }\n    add(el) {\n        let node = typeof el.value !== 'undefined' ? {value: el.value} : new ListNode(el);\n        //if (typeof node.next === 'undefined'){\n            node.next = null;\n        //}\n        let previous, current;\n        if (this.head === null){\n            node.previous = null;\n            this.head = node;\n        } else {\n            current = this.head;\n            while(current.next) {\n                previous = current;\n                current = current.next;\n            }\n            node.previous = current;\n            current.next = node;\n        }\n        this.length++;\n    }\n    remove(val) {\n        let current = this.head;\n        let previous;\n        if (current.value === val){\n            this.head = current.next;\n        } else {\n            while (current.value !== val){\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.length--;\n    }\n    clear() {\n        this.head = null;\n    }\n    first() {\n        return this.head;\n    }\n    next() {\n        return this.head.next;\n    }\n    last() {\n        let lastNode = this.head\n        if (lastNode){\n            while (lastNode.next) {\n                lastNode = lastNode.next;\n            }\n        }\n        return lastNode;\n    }\n    pop(){\n        let node = this.last();\n        this.remove(node.value);\n        this.length--;\n        return node;\n    }\n    shift() {\n        if (!this.head){\n            return null;\n        }\n        let node = this.head;\n        this.head = this.head.next;\n        this.length--;\n        return node;\n    }\n    unshift(val) {\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\n        let current = this.head;\n        node.next = current;\n        node.previous = null;\n        this.head = node\n        this.length++;\n        return this.length;\n    }\n    addToHead(val) {\n        return this.unshift(val);\n    }\n    indexOf(val){\n        let current = this.head;\n        let i = -1;\n        while (current) {\n            i++;\n            if (current.value === val){\n                return i;\n            }\n            current = current.next;\n        }\n        return -1;\n    }\n    contains(val) {\n        return this.indexOf(val) &gt; -1;\n    }\n    elementAt(i){\n        let current = this.head;\n        let count = 0;\n        while (count &lt; i){\n            count++;\n            current = current.next;\n        }\n        return current.value;\n    }\n    addAt(ind, val){\n        let node = typeof val.value !== 'undefined' ? val : new ListNode(val);\n        let current = this.head;\n        let previous;\n        let currentIndex = 0;\n        if (ind &gt; this.length){\n            return false;\n        }\n        if (ind === 0){\n            node.next = current;\n            node.previous = null;\n            this.head = node\n        } else {\n            while (currentIndex &lt; ind){\n                currentIndex++;\n                previous = current;\n                current = current.next;\n            }\n            node.next = current;\n            node.previous = previous;\n            previous.next = node;\n        }\n        this.length++;\n    }\n    removeAt(index){\n        let current = this.head;\n        let previous;\n        let currentIndex = 0;\n        if (index &lt; 0 || index &gt;= this.length){\n            return null;\n        }\n        if (index === 0){\n            this.head = current.next;\n        } else {\n            while (currentIndex &lt; index){\n                currentIndex++;\n                previous = current;\n                current = current.next;\n            }\n            previous.next = current.next;\n        }\n        this.length--;\n        return current.value;\n    }\n    count() {\n        return this.length;\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    print(current = this.head) {\n        if (current){\n            console.log (current.value)\n        } else {\n            return;\n        }\n        this.print(current.next)\n    }\n}\n</code></pre>\n</details>\n<hr>\n<p>Now I shall scroll up and read everything after that code first appeared. I've surely got more fish to fry.</p>\n\n",
      "PostDate": "2021-06-09T20:28:06.0115966Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "7f52f51b-9208-461b-8e60-e92b1aedcc7b",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Can I do anything special with this that I couldn't otherwise do with an array in JS?",
      "EditableFormat": "markdown",
      "HTML": "<p>Can I do anything special with this that I couldn't otherwise do with an array in JS?</p>\n\n",
      "PostDate": "2021-06-11T17:57:05.1488446Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "17d07caa-ba35-4f0a-bc22-610d42ff814a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "With a basic list, probably not. But for certain applications…\r\n\r\nIn my case, I'm rolling my own linked list because I'm using a slightly unorthodox method to remove elements from the list:\r\nRemoval:\r\n>     this.next.prev = this.prev\r\n>     this.prev.next = this.next\r\nAnd to undo removal:\r\n>     this.prev.next = this.next.prev = this\r\n\r\nIt's a lot faster than standard arrays for tasks where you'll be repeatedly deleting and undeleting elements, but you don't need to add anything new. Two integer assignments and you're done :)\r\n\r\nAlso, cyclical linked lists (the last element's `next` points to the first element again)  can be used in interesting ways. For example, if you want to loop over a list starting with a specified element, you can easily loop until you get back to the start point. No need to keep track of an index, or create a temporary data structure to collate your array.\r\n\r\nSome of these are rather unusual tasks, that you probably won't need often. The array is a general-purpose tool, so it's often quite inefficient compared to a specific type of list made for a specific task. So it's good to understand how these things work under the hood, in case you ever need them :)",
      "EditableFormat": "markdown",
      "HTML": "<p>With a basic list, probably not. But for certain applications…</p>\n<p>In my case, I'm rolling my own linked list because I'm using a slightly unorthodox method to remove elements from the list:<br>\nRemoval:</p>\n<blockquote>\n<pre><code>this.next.prev = this.prev\nthis.prev.next = this.next\n</code></pre>\n</blockquote>\n<p>And to undo removal:</p>\n<blockquote>\n<pre><code>this.prev.next = this.next.prev = this\n</code></pre>\n</blockquote>\n<p>It's a lot faster than standard arrays for tasks where you'll be repeatedly deleting and undeleting elements, but you don't need to add anything new. Two integer assignments and you're done :)</p>\n<p>Also, cyclical linked lists (the last element's <code>next</code> points to the first element again)  can be used in interesting ways. For example, if you want to loop over a list starting with a specified element, you can easily loop until you get back to the start point. No need to keep track of an index, or create a temporary data structure to collate your array.</p>\n<p>Some of these are rather unusual tasks, that you probably won't need often. The array is a general-purpose tool, so it's often quite inefficient compared to a specific type of list made for a specific task. So it's good to understand how these things work under the hood, in case you ever need them :)</p>\n\n",
      "PostDate": "2021-06-11T22:55:56.6652938Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5b20c571-2c31-417e-ac79-603876ce7875",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Somewhat irrelevant, but here's an example of a case where linked lists run a whole lot faster than the hybrid lists that JS uses. Written in Perl, but you can probably see what it's supposed to do. I really, really hope I've not made any dumb mistakes here.\r\n\r\nThis is a table implemented as a 2-dimensional linked list (with each cell being a hashref with 'up', 'down', 'left', and 'right' pointers; as well as 'action' pointing to the row header, and 'header' the column header), and where the row/column headers are hashrefs with either \"top\" and \"bottom\", or \"first\" and \"last\" pointers. In my implementation, $header->{last}->{right} is the same as $header->{first} - all rows and columns are infinite loops, which makes it a little faster to loop over them starting with an arbitrary element.\r\n\r\n```\r\nsub do_solve {\r\n  my ($colhead, $solution) = @_;\r\n  if ($shortest_first) {\r\n    my $shortest = $colhead;\r\n    for (my $col = $colhead->{right} ; $col != $colhead ; $col = $col->{right}) {\r\n      if ($col->{count} < $shortest->{count}) {\r\n        $shortest = $col;\r\n      }\r\n    }\r\n    $colhead = $shortest;\r\n  }\r\n  my $option = $colhead->{top};\r\n  while ($option = $option->{down}) {\r\n    choose_row($option, $solution);\r\n    last if ($option == $colhead->{bottom});\r\n  }\r\n}\r\n\r\nsub choose_row {\r\n  my ($startcell, $solution) = @_;\r\n  my $reason;\r\n  $startcell->{action}->{prev} = $solution;\r\n  for (my $cell = $startcell->{left} ; $cell != $startcell ; $cell = $cell->{left}) {\r\n    if ($reason = remove_column($cell)) {\r\n      # failed to make the choice, so undo\r\n      while ($startcell != $cell = $cell->{right}) {\r\n        unremove_column($cell);\r\n      }\r\n      return $reason;\r\n    }\r\n  }\r\n  # Removed the row without errors\r\n  # So if this header is the last one, we have a valid solution\r\n  my $header = $startcell->{header};\r\n  if ($header->{left} == $header) {\r\n    output_solution($startcell->{action});\r\n  } else {\r\n    # Not finished yet, so remove the column and do the next one\r\n    unless ($reason = remove_column($startcell)) {\r\n      do_solve($header->{right}, $startcell->{action});\r\n      unremove_column($startcell);\r\n    }\r\n  }\r\n  for (my $cell=$startcell->{right} ; $cell != $startcell ; $cell = $cell->{right}) {\r\n    unremove_column($cell);\r\n  }\r\n  return $reason;\r\n}\r\n\r\nsub remove_row {\r\n  my $startcell = shift;\r\n  for(my $cell=$startcell->{right} ; $cell != $startcell ; $cell = $cell->{right}) {\r\n    if ($cell->{up} == $cell) {\r\n      # Only cell in the column - stop part way and undo the failed transaction\r\n      my $reason = \"Failed to meet constraint \" . $cell->{header}->{name};\r\n      while ($startcell != $cell = $cell->{left}) {\r\n        $cell->{up}->{down} = $cell->{down};\r\n\t$cell->{down}->{up} = $cell->{up};\r\n\t$cell->{header}->{count}++;\r\n      }\r\n      return $reason;\r\n    }\r\n    $cell->{up}->{down} = $cell->{down};\r\n    $cell->{down}->{up} = $cell->{up};\r\n    $cell->{header}->{count}--;\r\n  }\r\n}\r\n\r\nsub unremove_row {\r\n  my $startcell = shift;\r\n  for(my $cell=$startcell->{left} ; $cell != $startcell ; $cell = $cell->{left}) {\r\n    $cell->{up}->{down} = $cell;\r\n    $cell->{down}->{up} = $cell;\r\n    $cell->{header}->{count}++;\r\n  }\r\n}\r\n\r\nsub remove_column {\r\n  my $startcell = shift;\r\n  my $reason;\r\n  for (my $cell=$startcell->{down} ; $cell != $startcell ; $cell=$cell->{down}) {\r\n    if ($reason = remove_row($cell)) {\r\n      # failed to remove; so undo back to the start of the transaction\r\n      while ($startcell != $cell = $cell->{up}) {\r\n        unremove_row($cell);\r\n      }\r\n      return $reason;\r\n    }\r\n  }\r\n  $startcell->{header}->{left}->{right} = $startcell->{header}->{right};\r\n  $startcell->{header}->{right}->{left} = $startcell->{header}->{left};\r\n}\r\n\r\nsub unremove_column {\r\n  my $startcell = shift;\r\n  $startcell->{header}->{left}->{right} = $startcell;\r\n  $startcell->{header}->{right}->{left} = $startcell;\r\n  for (my $cell=$startcell->{up} ; $cell != $startcell ; $cell=$cell->{up}) {\r\n    unremove_row($cell);\r\n  }\r\n}\r\n```\r\nIn case you need help understanding Perl:\r\n* The parameters to a subroutine are in a local array named `@_`. The `shift` function operates on @_ if you don't give it a parameter.\r\n* `$somevar` is a *scalar* variable (float, int, string, or reference)\r\n* `@somevar` is an array (list). `$somevar[0]` is its first element.\r\n* `%somevar` is a hash (dictionary). `$somevar{key}` is an element of it. The key is assumed to be a string unless it contains any symbol characters.\r\n     * You can also get an array of some of its values by doing something like `@somehash{@array_of_keys)`, which I think is pretty neat.\r\n* If `$somevar` is a reference to another variable, you can get the variable it points to using `$$somevar`, `@$somevar`, `%$somevar` or similar.\r\n     * If an array element is a pointer to an array, this becomes something like `@{$somearray[4]}`\r\n     * The arrow operator makes nested arrays/hashes easier to read. `$somearray[4]->{somekey}` is the \"somekey\" element of the hash pointed to by the 4th element of `@somearray`.\r\n* `[\"apple\", \"banana\", \"fish\"]` returns a *reference* to an array, and `{\"fruit\" => \"apple\", \"fish\" => \"cod\"}` returns a reference to a hash.\r\n\r\nWhat do you think?",
      "EditableFormat": "markdown",
      "HTML": "<p>Somewhat irrelevant, but here's an example of a case where linked lists run a whole lot faster than the hybrid lists that JS uses. Written in Perl, but you can probably see what it's supposed to do. I really, really hope I've not made any dumb mistakes here.</p>\n<p>This is a table implemented as a 2-dimensional linked list (with each cell being a hashref with 'up', 'down', 'left', and 'right' pointers; as well as 'action' pointing to the row header, and 'header' the column header), and where the row/column headers are hashrefs with either \"top\" and \"bottom\", or \"first\" and \"last\" pointers. In my implementation, $header-&gt;{last}-&gt;{right} is the same as $header-&gt;{first} - all rows and columns are infinite loops, which makes it a little faster to loop over them starting with an arbitrary element.</p>\n<pre><code>sub do_solve {\n  my ($colhead, $solution) = @_;\n  if ($shortest_first) {\n    my $shortest = $colhead;\n    for (my $col = $colhead-&gt;{right} ; $col != $colhead ; $col = $col-&gt;{right}) {\n      if ($col-&gt;{count} &lt; $shortest-&gt;{count}) {\n        $shortest = $col;\n      }\n    }\n    $colhead = $shortest;\n  }\n  my $option = $colhead-&gt;{top};\n  while ($option = $option-&gt;{down}) {\n    choose_row($option, $solution);\n    last if ($option == $colhead-&gt;{bottom});\n  }\n}\n\nsub choose_row {\n  my ($startcell, $solution) = @_;\n  my $reason;\n  $startcell-&gt;{action}-&gt;{prev} = $solution;\n  for (my $cell = $startcell-&gt;{left} ; $cell != $startcell ; $cell = $cell-&gt;{left}) {\n    if ($reason = remove_column($cell)) {\n      # failed to make the choice, so undo\n      while ($startcell != $cell = $cell-&gt;{right}) {\n        unremove_column($cell);\n      }\n      return $reason;\n    }\n  }\n  # Removed the row without errors\n  # So if this header is the last one, we have a valid solution\n  my $header = $startcell-&gt;{header};\n  if ($header-&gt;{left} == $header) {\n    output_solution($startcell-&gt;{action});\n  } else {\n    # Not finished yet, so remove the column and do the next one\n    unless ($reason = remove_column($startcell)) {\n      do_solve($header-&gt;{right}, $startcell-&gt;{action});\n      unremove_column($startcell);\n    }\n  }\n  for (my $cell=$startcell-&gt;{right} ; $cell != $startcell ; $cell = $cell-&gt;{right}) {\n    unremove_column($cell);\n  }\n  return $reason;\n}\n\nsub remove_row {\n  my $startcell = shift;\n  for(my $cell=$startcell-&gt;{right} ; $cell != $startcell ; $cell = $cell-&gt;{right}) {\n    if ($cell-&gt;{up} == $cell) {\n      # Only cell in the column - stop part way and undo the failed transaction\n      my $reason = \"Failed to meet constraint \" . $cell-&gt;{header}-&gt;{name};\n      while ($startcell != $cell = $cell-&gt;{left}) {\n        $cell-&gt;{up}-&gt;{down} = $cell-&gt;{down};\n\t$cell-&gt;{down}-&gt;{up} = $cell-&gt;{up};\n\t$cell-&gt;{header}-&gt;{count}++;\n      }\n      return $reason;\n    }\n    $cell-&gt;{up}-&gt;{down} = $cell-&gt;{down};\n    $cell-&gt;{down}-&gt;{up} = $cell-&gt;{up};\n    $cell-&gt;{header}-&gt;{count}--;\n  }\n}\n\nsub unremove_row {\n  my $startcell = shift;\n  for(my $cell=$startcell-&gt;{left} ; $cell != $startcell ; $cell = $cell-&gt;{left}) {\n    $cell-&gt;{up}-&gt;{down} = $cell;\n    $cell-&gt;{down}-&gt;{up} = $cell;\n    $cell-&gt;{header}-&gt;{count}++;\n  }\n}\n\nsub remove_column {\n  my $startcell = shift;\n  my $reason;\n  for (my $cell=$startcell-&gt;{down} ; $cell != $startcell ; $cell=$cell-&gt;{down}) {\n    if ($reason = remove_row($cell)) {\n      # failed to remove; so undo back to the start of the transaction\n      while ($startcell != $cell = $cell-&gt;{up}) {\n        unremove_row($cell);\n      }\n      return $reason;\n    }\n  }\n  $startcell-&gt;{header}-&gt;{left}-&gt;{right} = $startcell-&gt;{header}-&gt;{right};\n  $startcell-&gt;{header}-&gt;{right}-&gt;{left} = $startcell-&gt;{header}-&gt;{left};\n}\n\nsub unremove_column {\n  my $startcell = shift;\n  $startcell-&gt;{header}-&gt;{left}-&gt;{right} = $startcell;\n  $startcell-&gt;{header}-&gt;{right}-&gt;{left} = $startcell;\n  for (my $cell=$startcell-&gt;{up} ; $cell != $startcell ; $cell=$cell-&gt;{up}) {\n    unremove_row($cell);\n  }\n}\n</code></pre>\n<p>In case you need help understanding Perl:</p>\n<ul>\n<li>The parameters to a subroutine are in a local array named <code>@_</code>. The <code>shift</code> function operates on @_ if you don't give it a parameter.</li>\n<li><code>$somevar</code> is a <em>scalar</em> variable (float, int, string, or reference)</li>\n<li><code>@somevar</code> is an array (list). <code>$somevar[0]</code> is its first element.</li>\n<li><code>%somevar</code> is a hash (dictionary). <code>$somevar{key}</code> is an element of it. The key is assumed to be a string unless it contains any symbol characters.\n<ul>\n<li>You can also get an array of some of its values by doing something like <code>@somehash{@array_of_keys)</code>, which I think is pretty neat.</li>\n</ul>\n</li>\n<li>If <code>$somevar</code> is a reference to another variable, you can get the variable it points to using <code>$$somevar</code>, <code>@$somevar</code>, <code>%$somevar</code> or similar.\n<ul>\n<li>If an array element is a pointer to an array, this becomes something like <code>@{$somearray[4]}</code></li>\n<li>The arrow operator makes nested arrays/hashes easier to read. <code>$somearray[4]-&gt;{somekey}</code> is the \"somekey\" element of the hash pointed to by the 4th element of <code>@somearray</code>.</li>\n</ul>\n</li>\n<li><code>[\"apple\", \"banana\", \"fish\"]</code> returns a <em>reference</em> to an array, and <code>{\"fruit\" =&gt; \"apple\", \"fish\" =&gt; \"cod\"}</code> returns a reference to a hash.</li>\n</ul>\n<p>What do you think?</p>\n\n",
      "PostDate": "2021-06-21T13:11:42.6146138Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4d7d3efc-1bca-4605-afae-3cf610b676c0",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> In case you need help understanding Perl\r\n\r\nI did need this! I was scrolling through the code, and I was just about to start grumbling to myself about needing to go learn a little Perl when I found the explanation you added.\r\n\r\nThis seems like a sidetrack, but it's not:\r\nI'm nearly done with my homemade text adventure written in Vanilla Javascript. (In fact, I *would* be done, had I not decided to add code which allows the NPCs to take commands. Most of the NPC stuff is working. Just a few wrinkles left to find and iron out. Anyway...)\r\n\r\nA few days ago, I decided I should rewrite the whole thing in the current version of BASIC, just for fun and also to negate any thoughts about cross-browser compatibility. Well, the current version of BASIC doesn't look anything like the BASIC that was on my Tandy CC2. In fact, the new BASIC looks a lot like C#. So, I said [CENSORED] the new BASIC, and . . .\r\n\r\nTwo days ago, I started learning C++ whenever I felt like taking a break from my Vanilla JS project. I think I know enough about C++ now to be dangerous. It looks like I cannot have a \"mixed\" array. Meaning it looks like my array has to have all the same types of keys: int, double, string, etc. I also have to declare an array's maximum length. This leads me to believe. . .\r\n\r\nI definitely need to really learn about tables, linked lists and hash tables, and two-dimensional arrays, too!\r\n\r\n...and, just like it always works, you happen to post about the very thing I need to learn about just when I need to see it.\r\n\r\nThe Force is pretty awesome.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>In case you need help understanding Perl</p>\n</blockquote>\n<p>I did need this! I was scrolling through the code, and I was just about to start grumbling to myself about needing to go learn a little Perl when I found the explanation you added.</p>\n<p>This seems like a sidetrack, but it's not:<br>\nI'm nearly done with my homemade text adventure written in Vanilla Javascript. (In fact, I <em>would</em> be done, had I not decided to add code which allows the NPCs to take commands. Most of the NPC stuff is working. Just a few wrinkles left to find and iron out. Anyway...)</p>\n<p>A few days ago, I decided I should rewrite the whole thing in the current version of BASIC, just for fun and also to negate any thoughts about cross-browser compatibility. Well, the current version of BASIC doesn't look anything like the BASIC that was on my Tandy CC2. In fact, the new BASIC looks a lot like C#. So, I said [CENSORED] the new BASIC, and . . .</p>\n<p>Two days ago, I started learning C++ whenever I felt like taking a break from my Vanilla JS project. I think I know enough about C++ now to be dangerous. It looks like I cannot have a \"mixed\" array. Meaning it looks like my array has to have all the same types of keys: int, double, string, etc. I also have to declare an array's maximum length. This leads me to believe. . .</p>\n<p>I definitely need to really learn about tables, linked lists and hash tables, and two-dimensional arrays, too!</p>\n<p>...and, just like it always works, you happen to post about the very thing I need to learn about just when I need to see it.</p>\n<p>The Force is pretty awesome.</p>\n\n",
      "PostDate": "2021-06-21T15:23:02.5742521Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e7653c02-05e1-4af0-8ebb-001f5895b61c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Good luck with the C++ :-)\r\n\r\nIn case you're curious; the perl code above is a somewhat-optimised way of solving a covering problem. Basically, it takes a table/matrix, and finds a subset of the rows which contain exactly one cell in each column.\r\n\r\nIt picks the column with fewest options and loops over it choosing the rows. For each row, it deletes from the table all other rows that share a column with it. If this leaves a different column with no rows in it, we've failed so undo and go back to the . If there are no columns left, we succeeded. Otherwise, we continue by running the solver on a different column.\r\n\r\nThis algorithm requires a *lot* of backtracking. So we need a method of maintaining an 'undo' buffer that doesn't take a ton of memory storing everything we've tried, and doesn't need to keep allocating new memory for temporary things. In this case, it's pretty fast because of the \"dancing links\" - each cell has pointers to the cells that were next to it in the row or column before it was deleted, and when we undelete we're always rolling back to the same point we were at before, so we're reversing the order of deletions. So we can just do `cell.prev.next = cell.next.prev = cell` to put the cell back where it was. No `if`, no calculations, just a straight assignment.\r\n\r\nAmong other things, you can use it for solving sudoku. The row headers are actions like \"Place 5 in cell (7,2)\" and column headers are conditions like \"Placed a 5 in row 2\", \"Placed a 5 in column 7\", \"Placed a 5 in box 3\", and \"Placed a digit in (7,2)\" that have to be satisfied exactly once to make a correct solution. This makes a 324×729 matrix of options, (smaller if you have given digits), so I'm sure you can see why having the loop run fast is a good thing.",
      "EditableFormat": "markdown",
      "HTML": "<p>Good luck with the C++ :-)</p>\n<p>In case you're curious; the perl code above is a somewhat-optimised way of solving a covering problem. Basically, it takes a table/matrix, and finds a subset of the rows which contain exactly one cell in each column.</p>\n<p>It picks the column with fewest options and loops over it choosing the rows. For each row, it deletes from the table all other rows that share a column with it. If this leaves a different column with no rows in it, we've failed so undo and go back to the . If there are no columns left, we succeeded. Otherwise, we continue by running the solver on a different column.</p>\n<p>This algorithm requires a <em>lot</em> of backtracking. So we need a method of maintaining an 'undo' buffer that doesn't take a ton of memory storing everything we've tried, and doesn't need to keep allocating new memory for temporary things. In this case, it's pretty fast because of the \"dancing links\" - each cell has pointers to the cells that were next to it in the row or column before it was deleted, and when we undelete we're always rolling back to the same point we were at before, so we're reversing the order of deletions. So we can just do <code>cell.prev.next = cell.next.prev = cell</code> to put the cell back where it was. No <code>if</code>, no calculations, just a straight assignment.</p>\n<p>Among other things, you can use it for solving sudoku. The row headers are actions like \"Place 5 in cell (7,2)\" and column headers are conditions like \"Placed a 5 in row 2\", \"Placed a 5 in column 7\", \"Placed a 5 in box 3\", and \"Placed a digit in (7,2)\" that have to be satisfied exactly once to make a correct solution. This makes a 324×729 matrix of options, (smaller if you have given digits), so I'm sure you can see why having the loop run fast is a good thing.</p>\n\n",
      "PostDate": "2021-06-21T19:15:34.1687401Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8947759a-77a6-43a8-8b55-d7b89609411a",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> the perl code above . . .\r\n\r\nI was almost ready for the stuff we've covered in ZIL/MDL -- almost ready enough to get through it all. So, I guess \"barely ready\" is the proper terminology.\r\n\r\nI'm not ready for this stuff yet, though. I think I'll be forced to learn enough to be ready for it if I get far enough in C++, though. At that time, I shall return and learn from these posts (trust me; I will).\r\n\r\n---\r\n> Good luck with the C++ :-)\r\n\r\nIt looks mostly like JS. (Or I guess JS looks mostly like C++; huh?)\r\n\r\nThe big differences I've seen so far are:\r\n- arrays have to include all the same types (a good reason to use linked lists, I wot)\r\n- array max length is set when array is declared (another good reason to use linked list, I reckon)\r\n- function parameters must be specified by type\r\n    - but we can make multiple functions with the same name but different types\r\n- no ```forEach``` (only ```for```, which I know how to use, so meh)\r\n\r\n---\r\nAlso, I apparently need to expose myself to Sudoku, since 80% of the examples I see concerning complex code use Sudoku to illustrate. :o)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>the perl code above . . .</p>\n</blockquote>\n<p>I was almost ready for the stuff we've covered in ZIL/MDL -- almost ready enough to get through it all. So, I guess \"barely ready\" is the proper terminology.</p>\n<p>I'm not ready for this stuff yet, though. I think I'll be forced to learn enough to be ready for it if I get far enough in C++, though. At that time, I shall return and learn from these posts (trust me; I will).</p>\n<hr>\n<blockquote>\n<p>Good luck with the C++ :-)</p>\n</blockquote>\n<p>It looks mostly like JS. (Or I guess JS looks mostly like C++; huh?)</p>\n<p>The big differences I've seen so far are:</p>\n<ul>\n<li>arrays have to include all the same types (a good reason to use linked lists, I wot)</li>\n<li>array max length is set when array is declared (another good reason to use linked list, I reckon)</li>\n<li>function parameters must be specified by type\n<ul>\n<li>but we can make multiple functions with the same name but different types</li>\n</ul>\n</li>\n<li>no <code>forEach</code> (only <code>for</code>, which I know how to use, so meh)</li>\n</ul>\n<hr>\n<p>Also, I apparently need to expose myself to Sudoku, since 80% of the examples I see concerning complex code use Sudoku to illustrate. :o)</p>\n\n",
      "PostDate": "2021-06-21T20:15:26.8620308Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1680307c-2e1a-4851-b62b-21f3a91c552d",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> > Good luck with the C++ :-)\r\n\r\nAm I better off just sticking to JS and learning as much about it as possible?",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<blockquote>\n<p>Good luck with the C++ :-)</p>\n</blockquote>\n</blockquote>\n<p>Am I better off just sticking to JS and learning as much about it as possible?</p>\n\n",
      "PostDate": "2021-06-21T22:55:16.4017387Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "faf3e9e2-0228-4604-b5d1-12d7dba50075",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "After seriously fooling with C++ for a couple of days, I understand pointers and addresses now -- at least on an elementary level.\r\n\r\n...and tables, too.\r\n\r\n---\r\nI was thinking I should go with C++, as I wish to learn the most universal language, and I thought C++ would have fewer cross-platform concerns than JS has cross-browser concerns. Now, though, I'm thinking:\r\n\r\n- JS seems to handle everything that can be done with C++, with less tedious coding involved.\r\n- C++ seems to have the same amount of cross-whatever concerns as JS.\r\n- I could only really compile binaries for the Windows crowd, in the event that I actually created something worth sharing, unless I spent far too much time on it. Whereas JS will run in any browser; it's just the HTML side I really need think about as far as cross-browser compatibility is concerned.\r\n\r\n---\r\nAlso, Python, Perl, Ruby, etc., aren't installed on most machines (I don't think); so, it seems like those languages are like \"extra-credit\" languages, for lack of a better term.\r\n\r\nI think maybe I should just learn half of what mrangel knows about JS, and then I'd have accomplished something.\r\n\r\nAm I wrong? Can C++ do something we can't do with JS, as far as text adventures are concerned?",
      "EditableFormat": "markdown",
      "HTML": "<p>After seriously fooling with C++ for a couple of days, I understand pointers and addresses now -- at least on an elementary level.</p>\n<p>...and tables, too.</p>\n<hr>\n<p>I was thinking I should go with C++, as I wish to learn the most universal language, and I thought C++ would have fewer cross-platform concerns than JS has cross-browser concerns. Now, though, I'm thinking:</p>\n<ul>\n<li>JS seems to handle everything that can be done with C++, with less tedious coding involved.</li>\n<li>C++ seems to have the same amount of cross-whatever concerns as JS.</li>\n<li>I could only really compile binaries for the Windows crowd, in the event that I actually created something worth sharing, unless I spent far too much time on it. Whereas JS will run in any browser; it's just the HTML side I really need think about as far as cross-browser compatibility is concerned.</li>\n</ul>\n<hr>\n<p>Also, Python, Perl, Ruby, etc., aren't installed on most machines (I don't think); so, it seems like those languages are like \"extra-credit\" languages, for lack of a better term.</p>\n<p>I think maybe I should just learn half of what mrangel knows about JS, and then I'd have accomplished something.</p>\n<p>Am I wrong? Can C++ do something we can't do with JS, as far as text adventures are concerned?</p>\n\n",
      "PostDate": "2021-06-23T02:06:42.2591905Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "73df95d3-d80a-46d6-96f7-ae1bf635c1b9",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "JavaScript does not have much cross-browser issues nowadays. I have taken JavaScript ES6 (ECMAScript 2015) as my standard, and I reckon if it is in that, at least 98% of users will be fine, and that figure will increase. Besides that, I ignore browser issues.\r\n\r\nC++ I suspect will have more cross platform issues, like for example, the size of an integer can be different on a 32-bit computer compared to 64-bit - but then, you have something like 20 different integer types to choose from, and only some depend on the platform.\r\n\r\nYour C++ code is cross-platform, but you have one .exe for Apple, another for Windows, another for Linux, and ideally you would test in each environment. Plus, some people will be reluctant to download a .exe from a random source because of the security risk. This is a big reason why I went to JavaScript; the browser is your player, and everyone already has the player installed.\r\n\r\nWorth noting that Inform uses JavaScript too when output to a webpage. Parchment and Quixe are both JavaScript programs that will load an Inform file and play it.",
      "EditableFormat": "markdown",
      "HTML": "<p>JavaScript does not have much cross-browser issues nowadays. I have taken JavaScript ES6 (ECMAScript 2015) as my standard, and I reckon if it is in that, at least 98% of users will be fine, and that figure will increase. Besides that, I ignore browser issues.</p>\n<p>C++ I suspect will have more cross platform issues, like for example, the size of an integer can be different on a 32-bit computer compared to 64-bit - but then, you have something like 20 different integer types to choose from, and only some depend on the platform.</p>\n<p>Your C++ code is cross-platform, but you have one .exe for Apple, another for Windows, another for Linux, and ideally you would test in each environment. Plus, some people will be reluctant to download a .exe from a random source because of the security risk. This is a big reason why I went to JavaScript; the browser is your player, and everyone already has the player installed.</p>\n<p>Worth noting that Inform uses JavaScript too when output to a webpage. Parchment and Quixe are both JavaScript programs that will load an Inform file and play it.</p>\n\n",
      "PostDate": "2021-06-23T07:44:51.4155562Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8f6bbfc5-9e34-4d7c-add0-3cda24a392ba",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> arrays have to include all the same types (a good reason to use linked lists, I wot)\r\n\r\nAhh, welcome to the wonder of strongly typed languages :)\r\n\r\nIf you want a list with different types, you'll probably end up working with templates and generics, which can be a real pain.\r\n\r\nLanguages with dynamic types tend to be more flexible, and easier to Just Do Stuff without building a structure around it first. The big difference is usually efficiency.\r\n\r\nIn JS, you come to an expression like `a + b`. If the variables are strings, they're catenated. If they're ints, you add them together. If they're different types, a fancy algorithm has to determine what type to convert them to before adding or catenating.\r\n\r\nIn C/C++/Java, when the compiler sees `a + b`, it looks at the types of those variables and selects an appropriate function to combine them. This is done at compile time, so when the code actually runs the `+` has already been replaced by a piece of code that adds two numbers together, or whatever. Just doing addition is faster than checking the types every time.\r\n\r\nSo, JS does almost everything C++ can do now, but more slowly, because a function doesn't know what types its arguments are until it's running and it needs to check every time.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>arrays have to include all the same types (a good reason to use linked lists, I wot)</p>\n</blockquote>\n<p>Ahh, welcome to the wonder of strongly typed languages :)</p>\n<p>If you want a list with different types, you'll probably end up working with templates and generics, which can be a real pain.</p>\n<p>Languages with dynamic types tend to be more flexible, and easier to Just Do Stuff without building a structure around it first. The big difference is usually efficiency.</p>\n<p>In JS, you come to an expression like <code>a + b</code>. If the variables are strings, they're catenated. If they're ints, you add them together. If they're different types, a fancy algorithm has to determine what type to convert them to before adding or catenating.</p>\n<p>In C/C++/Java, when the compiler sees <code>a + b</code>, it looks at the types of those variables and selects an appropriate function to combine them. This is done at compile time, so when the code actually runs the <code>+</code> has already been replaced by a piece of code that adds two numbers together, or whatever. Just doing addition is faster than checking the types every time.</p>\n<p>So, JS does almost everything C++ can do now, but more slowly, because a function doesn't know what types its arguments are until it's running and it needs to check every time.</p>\n\n",
      "PostDate": "2021-06-23T10:59:27.128875Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ef03b2c5-36b0-4cba-b200-5333dcef9457",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> JavaScript does not have much cross-browser issues nowadays.\r\n\r\nTrue. Most of my issues involve the way the HTML is displayed (and whether or not the player is using a mobile browser).\r\n\r\nThat's not really anything to do with JS, I don't reckon. :)\r\n\r\n---\r\n> C++ I suspect will have more cross platform issues, like for example, the size of an integer can be different on a 32-bit computer compared to 64-bit - but then, you have something like 20 different integer types to choose from, and only some depend on the platform.\r\n\r\nYou ain't just whistling Dixie! I found this out on Day 1.\r\n\r\n---\r\n> Your C++ code is cross-platform, but you have one .exe for Apple, another for Windows, another for Linux\r\n\r\nWell, pretty much, except one Linux binary is not enough. There are multiple \"flavors\" of Linux, and they don't all behave the same way. That's why (come to find out) I usually have to build from the source code when installing a release of something for Linux on GitHub.\r\n\r\n---\r\n> Worth noting that Inform uses JavaScript too when output to a webpage. Parchment and Quixe are both JavaScript programs that will load an Inform file and play it.\r\n\r\nYeah, neither can handle the help menu properly in a browser, and Parchment doesn't save progress worth a crap (see the many threads on this site asking how to save progress in the Inform port of Zork).\r\n\r\nNow that I think about it, after making the INVISICLUES style menu work in Quest, I think I could probably fix their issue with the menus -- if their code wasn't a jumbled mess. Even after converting it from Base64 and running it through ```btoa()``` (which is what I believe I had to do), the JS is in-line, and the line is a million kilometers long!  Egads!!!\r\n\r\n---\r\nAll that aside, it does look to me like C++ is more tedious than it is 'better than JS'.\r\n\r\n---\r\n> Plus, some people will be reluctant to download a .exe from a random source because of the security risk.\r\n\r\nYeah, that's definitely true, too.\r\n\r\n---\r\n>This is a big reason why I went to JavaScript; the browser is your player, and everyone already has the player installed.\r\n\r\nA very good call, good sir!\r\n\r\n---\r\n> Ahh, welcome to the wonder of strongly typed languages :)\r\n\r\nHa ha! Yeah...\r\n\r\nIt is definitely educational, though!\r\n\r\n---\r\n>In JS, you come to an expression like ```a + b```. . .\r\n\r\n> In C/C++/Java, when the compiler sees ```a + b```. . .\r\n\r\nHey. . . Is that what the Just In Time thing means?",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>JavaScript does not have much cross-browser issues nowadays.</p>\n</blockquote>\n<p>True. Most of my issues involve the way the HTML is displayed (and whether or not the player is using a mobile browser).</p>\n<p>That's not really anything to do with JS, I don't reckon. :)</p>\n<hr>\n<blockquote>\n<p>C++ I suspect will have more cross platform issues, like for example, the size of an integer can be different on a 32-bit computer compared to 64-bit - but then, you have something like 20 different integer types to choose from, and only some depend on the platform.</p>\n</blockquote>\n<p>You ain't just whistling Dixie! I found this out on Day 1.</p>\n<hr>\n<blockquote>\n<p>Your C++ code is cross-platform, but you have one .exe for Apple, another for Windows, another for Linux</p>\n</blockquote>\n<p>Well, pretty much, except one Linux binary is not enough. There are multiple \"flavors\" of Linux, and they don't all behave the same way. That's why (come to find out) I usually have to build from the source code when installing a release of something for Linux on GitHub.</p>\n<hr>\n<blockquote>\n<p>Worth noting that Inform uses JavaScript too when output to a webpage. Parchment and Quixe are both JavaScript programs that will load an Inform file and play it.</p>\n</blockquote>\n<p>Yeah, neither can handle the help menu properly in a browser, and Parchment doesn't save progress worth a crap (see the many threads on this site asking how to save progress in the Inform port of Zork).</p>\n<p>Now that I think about it, after making the INVISICLUES style menu work in Quest, I think I could probably fix their issue with the menus -- if their code wasn't a jumbled mess. Even after converting it from Base64 and running it through <code>btoa()</code> (which is what I believe I had to do), the JS is in-line, and the line is a million kilometers long!  Egads!!!</p>\n<hr>\n<p>All that aside, it does look to me like C++ is more tedious than it is 'better than JS'.</p>\n<hr>\n<blockquote>\n<p>Plus, some people will be reluctant to download a .exe from a random source because of the security risk.</p>\n</blockquote>\n<p>Yeah, that's definitely true, too.</p>\n<hr>\n<blockquote>\n<p>This is a big reason why I went to JavaScript; the browser is your player, and everyone already has the player installed.</p>\n</blockquote>\n<p>A very good call, good sir!</p>\n<hr>\n<blockquote>\n<p>Ahh, welcome to the wonder of strongly typed languages :)</p>\n</blockquote>\n<p>Ha ha! Yeah...</p>\n<p>It is definitely educational, though!</p>\n<hr>\n<blockquote>\n<p>In JS, you come to an expression like <code>a + b</code>. . .</p>\n</blockquote>\n<blockquote>\n<p>In C/C++/Java, when the compiler sees <code>a + b</code>. . .</p>\n</blockquote>\n<p>Hey. . . Is that what the Just In Time thing means?</p>\n\n",
      "PostDate": "2021-06-23T17:09:08.448515Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3be3f2ed-8327-4eba-afb2-3a4d7d90dd13",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> the JS is in-line, and the line is a million kilometers long! Egads!!!\r\n\r\nThis is why I like Chrome.\r\nThe developer console is pretty good at formatting compressed javascript in a readable way.\r\n\r\n> Hey. . . Is that what the Just In Time thing means?\r\n\r\nNot quite. As far as I understand it, JIT means a language operates in a way that's a cross between a compiled language and an interpreter. Like the JS engine tries to analyse your code while it's running, and find better compilation paths if it can spot where the bottlenecks are. This is a kind of hybrid of interpreter flexibility and compiled speed.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>the JS is in-line, and the line is a million kilometers long! Egads!!!</p>\n</blockquote>\n<p>This is why I like Chrome.<br>\nThe developer console is pretty good at formatting compressed javascript in a readable way.</p>\n<blockquote>\n<p>Hey. . . Is that what the Just In Time thing means?</p>\n</blockquote>\n<p>Not quite. As far as I understand it, JIT means a language operates in a way that's a cross between a compiled language and an interpreter. Like the JS engine tries to analyse your code while it's running, and find better compilation paths if it can spot where the bottlenecks are. This is a kind of hybrid of interpreter flexibility and compiled speed.</p>\n\n",
      "PostDate": "2021-06-23T22:58:35.3354424Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8564a2a9-d859-403e-8641-b75a0cc765e4",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> This is why I like Chrome.\r\nThe developer console is pretty good at formatting compressed javascript in a readable way.\r\n\r\nOh,  re-hee-hee-heely???\r\n\r\nI'm off to see how Quixe makes the [MORE](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/more) prompt work in the website version! (I really don't like ```scrollToEnd()```.)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>This is why I like Chrome.<br>\nThe developer console is pretty good at formatting compressed javascript in a readable way.</p>\n</blockquote>\n<p>Oh,  re-hee-hee-heely???</p>\n<p>I'm off to see how Quixe makes the <a href=\"https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/more\">MORE</a> prompt work in the website version! (I really don't like <code>scrollToEnd()</code>.)</p>\n\n",
      "PostDate": "2021-06-24T02:53:20.8351139Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
