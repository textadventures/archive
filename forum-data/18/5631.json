{
  "Topic": {
    "TopicId": "5631",
    "ForumId": "18",
    "Title": "Object-orientated programming with Quest",
    "LastUpdated": "2015-11-25T23:16:53+00:00",
    "ReplyCount": 2
  },
  "Posts": [
    {
      "PostId": "38737",
      "UserId": 0,
      "Username": "The Pixie",
      "UserAvatar": null,
      "UserGravatar": "cfa37e927f96177bcf6053ae8f108f77",
      "EditableText": "Object-orientated Programming With Quest\n\nThe coding language of Quest is designed to be relatively simple, but it does support object-orientated programming (OOP). One of the problems with using Quest in this way is that &quot;object&quot; has a different meaning in text adventures leading to some potential confusion, however, they are not too different.\n\nIn OOP, all objects belong to a class, and in the Quest the equivalent of a class is a [i:rvl5d9st]type[/i:rvl5d9st]. To learn about types, go to the [url=http&#58;//docs&#46;textadventures&#46;co&#46;uk/quest/guides/:rvl5d9st]&quot;How to...&quot;[/url:rvl5d9st] page, and read the following:\n\nUse Types\nUse Types and Tabs\nMore on Tabs (implementing a magic system)\nSimple Combat System\n\nI am going to assume you have read and understood them from here on.\n\nThe last one presents the &quot;monster&quot; type. It looks like this:\n[code:rvl5d9st]  &lt;type name=&quot;monster&quot;&gt;\n    &lt;defence type=&quot;int&quot;&gt;0&lt;/defence&gt;\n    &lt;armour type=&quot;int&quot;&gt;0&lt;/armour&gt;\n    &lt;hitpoints type=&quot;int&quot;&gt;10&lt;/hitpoints&gt;\n    &lt;take type=&quot;boolean&quot;&gt;false&lt;/take&gt;\n    &lt;attack type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;\n      attackroll = GetRandomInt (1, 20) - this&#46;defence + player&#46;attack\n      attackroll = attackroll + player&#46;equipped&#46;attackbonus\n      if (attackroll &gt; 10) {\n        damage = player&#46;equipped&#46;damagebonus\n        for (i, 1, player&#46;equipped&#46;damagedicenumber) {\n          damage = damage + GetRandomInt (1, player&#46;equipped&#46;damagedicesides) - this&#46;armour\n        }\n        this&#46;hitpoints = this&#46;hitpoints - damage\n        if (this&#46;hitpointsyour  &gt; 0) {\n          msg (&quot;You swing &quot; + player&#46;equipped&#46;alias + &quot; and hit, doing &quot; + damage + &quot; points of damage; &quot; + this&#46;hurt)\n        }\n        else {\n          msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and hit, doing &quot; + damage + &quot; points of damage; &quot; + this&#46;death)\n          Death (this)\n        }\n      }\n      else {\n        msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and miss&#46;&quot;)\n      }\n    &#93;&#93;&gt;&lt;/attack&gt;\n  &lt;/type&gt;[/code:rvl5d9st]\nIn OOP terms this is the class definition. It defines some attributes, defence, armour, etc. and an instance method, attack. An instance method is a function that belongs to an instance of the class; if we create a monster, it will have that script attached to it (Quest dos not support class method, in case you are wondering).\n\n\n[b:rvl5d9st][i:rvl5d9st]Inheritance[/i:rvl5d9st][/b:rvl5d9st]\n\nInheritance allows the coder to go from the general to the specific. Let us say there will be a lot of undead in my game. Undead are a type of monster, but have their own properties.  I can create a new type that is [i:rvl5d9st]inherited[/i:rvl5d9st] from &quot;monster&quot;, and so has all those methods and scripts, but with its own unique features.\n[code:rvl5d9st]  &lt;type name=&quot;undead&quot;&gt;\n    &lt;inherit name=&quot;monster&quot; /&gt;\n    &lt;soulchill type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;\n      msg (&quot;You feel a chill to the very core of your soul&#46;&quot;)\n  &#93;&#93;&gt;&lt;/soulchill&gt;\n  &lt;/type&gt;[/code:rvl5d9st]\nA class can inherit from a class that inherits from another class, so we can do this:\n[code:rvl5d9st]  &lt;type name=&quot;ghost&quot;&gt;\n    &lt;inherit name=&quot;undead&quot; /&gt;\n    &lt;noncorporeal type=&quot;boolean&quot;&gt;true&lt;/noncorporeal&gt;\n  &lt;/type&gt;[/code:rvl5d9st]\nQuest allows multiple inheritance, which means an object or class can inherit from multiple parents. This object is inheriting from both &quot;ghost&quot; and &quot;editor_object&quot;.\n[code:rvl5d9st]    &lt;object name=&quot;ghost_of_lady_grey&quot;&gt;\n      &lt;inherit name=&quot;editor_object&quot; /&gt;\n      &lt;inherit name=&quot;ghost&quot; /&gt;\n    &lt;/object&gt;[/code:rvl5d9st]\nThis can potentially lead to some confusion. Suppose &quot;ghost&quot; sets the hit points to be 15, and &quot;editor_object&quot; sets it to 0; which one wins? The answer is that the one that come later in the list will overwrite the earlier value, so in the above example, the value from &quot;ghost&quot; will win.\n\nYou can test inheritance using the DoesInherit function.\n[code:rvl5d9st]DoesInherit(ghost_of_lady_grey, &quot;editor_object&quot;)\nDoesInherit(ghost_of_lady_grey, &quot;ghost&quot;)\nDoesInherit(ghost_of_lady_grey, &quot;undead&quot;)\nDoesInherit(ghost_of_lady_grey, &quot;monster&quot;)[/code:rvl5d9st]\nAll these will evaluate to true... until you publish your game, when all the editor types will be stripped out!\n\n\n[b:rvl5d9st][i:rvl5d9st]Encapsulation[/i:rvl5d9st][/b:rvl5d9st]\n\nEncapsulation is the idea that all the code for something is hidden away with that thing, so other codes cannot mess around with it. Specifically;\n\nRestrict access to certain components of the object\nBundle together all the code for an object with that object\n\nSadly Quest does not allow us to do the former, which does mean you can screw around with some pretty fundamental functions. However, we can do the latter. All you have to do is have all the code that relates to monsters defined inside the monster class, either in scripts or in delegates. Quest does not encourage you to do that (how many times have you used a delegate?),but the facility is there.\n\n\n[b:rvl5d9st][i:rvl5d9st]Polymorphism[/i:rvl5d9st][/b:rvl5d9st]\n\nPolymorphism is the idea that you can tell an object to do something without worrying about what it will do or how it will do it, or even what the object actually is. Quest is pretty big on polymorphism, though you may not realise it, and it is not necessarily proper OOP polymorphism. Play any Quest game and type GET for some object, and Quest will handle that; it does not matter if you are trying to get a door or a ball or the room you are in. \n\nLet us say our ghost cannot be hurt by the player, being insubstantial, we could do this:\n[code:rvl5d9st]  &lt;type name=&quot;ghost&quot;&gt;\n    &lt;inherit name=&quot;undead&quot; /&gt;\n    &lt;noncorporeal type=&quot;boolean&quot;&gt;true&lt;/noncorporeal&gt;\n    &lt;attack type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;\n      msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and it goes right through the ghost!&quot;)\n    &#93;&#93;&gt;&lt;/attack&gt;\n  &lt;/type&gt;[/code:rvl5d9st]\nThe &quot;attack&quot; method here will now [i:rvl5d9st]override[/i:rvl5d9st] the attack method of monster. The player types ATTACK GHOST, and Quest will use the &quot;attack&quot; script from the &quot;ghost&quot; type. When she types ATTACK GOBLIN, though, the normal attack script applies.\n\nWant to add a new type? Perhaps robots with force fields act differently. How they act is kept with them; no need to touch the original code,\n\nThink for a moment about the alternative. If &quot;attack&quot; was instead handled by a function, we would have to check whether the target was a ghost, and if so do one thing, and if not, do another. That is not so bad for one exception, but what if you have half a dozen monsters that behave a bit differently. Soon your function is huge, and the code for your ghost is lost in with the code for other monsters.\n\n\n[i:rvl5d9st][u:rvl5d9st]Message passing[/u:rvl5d9st][/i:rvl5d9st]\n\nThis is the key feature of OOP, the concept of passing a message to an object, and letting it handle it itself. It fits naturally with encapsulation and polymorphism, so it has been covered already, it is just connecting that to the terminology.\n\nIn the above examples, Quest is passing the message &quot;attack&quot; to the monster, then letting the monster sort out what to do with it.\n[code:rvl5d9st]do(monster, &quot;attack&quot;)[/code:rvl5d9st]",
      "EditableFormat": "bbcode",
      "HTML": "Object-orientated Programming With Quest<br/><br/>The coding language of Quest is designed to be relatively simple, but it does support object-orientated programming (OOP). One of the problems with using Quest in this way is that &quot;object&quot; has a different meaning in text adventures leading to some potential confusion, however, they are not too different.<br/><br/>In OOP, all objects belong to a class, and in the Quest the equivalent of a class is a <span style=\"font-style:italic;\">type</span>. To learn about types, go to the <a href=\"http&#58;//docs&#46;textadventures&#46;co&#46;uk/quest/guides/\" rel=\"nofollow\">&quot;How to...&quot;</a> page, and read the following:<br/><br/>Use Types<br/>Use Types and Tabs<br/>More on Tabs (implementing a magic system)<br/>Simple Combat System<br/><br/>I am going to assume you have read and understood them from here on.<br/><br/>The last one presents the &quot;monster&quot; type. It looks like this:<br/><pre><code>  &lt;type name=&quot;monster&quot;&gt;<br/>    &lt;defence type=&quot;int&quot;&gt;0&lt;/defence&gt;<br/>    &lt;armour type=&quot;int&quot;&gt;0&lt;/armour&gt;<br/>    &lt;hitpoints type=&quot;int&quot;&gt;10&lt;/hitpoints&gt;<br/>    &lt;take type=&quot;boolean&quot;&gt;false&lt;/take&gt;<br/>    &lt;attack type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;<br/>      attackroll = GetRandomInt (1, 20) - this&#46;defence + player&#46;attack<br/>      attackroll = attackroll + player&#46;equipped&#46;attackbonus<br/>      if (attackroll &gt; 10) {<br/>        damage = player&#46;equipped&#46;damagebonus<br/>        for (i, 1, player&#46;equipped&#46;damagedicenumber) {<br/>          damage = damage + GetRandomInt (1, player&#46;equipped&#46;damagedicesides) - this&#46;armour<br/>        }<br/>        this&#46;hitpoints = this&#46;hitpoints - damage<br/>        if (this&#46;hitpointsyour  &gt; 0) {<br/>          msg (&quot;You swing &quot; + player&#46;equipped&#46;alias + &quot; and hit, doing &quot; + damage + &quot; points of damage; &quot; + this&#46;hurt)<br/>        }<br/>        else {<br/>          msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and hit, doing &quot; + damage + &quot; points of damage; &quot; + this&#46;death)<br/>          Death (this)<br/>        }<br/>      }<br/>      else {<br/>        msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and miss&#46;&quot;)<br/>      }<br/>    &#93;&#93;&gt;&lt;/attack&gt;<br/>  &lt;/type&gt;</code></pre><br/>In OOP terms this is the class definition. It defines some attributes, defence, armour, etc. and an instance method, attack. An instance method is a function that belongs to an instance of the class; if we create a monster, it will have that script attached to it (Quest dos not support class method, in case you are wondering).<br/><br/><br/><span style=\"font-weight:bold;\"><span style=\"font-style:italic;\">Inheritance</span></span><br/><br/>Inheritance allows the coder to go from the general to the specific. Let us say there will be a lot of undead in my game. Undead are a type of monster, but have their own properties.  I can create a new type that is <span style=\"font-style:italic;\">inherited</span> from &quot;monster&quot;, and so has all those methods and scripts, but with its own unique features.<br/><pre><code>  &lt;type name=&quot;undead&quot;&gt;<br/>    &lt;inherit name=&quot;monster&quot; /&gt;<br/>    &lt;soulchill type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;<br/>      msg (&quot;You feel a chill to the very core of your soul&#46;&quot;)<br/>  &#93;&#93;&gt;&lt;/soulchill&gt;<br/>  &lt;/type&gt;</code></pre><br/>A class can inherit from a class that inherits from another class, so we can do this:<br/><pre><code>  &lt;type name=&quot;ghost&quot;&gt;<br/>    &lt;inherit name=&quot;undead&quot; /&gt;<br/>    &lt;noncorporeal type=&quot;boolean&quot;&gt;true&lt;/noncorporeal&gt;<br/>  &lt;/type&gt;</code></pre><br/>Quest allows multiple inheritance, which means an object or class can inherit from multiple parents. This object is inheriting from both &quot;ghost&quot; and &quot;editor_object&quot;.<br/><pre><code>    &lt;object name=&quot;ghost_of_lady_grey&quot;&gt;<br/>      &lt;inherit name=&quot;editor_object&quot; /&gt;<br/>      &lt;inherit name=&quot;ghost&quot; /&gt;<br/>    &lt;/object&gt;</code></pre><br/>This can potentially lead to some confusion. Suppose &quot;ghost&quot; sets the hit points to be 15, and &quot;editor_object&quot; sets it to 0; which one wins? The answer is that the one that come later in the list will overwrite the earlier value, so in the above example, the value from &quot;ghost&quot; will win.<br/><br/>You can test inheritance using the DoesInherit function.<br/><pre><code>DoesInherit(ghost_of_lady_grey, &quot;editor_object&quot;)<br/>DoesInherit(ghost_of_lady_grey, &quot;ghost&quot;)<br/>DoesInherit(ghost_of_lady_grey, &quot;undead&quot;)<br/>DoesInherit(ghost_of_lady_grey, &quot;monster&quot;)</code></pre><br/>All these will evaluate to true... until you publish your game, when all the editor types will be stripped out!<br/><br/><br/><span style=\"font-weight:bold;\"><span style=\"font-style:italic;\">Encapsulation</span></span><br/><br/>Encapsulation is the idea that all the code for something is hidden away with that thing, so other codes cannot mess around with it. Specifically;<br/><br/>Restrict access to certain components of the object<br/>Bundle together all the code for an object with that object<br/><br/>Sadly Quest does not allow us to do the former, which does mean you can screw around with some pretty fundamental functions. However, we can do the latter. All you have to do is have all the code that relates to monsters defined inside the monster class, either in scripts or in delegates. Quest does not encourage you to do that (how many times have you used a delegate?),but the facility is there.<br/><br/><br/><span style=\"font-weight:bold;\"><span style=\"font-style:italic;\">Polymorphism</span></span><br/><br/>Polymorphism is the idea that you can tell an object to do something without worrying about what it will do or how it will do it, or even what the object actually is. Quest is pretty big on polymorphism, though you may not realise it, and it is not necessarily proper OOP polymorphism. Play any Quest game and type GET for some object, and Quest will handle that; it does not matter if you are trying to get a door or a ball or the room you are in. <br/><br/>Let us say our ghost cannot be hurt by the player, being insubstantial, we could do this:<br/><pre><code>  &lt;type name=&quot;ghost&quot;&gt;<br/>    &lt;inherit name=&quot;undead&quot; /&gt;<br/>    &lt;noncorporeal type=&quot;boolean&quot;&gt;true&lt;/noncorporeal&gt;<br/>    &lt;attack type=&quot;script&quot;&gt;&lt;!&#91;CDATA&#91;<br/>      msg (&quot;You swing your &quot; + player&#46;equipped&#46;alias + &quot; and it goes right through the ghost!&quot;)<br/>    &#93;&#93;&gt;&lt;/attack&gt;<br/>  &lt;/type&gt;</code></pre><br/>The &quot;attack&quot; method here will now <span style=\"font-style:italic;\">override</span> the attack method of monster. The player types ATTACK GHOST, and Quest will use the &quot;attack&quot; script from the &quot;ghost&quot; type. When she types ATTACK GOBLIN, though, the normal attack script applies.<br/><br/>Want to add a new type? Perhaps robots with force fields act differently. How they act is kept with them; no need to touch the original code,<br/><br/>Think for a moment about the alternative. If &quot;attack&quot; was instead handled by a function, we would have to check whether the target was a ghost, and if so do one thing, and if not, do another. That is not so bad for one exception, but what if you have half a dozen monsters that behave a bit differently. Soon your function is huge, and the code for your ghost is lost in with the code for other monsters.<br/><br/><br/><span style=\"font-style:italic;\"><span style=\"text-decoration:underline;\">Message passing</span></span><br/><br/>This is the key feature of OOP, the concept of passing a message to an object, and letting it handle it itself. It fits naturally with encapsulation and polymorphism, so it has been covered already, it is just connecting that to the terminology.<br/><br/>In the above examples, Quest is passing the message &quot;attack&quot; to the monster, then letting the monster sort out what to do with it.<br/><pre><code>do(monster, &quot;attack&quot;)</code></pre>",
      "PostDate": "2015-11-17T11:24:26+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "38842",
      "UserId": 0,
      "Username": "The Pixie",
      "UserAvatar": null,
      "UserGravatar": "cfa37e927f96177bcf6053ae8f108f77",
      "EditableText": "Incidentally, Quest offers an alternative to &quot;do&quot;. At first glance these achieve the same thing:\n[code:2pqatd0o]do(monster, &quot;attack&quot;)\ninvoke(monster&#46;attack)[/code:2pqatd0o]\nHowever, if you use &quot;do&quot;, you have access to &quot;this&quot; in your script. If you use &quot;invoke&quot; you do not (because invoke has only been sent the script itself, not the object it is attached to). For this reason, &quot;do&quot; is far better.",
      "EditableFormat": "bbcode",
      "HTML": "Incidentally, Quest offers an alternative to &quot;do&quot;. At first glance these achieve the same thing:<br/><pre><code>do(monster, &quot;attack&quot;)<br/>invoke(monster&#46;attack)</code></pre><br/>However, if you use &quot;do&quot;, you have access to &quot;this&quot; in your script. If you use &quot;invoke&quot; you do not (because invoke has only been sent the script itself, not the object it is attached to). For this reason, &quot;do&quot; is far better.",
      "PostDate": "2015-11-24T11:33:59+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "38870",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Thanks for the explanation of this with regards to quest and the snippet too about do vs invoke. Useful for people like me, who're just learning the basics of programming.",
      "EditableFormat": "bbcode",
      "HTML": "Thanks for the explanation of this with regards to quest and the snippet too about do vs invoke. Useful for people like me, who're just learning the basics of programming.",
      "PostDate": "2015-11-25T23:16:53+00:00",
      "LastEditDate": null
    }
  ]
}
