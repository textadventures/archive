{
  "Topic": {
    "TopicId": "2wel1vfq6kiwfu_omrvnzq",
    "ForumId": "18",
    "Title": "Making any command affect a different object (Quest)",
    "LastUpdated": "2020-11-23T15:43:38.6767484Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "f504191e-10fe-415c-9940-dba0cae21902",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I've seen a few people mention this, and thought I should give it a try.\r\nThe basic idea is making a command or verb apply to a different example. For example, making \"switch on chandelier\" act as if the player typed \"switch on light switch\", while allowing both objects to have separate descriptions for the purpose of looking at them. Or making \"unlock gate\" be the same as \"unlock brass padlock\", if the lock is a separate object.\r\n\r\nThe idea here is that you might want using a specific command (or list of commands) automatically transfer to a different object. This might be easy to do with verbs, but with some commands (such as \"open\") it can be needlessly complex. So why not let the parser do it?\r\n\r\n<pre><code>  &lt;function name=\"AddToResolvedNames\" parameters=\"var, result\">\r\n    <b style=\"color: green\">if (TypeOf(result) = \"object\") {\r\n      result = GetIndirectObject (result, game.pov.currentcommandpattern.name, var)\r\n    else if (EndsWith (TypeOf(result), \"list\")) {\r\n      indirect = NewObjectList()\r\n      foreach (obj, result) {\r\n        list add (indirect, GetIndirectObject (result, game.pov.currentcommandpattern.name, var)\r\n      }\r\n      result = indirect\r\n    }</b>\r\n    if (TypeOf(result) = \"object\") {\r\n      if (result.type = \"object\") {\r\n        list add (game.pov.currentcommandresolvedobjects, result)\r\n      }\r\n    }\r\n    else if (TypeOf(result) = \"objectlist\") {\r\n      foreach (obj, result) {\r\n        if (obj.type = \"object\") {\r\n          list add (game.pov.currentcommandresolvedobjects, obj)\r\n        }\r\n      }\r\n    }\r\n    dictionary add(game.pov.currentcommandresolvedelements, var, result)\r\n    ResolveNextName\r\n  &lt;/function>\r\n\r\n<b style=\"color: green\">  &lt;function name=\"GetIndirectObject\" parameters=\"object, command, var\" type=\"object\">\r\n    if (object = null) {\r\n      return (object)\r\n    }\r\n    if (not HasAttribute (object, \"indirectcommandobjects\")) {\r\n      return (object)\r\n    }\r\n    if (DictionaryContains (object.indirectcommandobjects, command.name + \"/\" + var)) {\r\n      return (ObjectDictionaryItem (object.indirectcommandobjects, command.name + \"/\" + var))\r\n    }\r\n    if (DictionaryContains (object.indirectcommandobjects, command.name)) {\r\n      return (ObjectDictionaryItem (object.indirectcommandobjects, command.name))\r\n    }\r\n  &lt;/function></b></code></pre>\r\n\r\nThis allows any object to have a dictionary `indirectcommandobjects` which is an objectdictionary. Its key is the name of the command (so \"switch on\" for the chandelier, or \"open\" for the desk in my examples), and the value is the object which the command should apply to instead.\r\n\r\nThe object is replaced with its indirect object after all the fiddling with disambiguation menus and similar, so I think it will allow compound objects (such as separate objects for a door, latch, and keyhole, for example) to be handled more elegantly without causing any other problems.",
      "EditableFormat": "markdown",
      "HTML": "<p>I've seen a few people mention this, and thought I should give it a try.<br>\nThe basic idea is making a command or verb apply to a different example. For example, making \"switch on chandelier\" act as if the player typed \"switch on light switch\", while allowing both objects to have separate descriptions for the purpose of looking at them. Or making \"unlock gate\" be the same as \"unlock brass padlock\", if the lock is a separate object.</p>\n<p>The idea here is that you might want using a specific command (or list of commands) automatically transfer to a different object. This might be easy to do with verbs, but with some commands (such as \"open\") it can be needlessly complex. So why not let the parser do it?</p>\n<pre><code>  &lt;function name=\"AddToResolvedNames\" parameters=\"var, result\"&gt;\n    <b style=\"color: green\">if (TypeOf(result) = \"object\") {\n      result = GetIndirectObject (result, game.pov.currentcommandpattern.name, var)\n    else if (EndsWith (TypeOf(result), \"list\")) {\n      indirect = NewObjectList()\n      foreach (obj, result) {\n        list add (indirect, GetIndirectObject (result, game.pov.currentcommandpattern.name, var)\n      }\n      result = indirect\n    }</b>\n    if (TypeOf(result) = \"object\") {\n      if (result.type = \"object\") {\n        list add (game.pov.currentcommandresolvedobjects, result)\n      }\n    }\n    else if (TypeOf(result) = \"objectlist\") {\n      foreach (obj, result) {\n        if (obj.type = \"object\") {\n          list add (game.pov.currentcommandresolvedobjects, obj)\n        }\n      }\n    }\n    dictionary add(game.pov.currentcommandresolvedelements, var, result)\n    ResolveNextName\n  &lt;/function&gt;\n\n<b style=\"color: green\">  &lt;function name=\"GetIndirectObject\" parameters=\"object, command, var\" type=\"object\"&gt;\n    if (object = null) {\n      return (object)\n    }\n    if (not HasAttribute (object, \"indirectcommandobjects\")) {\n      return (object)\n    }\n    if (DictionaryContains (object.indirectcommandobjects, command.name + \"/\" + var)) {\n      return (ObjectDictionaryItem (object.indirectcommandobjects, command.name + \"/\" + var))\n    }\n    if (DictionaryContains (object.indirectcommandobjects, command.name)) {\n      return (ObjectDictionaryItem (object.indirectcommandobjects, command.name))\n    }\n  &lt;/function&gt;</b></code></pre>\n<p>This allows any object to have a dictionary <code>indirectcommandobjects</code> which is an objectdictionary. Its key is the name of the command (so \"switch on\" for the chandelier, or \"open\" for the desk in my examples), and the value is the object which the command should apply to instead.</p>\n<p>The object is replaced with its indirect object after all the fiddling with disambiguation menus and similar, so I think it will allow compound objects (such as separate objects for a door, latch, and keyhole, for example) to be handled more elegantly without causing any other problems.</p>\n\n",
      "PostDate": "2020-11-23T15:43:38.6767484Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
