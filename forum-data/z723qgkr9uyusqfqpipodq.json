{
  "Topic": {
    "TopicId": "z723qgkr9uyusqfqpipodq",
    "ForumId": "10",
    "Title": "How to reference grid.js variables to use other paper.js functions on grid [SOLVED]",
    "LastUpdated": "2023-10-12T22:02:53.7997177Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "cd227d04-58b2-42f7-9ad9-fcc8b38d5f3f",
      "UserId": 599148,
      "Username": "DeepDredux",
      "AvatarUrl": "https://i.imgur.com/0MkvPpKb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm trying to do some funky things with the Quest 5.8 map by incorporating more of the `paper.js` functionality (curves, animations, etc.), but I've hit a roadblock. \r\n\r\nI'd like to try to leverage as much of the existing functionality already provided by the built-in `grid.js` as I can,  such as having anything I render drag and move when the player does. To do this, I need to be able to reference (and directly edit) the variables within `grid.js`, but unlike `playercore.js` and the other built-in javascript files, it seems like `grid.js` is loaded in some strange way such that I can't for the life of me figure out how to reference any of its variables from my own custom javascript files...\r\n\r\nI've figured out how to draw custom objects to the map using `paper.js` javascript functions, but they will not move or drag with the map. (They will zoom, oddly enough, I suspect because the zoom functions in `grid.js` were all put in a gridApi container, but sadly the drag functions were not)...\r\n\r\nWhile I've gotten pretty good at manipulating the Quest .aslx code, I'm still a novice when it comes to javascript so maybe there's something I'm missing? Anyone with more Javascript experience or Quest map experience have any ideas?\r\n\r\n**The built-in `grid.js` for reference:**\r\n <details>\r\n\r\n```\r\n\r\nvar scale, gridX, gridY, player,\r\n    playerVector, playerDestination,\r\n    offsetVector, offsetDestination,\r\n    allPaths = [],\r\n    customLayerPaths = [],\r\n    customLayerObjects = {},\r\n    customLayerSvg = {},\r\n    customLayerImages = {},\r\n    layers = [],\r\n    maxLayer = 7,\r\n    currentLayer = 0,\r\n    offset = new Point(0, 0),\r\n    symbols = {},\r\n    newShapePoints = [];\r\n\r\nfor (var i = -maxLayer; i <= maxLayer; i++) {\r\n    var layer = new Layer();\r\n    layers.push(project.activeLayer);\r\n}\r\n\r\nvar customLayer = new Layer(),\r\n    customLayerOffset = new Point(0, 0);\r\n\r\ncustomLayer.visible = false;\r\n\r\nfunction activateLayer(index) {\r\n    showCustomLayer(false);\r\n    layers[getLayerIndex(index)].activate();\r\n    layers[getLayerIndex(index)].opacity = 1;\r\n    if (currentLayer != index) {\r\n        layers[getLayerIndex(currentLayer)].opacity = 0.2;\r\n        currentLayer = index;\r\n    }\r\n}\r\n\r\nfunction getLayerIndex(index) {\r\n    if (index < -maxLayer || index > maxLayer) {\r\n        alert(\"Layer out of bounds. Current layer range: -\" + maxLayer + \" to \" + maxLayer);\r\n    }\r\n    // layers array represents z-indexes from -maxLayer to maxLayer\r\n    return index + maxLayer;\r\n}\r\n\r\nactivateLayer(currentLayer);\r\n\r\ngridApi.setScale = function(newScale) {\r\n    scale = newScale;\r\n    gridX = new Point(scale, 0);\r\n    gridY = new Point(0, scale);\r\n};\r\n\r\ngridApi.setZoom = function(zoom) {\r\n    paper.view.zoom = zoom;\r\n};\r\n\r\ngridApi.zoomIn = function(amount) {\r\n    zoom = paper.view.zoom * (Math.pow(1.1, amount));\r\n    if (zoom > 0.0001) {\r\n        paper.view.zoom = zoom;\r\n    }\r\n};\r\n\r\nfunction onMouseDrag(event) {\r\n    updateOffset(event.delta);\r\n}\r\n\r\n\r\nfunction onMouseUp(event) {\r\n    if (_respondToGridClicks) {\r\n        var x = getGridSquareX(event.point);\r\n        var y = getGridSquareY(event.point);\r\n        ASLEvent(\"JS_GridSquareClick\", x + \";\" + y);\r\n    }\r\n}\r\n\r\nfunction updateOffset(delta) {\r\n    setOffset(getOffset() + delta);\r\n    var paths;\r\n    if (project.activeLayer == customLayer) {\r\n        paths = customLayerPaths;\r\n    }\r\n    else {\r\n        paths = allPaths;\r\n    }\r\n    for (var i = 0; i < paths.length; i++) {\r\n        paths[i].position += delta;\r\n    }\r\n    if (playerDestination && project.activeLayer != customLayer) {\r\n        playerDestination += delta;\r\n    }\r\n}\r\n\r\nfunction getOffset() {\r\n    if (project.activeLayer == customLayer) {\r\n        return customLayerOffset;\r\n    }\r\n    return offset;\r\n}\r\n\r\nfunction setOffset(value) {\r\n    if (project.activeLayer == customLayer) {\r\n        customLayerOffset = value;\r\n    }\r\n    else {\r\n        offset = value;\r\n    }\r\n}\r\n\r\nfunction onFrame(event) {\r\n    if (playerVector) {\r\n        var distance = player.position - playerDestination;\r\n        if (distance.length > playerVector.length) {\r\n            player.position += playerVector;\r\n        }\r\n        else {\r\n            player.position = playerDestination;\r\n            playerVector = null;\r\n            playerDestination = null;\r\n\r\n            var playerPositionAbsolute = player.position - offset;\r\n            offsetDestination = paper.view.center - playerPositionAbsolute;\r\n\r\n            offsetVector = (offsetDestination-offset) / 10;\r\n        }\r\n    }\r\n    if (offsetVector) {\r\n        var distance = offset - offsetDestination;\r\n        if (distance.length > offsetVector.length) {\r\n            updateOffset(offsetVector);\r\n        }\r\n        else {\r\n            updateOffset(offsetDestination-offset);\r\n            offsetVector = null;\r\n            offsetDestination = null;\r\n        }\r\n    }\r\n}\r\n\r\ngridApi.drawGrid = function(minX, minY, maxX, maxY, border) {\r\n\r\n    function gridLine(start, end) {\r\n        var path = new Path();\r\n        path.strokeColor = border;\r\n        path.add(start, end);\r\n        addPathToCurrentLayerList(path);\r\n    }\r\n\r\n    // draw the vertical lines\r\n    for (var x = minX; x <= maxX; x++) {\r\n        var start = gridPoint(x, minY);\r\n        var end = gridPoint(x, maxY);\r\n        gridLine(start, end);\r\n    }\r\n\r\n    // draw the horizontal lines\r\n    for (var y = minY; y <= maxY; y++) {\r\n        var start = gridPoint(minX, y);\r\n        var end = gridPoint(maxX, y);\r\n        gridLine(start, end);\r\n    }\r\n};\r\n\r\nfunction gridPoint(x, y) {\r\n    return (gridX * x) + (gridY * y) + getOffset();\r\n}\r\n\r\nfunction getGridSquareX(point) {\r\n    return Math.floor(((point - getOffset()) / gridX).x);\r\n}\r\n\r\nfunction getGridSquareY(point) {\r\n    return Math.floor(((point - getOffset()) / gridY).y);\r\n}\r\n\r\nfunction gridPointNudge(x, y, nudgeX, nudgeY) {\r\n    var result = gridPoint(x, y);\r\n    result.x += nudgeX;\r\n    result.y += nudgeY;\r\n    return result;\r\n}\r\n\r\nvar firstBox = true;\r\n\r\ngridApi.drawBox = function(x, y, z, width, height, border, borderWidth, fill, sides) {\r\n    activateLayer(z);\r\n    // if this is the very first room, centre the canvas by updating the offset\r\n    if (firstBox) {\r\n        var centrePoint = gridPoint(x + width / 2, y + height / 2);\r\n        var offsetX = paper.view.center.x - centrePoint.x;\r\n        var offsetY = paper.view.center.y - centrePoint.y;\r\n        updateOffset(new Point(offsetX, offsetY));\r\n        firstBox = false;\r\n    }\r\n    var path = null;\r\n    var points = [gridPoint(x, y), gridPoint(x + width, y), gridPoint(x + width, y + height), gridPoint(x, y + height)];\r\n    // sides is encoded with bits to represent NESW\r\n    var draw = [sides & 8, sides & 4, sides & 2, sides & 1];\r\n    for (var i = 0; i < 4; i++) {\r\n        var next = (i + 1) % 4;\r\n        if (draw[i]) {\r\n            if (path == null) {\r\n                path = new Path();\r\n                allPaths.push(path);\r\n                if (borderWidth > 0) {\r\n                    path.strokeColor = border;\r\n                    path.strokeWidth = borderWidth;\r\n                }\r\n                path.add(points[i]);\r\n            }\r\n            path.add(points[next]);\r\n        } else {\r\n            path = null;\r\n        }\r\n    }\r\n    var fillPath;\r\n    if (sides == 15) {\r\n        fillPath = path;\r\n    } else {\r\n        fillPath = new Path();\r\n        fillPath.add(points[0], points[1], points[2], points[3]);\r\n        allPaths.push(fillPath);\r\n    }\r\n    fillPath.fillColor = fill;\r\n    fillPath.closed = true;\r\n};\r\n\r\ngridApi.drawLine = function(x1, y1, x2, y2, border, borderWidth) {\r\n    var path = new Path;\r\n    path.strokeColor = border;\r\n    path.strokeWidth = borderWidth;\r\n    path.add(gridPoint(x1, y1));\r\n    path.add(gridPoint(x2, y2));\r\n    addPathToCurrentLayerList(path);\r\n};\r\n\r\ngridApi.drawArrow = function (id, x1, y1, x2, y2, border, borderWidth) {\r\n    clearExistingObject(id);\r\n    \r\n    var linePath = new Path;\r\n    var start = gridPoint(x1, y1);\r\n    var end = gridPoint(x2, y2);\r\n    linePath.strokeColor = border;\r\n    linePath.strokeWidth = borderWidth;\r\n    linePath.add(start);\r\n    linePath.add(end);\r\n    addPathToCurrentLayerList(linePath);\r\n\r\n    var vector = end - start;\r\n    var arrowVector = vector.normalize(10);\r\n    var arrowheadPath = new Path([\r\n        end + arrowVector.rotate(150),\r\n        end,\r\n        end + arrowVector.rotate(-150)\r\n    ]);\r\n    arrowheadPath.strokeColor = border;\r\n    arrowheadPath.strokeWidth = borderWidth;\r\n    addPathToCurrentLayerList(arrowheadPath);\r\n\r\n    customLayerObjects[id] = [linePath, arrowheadPath];\r\n};\r\n\r\nfunction addPathToCurrentLayerList(path) {\r\n    if (project.activeLayer == customLayer) {\r\n        customLayerPaths.push(path);\r\n    }\r\n    else {\r\n        allPaths.push(path);\r\n    }\r\n}\r\n\r\ngridApi.drawPlayer = function(x, y, z, radius, border, borderWidth, fill) {\r\n    activateLayer(z);\r\n    if (!player) {\r\n        player = new Path.Circle(gridPoint(x, y), radius);\r\n        player.strokeColor = border;\r\n        player.strokeWidth = borderWidth;\r\n        player.fillColor = fill;\r\n        player.fillColor = fill;\r\n        allPaths.push(player);\r\n\r\n        var playerPositionAbsolute = player.position - offset;\r\n        var offsetDestinationX = paper.view.center.x - playerPositionAbsolute.x;\r\n        var offsetDestinationY = paper.view.center.y - playerPositionAbsolute.y;\r\n\r\n        offsetDestination = new Point(offsetDestinationX, offsetDestinationY);\r\n        offsetVector = (offsetDestination - offset);\r\n    } else {\r\n        playerDestination = gridPoint(x, y);\r\n        playerVector = (playerDestination - player.position) / 10;\r\n        // move player to the end of the activeLayer so it gets drawn on top\r\n        project.activeLayer.addChild(player);\r\n    }\r\n};\r\n\r\n \r\ngridApi.drawLabel = function(x, y, z, text, col) {\r\n    if (col === undefined) col = \"black\";\r\n    activateLayer(z);\r\n    var pointText = new PointText(gridPoint(x, y));\r\n    pointText.justification = \"center\";\r\n    pointText.fillColor = col;\r\n    pointText.content = text;\r\n    allPaths.push(pointText);\r\n};\r\n\r\nfunction showCustomLayer(visible) {\r\n    if (visible != customLayer.visible) {\r\n        customLayer.visible = visible;\r\n        for (var idx = 0; idx < layers.length; idx++) {\r\n            layers[idx].visible = !visible;\r\n        }\r\n        if (visible) {\r\n            customLayer.activate();\r\n        }\r\n        else {\r\n            layers[getLayerIndex(currentLayer)].activate();\r\n        }\r\n    }\r\n}\r\n\r\ngridApi.showCustomLayer = function(visible) {\r\n    showCustomLayer(visible);\r\n};\r\n\r\ngridApi.clearCustomLayer = function() {\r\n    customLayer.removeChildren();\r\n};\r\n\r\ngridApi.clearAllLayers = function () {\r\n    player = null;\r\n    $.each(layers, function(idx, layer) {\r\n        layer.removeChildren();\r\n    });\r\n};\r\n\r\ngridApi.setCentre = function(x, y) {\r\n    var centrePoint = gridPoint(x, y);\r\n    var offsetX = paper.view.center.x - centrePoint.x;\r\n    var offsetY = paper.view.center.y - centrePoint.y;\r\n    var curOffset = getOffset();\r\n    updateOffset(new Point(offsetX, offsetY));\r\n};\r\n\r\ngridApi.drawCustomLayerSquare = function(id, x, y, width, height, text, fill) {\r\n    var points = [];\r\n    points.push(gridPointNudge(x, y, 1, 1));\r\n    points.push(gridPointNudge(x + width, y, -1, 1));\r\n    points.push(gridPointNudge(x + width, y + height, -1, -1));\r\n    points.push(gridPointNudge(x, y + height, 1, -1));\r\n\r\n    var textPoint = gridPoint(x + width / 2, y + height / 2);\r\n    gridApi.drawCustomLayerObject(id, points, text, textPoint, fill, fill);\r\n};\r\n\r\nfunction clearExistingObject(id) {\r\n    var existing = customLayerObjects[id];\r\n    if (existing) {\r\n        for (var idx in existing) {\r\n            var path = existing[idx];\r\n            // TO DO: Should remove path from layer and layerlist array\r\n            path.visible = false;\r\n        }\r\n    }\r\n}\r\n\r\ngridApi.drawCustomLayerObject = function (id, points, text, textPoint, border, fill, opacity) {\r\n    clearExistingObject(id);\r\n\r\n    var paths = new Array();\r\n    path = new Path();\r\n    path.strokeColor = border;\r\n    $.each(points, function(index, value) {\r\n        path.add(value);\r\n    });\r\n    path.fillColor = fill;\r\n    path.closed = true;\r\n    if (typeof opacity != \"undefined\") {\r\n        path.opacity = opacity;\r\n    }\r\n    addPathToCurrentLayerList(path);\r\n    paths.push(path);\r\n\r\n    if (text) {\r\n        var pointText = new PointText(textPoint);\r\n        pointText.justification = \"center\";\r\n        pointText.fillColor = \"black\";\r\n        pointText.content = text;\r\n        if (typeof opacity != \"undefined\") {\r\n            pointText.opacity = opacity;\r\n        }\r\n        addPathToCurrentLayerList(pointText);\r\n        paths.push(pointText);\r\n    }\r\n\r\n    customLayerObjects[id] = paths;\r\n};\r\n\r\ngridApi.loadSvg = function (data, id) {\r\n    var svg = paper.project.importSVG(data);\r\n    if (svg) {\r\n        symbols[id] = new Symbol(svg);\r\n    }\r\n};\r\n\r\ngridApi.drawCustomLayerSvg = function (id, symbolId, x, y, width, height) {\r\n    if (symbolId in symbols) {\r\n        var existing = customLayerSvg[id];\r\n        var placedSymbol = existing ? existing : symbols[symbolId].place();\r\n        placedSymbol.scale(gridX.x * width / placedSymbol.bounds.width, gridY.y * height / placedSymbol.bounds.height);\r\n        placedSymbol.position = gridPoint(x, y) + placedSymbol.bounds.size / 2;\r\n        if (!existing) addPathToCurrentLayerList(placedSymbol);\r\n        customLayerSvg[id] = placedSymbol;\r\n    } else {\r\n        console.log(\"No symbol loaded with id '\" + symbolId + \"'\");\r\n    }\r\n};\r\n\r\ngridApi.drawCustomLayerImage = function(id, url, x, y, width, height) {\r\n    var existing = customLayerImages[id];\r\n    var raster = existing ? existing : new Raster(url);\r\n    var resizeRaster = function() {\r\n        raster.scale(gridX.x * width / raster.bounds.width, gridY.y * height / raster.bounds.height);\r\n        raster.position = gridPoint(x, y) + raster.bounds.size / 2;\r\n    };\r\n    if (existing) {\r\n        resizeRaster();\r\n    } else {\r\n        raster.onLoad = resizeRaster;\r\n        addPathToCurrentLayerList(raster);\r\n        customLayerImages[id] = raster;\r\n    }    \r\n}\r\n\r\ngridApi.addNewShapePoint = function (x, y) {\r\n    newShapePoints.push([x, y]);\r\n};\r\n\r\ngridApi.drawShape = function (id, border, fill, opacity) {\r\n    var points = [];\r\n    for (var idx in newShapePoints) {\r\n        var xy = newShapePoints[idx];\r\n        points.push(gridPoint(xy[0], xy[1]));\r\n    }\r\n    gridApi.drawCustomLayerObject(id, points, null, null, border, fill, opacity);\r\n    newShapePoints = [];\r\n};\r\n\r\ngridApi.onLoad();\r\n\r\n\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm trying to do some funky things with the Quest 5.8 map by incorporating more of the <code>paper.js</code> functionality (curves, animations, etc.), but I've hit a roadblock.</p>\n<p>I'd like to try to leverage as much of the existing functionality already provided by the built-in <code>grid.js</code> as I can,  such as having anything I render drag and move when the player does. To do this, I need to be able to reference (and directly edit) the variables within <code>grid.js</code>, but unlike <code>playercore.js</code> and the other built-in javascript files, it seems like <code>grid.js</code> is loaded in some strange way such that I can't for the life of me figure out how to reference any of its variables from my own custom javascript files...</p>\n<p>I've figured out how to draw custom objects to the map using <code>paper.js</code> javascript functions, but they will not move or drag with the map. (They will zoom, oddly enough, I suspect because the zoom functions in <code>grid.js</code> were all put in a gridApi container, but sadly the drag functions were not)...</p>\n<p>While I've gotten pretty good at manipulating the Quest .aslx code, I'm still a novice when it comes to javascript so maybe there's something I'm missing? Anyone with more Javascript experience or Quest map experience have any ideas?</p>\n<p><strong>The built-in <code>grid.js</code> for reference:</strong></p>\n <details>\n<pre><code>\nvar scale, gridX, gridY, player,\n    playerVector, playerDestination,\n    offsetVector, offsetDestination,\n    allPaths = [],\n    customLayerPaths = [],\n    customLayerObjects = {},\n    customLayerSvg = {},\n    customLayerImages = {},\n    layers = [],\n    maxLayer = 7,\n    currentLayer = 0,\n    offset = new Point(0, 0),\n    symbols = {},\n    newShapePoints = [];\n\nfor (var i = -maxLayer; i &lt;= maxLayer; i++) {\n    var layer = new Layer();\n    layers.push(project.activeLayer);\n}\n\nvar customLayer = new Layer(),\n    customLayerOffset = new Point(0, 0);\n\ncustomLayer.visible = false;\n\nfunction activateLayer(index) {\n    showCustomLayer(false);\n    layers[getLayerIndex(index)].activate();\n    layers[getLayerIndex(index)].opacity = 1;\n    if (currentLayer != index) {\n        layers[getLayerIndex(currentLayer)].opacity = 0.2;\n        currentLayer = index;\n    }\n}\n\nfunction getLayerIndex(index) {\n    if (index &lt; -maxLayer || index &gt; maxLayer) {\n        alert(\"Layer out of bounds. Current layer range: -\" + maxLayer + \" to \" + maxLayer);\n    }\n    // layers array represents z-indexes from -maxLayer to maxLayer\n    return index + maxLayer;\n}\n\nactivateLayer(currentLayer);\n\ngridApi.setScale = function(newScale) {\n    scale = newScale;\n    gridX = new Point(scale, 0);\n    gridY = new Point(0, scale);\n};\n\ngridApi.setZoom = function(zoom) {\n    paper.view.zoom = zoom;\n};\n\ngridApi.zoomIn = function(amount) {\n    zoom = paper.view.zoom * (Math.pow(1.1, amount));\n    if (zoom &gt; 0.0001) {\n        paper.view.zoom = zoom;\n    }\n};\n\nfunction onMouseDrag(event) {\n    updateOffset(event.delta);\n}\n\n\nfunction onMouseUp(event) {\n    if (_respondToGridClicks) {\n        var x = getGridSquareX(event.point);\n        var y = getGridSquareY(event.point);\n        ASLEvent(\"JS_GridSquareClick\", x + \";\" + y);\n    }\n}\n\nfunction updateOffset(delta) {\n    setOffset(getOffset() + delta);\n    var paths;\n    if (project.activeLayer == customLayer) {\n        paths = customLayerPaths;\n    }\n    else {\n        paths = allPaths;\n    }\n    for (var i = 0; i &lt; paths.length; i++) {\n        paths[i].position += delta;\n    }\n    if (playerDestination &amp;&amp; project.activeLayer != customLayer) {\n        playerDestination += delta;\n    }\n}\n\nfunction getOffset() {\n    if (project.activeLayer == customLayer) {\n        return customLayerOffset;\n    }\n    return offset;\n}\n\nfunction setOffset(value) {\n    if (project.activeLayer == customLayer) {\n        customLayerOffset = value;\n    }\n    else {\n        offset = value;\n    }\n}\n\nfunction onFrame(event) {\n    if (playerVector) {\n        var distance = player.position - playerDestination;\n        if (distance.length &gt; playerVector.length) {\n            player.position += playerVector;\n        }\n        else {\n            player.position = playerDestination;\n            playerVector = null;\n            playerDestination = null;\n\n            var playerPositionAbsolute = player.position - offset;\n            offsetDestination = paper.view.center - playerPositionAbsolute;\n\n            offsetVector = (offsetDestination-offset) / 10;\n        }\n    }\n    if (offsetVector) {\n        var distance = offset - offsetDestination;\n        if (distance.length &gt; offsetVector.length) {\n            updateOffset(offsetVector);\n        }\n        else {\n            updateOffset(offsetDestination-offset);\n            offsetVector = null;\n            offsetDestination = null;\n        }\n    }\n}\n\ngridApi.drawGrid = function(minX, minY, maxX, maxY, border) {\n\n    function gridLine(start, end) {\n        var path = new Path();\n        path.strokeColor = border;\n        path.add(start, end);\n        addPathToCurrentLayerList(path);\n    }\n\n    // draw the vertical lines\n    for (var x = minX; x &lt;= maxX; x++) {\n        var start = gridPoint(x, minY);\n        var end = gridPoint(x, maxY);\n        gridLine(start, end);\n    }\n\n    // draw the horizontal lines\n    for (var y = minY; y &lt;= maxY; y++) {\n        var start = gridPoint(minX, y);\n        var end = gridPoint(maxX, y);\n        gridLine(start, end);\n    }\n};\n\nfunction gridPoint(x, y) {\n    return (gridX * x) + (gridY * y) + getOffset();\n}\n\nfunction getGridSquareX(point) {\n    return Math.floor(((point - getOffset()) / gridX).x);\n}\n\nfunction getGridSquareY(point) {\n    return Math.floor(((point - getOffset()) / gridY).y);\n}\n\nfunction gridPointNudge(x, y, nudgeX, nudgeY) {\n    var result = gridPoint(x, y);\n    result.x += nudgeX;\n    result.y += nudgeY;\n    return result;\n}\n\nvar firstBox = true;\n\ngridApi.drawBox = function(x, y, z, width, height, border, borderWidth, fill, sides) {\n    activateLayer(z);\n    // if this is the very first room, centre the canvas by updating the offset\n    if (firstBox) {\n        var centrePoint = gridPoint(x + width / 2, y + height / 2);\n        var offsetX = paper.view.center.x - centrePoint.x;\n        var offsetY = paper.view.center.y - centrePoint.y;\n        updateOffset(new Point(offsetX, offsetY));\n        firstBox = false;\n    }\n    var path = null;\n    var points = [gridPoint(x, y), gridPoint(x + width, y), gridPoint(x + width, y + height), gridPoint(x, y + height)];\n    // sides is encoded with bits to represent NESW\n    var draw = [sides &amp; 8, sides &amp; 4, sides &amp; 2, sides &amp; 1];\n    for (var i = 0; i &lt; 4; i++) {\n        var next = (i + 1) % 4;\n        if (draw[i]) {\n            if (path == null) {\n                path = new Path();\n                allPaths.push(path);\n                if (borderWidth &gt; 0) {\n                    path.strokeColor = border;\n                    path.strokeWidth = borderWidth;\n                }\n                path.add(points[i]);\n            }\n            path.add(points[next]);\n        } else {\n            path = null;\n        }\n    }\n    var fillPath;\n    if (sides == 15) {\n        fillPath = path;\n    } else {\n        fillPath = new Path();\n        fillPath.add(points[0], points[1], points[2], points[3]);\n        allPaths.push(fillPath);\n    }\n    fillPath.fillColor = fill;\n    fillPath.closed = true;\n};\n\ngridApi.drawLine = function(x1, y1, x2, y2, border, borderWidth) {\n    var path = new Path;\n    path.strokeColor = border;\n    path.strokeWidth = borderWidth;\n    path.add(gridPoint(x1, y1));\n    path.add(gridPoint(x2, y2));\n    addPathToCurrentLayerList(path);\n};\n\ngridApi.drawArrow = function (id, x1, y1, x2, y2, border, borderWidth) {\n    clearExistingObject(id);\n    \n    var linePath = new Path;\n    var start = gridPoint(x1, y1);\n    var end = gridPoint(x2, y2);\n    linePath.strokeColor = border;\n    linePath.strokeWidth = borderWidth;\n    linePath.add(start);\n    linePath.add(end);\n    addPathToCurrentLayerList(linePath);\n\n    var vector = end - start;\n    var arrowVector = vector.normalize(10);\n    var arrowheadPath = new Path([\n        end + arrowVector.rotate(150),\n        end,\n        end + arrowVector.rotate(-150)\n    ]);\n    arrowheadPath.strokeColor = border;\n    arrowheadPath.strokeWidth = borderWidth;\n    addPathToCurrentLayerList(arrowheadPath);\n\n    customLayerObjects[id] = [linePath, arrowheadPath];\n};\n\nfunction addPathToCurrentLayerList(path) {\n    if (project.activeLayer == customLayer) {\n        customLayerPaths.push(path);\n    }\n    else {\n        allPaths.push(path);\n    }\n}\n\ngridApi.drawPlayer = function(x, y, z, radius, border, borderWidth, fill) {\n    activateLayer(z);\n    if (!player) {\n        player = new Path.Circle(gridPoint(x, y), radius);\n        player.strokeColor = border;\n        player.strokeWidth = borderWidth;\n        player.fillColor = fill;\n        player.fillColor = fill;\n        allPaths.push(player);\n\n        var playerPositionAbsolute = player.position - offset;\n        var offsetDestinationX = paper.view.center.x - playerPositionAbsolute.x;\n        var offsetDestinationY = paper.view.center.y - playerPositionAbsolute.y;\n\n        offsetDestination = new Point(offsetDestinationX, offsetDestinationY);\n        offsetVector = (offsetDestination - offset);\n    } else {\n        playerDestination = gridPoint(x, y);\n        playerVector = (playerDestination - player.position) / 10;\n        // move player to the end of the activeLayer so it gets drawn on top\n        project.activeLayer.addChild(player);\n    }\n};\n\n \ngridApi.drawLabel = function(x, y, z, text, col) {\n    if (col === undefined) col = \"black\";\n    activateLayer(z);\n    var pointText = new PointText(gridPoint(x, y));\n    pointText.justification = \"center\";\n    pointText.fillColor = col;\n    pointText.content = text;\n    allPaths.push(pointText);\n};\n\nfunction showCustomLayer(visible) {\n    if (visible != customLayer.visible) {\n        customLayer.visible = visible;\n        for (var idx = 0; idx &lt; layers.length; idx++) {\n            layers[idx].visible = !visible;\n        }\n        if (visible) {\n            customLayer.activate();\n        }\n        else {\n            layers[getLayerIndex(currentLayer)].activate();\n        }\n    }\n}\n\ngridApi.showCustomLayer = function(visible) {\n    showCustomLayer(visible);\n};\n\ngridApi.clearCustomLayer = function() {\n    customLayer.removeChildren();\n};\n\ngridApi.clearAllLayers = function () {\n    player = null;\n    $.each(layers, function(idx, layer) {\n        layer.removeChildren();\n    });\n};\n\ngridApi.setCentre = function(x, y) {\n    var centrePoint = gridPoint(x, y);\n    var offsetX = paper.view.center.x - centrePoint.x;\n    var offsetY = paper.view.center.y - centrePoint.y;\n    var curOffset = getOffset();\n    updateOffset(new Point(offsetX, offsetY));\n};\n\ngridApi.drawCustomLayerSquare = function(id, x, y, width, height, text, fill) {\n    var points = [];\n    points.push(gridPointNudge(x, y, 1, 1));\n    points.push(gridPointNudge(x + width, y, -1, 1));\n    points.push(gridPointNudge(x + width, y + height, -1, -1));\n    points.push(gridPointNudge(x, y + height, 1, -1));\n\n    var textPoint = gridPoint(x + width / 2, y + height / 2);\n    gridApi.drawCustomLayerObject(id, points, text, textPoint, fill, fill);\n};\n\nfunction clearExistingObject(id) {\n    var existing = customLayerObjects[id];\n    if (existing) {\n        for (var idx in existing) {\n            var path = existing[idx];\n            // TO DO: Should remove path from layer and layerlist array\n            path.visible = false;\n        }\n    }\n}\n\ngridApi.drawCustomLayerObject = function (id, points, text, textPoint, border, fill, opacity) {\n    clearExistingObject(id);\n\n    var paths = new Array();\n    path = new Path();\n    path.strokeColor = border;\n    $.each(points, function(index, value) {\n        path.add(value);\n    });\n    path.fillColor = fill;\n    path.closed = true;\n    if (typeof opacity != \"undefined\") {\n        path.opacity = opacity;\n    }\n    addPathToCurrentLayerList(path);\n    paths.push(path);\n\n    if (text) {\n        var pointText = new PointText(textPoint);\n        pointText.justification = \"center\";\n        pointText.fillColor = \"black\";\n        pointText.content = text;\n        if (typeof opacity != \"undefined\") {\n            pointText.opacity = opacity;\n        }\n        addPathToCurrentLayerList(pointText);\n        paths.push(pointText);\n    }\n\n    customLayerObjects[id] = paths;\n};\n\ngridApi.loadSvg = function (data, id) {\n    var svg = paper.project.importSVG(data);\n    if (svg) {\n        symbols[id] = new Symbol(svg);\n    }\n};\n\ngridApi.drawCustomLayerSvg = function (id, symbolId, x, y, width, height) {\n    if (symbolId in symbols) {\n        var existing = customLayerSvg[id];\n        var placedSymbol = existing ? existing : symbols[symbolId].place();\n        placedSymbol.scale(gridX.x * width / placedSymbol.bounds.width, gridY.y * height / placedSymbol.bounds.height);\n        placedSymbol.position = gridPoint(x, y) + placedSymbol.bounds.size / 2;\n        if (!existing) addPathToCurrentLayerList(placedSymbol);\n        customLayerSvg[id] = placedSymbol;\n    } else {\n        console.log(\"No symbol loaded with id '\" + symbolId + \"'\");\n    }\n};\n\ngridApi.drawCustomLayerImage = function(id, url, x, y, width, height) {\n    var existing = customLayerImages[id];\n    var raster = existing ? existing : new Raster(url);\n    var resizeRaster = function() {\n        raster.scale(gridX.x * width / raster.bounds.width, gridY.y * height / raster.bounds.height);\n        raster.position = gridPoint(x, y) + raster.bounds.size / 2;\n    };\n    if (existing) {\n        resizeRaster();\n    } else {\n        raster.onLoad = resizeRaster;\n        addPathToCurrentLayerList(raster);\n        customLayerImages[id] = raster;\n    }    \n}\n\ngridApi.addNewShapePoint = function (x, y) {\n    newShapePoints.push([x, y]);\n};\n\ngridApi.drawShape = function (id, border, fill, opacity) {\n    var points = [];\n    for (var idx in newShapePoints) {\n        var xy = newShapePoints[idx];\n        points.push(gridPoint(xy[0], xy[1]));\n    }\n    gridApi.drawCustomLayerObject(id, points, null, null, border, fill, opacity);\n    newShapePoints = [];\n};\n\ngridApi.onLoad();\n\n\n</code></pre>\n</details>\n\n",
      "PostDate": "2023-10-12T22:02:53.7997177Z",
      "LastEditDate": "2023-10-30T02:28:12.1562928Z",
      "link": null
    },
    {
      "PostId": "05be97ae-81c5-4578-a686-2e18d9884ed3",
      "UserId": 599148,
      "Username": "DeepDredux",
      "AvatarUrl": "https://i.imgur.com/0MkvPpKb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "My above question still stands (and would resolve a great deal of headaches if I could figure it out), but in case it isn't possible after all, I've decided to try an alternative approach in the mean time. \r\n\r\nSince I've already worked out how to draw to the map grid manually with `paper.js` commands, I figure that might be good enough as long as I can manually \"mimic\" the existing grid behaviors as well:\r\n* zooming\r\n* dragging\r\n* moving rendered objects when player changes rooms \r\n\r\nAs mentioned before, zooming is working right out of the box, so that's good to go. To get dragging to work for my custom drawings like it does for the rest of the map, I tried the following javascript:\r\n```\r\n// Javascript\r\n// Draw a custom box to test dragging \r\n\r\nvar point = new paper.Point(20, 20);\r\nvar size = new paper.Size(60, 60);\r\nvar customShape = new paper.Shape.Rectangle(point, size);\r\ncustomShape.strokeColor = 'black'; \r\n\r\n// Dragging event handler... \r\n\r\npaper.project.view.onMouseDrag = function(event) {\r\n    customShape.position += event.delta;\r\n} \r\n\r\n``` \r\n\r\nAs far as I can tell, this _should_ be working (it works on the paper.js website perfectly), but for some reason it doesn't work when I run the Javascript in Quest... Anyone know why that might be the case?",
      "EditableFormat": "markdown",
      "HTML": "<p>My above question still stands (and would resolve a great deal of headaches if I could figure it out), but in case it isn't possible after all, I've decided to try an alternative approach in the mean time.</p>\n<p>Since I've already worked out how to draw to the map grid manually with <code>paper.js</code> commands, I figure that might be good enough as long as I can manually \"mimic\" the existing grid behaviors as well:</p>\n<ul>\n<li>zooming</li>\n<li>dragging</li>\n<li>moving rendered objects when player changes rooms</li>\n</ul>\n<p>As mentioned before, zooming is working right out of the box, so that's good to go. To get dragging to work for my custom drawings like it does for the rest of the map, I tried the following javascript:</p>\n<pre><code>// Javascript\n// Draw a custom box to test dragging \n\nvar point = new paper.Point(20, 20);\nvar size = new paper.Size(60, 60);\nvar customShape = new paper.Shape.Rectangle(point, size);\ncustomShape.strokeColor = 'black'; \n\n// Dragging event handler... \n\npaper.project.view.onMouseDrag = function(event) {\n&nbsp;&nbsp;&nbsp; customShape.position +=&nbsp;event.delta;\n} \n\n</code></pre>\n<p>As far as I can tell, this <em>should</em> be working (it works on the paper.js website perfectly), but for some reason it doesn't work when I run the Javascript in Quest... Anyone know why that might be the case?</p>\n\n",
      "PostDate": "2023-10-17T14:01:01.2361464Z",
      "LastEditDate": "2023-10-17T14:18:50.4741492Z",
      "link": null
    },
    {
      "PostId": "48fbfa43-a106-447d-b077-5121783eeb88",
      "UserId": 599148,
      "Username": "DeepDredux",
      "AvatarUrl": "https://i.imgur.com/0MkvPpKb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Never figured out how to directly reference the grid.js variables, but I DID figure out a way to use expanded paper.js functions to make unique shapes/animation in the map grid that ALSO follow the same rules as the other built-in grid-drawings (i.e. they will properly pan when the player moves, drags the map, zooms in and out, etc.). I even found a way to make custom shapes obey the z-layer (going see-through when the player changes level)!\r\n\r\nThe trick was to create a \"seed\" shape using the built-in Quest functionality so the Path would get logged in the internal grid.js functions. Then, after that seed shape is made, I can go in with Javascript to locate and modify that shape into whatever I want. Like so...\r\n```\r\n// In Quest...\r\n// Create reference path for javascript to find. \r\n// x and y are the desired origin of the shape, in Quest coordinates, though these can be changed later if you like. \r\n// The z coordinate is the level you want the shape to be on so it goes solid/see-through when the player moves up and down on the map.\r\n// IMPORTANT: I give the reference path a strokeColor of \"#010203\" and a fillColor of \"#030201\" so it can be found later by JS.drawCustomBlob. I chose these colors because they are unique enough to be unlikely to occur by accident.\r\nJS.Grid_DrawBox (x, y, z, 0, 0, \"#010203\", 1, \"#030201\", 15)\r\n// Call your own custom JS.drawCustomBlob function...\r\nJS.drawCustomBlob ()\r\n```\r\nThen, in Javascript, I have the following...\r\n```\r\n// In Javascript...\r\npaper.install(window);\r\n\r\n// 1 room unit in Quest grid = 30 units in paper.js. So scale=30...\r\nvar scale = 30;\r\n\r\nfunction findRefPath () {\r\n  // Finds and returns the reference path in the grid made by quest so it can be altered by custom functions\r\n  // Assumes customPath will have strokeColor of the unique color rgb(1,2,3) (HEX #010203) and fillColor of the unique color rgb(3,2,1) (HEX #030201)\r\n  var children = paper.project.activeLayer.children;\r\n  // Iterate through the items contained within the array:\r\n  for (var i = 0; i < children.length; i++) {\r\n    var child = children[i];\r\n    if (typeof child.strokeColor !== 'undefined' && typeof child.fillColor !== 'undefined') {\r\n      //console.log(\"index = \"+i.toString())\r\n      if (child.strokeColor !== null && child.fillColor !== null) {\r\n        if (child.strokeColor.toCSS()=='rgb(1,2,3)' && child.fillColor.toCSS()=='rgb(3,2,1)') {\r\n          child.strokeColor = null;\r\n          child.fillColor = null;\r\n           // To find refPath\r\n           var Index = i\r\n           //console.log (\"refPath Index (paper.project.activeLayer.children[i])=\"+Index.toString())\r\n           return Index\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // If not found within For loop, return error to console...\r\n  console.log (\"findRefPath() ERROR: Unable to find reference path of rgb(1,2,3)\");\r\n}\r\n\r\nfunction drawCustomBlob () {\r\n  // Find and remove CustomBlob from the grid if it already exists so new one can be drawn if Quest function called again\r\n  for (var i = 0; i < paper.project.layers.length; i++) {\r\n    if (typeof paper.project.layers[i].children['CustomBlob'] !== 'undefined') {\r\n      paper.project.layers[i].children['CustomBlob'].remove();\r\n    }\r\n  }\r\n  var refIndex = findRefPath();\r\n  var myPath = paper.project.activeLayer.children[refIndex]\r\n  // Use refPath point as origin\r\n  var originX = myPath.position.x;\r\n  var originY = myPath.position.y;\r\n  // Clear existing path data\r\n  myPath.removeSegments();\r\n  myPath.name = \"CustomBlob\";\r\n  //Top Right Curve\r\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, -6.0*scale+originY), null, new paper.Point(2.0*scale, 0*scale)));\r\n  myPath.add(new paper.Segment(new paper.Point(.5*scale+originX, -6.0*scale+originY), new paper.Point(0*scale, -2.0*scale), null));\r\n  //Bottom Right Curve\r\n  myPath.add(new paper.Segment(new paper.Point(.5*scale+originX, 4.5*scale+originY), null, new paper.Point(0*scale, 2.0*scale)));\r\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, 7.0*scale+originY), new paper.Point(2.0*scale, 0*scale), null));\r\n  //Bottom Left Curve\r\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, 7.0*scale+originY), null, new paper.Point(-1.5*scale, 0*scale)));\r\n  myPath.add(new paper.Segment(new paper.Point(-9.0*scale+originX, 4.5*scale+originY), new paper.Point(0*scale, 1.5*scale), null));\r\n  //Top Left Curve\r\n  myPath.add(new paper.Segment(new paper.Point(-9.0*scale+originX, -3.0*scale+originY), null, new paper.Point(0*scale, -1.5*scale)));\r\n  myPath.add(new paper.Segment(new paper.Point(-6.0*scale+originX, -6.0*scale+originY), new paper.Point(-1.5*scale, 0*scale), null));\r\n  myPath.closed = true;\r\n\r\n  myPath.fillColor = 'yellow';\r\n  myPath.strokeColor = 'black';\r\n  myPath.strokeWidth = 1;\r\n  myPath.opacity = 1.0;\r\n}\r\n```\r\n\r\nYou can do this to make any shape you want in the map grid using the Javascript functions defined by `paper.js`. References and tutorials for paper.js functions can be found here: [http://paperjs.org/tutorials/](http://paperjs.org/tutorials/). Keep in mind the `paper.js` version built-in to Quest 5.8 is pretty old (v0.9.12) compared to the latest version on the paper.js website, so not all functions will work, but I've so far found that most have worked for my needs.\r\n\r\nHopefully someone else finds this useful too",
      "EditableFormat": "markdown",
      "HTML": "<p>Never figured out how to directly reference the grid.js variables, but I DID figure out a way to use expanded paper.js functions to make unique shapes/animation in the map grid that ALSO follow the same rules as the other built-in grid-drawings (i.e. they will properly pan when the player moves, drags the map, zooms in and out, etc.). I even found a way to make custom shapes obey the z-layer (going see-through when the player changes level)!</p>\n<p>The trick was to create a \"seed\" shape using the built-in Quest functionality so the Path would get logged in the internal grid.js functions. Then, after that seed shape is made, I can go in with Javascript to locate and modify that shape into whatever I want. Like so...</p>\n<pre><code>// In Quest...\n// Create reference path for javascript to find. \n// x and y are the desired origin of the shape, in Quest coordinates, though these can be changed later if you like. \n// The z coordinate is the level you want the shape to be on so it goes solid/see-through when the player moves up and down on the map.\n// IMPORTANT: I give the reference path a strokeColor of \"#010203\" and a fillColor of \"#030201\" so it can be found later by JS.drawCustomBlob. I chose these colors because they are unique enough to be unlikely to occur by accident.\nJS.Grid_DrawBox (x, y, z, 0, 0, \"#010203\", 1, \"#030201\", 15)\n// Call your own custom JS.drawCustomBlob function...\nJS.drawCustomBlob ()\n</code></pre>\n<p>Then, in Javascript, I have the following...</p>\n<pre><code>// In Javascript...\npaper.install(window);\n\n// 1 room unit in Quest grid = 30 units in paper.js. So scale=30...\nvar scale = 30;\n\nfunction findRefPath () {\n  // Finds and returns the reference path in the grid made by quest so it can be altered by custom functions\n  // Assumes customPath will have strokeColor of the unique color rgb(1,2,3) (HEX #010203) and fillColor of the unique color rgb(3,2,1) (HEX #030201)\n  var children = paper.project.activeLayer.children;\n  // Iterate through the items contained within the array:\n  for (var i = 0; i &lt; children.length; i++) {\n    var child = children[i];\n    if (typeof child.strokeColor !== 'undefined' &amp;&amp; typeof child.fillColor !== 'undefined') {\n      //console.log(\"index = \"+i.toString())\n      if (child.strokeColor !== null &amp;&amp; child.fillColor !== null) {\n        if (child.strokeColor.toCSS()=='rgb(1,2,3)' &amp;&amp; child.fillColor.toCSS()=='rgb(3,2,1)') {\n          child.strokeColor = null;\n          child.fillColor = null;\n           // To find refPath\n           var Index = i\n           //console.log (\"refPath Index (paper.project.activeLayer.children[i])=\"+Index.toString())\n           return Index\n        }\n      }\n    }\n  }\n  // If not found within For loop, return error to console...\n  console.log (\"findRefPath() ERROR: Unable to find reference path of rgb(1,2,3)\");\n}\n\nfunction drawCustomBlob () {\n  // Find and remove CustomBlob from the grid if it already exists so new one can be drawn if Quest function called again\n  for (var i = 0; i &lt; paper.project.layers.length; i++) {\n    if (typeof paper.project.layers[i].children['CustomBlob'] !== 'undefined') {\n      paper.project.layers[i].children['CustomBlob'].remove();\n    }\n  }\n  var refIndex = findRefPath();\n  var myPath = paper.project.activeLayer.children[refIndex]\n  // Use refPath point as origin\n  var originX = myPath.position.x;\n  var originY = myPath.position.y;\n  // Clear existing path data\n  myPath.removeSegments();\n  myPath.name = \"CustomBlob\";\n  //Top Right Curve\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, -6.0*scale+originY), null, new paper.Point(2.0*scale, 0*scale)));\n  myPath.add(new paper.Segment(new paper.Point(.5*scale+originX, -6.0*scale+originY), new paper.Point(0*scale, -2.0*scale), null));\n  //Bottom Right Curve\n  myPath.add(new paper.Segment(new paper.Point(.5*scale+originX, 4.5*scale+originY), null, new paper.Point(0*scale, 2.0*scale)));\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, 7.0*scale+originY), new paper.Point(2.0*scale, 0*scale), null));\n  //Bottom Left Curve\n  myPath.add(new paper.Segment(new paper.Point(-4.0*scale+originX, 7.0*scale+originY), null, new paper.Point(-1.5*scale, 0*scale)));\n  myPath.add(new paper.Segment(new paper.Point(-9.0*scale+originX, 4.5*scale+originY), new paper.Point(0*scale, 1.5*scale), null));\n  //Top Left Curve\n  myPath.add(new paper.Segment(new paper.Point(-9.0*scale+originX, -3.0*scale+originY), null, new paper.Point(0*scale, -1.5*scale)));\n  myPath.add(new paper.Segment(new paper.Point(-6.0*scale+originX, -6.0*scale+originY), new paper.Point(-1.5*scale, 0*scale), null));\n  myPath.closed = true;\n\n  myPath.fillColor = 'yellow';\n  myPath.strokeColor = 'black';\n  myPath.strokeWidth = 1;\n  myPath.opacity = 1.0;\n}\n</code></pre>\n<p>You can do this to make any shape you want in the map grid using the Javascript functions defined by <code>paper.js</code>. References and tutorials for paper.js functions can be found here: <a href=\"http://paperjs.org/tutorials/\">http://paperjs.org/tutorials/</a>. Keep in mind the <code>paper.js</code> version built-in to Quest 5.8 is pretty old (v0.9.12) compared to the latest version on the paper.js website, so not all functions will work, but I've so far found that most have worked for my needs.</p>\n<p>Hopefully someone else finds this useful too</p>\n\n",
      "PostDate": "2023-10-30T02:27:12.6624668Z",
      "LastEditDate": "2023-10-30T02:36:58.4929372Z",
      "link": null
    }
  ]
}
