{
  "Topic": {
    "TopicId": "3671",
    "ForumId": "18",
    "Title": "Closure Library",
    "LastUpdated": "2013-05-08T09:28:11+01:00",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "24485",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Pseudo-closure library\n  \n(Note: This library might not be useful to many,  but if you can use it, then it can be really useful. And this has to do with function closures, not container objects! There isn't much code in this - the comments take up more lines, but it's straightforward and it works.)\n\n(Second note: This library requires Quest 5.4.1, since it uses the [ ] notation for accessing lists, which was broken before that revision. If you need a version pre-5.4.1, please let me know.)\n\n  == Overview ==\n  \n  This library supports a sort of &quot;pseudo-closure&quot; - a single entity that references\n  not only a script to be run but also variables to be available to that script when\n  run. It supports both standalone scripts as well as script attributes on objects.\n  It's not automatic like with Javascript, but it can still be very useful.\n  \n  A simple example:\n  \n  closure = Closure_Create(player, &quot;OnBattleComplete&quot;)\n  Closure_AddParameter(closure, &quot;enemy&quot;, enemy)\n  \n  Then at some point in time, by invoking:\n  \n  Closure_Call(closure)\n  \n  the script attribute &quot;OnBattleComplete&quot; of object &quot;player&quot; will be called with\n  parameter &quot;enemy&quot; set to the value of the variable enemy at the time it was added.\n  \n  This class can also be used as an alternative syntax for invoking a script with parameters.\n\n  == Usage ==\n  \n  To create a closure, call &quot;Closure_Create&quot;. This function takes an object\n  parameter and a script parameter. It has form:\n  \n  closure = Closure_Create(object, script)\n  \n  There are two ways to invoke this function:\n  \n  1) To &quot;do&quot; the script attribute of an object, pass the desired object as &quot;object&quot;\n  and the script attrubute *name* as the script parameter. This is the standard method.\n  \n  2) To &quot;invoke&quot; a standalone script, pass null for the object and the actual script\n  body for &quot;script&quot;. (Note that since Closure_Create will be called in the context\n  of an expression, you can't use the trailing { script } form of parameter passing.)\n  \n  Once the closure has been created, you may optionally add parameters/variables to be\n  available to the script when it's run. To do so, use the Closure_AddParameter method:\n  \n  Closure_AddParameter(closure, name, value)\n  \n  This will make the variable &quot;name&quot; with value &quot;value&quot; available to the script embodied\n  by the closure &quot;closure&quot; when it is called.\n  \n  At this point, you now have a single variable which can be passed around which encapsulates:\n  - A script to be called\n  - An object to call it on (if desired)\n  - Variables to be available when run (if desired)\n  \n  The closure will exist until all references to it are gone. It may be stored in a variable,\n  passed to functions, or stored in an object attribute.\n  \n  To invoke a closure, simply call Closure_Call, passing the desired closure as the sole parameter:\n  \n  Closure_Call(closure)\n  \n  The contained script will be called, with any previously set parameters available.\n\n  A closure may be called as many times as desired.",
      "EditableFormat": "bbcode",
      "HTML": "Pseudo-closure library<br/>  <br/>(Note: This library might not be useful to many,  but if you can use it, then it can be really useful. And this has to do with function closures, not container objects! There isn't much code in this - the comments take up more lines, but it's straightforward and it works.)<br/><br/>(Second note: This library requires Quest 5.4.1, since it uses the [ ] notation for accessing lists, which was broken before that revision. If you need a version pre-5.4.1, please let me know.)<br/><br/>  == Overview ==<br/>  <br/>  This library supports a sort of &quot;pseudo-closure&quot; - a single entity that references<br/>  not only a script to be run but also variables to be available to that script when<br/>  run. It supports both standalone scripts as well as script attributes on objects.<br/>  It's not automatic like with Javascript, but it can still be very useful.<br/>  <br/>  A simple example:<br/>  <br/>  closure = Closure_Create(player, &quot;OnBattleComplete&quot;)<br/>  Closure_AddParameter(closure, &quot;enemy&quot;, enemy)<br/>  <br/>  Then at some point in time, by invoking:<br/>  <br/>  Closure_Call(closure)<br/>  <br/>  the script attribute &quot;OnBattleComplete&quot; of object &quot;player&quot; will be called with<br/>  parameter &quot;enemy&quot; set to the value of the variable enemy at the time it was added.<br/>  <br/>  This class can also be used as an alternative syntax for invoking a script with parameters.<br/><br/>  == Usage ==<br/>  <br/>  To create a closure, call &quot;Closure_Create&quot;. This function takes an object<br/>  parameter and a script parameter. It has form:<br/>  <br/>  closure = Closure_Create(object, script)<br/>  <br/>  There are two ways to invoke this function:<br/>  <br/>  1) To &quot;do&quot; the script attribute of an object, pass the desired object as &quot;object&quot;<br/>  and the script attrubute *name* as the script parameter. This is the standard method.<br/>  <br/>  2) To &quot;invoke&quot; a standalone script, pass null for the object and the actual script<br/>  body for &quot;script&quot;. (Note that since Closure_Create will be called in the context<br/>  of an expression, you can't use the trailing { script } form of parameter passing.)<br/>  <br/>  Once the closure has been created, you may optionally add parameters/variables to be<br/>  available to the script when it's run. To do so, use the Closure_AddParameter method:<br/>  <br/>  Closure_AddParameter(closure, name, value)<br/>  <br/>  This will make the variable &quot;name&quot; with value &quot;value&quot; available to the script embodied<br/>  by the closure &quot;closure&quot; when it is called.<br/>  <br/>  At this point, you now have a single variable which can be passed around which encapsulates:<br/>  - A script to be called<br/>  - An object to call it on (if desired)<br/>  - Variables to be available when run (if desired)<br/>  <br/>  The closure will exist until all references to it are gone. It may be stored in a variable,<br/>  passed to functions, or stored in an object attribute.<br/>  <br/>  To invoke a closure, simply call Closure_Call, passing the desired closure as the sole parameter:<br/>  <br/>  Closure_Call(closure)<br/>  <br/>  The contained script will be called, with any previously set parameters available.<br/><br/>  A closure may be called as many times as desired.<div><a href=\"/attachment/609\">Closure.aslx</a></div>",
      "PostDate": "2013-05-08T09:28:11+01:00",
      "LastEditDate": null
    }
  ]
}
