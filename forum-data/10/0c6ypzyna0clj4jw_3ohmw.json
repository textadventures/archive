{
  "Topic": {
    "TopicId": "0c6ypzyna0clj4jw_3ohmw",
    "ForumId": "10",
    "Title": "A Way To Save/Load Between Versions on Desktop or Online: SaveLoadCodes",
    "LastUpdated": "2022-03-07T05:45:27.4748492Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "12cad87d-36e3-42b5-9e4b-127a956cd0e3",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/6db113b483dd96ac77a9389513efab6b?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hello everyone! \r\n\r\nBeen a big fan of text adventure games for a while, but just recently decided to try my hand at making one of my own! One of the things I wanted to be able to do with my game was give the player the ability to save their game and resume playing even on a future version of the game.\r\n\r\nI considered using the SaveLoad library created by Pix (<a href=\"https://github.com/ThePix/quest/wiki/Library:-Save-and-Load\">https://github.com/ThePix/quest/wiki/Library:-Save-and-Load</a>), but unfortunately some of its limitations didn't quite work for what I had in mind. In particular, I wanted the player to be able to save their game to an actual file that could then be loaded on either the online player or desktop player. The solution I came up with was a copy/pastable code that could then be saved locally, but you may prefer Pix's cleaner in-game save/load menu solution. Additionally, I wanted to be able to change the player object (game.pov) mid-game, which is unfortunately a limitation of Pix's library. \r\n\r\nBesides that, one of the primary differences between Pix's SaveLoad library and mine is that their library saves objects explicitly, rather than procedurally, which allows the author to ensure they're ONLY saving the attributes they want to in exchange for some extra legwork. My library, on the other hand, grabs everything it can, then excludes the attributes you don't want. This means that although my library is (theoretically) easier to integrate into existing games, extra care may be required to ensure you're saving all the attributes you truly want to (especially when it comes to ensuring compatibility between saves). I highly recommend checking out Pix's library as well as mine, as both have their merits!\r\n\r\nThis may be something that others have already encountered and come up with solutions for, but I wasn't able to find any concrete examples in my online or forum searches, so I figured I would share my solution here in case others would like to use it as well!\r\n\r\nWhat I came up with is a system to save and load the player's game by creating a <b>SaveGameCode</b> function that collects nearly every attribute in the player's game, as well as a <b>LoadGameCode</b> function that parses out the saved code to update any changed attributes. Paired with some javascript to add a popup UI for the functions as well as base64 encoding (to limit the player's ability to directly edit savegames), I tried to keep everything as modular as possible, with self-explanatory comments, so others could use it too.\r\n\r\n## What do these functions do?\r\nThese functions allow you to save your game in the form of a base64-encoded code. This code can be saved locally, then copied into the load function to allow the player to load their game. \r\n\r\nWhat this means is that players can play the game online, save their progress to a save code, then load and resume that progress on a desktop version of the same game, or vice-versa. This also means that saves can be stored SEPARATELY from the rest of the Quest game, potentially allowing a player to continue their old save even on a new version of the game (provided you, as the author, account for that, but more on that in the wiki). Furthermore, loading a save code is typically MUCH faster than loading a traditional Quest 5.8 save, as traditional Quest saves save the ENTIRE game each time (and thus require you to load the entire game each time).\r\n\r\n### The _SaveGameCode_ function\r\nI encourage you to look at the source code to learn more, but at a high level the SaveGameCode function works by parsing through all objects, exits, and turnscripts in the game to save as many changeable attributes as possible in the form of a long 'SaveString'. There are some limitations to this (see the 'Limitations' section in the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a>), but for most applications the SaveString that is created is enough to completely recreate the player's game state when fed back in to the LoadGameCode function. And all of this happens more or less ***automatically*** after installing the functions and javascript, so it can potentially be added on to nearly any existing game (barring limitations)!\r\n\r\n### The _LoadGameCode_ function\r\nYou probably can guess, but the _LoadGameCode_ function is responsible for parsing a given SaveString created by the SaveGameCode function, converting it back into usable object and attribute data, and updating the corresponding attributes in the game to recreate the player's saved state. There's a bit more to it, but that's the high-level explanation. To learn more, I again highly recommend checking out the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> and/or source code!\r\n\r\n### The _SaveLoadJavaCode.js_ javascript\r\nIn addition to those two functions, I also included some additional javascript functions for converting the savecode to/from Base64 encoding (to make it a little harder to 'cheat' by editing your save state), as well as provide a nice UI for presenting the savecode and a nice UI for the player to paste existing savecodes into.\r\n\r\n### **New v3.0 Functions:**\r\n<details>\r\n\r\n### The _SaveCheckpoints_ function\r\nSaveCheckpoint works very similarly to SaveGameCode, except instead of saving the SaveString to present it to the player, it instead will save a SaveString to a game.checkpoints stringdictionary. If game.checkpoints does not exist when SaveCheckpoints is called, then it will create it.\r\n\r\nThis is useful for saving checkpoints internally that can then be loaded internally using the LoadCheckpoint function.\r\n\r\nSee the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> for more details.\r\n\r\n### The _LoadCheckpoint_ function\r\nLoadCheckpoint works very similarly to LoadGameCode, except it will not print any messages and it will not overwrite existing checkpoint data. It will also only load existing checkpoints. If it cannot find a matching checkpoint in game.checkpoints, it will throw an error.\r\n\r\nUseful for loading internally-created checkpoints (i.e. after a \"you have died! Would you like to reload before you died?\" type screen, for instance).\r\n\r\n### The _GetSaveGameCodeDelims_ function\r\nGetSaveGameCodeDelims() returns a stringlist of the delimiters used by the SaveGameCode function.\r\n\r\nUseful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveGameCode contain a banned delimiter, the game will not save/load properly.\r\n\r\n### The _GetSaveCheckpointDelims_ function\r\nGetSaveCheckpointDelims() returns a stringlist of the delimiters used by the SaveCheckpoint function.\r\n\r\nUseful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveCheckpoint contain a banned delimiter, the game will not save/load checkpoints properly.\r\n</details>\r\n\r\n<hr>\r\nI've now completed the wiki page for these functions. Check it out if you're interested, as it goes into great detail regarding how to use these functions in your game, their limitations, workarounds, etc: <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>\r\n\r\nI also created a small test game to show off the functionality here: <a href=\"http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/\">http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/</a>\r\n\r\nI've also set up a git repository with these functions and commands drawn up in a library, 'SaveLoadCodeFunctionsLibrary.aslx', and the required javascript, 'SaveLoadJavaCode.js', here: <a href=\"https://github.com/Leviathon44/SaveLoadCode\">https://github.com/Leviathon44/SaveLoadCode</a>.\r\n\r\nThe code is also posted farther down in this post, if you'd rather scroll than click the link.\r\n\r\nSpecial thanks to KV, mrangel, and Pix! I never spoke to any of you directly, but your forum posts and functions over the years were a valuable resource in getting this made! I hope others find this useful!\r\n<hr>\r\n<h3>The SaveGameCode and LoadGameCode functions require the following javascript, 'SaveLoadJavaCode.js':</h3>\r\n<details>\r\n\r\n(Disclaimer: I am not super familiar to javascript, so I apologize if it's not as clean as it could be)\r\n\r\n```javascript\r\n//Converts Strings to Base64 for the SaveGame code functionality\r\nfunction showPopupSave(text) {\r\n    try {\r\n\t//Original Popup Function Courtesy of KV. Altered slightly for our specific save code popup.\r\n\t$('#msgboxCaption').html(text);\r\n\r\n    var msgboxOptions = {\r\n        modal: true,\r\n        autoOpen: false,\r\n        title: \"Save Game Code\",\r\n        width: \"650px\",\r\n        height: \"auto\",\r\n        buttons: [\r\n\t\t\t{\r\n\t\t\t    text: 'Copy To Clipboard',\r\n\t\t\t    //click: function () { $(this).dialog('close'); }\r\n\t\t\t\tclick: function () {  \r\n\t\t\t\t\t// Select the SaveCode text  \r\n\t\t\t\t\tvar SaveCode = document.querySelector('#msgboxCaption');  \r\n\t\t\t\t\tvar range = document.createRange();  \r\n\t\t\t\t\trange.selectNode(SaveCode);  \r\n\t\t\t\t\twindow.getSelection().addRange(range);  \r\n\r\n\t\t\t\t\ttry {  \r\n\t\t\t\t\t\t// Execute the copy command on selected text\r\n\t\t\t\t\t\tvar successful = document.execCommand('copy');  \r\n\t\t\t\t\t\t//var msg = successful ? 'successful' : 'unsuccessful';  \r\n\t\t\t\t\t\t//console.log('Copy email command was ' + msg);  \r\n\t\t\t\t\t} \t\t\t\t\t\r\n\t\t\t\t\tcatch(err) {  \r\n\t\t\t\t\t//console.log('Oops, unable to copy');  \r\n\t\t\t\t\t}  \r\n\r\n\t\t\t\t\t// Remove the selections \r\n\t\t\t\t\twindow.getSelection().removeAllRanges();  \r\n}\r\n\t\t\t},\r\n        ],\r\n        closeOnEscape: false,\r\n    };\r\n\r\n    $('#msgbox').dialog(msgboxOptions);\r\n    $('#msgbox').dialog('open');\r\n\t}\r\n\tcatch(err) {\r\n\t\tASLEvent(\"Log\", err);\r\n\t}\r\n};\r\n\r\nfunction ConvertToBase64(string) {\r\n  if (string != null && string != \"\") {\r\n\t  try {\r\n\t    conversion = btoa(string)\r\n\t  }\r\n\t  catch(err) {\r\n\t\tconversion = \"Error: \"+err\r\n\t  }\r\n\t  finally {\r\n        return conversion;\r\n\t\t//ASLEvent(\"Log\", conversion);\t//For Debugging\r\n\t  }\r\n  }\r\n}\r\n\r\nfunction ConvertFromBase64(string) {\r\n\tif (string != null && string != \"\") {\r\n      try {\r\n\t    conversion = atob(string)\r\n\t  }\r\n\t  catch(err) {\r\n\t\tconversion = \"Error: \"+err\r\n\t  }\r\n\t  finally {\r\n        return conversion;\r\n\t\t//ASLEvent(\"Log\", conversion);\t//For Debugging\r\n\t  }\r\n    }\r\n}\r\n\r\nfunction CreateSaveCode(string) {\r\n\t//Convert the saved attribute data to Base64 to make it harder for the player to manually alter\r\n\t//converted = ConvertToBase64(string);\r\n\tconverted = compressToBase64(string)\r\n\t//Post the created Save Code to the player for them to copy and save\r\n\tshowPopupSave(converted);\r\n}\r\n\r\nfunction LoadSaveCode(LoadCode) {\r\n\t//Check if loaded code is encoded in Base64. The SaveGame() code has game.gameid as it's first parameter, so if first 4 characters are \"game\", assume it hasn't been encoded.\r\n\tfirst4char = LoadCode.substring(0, 4);\r\n\tif (first4char == \"game\") {\r\n\t\tvar P = LoadCode\r\n\t}\r\n\telse {\r\n\t\t//var P = ConvertFromBase64(LoadCode)\r\n\t\tvar P = decompressFromBase64(LoadCode)\r\n\t}\r\n\t//Send the loadcode back to the LoadGame() function in Quest\r\n\tASLEvent(\"LoadGameCode\", P);\r\n}\r\n\r\nfunction LoadGamePrompt() {\r\n\t$('#msgboxCaption').html(\"<form id='LoadCodeForm'><textarea id='LoadCodeBox' cols='55' rows='11' style='overflow:auto;max-width:100%'></textarea></form>\");\r\n\r\n    var msgboxOptions = {\r\n        modal: true,\r\n        autoOpen: false,\r\n        title: \"Paste SaveCode to Load\",\r\n\t\twidth: \"650px\",\r\n        buttons: [\r\n\t\t\t{\r\n\t\t\t    text: 'Load Saved Game',\r\n\t\t\t\tclick: function () {  \r\n\t\t\t\t\t// On click, retrieve the pasted load code from the textbox   \r\n\t\t\t\t\tvar LoadCode = $(\"#LoadCodeBox\").val();\r\n\t\t\t\t\tif (LoadCode != null && LoadCode != \"\") {\r\n\t\t\t\t\t  $(this).dialog('close');\r\n\t\t\t\t\t  //document.getElementById(\"#LoadCodeForm\").submit();\r\n\t\t\t\t\t  //var LoadCode = document.getElementById('#LoadCodeBox').value;\r\n\t\t\t\t\t  LoadSaveCode(LoadCode);\r\n\t\t\t\t\t}\r\n}\r\n\t\t\t},\r\n        ],\r\n        closeOnEscape: false,\r\n    };\r\n\r\n    $('#msgbox').dialog(msgboxOptions);\r\n    $('#msgbox').dialog('open');\r\n};\r\n\r\n\r\n// The below is adapted from Pieroxy's LZ-string javascript library. An excerpt from LZ-string was pulled in and adapted to allow for string compression to cut down on the length of the savecode (especially when the savecode contains multiple checkpoints)...\r\n\r\n// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\r\n// This work is free. You can redistribute it and/or modify it\r\n// under the terms of the WTFPL, Version 2\r\n// For more information see LICENSE.txt or http://www.wtfpl.net/\r\n//\r\n// For more information, the home page:\r\n// http://pieroxy.net/blog/pages/lz-string/testing.html\r\n//\r\n// LZ-based compression algorithm, version 1.4.4\r\n\r\nfunction getBaseValue(alphabet, character) {\r\n  var f = String.fromCharCode;\r\n  var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n  var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\n  var baseReverseDic = {};\r\n  if (!baseReverseDic[alphabet]) {\r\n    baseReverseDic[alphabet] = {};\r\n    for (var i=0 ; i<alphabet.length ; i++) {\r\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\r\n    }\r\n  }\r\n  return baseReverseDic[alphabet][character];\r\n}\r\n\r\nfunction compressToBase64(input) {\r\n    try {\r\n\t  var f = String.fromCharCode;\r\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\n      var baseReverseDic = {};\r\n      if (input == null) return \"\";\r\n      var res = _compress(input, 6, function(a){return keyStrBase64.charAt(a);});\r\n      switch (res.length % 4) { // To produce valid Base64\r\n      default: // When could this happen ?\r\n      case 0 : return res;\r\n      case 1 : return res+\"===\";\r\n      case 2 : return res+\"==\";\r\n      case 3 : return res+\"=\";\r\n      }\r\n    }\r\n\tcatch(err) {\r\n\treturn \"Error: \"+err;\r\n\t}\r\n}\r\n\r\nfunction decompressFromBase64(input) {\r\n    try {\r\n\t  var f = String.fromCharCode;\r\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\n      var baseReverseDic = {};\r\n      if (input == null) return \"\";\r\n      if (input == \"\") return null;\r\n      return _decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\r\n    }\r\n\tcatch(err) {\r\n\t  return \"Error: \"+err;\r\n\t}\r\n}\r\n\r\nfunction compress(uncompressed) {\r\n    return _compress(uncompressed, 16, function(a){return f(a);});\r\n}\r\n   \r\nfunction _compress(uncompressed, bitsPerChar, getCharFromInt) {\r\n  try {\r\n\tvar f = String.fromCharCode;\r\n    var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n    var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\n    var baseReverseDic = {};\r\n    if (uncompressed == null) return \"\";\r\n    var i, value,\r\n        context_dictionary= {},\r\n        context_dictionaryToCreate= {},\r\n        context_c=\"\",\r\n        context_wc=\"\",\r\n        context_w=\"\",\r\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\r\n        context_dictSize= 3,\r\n        context_numBits= 2,\r\n        context_data=[],\r\n        context_data_val=0,\r\n        context_data_position=0,\r\n        ii;\r\n\r\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\r\n      context_c = uncompressed.charAt(ii);\r\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\r\n        context_dictionary[context_c] = context_dictSize++;\r\n        context_dictionaryToCreate[context_c] = true;\r\n      }\r\n\r\n      context_wc = context_w + context_c;\r\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\r\n        context_w = context_wc;\r\n      } else {\r\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\r\n          if (context_w.charCodeAt(0)<256) {\r\n            for (i=0 ; i<context_numBits ; i++) {\r\n              context_data_val = (context_data_val << 1);\r\n              if (context_data_position == bitsPerChar-1) {\r\n                context_data_position = 0;\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                context_data_val = 0;\r\n              } else {\r\n                context_data_position++;\r\n              }\r\n            }\r\n            value = context_w.charCodeAt(0);\r\n            for (i=0 ; i<8 ; i++) {\r\n              context_data_val = (context_data_val << 1) | (value&1);\r\n              if (context_data_position == bitsPerChar-1) {\r\n                context_data_position = 0;\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                context_data_val = 0;\r\n              } else {\r\n                context_data_position++;\r\n              }\r\n              value = value >> 1;\r\n            }\r\n          } else {\r\n            value = 1;\r\n            for (i=0 ; i<context_numBits ; i++) {\r\n              context_data_val = (context_data_val << 1) | value;\r\n              if (context_data_position ==bitsPerChar-1) {\r\n                context_data_position = 0;\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                context_data_val = 0;\r\n              } else {\r\n                context_data_position++;\r\n              }\r\n              value = 0;\r\n            }\r\n            value = context_w.charCodeAt(0);\r\n            for (i=0 ; i<16 ; i++) {\r\n              context_data_val = (context_data_val << 1) | (value&1);\r\n              if (context_data_position == bitsPerChar-1) {\r\n                context_data_position = 0;\r\n                context_data.push(getCharFromInt(context_data_val));\r\n                context_data_val = 0;\r\n              } else {\r\n                context_data_position++;\r\n              }\r\n              value = value >> 1;\r\n            }\r\n          }\r\n          context_enlargeIn--;\r\n          if (context_enlargeIn == 0) {\r\n            context_enlargeIn = Math.pow(2, context_numBits);\r\n            context_numBits++;\r\n          }\r\n          delete context_dictionaryToCreate[context_w];\r\n        } else {\r\n          value = context_dictionary[context_w];\r\n          for (i=0 ; i<context_numBits ; i++) {\r\n            context_data_val = (context_data_val << 1) | (value&1);\r\n            if (context_data_position == bitsPerChar-1) {\r\n              context_data_position = 0;\r\n              context_data.push(getCharFromInt(context_data_val));\r\n              context_data_val = 0;\r\n            } else {\r\n              context_data_position++;\r\n            }\r\n            value = value >> 1;\r\n          }\r\n\r\n\r\n        }\r\n        context_enlargeIn--;\r\n        if (context_enlargeIn == 0) {\r\n          context_enlargeIn = Math.pow(2, context_numBits);\r\n          context_numBits++;\r\n        }\r\n        // Add wc to the dictionary.\r\n        context_dictionary[context_wc] = context_dictSize++;\r\n        context_w = String(context_c);\r\n      }\r\n    }\r\n\r\n    // Output the code for w.\r\n    if (context_w !== \"\") {\r\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\r\n        if (context_w.charCodeAt(0)<256) {\r\n          for (i=0 ; i<context_numBits ; i++) {\r\n            context_data_val = (context_data_val << 1);\r\n            if (context_data_position == bitsPerChar-1) {\r\n              context_data_position = 0;\r\n              context_data.push(getCharFromInt(context_data_val));\r\n              context_data_val = 0;\r\n            } else {\r\n              context_data_position++;\r\n            }\r\n          }\r\n          value = context_w.charCodeAt(0);\r\n          for (i=0 ; i<8 ; i++) {\r\n            context_data_val = (context_data_val << 1) | (value&1);\r\n            if (context_data_position == bitsPerChar-1) {\r\n              context_data_position = 0;\r\n              context_data.push(getCharFromInt(context_data_val));\r\n              context_data_val = 0;\r\n            } else {\r\n              context_data_position++;\r\n            }\r\n            value = value >> 1;\r\n          }\r\n        } else {\r\n          value = 1;\r\n          for (i=0 ; i<context_numBits ; i++) {\r\n            context_data_val = (context_data_val << 1) | value;\r\n            if (context_data_position == bitsPerChar-1) {\r\n              context_data_position = 0;\r\n              context_data.push(getCharFromInt(context_data_val));\r\n              context_data_val = 0;\r\n            } else {\r\n              context_data_position++;\r\n            }\r\n            value = 0;\r\n          }\r\n          value = context_w.charCodeAt(0);\r\n          for (i=0 ; i<16 ; i++) {\r\n            context_data_val = (context_data_val << 1) | (value&1);\r\n            if (context_data_position == bitsPerChar-1) {\r\n              context_data_position = 0;\r\n              context_data.push(getCharFromInt(context_data_val));\r\n              context_data_val = 0;\r\n            } else {\r\n              context_data_position++;\r\n            }\r\n            value = value >> 1;\r\n          }\r\n        }\r\n        context_enlargeIn--;\r\n        if (context_enlargeIn == 0) {\r\n          context_enlargeIn = Math.pow(2, context_numBits);\r\n          context_numBits++;\r\n        }\r\n        delete context_dictionaryToCreate[context_w];\r\n      } else {\r\n        value = context_dictionary[context_w];\r\n        for (i=0 ; i<context_numBits ; i++) {\r\n          context_data_val = (context_data_val << 1) | (value&1);\r\n          if (context_data_position == bitsPerChar-1) {\r\n            context_data_position = 0;\r\n            context_data.push(getCharFromInt(context_data_val));\r\n            context_data_val = 0;\r\n          } else {\r\n            context_data_position++;\r\n          }\r\n          value = value >> 1;\r\n        }\r\n\r\n\r\n      }\r\n      context_enlargeIn--;\r\n      if (context_enlargeIn == 0) {\r\n        context_enlargeIn = Math.pow(2, context_numBits);\r\n        context_numBits++;\r\n      }\r\n    }\r\n\r\n    // Mark the end of the stream\r\n    value = 2;\r\n    for (i=0 ; i<context_numBits ; i++) {\r\n      context_data_val = (context_data_val << 1) | (value&1);\r\n      if (context_data_position == bitsPerChar-1) {\r\n        context_data_position = 0;\r\n        context_data.push(getCharFromInt(context_data_val));\r\n        context_data_val = 0;\r\n      } else {\r\n        context_data_position++;\r\n      }\r\n      value = value >> 1;\r\n    }\r\n\r\n    // Flush the last char\r\n    while (true) {\r\n      context_data_val = (context_data_val << 1);\r\n      if (context_data_position == bitsPerChar-1) {\r\n        context_data.push(getCharFromInt(context_data_val));\r\n        break;\r\n      }\r\n      else context_data_position++;\r\n    }\r\n    return context_data.join('');\r\n  }\r\n  catch(err) {\r\n    return \"Error: \"+err;\r\n  }\r\n}\r\n\r\nfunction decompress(compressed) {\r\n    if (compressed == null) return \"\";\r\n    if (compressed == \"\") return null;\r\n    return _decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\r\n}\r\n\r\nfunction _decompress(length, resetValue, getNextValue) {\r\n  try {\r\n\tvar f = String.fromCharCode;\r\n    var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n    var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\r\n    var baseReverseDic = {};\r\n    var dictionary = [],\r\n        next,\r\n        enlargeIn = 4,\r\n        dictSize = 4,\r\n        numBits = 3,\r\n        entry = \"\",\r\n        result = [],\r\n        i,\r\n        w,\r\n        bits, resb, maxpower, power,\r\n        c,\r\n        data = {val:getNextValue(0), position:resetValue, index:1};\r\n\r\n    for (i = 0; i < 3; i += 1) {\r\n      dictionary[i] = i;\r\n    }\r\n\r\n    bits = 0;\r\n    maxpower = Math.pow(2,2);\r\n    power=1;\r\n    while (power!=maxpower) {\r\n      resb = data.val & data.position;\r\n      data.position >>= 1;\r\n      if (data.position == 0) {\r\n        data.position = resetValue;\r\n        data.val = getNextValue(data.index++);\r\n      }\r\n      bits |= (resb>0 ? 1 : 0) * power;\r\n      power <<= 1;\r\n    }\r\n\r\n    switch (next = bits) {\r\n      case 0:\r\n          bits = 0;\r\n          maxpower = Math.pow(2,8);\r\n          power=1;\r\n          while (power!=maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n              data.position = resetValue;\r\n              data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb>0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n          }\r\n        c = f(bits);\r\n        break;\r\n      case 1:\r\n          bits = 0;\r\n          maxpower = Math.pow(2,16);\r\n          power=1;\r\n          while (power!=maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n              data.position = resetValue;\r\n              data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb>0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n          }\r\n        c = f(bits);\r\n        break;\r\n      case 2:\r\n        return \"\";\r\n    }\r\n    dictionary[3] = c;\r\n    w = c;\r\n    result.push(c);\r\n    while (true) {\r\n      if (data.index > length) {\r\n        return \"\";\r\n      }\r\n\r\n      bits = 0;\r\n      maxpower = Math.pow(2,numBits);\r\n      power=1;\r\n      while (power!=maxpower) {\r\n        resb = data.val & data.position;\r\n        data.position >>= 1;\r\n        if (data.position == 0) {\r\n          data.position = resetValue;\r\n          data.val = getNextValue(data.index++);\r\n        }\r\n        bits |= (resb>0 ? 1 : 0) * power;\r\n        power <<= 1;\r\n      }\r\n\r\n      switch (c = bits) {\r\n        case 0:\r\n          bits = 0;\r\n          maxpower = Math.pow(2,8);\r\n          power=1;\r\n          while (power!=maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n              data.position = resetValue;\r\n              data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb>0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n          }\r\n\r\n          dictionary[dictSize++] = f(bits);\r\n          c = dictSize-1;\r\n          enlargeIn--;\r\n          break;\r\n        case 1:\r\n          bits = 0;\r\n          maxpower = Math.pow(2,16);\r\n          power=1;\r\n          while (power!=maxpower) {\r\n            resb = data.val & data.position;\r\n            data.position >>= 1;\r\n            if (data.position == 0) {\r\n              data.position = resetValue;\r\n              data.val = getNextValue(data.index++);\r\n            }\r\n            bits |= (resb>0 ? 1 : 0) * power;\r\n            power <<= 1;\r\n          }\r\n          dictionary[dictSize++] = f(bits);\r\n          c = dictSize-1;\r\n          enlargeIn--;\r\n          break;\r\n        case 2:\r\n          return result.join('');\r\n      }\r\n\r\n      if (enlargeIn == 0) {\r\n        enlargeIn = Math.pow(2, numBits);\r\n        numBits++;\r\n      }\r\n\r\n      if (dictionary[c]) {\r\n        entry = dictionary[c];\r\n      } else {\r\n        if (c === dictSize) {\r\n          entry = w + w.charAt(0);\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n      result.push(entry);\r\n\r\n      // Add w+entry[0] to the dictionary.\r\n      dictionary[dictSize++] = w + entry.charAt(0);\r\n      enlargeIn--;\r\n\r\n      w = entry;\r\n\r\n      if (enlargeIn == 0) {\r\n        enlargeIn = Math.pow(2, numBits);\r\n        numBits++;\r\n      }\r\n\r\n    }\r\n  }\r\n  catch(err) {\r\n\treturn \"Error: \"+err;\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _SaveGameCode_ function code:</h3>\r\n\r\n(Function below has been updated to v3.0)\r\n\r\n<details>\r\n\r\n```\r\n// SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\r\n// The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\r\n// Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n// Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n// Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\nSuppressTurnscripts\r\n// Make sure ShowCodePopupFlag is of type 'boolean'\r\nif (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\r\n  X = TypeOf(ShowCodePopupFlag)\r\n  error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\r\n}\r\nSaveString = \"\"\r\nCreatedObj = NewStringList()\r\nDestroyedObj = NewStringList()\r\n// Set delimiters.\r\n// WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n// WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n// D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n// D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\nD1 = \"|\"\r\nD2 = \"$\"\r\nD3 = \";\"\r\nD4 = \"@\"\r\n// Save the player's current map before saving\r\n// Make sure first two entries are gameid and version (for load function)\r\nSaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\nSaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n// Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\nSaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n// Record all changable object attributes\r\nforeach (o, AllObjects()) {\r\n  objectname = o.name\r\n  // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n  if (not ListContains(game.StartingObjStrList, objectname)) {\r\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n    if (not ListContains(CreatedObj, objectname)) {\r\n      list add (CreatedObj, objectname)\r\n    }\r\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n    IncludeTypeFlag = True\r\n  }\r\n  else {\r\n    IncludeTypeFlag = False\r\n  }\r\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n      if (att_datatype=\"object\") {\r\n        v = GetAttribute (o, attributename)\r\n        att_value = v.name\r\n      }\r\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n        // Confirm there are no banned delimiters in the list entries\r\n        v = GetAttribute (o, attributename)\r\n        if (ListCount(v)>0) {\r\n          if (att_datatype=\"stringlist\") {\r\n            foreach (listcheck, v) {\r\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n              if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n        // Confirm there are no banned delimiters in the dictionary entries\r\n        v = GetAttribute (o, attributename)\r\n        if (DictionaryCount(v)>0) {\r\n          foreach (dictkey, v) {\r\n            if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n              error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n            }\r\n            if (att_datatype=\"stringdictionary\") {\r\n              dictitm = DictionaryItem (v, dictkey)\r\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n              if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        att_value = ToString(GetAttribute (o, attributename))\r\n      }\r\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n      if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n      }\r\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n    }\r\n  }\r\n}\r\nforeach (o, AllExits()) {\r\n  objectname = o.name\r\n  // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n  if (not ListContains(game.StartingObjStrList, objectname)) {\r\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n    if (not ListContains(CreatedObj, objectname)) {\r\n      list add (CreatedObj, objectname)\r\n    }\r\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n    IncludeTypeFlag = True\r\n  }\r\n  else {\r\n    IncludeTypeFlag = False\r\n  }\r\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n      if (att_datatype=\"object\") {\r\n        v = GetAttribute (o, attributename)\r\n        att_value = v.name\r\n      }\r\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n      }\r\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n      }\r\n      else {\r\n        att_value = ToString(GetAttribute (o, attributename))\r\n      }\r\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n      if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n      }\r\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n    }\r\n  }\r\n}\r\nforeach (turnscript, AllTurnScripts()) {\r\n  // Check for which turnscripts are enabled/disabled\r\n  if (GetBoolean(turnscript, \"enabled\")) {\r\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n  }\r\n  else {\r\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n  }\r\n}\r\n// Determine if any objects were destroyed by the player since game start...\r\nforeach (objectname, game.StartingObjStrList) {\r\n  IsThere = GetObject(objectname)\r\n  if (Equal(IsThere,null)) {\r\n    list add (DestroyedObj, objectname)\r\n  }\r\n}\r\n// Save the game.timeelapsed attribute\r\nSaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n// Check if game.SaveAtts and/or game.SaveTimers exists.\r\n// game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\nif (HasAttribute (game, \"SaveAtts\")) {\r\n  SaveAttType = TypeOf(game.SaveAtts)\r\n  if (SaveAttType=\"stringlist\") {\r\n    if (ListCount(game.SaveAtts)>0) {\r\n      foreach (x, game.SaveAtts) {\r\n        AttValue = GetAttribute (game, x)\r\n        att_datatype = TypeOf(AttValue)\r\n        if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n          SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n        }\r\n        else if (Equal(x,\"checkpoints\")) {\r\n          error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n        }\r\n        else if (Equal(AttValue,null)) {\r\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n        }\r\n        else {\r\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n  }\r\n}\r\n// game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\nif (HasAttribute (game, \"SaveTimers\")) {\r\n  SaveAttType = TypeOf(game.SaveTimers)\r\n  if (SaveAttType=\"stringlist\") {\r\n    if (ListCount(game.SaveTimers)>0) {\r\n      foreach (x, game.SaveTimers) {\r\n        T = GetObject(x)\r\n        if (not Equal(T,null)) {\r\n          TimerName = x.name\r\n          TimerValue1 = x.trigger\r\n          TimerValue2 = x.interval\r\n          TimerValue3 = x.enabled\r\n          TimerValue1Type = TypeOf(TimerValue1)\r\n          TimerValue2Type = TypeOf(TimerValue2)\r\n          TimerValue3Type = TypeOf(TimerValue3)\r\n          SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n          SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n          SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n        }\r\n        else {\r\n          error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n  }\r\n}\r\n// If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n// *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n// The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n// For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n// Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n// grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\nforeach (o, AllObjects()) {\r\n  foreach (attributename, GetAttributeNames(o,false)) {\r\n    objectname = o.name\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n      // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n      foreach (UKey, GetAttribute(o, attributename)) {\r\n        SaveString = SaveString+UKey+D2\r\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n        foreach (Lkey, UVal) {\r\n          Lval = DictionaryItem(UVal, Lkey)\r\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n        }\r\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n      }\r\n    }\r\n    else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n      // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n      foreach (UKey, GetAttribute(o, attributename)) {\r\n        SaveString = SaveString+UKey+D2\r\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n        foreach (Lkey, UVal) {\r\n          Lval = DictionaryItem(UVal, Lkey)\r\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n        }\r\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n      }\r\n    }\r\n  }\r\n}\r\n// Add on the list of created/destroyed objects...\r\nX = ToString(CreatedObj)\r\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\nCreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\nX = ToString(DestroyedObj)\r\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\nDestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\nSaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n// Special logic needed in order to save the game.checkpoints attribute\r\nD4toD1 = D4+D3+D2+D1\r\nif (HasAttribute(game,\"checkpoints\")) {\r\n  if (DictionaryCount(game.checkpoints)>0) {\r\n    KeyList = \"\"\r\n    CheckValList = \"\"\r\n    foreach (k, game.checkpoints) {\r\n      KeyList = KeyList+k+D3\r\n      val = DictionaryItem(game.checkpoints, k)\r\n      CheckValList = CheckValList+val+D4toD1\r\n    }\r\n    // Remove final D3 from KeyList string and final D4toD1 from CheckValList\r\n    KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\r\n    CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\r\n    // Add game.checkpoints data to SaveString\r\n    SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\r\n  }\r\n  else {\r\n    // If game.checkpoints empty, just add D4toD1 to SaveString.\r\n    SaveString = SaveString+D4toD1\r\n  }\r\n}\r\nelse {\r\n  // If game.checkpoints non-existant, just add D4toD1 to SaveString.\r\n  SaveString = SaveString+D4toD1\r\n}\r\n// Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\nSaveString = SaveString+D1+D2+D3+D4\r\n// msg for Debugging:\r\n// msg (SaveString+\"<br><br>\")\r\nif (ShowCodePopupFlag=True) {\r\n  // Create save code and present to player in textbox\r\n  JS.CreateSaveCode (SaveString)\r\n  JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\r\n}\r\nreturn (SaveString)\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _LoadGameCode_ function code:</h3>\r\n\r\n(Function below has been updated to v3.0.)\r\n\r\n<details>\r\n\r\n```\r\n// LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\r\nSuppressTurnscripts\r\n// NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\r\n// TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\nOldestAllowedVersion = 0.0\r\n// TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\nDebugMode = False\r\n// Msg for Debugging:\r\nif (DebugMode) {\r\n  msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n}\r\n// Set up other variables for later\r\nbla => {\r\n}\r\nupgradesave = False\r\nProceed = False\r\nSkippedAttList = \"\"\r\nCreatedObjDebugList = \"\"\r\nDestroyedObjDebugList = \"\"\r\n// Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\r\nCheckForCheck = Right(SaveGameCodeDecoded,2)\r\nif (CheckForCheck=\"✓✓\") {\r\n  upgradesave = True\r\n  SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\r\n}\r\n// Retrieve delimiters from end of SaveGameCodeDecoded\r\nDls = Right(SaveGameCodeDecoded,4)\r\nD1 = Mid (Dls, 1, 1)\r\nD2 = Mid (Dls, 2, 1)\r\nD3 = Mid (Dls, 3, 1)\r\nD4 = Mid (Dls, 4, 1)\r\n// Remove delimiters from end of SaveGameCode\r\nSaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n// Special logic to extract saved game.checkpoints attribute\r\nD4toD1 = D4+D3+D2+D1\r\nCheckpointSplit = Split(SaveCode, D4toD1)\r\nSaveCode = ListItem(CheckpointSplit,0)\r\nCheckpointKeys = ListItem(CheckpointSplit,1)\r\n// If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\r\nif (not CheckpointKeys=\"\") {\r\n  CheckpointKeyList = Split(CheckpointKeys, D3)\r\n  game.checkpoints = NewStringDictionary()\r\n  for (xx, 0, ListCount(CheckpointKeyList)-1) {\r\n    key = ListItem(CheckpointKeyList,xx)\r\n    val = ListItem(CheckpointSplit,xx+1)\r\n    DictionaryAdd (game.checkpoints, key, val)\r\n  }\r\n}\r\n// Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\nCreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\nif (DebugMode) {\r\n  msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n}\r\nCDList = Split(CreatedDestroyedInfo,D1)\r\nCSection = ListItem (CDList, 0)\r\nDSection = ListItem (CDList, 1)\r\nif (CSection=\"\") {\r\n  CreatedList = NewStringList()\r\n}\r\nelse {\r\n  CreatedList = Split (CSection, D3)\r\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n  list remove (CreatedList, \" \")\r\n}\r\nif (DSection=\"\") {\r\n  DestroyedList = NewStringList()\r\n}\r\nelse {\r\n  DestroyedList = Split (DSection, D3)\r\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n  list remove (DestroyedList, \" \")\r\n}\r\n// Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n// Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\nGridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\nif (DebugMode) {\r\n  msg (\"<br>GridGInfo: \"+GridGInfo)\r\n}\r\n// Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\nif (DebugMode) {\r\n  msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n}\r\n// Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n// Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\nGameIdDelim = Instr (SaveCode, D1)\r\nGameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\nGamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\nGameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\nGameIdObjectEl = ListItem (GameInfo,0)\r\nGameIdElements = Split(GameIdObjectEl,D2)\r\nLoaded_GameId = ListItem (GameIdElements, 3)\r\nGameVerObjectEl = ListItem (GameInfo,1)\r\nGameVerElements = Split(GameVerObjectEl,D2)\r\nVersionString = ListItem (GameVerElements, 3)\r\nLoaded_GameVersion = ToDouble(VersionString)\r\nGamePOVObjectEl = ListItem (GameInfo,2)\r\nGamePOVElements = Split(GamePOVObjectEl,D2)\r\nGamePOVName = ListItem (GamePOVElements, 3)\r\nif (StartsWith(GamePOVName,\"Object: \")) {\r\n  GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n}\r\nGamePOVObject = GetObject (GamePOVName)\r\nGamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n// Check that the save belongs to this game by comparing gameIds\r\nif (not Loaded_GameId=game.gameid) {\r\n  error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n}\r\nelse {\r\n  // Compare version of game in SaveCode to version of game loading it\r\n  ThisGame_GameVersion = ToDouble(game.version)\r\n  if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n    OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n  }\r\n  else {\r\n    OldestAllowedVersion_Double = OldestAllowedVersion\r\n  }\r\n  // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n  if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n    if (upgradesave = False) {\r\n      if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n        msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br><br>Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\r\n        // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\r\n        create (\"SaveGameDecodedObj\")\r\n        set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\r\n        ShowMenu (\"\", Split(\"Yes;No\"), false) {\r\n          switch (result) {\r\n            case (\"Yes\") {\r\n              SuppressTurnscripts\r\n              msg (\"Save code identified! Proceeding with load, please wait...\")\r\n              OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\r\n              LoadGameCode (OlderSaveCode)\r\n              destroy (\"SaveGameDecodedObj\")\r\n            }\r\n            case (\"No\") {\r\n              SuppressTurnscripts\r\n              msg (\"Load Aborted.\")\r\n              destroy (\"SaveGameDecodedObj\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n      }\r\n    }\r\n    else {\r\n      msg (\"Applying savecode from older version...\")\r\n      Proceed = True\r\n    }\r\n  }\r\n  else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n    error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n  }\r\n  else {\r\n    msg (\"Proceeding with load...\")\r\n    Proceed = True\r\n  }\r\n  if (Proceed=True) {\r\n    // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n    if (ListCount(CreatedList)>0) {\r\n      foreach (o, CreatedList) {\r\n        // Check that objects don't already exist...\r\n        IsThere = GetObject(o)\r\n        if (Equal(IsThere,null)) {\r\n          // If not, create the object\r\n          create (o)\r\n          CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n        }\r\n      }\r\n    }\r\n    player.grid_coordinates = null\r\n    // Split the save code up into all objects. Then parse through the value of each object attribute\r\n    SavedObjectList = Split(SaveCode, D1)\r\n    foreach (o, SavedObjectList) {\r\n      Skip_Att = False\r\n      objelements = Split(o, D2)\r\n      objectname = ListItem (objelements, 0)\r\n      object = GetObject (objectname)\r\n      attributename = ListItem (objelements, 1)\r\n      fullname = objectname+\".\"+attributename\r\n      preload_att_value = GetAttribute (object, attributename)\r\n      att_datatype = ListItem (objelements, 2)\r\n      if (ListCount(objelements)=3) {\r\n        att_value = \"\"\r\n      }\r\n      else {\r\n        att_value = ListItem (objelements, 3)\r\n      }\r\n      // Check that the attribute is supported\r\n      if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n        msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n        Skip_Att = True\r\n        SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n      }\r\n      // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n      att_value_obj = att_value\r\n      if (att_datatype=\"object\") {\r\n        if (StartsWith(att_value,\"Object: \")) {\r\n          att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n        }\r\n        else {\r\n          att_value_obj = GetObject(att_value)\r\n        }\r\n      }\r\n      else if (att_datatype=\"boolean\") {\r\n        if (att_value=\"True\") {\r\n          att_value_obj = True\r\n        }\r\n        else {\r\n          att_value_obj = False\r\n        }\r\n      }\r\n      else if (att_datatype=\"int\") {\r\n        att_value_obj = ToInt(att_value)\r\n      }\r\n      else if (att_datatype=\"double\") {\r\n        att_value_obj = ToDouble(att_value)\r\n      }\r\n      else if (att_datatype=\"stringlist\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewStringList()\r\n        }\r\n        else {\r\n          att_value_obj = Split (att_value, D3)\r\n          // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n          list remove (att_value_obj, \" \")\r\n        }\r\n      }\r\n      else if (att_datatype=\"objectlist\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewObjectList()\r\n        }\r\n        else {\r\n          att_value_obj = NewObjectList()\r\n          objlistlist = Split (att_value, D3)\r\n          foreach (olt, objlistlist) {\r\n            // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n            if (StartsWith(olt,\"Object: \")) {\r\n              value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n              if (not value=null) {\r\n                list add (att_value_obj, value)\r\n              }\r\n              else {\r\n                msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"stringdictionary\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewStringDictionary()\r\n        }\r\n        else {\r\n          att_value_obj = NewStringDictionary()\r\n          // Add dictionary values from SaveGame\r\n          dictrows = Split(att_value, \";\")\r\n          foreach (kv, dictrows) {\r\n            if (DebugMode) {\r\n              msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n            }\r\n            KeyValList = Split(kv,\" = \")\r\n            key = ListItem(KeyValList, 0)\r\n            value = ListItem(KeyValList, 1)\r\n            DictionaryAdd (att_value_obj, key, value)\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"objectdictionary\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewObjectDictionary()\r\n        }\r\n        else {\r\n          att_value_obj = NewObjectDictionary()\r\n          dictrows = Split(att_value, \";\")\r\n          foreach (kv, dictrows) {\r\n            if (DebugMode) {\r\n              msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n            }\r\n            KeyValList = Split(kv,\" = \")\r\n            key = ListItem(KeyValList, 0)\r\n            obj = ListItem(KeyValList, 1)\r\n            if (StartsWith(obj,\"Object: \")) {\r\n              value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              value = obj\r\n            }\r\n            if (not value=null) {\r\n              DictionaryAdd (att_value_obj, key, value)\r\n            }\r\n            else {\r\n              msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n              SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (objectname=GamePOVName and attributename=\"parent\") {\r\n        // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n        Skip_Att = True\r\n        GamePOVParent = att_value_obj\r\n      }\r\n      // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n      if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n        if (Equal(preload_att_value,null)) {\r\n          if (DebugMode) {\r\n            msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n          }\r\n          preload_att_value = \"null\"\r\n        }\r\n        // Msgs for debugging:\r\n        if (DebugMode) {\r\n          msg (\"objectname=\"+objectname)\r\n          msg (\"attributename=\"+attributename)\r\n          msg (\"att_datatype=\"+att_datatype)\r\n          msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n          if (Equal(preload_att_value,\"null\")) {\r\n            msg (\"preload_att_datatype=null\")\r\n          }\r\n          else {\r\n            msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n          }\r\n          msg (\"att_value=\"+ToString(att_value))\r\n          msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n          msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n          msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n          msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n          msg (\"<br>\")\r\n        }\r\n        // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n        if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n          if (DebugMode) {\r\n            msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n          }\r\n          // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n          cha = \"changed\" + attributename\r\n          if (HasAttribute (object, cha)) {\r\n            // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n            scr = GetAttribute (object, cha)\r\n            set (object, cha, bla)\r\n          }\r\n          // Update the attributes in the game with those from the SaveCode...\r\n          if (att_datatype=\"boolean\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"object\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            // NOTE TO DEVELOPER:\r\n            // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n            // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n            // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n            // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n            if (upgradesave = True) {\r\n              // This section will trigger if the player is loading a save from a previous game version\r\n              ReplaceContents = True\r\n            }\r\n            else {\r\n              // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n              ReplaceContents = True\r\n            }\r\n            if (att_datatype=\"stringlist\") {\r\n              if (ReplaceContents = True) {\r\n                // Completely replace stringlist contents with those found in the SaveCode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                FinalList = NewStringList()\r\n                // Retrieve the contents of the existing list\r\n                PreLoadList = preload_att_value\r\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                // Remove duplicates\r\n                CompactList = ListCompact (CombinedList)\r\n                // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                foreach (olt, CompactList) {\r\n                  list add (FinalList, olt)\r\n                }\r\n                set (object, attributename, FinalList)\r\n              }\r\n            }\r\n            else if (att_datatype=\"objectlist\") {\r\n              if (ReplaceContents = True) {\r\n                // Completely replace objectlist contents with those found in the SaveCode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                // Retrieve the contents of the existing list\r\n                PreLoadList = preload_att_value\r\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                // Remove duplicates\r\n                FinalList = ObjectListCompact (CombinedList)\r\n                set (object, attributename, FinalList)\r\n              }\r\n            }\r\n            else if (att_datatype=\"stringdictionary\") {\r\n              if (ReplaceContents = True) {\r\n                // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                set (object, attributename, att_value_obj)\r\n                Dummy = NewStringDictionary()\r\n              }\r\n              else {\r\n                // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                Dummy = preload_att_value\r\n                // Add dictionary values from SaveGame\r\n                dictrows = Split(att_value, \";\")\r\n                foreach (kv, dictrows) {\r\n                  KeyValList = Split(kv,\" = \")\r\n                  key = ListItem(KeyValList, 0)\r\n                  value = ListItem(KeyValList, 1)\r\n                  DictionaryAdd (Dummy, key, value)\r\n                }\r\n                set (object, attributename, Dummy)\r\n              }\r\n            }\r\n            else if (att_datatype=\"objectdictionary\") {\r\n              if (upgradesave = False) {\r\n                // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                Dummy = preload_att_value\r\n                // Add dictionary values from SaveGame\r\n                dictrows = Split(att_value, \";\")\r\n                foreach (kv, dictrows) {\r\n                  KeyValList = Split(kv,\" = \")\r\n                  key = ListItem(KeyValList, 0)\r\n                  value = ListItem(KeyValList, 1)\r\n                  if (StartsWith(value,\"Object: \")) {\r\n                    value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                  }\r\n                  DictionaryAdd (Dummy, key, value)\r\n                }\r\n                set (object, attributename, Dummy)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"string\") {\r\n            set (object, attributename, att_value)\r\n          }\r\n          else {\r\n            error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n          }\r\n          if (HasAttribute (object, cha)) {\r\n            // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n            set (object, cha, scr)\r\n            scr => {\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n    // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n    AllSavedGrids = Split(GridGInfo,D4)\r\n    if (DebugMode) {\r\n      msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n    }\r\n    foreach (A, AllSavedGrids) {\r\n      UDictionary = NewDictionary()\r\n      ItemAndValue = Split(A,\"&%&\")\r\n      ObjAndAtt = ListItem(ItemAndValue,0)\r\n      ObjAndAtt = Split(ObjAndAtt,D2)\r\n      objectname = ListItem(ObjAndAtt,0)\r\n      attributename = ListItem(ObjAndAtt,1)\r\n      object = GetObject(objectname)\r\n      GridVals = ListItem(ItemAndValue,1)\r\n      GridVals = Split(GridVals,D1)\r\n      foreach (B, GridVals) {\r\n        UKeyAndUVal = Split(B,D2)\r\n        UKey = ListItem(UKeyAndUVal,0)\r\n        UVal = ListItem(UKeyAndUVal,1)\r\n        UVal = Split(UVal,D3)\r\n        LDictionary = NewDictionary()\r\n        foreach (C, UVal) {\r\n          LkeyAndLval = Split(C,\" = \")\r\n          Lkey = ListItem(LkeyAndLval,0)\r\n          LvalAndType = ListItem(LkeyAndLval,1)\r\n          LvalAndType = Split(LvalAndType,\":\")\r\n          Lval_str = ListItem(LvalAndType,0)\r\n          LType = ListItem(LvalAndType,1)\r\n          if (LType=\"int\") {\r\n            Lval = ToInt(Lval_str)\r\n          }\r\n          else if (LType=\"double\") {\r\n            Lval = ToDouble(Lval_str)\r\n          }\r\n          else if (LType=\"boolean\") {\r\n            if (Lval_str=\"True\") {\r\n              Lval = True\r\n            }\r\n            else {\r\n              Lval = False\r\n            }\r\n          }\r\n          else {\r\n            error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n          }\r\n          DictionaryAdd (LDictionary, Lkey, Lval)\r\n        }\r\n        DictionaryAdd (UDictionary, UKey, LDictionary)\r\n      }\r\n      if (DebugMode) {\r\n        msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n      }\r\n      set (object, attributename, UDictionary)\r\n    }\r\n    // Destroy any objects that the player destroyed during their saved game, if any\r\n    if (ListCount(DestroyedList)>0) {\r\n      foreach (o, DestroyedList) {\r\n        // Check that objects still exist...\r\n        IsThere = GetObject(o)\r\n        if (not Equal(IsThere,null)) {\r\n          // If its there, destroy the object\r\n          destroy (o)\r\n          DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n        }\r\n      }\r\n    }\r\n    msg (\"Load complete!\")\r\n    if (DebugMode) {\r\n      msg (\"Created objects: \"+CreatedObjDebugList)\r\n      msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n      msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n    }\r\n    // Finally, update game.pov.parent and game.pov\r\n    wait {\r\n      set (GamePOVObject, \"parent\", GamePOVParent)\r\n      game.pov = GamePOVObject\r\n      // player.grid_coordinates = null\r\n      JS.Grid_ClearAllLayers ()\r\n      Grid_Redraw\r\n      Grid_DrawPlayerInRoom (game.pov.parent)\r\n      ClearScreen\r\n      ShowRoomDescription\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _SaveCheckpoint_ function code:</h3>\r\n\r\n(Function below is new with v3.0)\r\n\r\n<details>\r\n\r\n```\r\n// SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\r\n// The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\r\n// If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\r\n// Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n// Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n// Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\nSuppressTurnscripts\r\n// Check if game.checkpoints exists. If not, create it.\r\nif (not HasAttribute(game, \"checkpoints\")) {\r\n  set (game, \"checkpoints\", NewStringDictionary())\r\n}\r\n// Make sure CheckpointName input is of 'string' datatype\r\nif (not TypeOf(CheckpointName)=\"string\") {\r\n  X = TypeOf(CheckpointName)\r\n  error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n}\r\nSaveString = \"\"\r\nCreatedObj = NewStringList()\r\nDestroyedObj = NewStringList()\r\n// Set delimiters.\r\n// WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n// WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n// D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n// D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\nD1 = \"|\"\r\nD2 = \"$\"\r\nD3 = \";\"\r\nD4 = \"@\"\r\n// Save the player's current map before saving\r\n// Make sure first two entries are gameid and version (for load function)\r\nSaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\nSaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n// Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\nSaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n// Record all changable object attributes\r\nforeach (o, AllObjects()) {\r\n  objectname = o.name\r\n  // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n  if (not ListContains(game.StartingObjStrList, objectname)) {\r\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n    if (not ListContains(CreatedObj, objectname)) {\r\n      list add (CreatedObj, objectname)\r\n    }\r\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n    IncludeTypeFlag = True\r\n  }\r\n  else {\r\n    IncludeTypeFlag = False\r\n  }\r\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n      if (att_datatype=\"object\") {\r\n        v = GetAttribute (o, attributename)\r\n        att_value = v.name\r\n      }\r\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n        // Confirm there are no banned delimiters in the list entries\r\n        v = GetAttribute (o, attributename)\r\n        if (ListCount(v)>0) {\r\n          if (att_datatype=\"stringlist\") {\r\n            foreach (listcheck, v) {\r\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n              if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n        // Confirm there are no banned delimiters in the dictionary entries\r\n        v = GetAttribute (o, attributename)\r\n        if (DictionaryCount(v)>0) {\r\n          foreach (dictkey, v) {\r\n            if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n              error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n            }\r\n            if (att_datatype=\"stringdictionary\") {\r\n              dictitm = DictionaryItem (v, dictkey)\r\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n              if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        att_value = ToString(GetAttribute (o, attributename))\r\n      }\r\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n      if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n      }\r\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n    }\r\n  }\r\n}\r\nforeach (o, AllExits()) {\r\n  objectname = o.name\r\n  // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n  if (not ListContains(game.StartingObjStrList, objectname)) {\r\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n    if (not ListContains(CreatedObj, objectname)) {\r\n      list add (CreatedObj, objectname)\r\n    }\r\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n    IncludeTypeFlag = True\r\n  }\r\n  else {\r\n    IncludeTypeFlag = False\r\n  }\r\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n      if (att_datatype=\"object\") {\r\n        v = GetAttribute (o, attributename)\r\n        att_value = v.name\r\n      }\r\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n      }\r\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n        X = ToString(GetAttribute (o, attributename))\r\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n      }\r\n      else {\r\n        att_value = ToString(GetAttribute (o, attributename))\r\n      }\r\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n      if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n      }\r\n      else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n      }\r\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n    }\r\n  }\r\n}\r\nforeach (turnscript, AllTurnScripts()) {\r\n  // Check for which turnscripts are enabled/disabled\r\n  if (GetBoolean(turnscript, \"enabled\")) {\r\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n  }\r\n  else {\r\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n  }\r\n}\r\n// Determine if any objects were destroyed by the player since game start...\r\nforeach (objectname, game.StartingObjStrList) {\r\n  IsThere = GetObject(objectname)\r\n  if (Equal(IsThere,null)) {\r\n    list add (DestroyedObj, objectname)\r\n  }\r\n}\r\n// Save the game.timeelapsed attribute\r\nSaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n// Check if game.SaveAtts and/or game.SaveTimers exists.\r\n// game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\nif (HasAttribute (game, \"SaveAtts\")) {\r\n  SaveAttType = TypeOf(game.SaveAtts)\r\n  if (SaveAttType=\"stringlist\") {\r\n    if (ListCount(game.SaveAtts)>0) {\r\n      foreach (x, game.SaveAtts) {\r\n        AttValue = GetAttribute (game, x)\r\n        att_datatype = TypeOf(AttValue)\r\n        if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n          SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n        }\r\n        else if (Equal(x,\"checkpoints\")) {\r\n          error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n        }\r\n        else if (Equal(AttValue,null)) {\r\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n        }\r\n        else {\r\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n  }\r\n}\r\n// game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\nif (HasAttribute (game, \"SaveTimers\")) {\r\n  SaveAttType = TypeOf(game.SaveTimers)\r\n  if (SaveAttType=\"stringlist\") {\r\n    if (ListCount(game.SaveTimers)>0) {\r\n      foreach (x, game.SaveTimers) {\r\n        T = GetObject(x)\r\n        if (not Equal(T,null)) {\r\n          TimerName = x.name\r\n          TimerValue1 = x.trigger\r\n          TimerValue2 = x.interval\r\n          TimerValue3 = x.enabled\r\n          TimerValue1Type = TypeOf(TimerValue1)\r\n          TimerValue2Type = TypeOf(TimerValue2)\r\n          TimerValue3Type = TypeOf(TimerValue3)\r\n          SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n          SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n          SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n        }\r\n        else {\r\n          error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n  }\r\n}\r\n// If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n// *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n// The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n// For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n// Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n// grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\nforeach (o, AllObjects()) {\r\n  foreach (attributename, GetAttributeNames(o,false)) {\r\n    objectname = o.name\r\n    fullname = objectname+\".\"+attributename\r\n    att_datatype = ToString(TypeOf(o, attributename))\r\n    if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n      // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n      foreach (UKey, GetAttribute(o, attributename)) {\r\n        SaveString = SaveString+UKey+D2\r\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n        foreach (Lkey, UVal) {\r\n          Lval = DictionaryItem(UVal, Lkey)\r\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n        }\r\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n      }\r\n    }\r\n    else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n      // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n      foreach (UKey, GetAttribute(o, attributename)) {\r\n        SaveString = SaveString+UKey+D2\r\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n        foreach (Lkey, UVal) {\r\n          Lval = DictionaryItem(UVal, Lkey)\r\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n        }\r\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n      }\r\n    }\r\n  }\r\n}\r\n// Add on the list of created/destroyed objects...\r\nX = ToString(CreatedObj)\r\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\nCreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\nX = ToString(DestroyedObj)\r\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\nDestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\nSaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n// Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\nSaveString = SaveString+D1+D2+D3+D4\r\n// msg for Debugging:\r\n// msg (SaveString+\"<br><br>\")\r\n// Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\r\nif (not CheckpointName=\"\") {\r\n  DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\r\n}\r\nreturn (SaveString)\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _LoadCheckpoint_ function code:</h3>\r\n\r\n(Function below is new with v3.0)\r\n\r\n<details>\r\n\r\n```\r\n// LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\r\n// Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\r\nSuppressTurnscripts\r\n// TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\nOldestAllowedVersion = 2.0\r\n// TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\nDebugMode = False\r\n// Msg for Debugging:\r\nif (DebugMode) {\r\n  msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n}\r\n// Make sure CheckpointName input is of type 'string'\r\nif (not TypeOf(CheckpointName)=\"string\") {\r\n  X = TypeOf(CheckpointName)\r\n  error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n}\r\n// Retrieve SaveString from game.checkpoints dictionary\r\nif (HasAttribute(game, \"checkpoints\")) {\r\n  if (DictionaryContains(game.checkpoints, CheckpointName)) {\r\n    SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\r\n  }\r\n  else {\r\n    error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\r\n  }\r\n}\r\nelse {\r\n  error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\r\n}\r\n// Set up other variables for later\r\nbla => {\r\n}\r\nupgradesave = False\r\nProceed = False\r\nSkippedAttList = \"\"\r\nCreatedObjDebugList = \"\"\r\nDestroyedObjDebugList = \"\"\r\n// Retrieve delimiters from end of SaveGameCodeDecoded\r\nDls = Right(SaveGameCodeDecoded,4)\r\nD1 = Mid (Dls, 1, 1)\r\nD2 = Mid (Dls, 2, 1)\r\nD3 = Mid (Dls, 3, 1)\r\nD4 = Mid (Dls, 4, 1)\r\n// Remove delimiters from end of SaveGameCode\r\nSaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n// Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\nCreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\nif (DebugMode) {\r\n  msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n}\r\nCDList = Split(CreatedDestroyedInfo,D1)\r\nCSection = ListItem (CDList, 0)\r\nDSection = ListItem (CDList, 1)\r\nif (CSection=\"\") {\r\n  CreatedList = NewStringList()\r\n}\r\nelse {\r\n  CreatedList = Split (CSection, D3)\r\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n  list remove (CreatedList, \" \")\r\n}\r\nif (DSection=\"\") {\r\n  DestroyedList = NewStringList()\r\n}\r\nelse {\r\n  DestroyedList = Split (DSection, D3)\r\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n  list remove (DestroyedList, \" \")\r\n}\r\n// Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n// Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\nGridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\nif (DebugMode) {\r\n  msg (\"<br>GridGInfo: \"+GridGInfo)\r\n}\r\n// Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\nif (DebugMode) {\r\n  msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n}\r\n// Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n// Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\nGameIdDelim = Instr (SaveCode, D1)\r\nGameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\nGamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\nGameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\nGameIdObjectEl = ListItem (GameInfo,0)\r\nGameIdElements = Split(GameIdObjectEl,D2)\r\nLoaded_GameId = ListItem (GameIdElements, 3)\r\nGameVerObjectEl = ListItem (GameInfo,1)\r\nGameVerElements = Split(GameVerObjectEl,D2)\r\nVersionString = ListItem (GameVerElements, 3)\r\nLoaded_GameVersion = ToDouble(VersionString)\r\nGamePOVObjectEl = ListItem (GameInfo,2)\r\nGamePOVElements = Split(GamePOVObjectEl,D2)\r\nGamePOVName = ListItem (GamePOVElements, 3)\r\nif (StartsWith(GamePOVName,\"Object: \")) {\r\n  GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n}\r\nGamePOVObject = GetObject (GamePOVName)\r\nGamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n// Check that the save belongs to this game by comparing gameIds\r\nif (not Loaded_GameId=game.gameid) {\r\n  error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n}\r\nelse {\r\n  // Compare version of game in SaveCode to version of game loading it\r\n  ThisGame_GameVersion = ToDouble(game.version)\r\n  if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n    OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n  }\r\n  else {\r\n    OldestAllowedVersion_Double = OldestAllowedVersion\r\n  }\r\n  // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n  if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n    if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n      upgradesave = True\r\n      Proceed = True\r\n    }\r\n    else {\r\n      error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n    }\r\n  }\r\n  else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n    error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n  }\r\n  else {\r\n    Proceed = True\r\n  }\r\n  if (Proceed=True) {\r\n    // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n    if (ListCount(CreatedList)>0) {\r\n      foreach (o, CreatedList) {\r\n        // Check that objects don't already exist...\r\n        IsThere = GetObject(o)\r\n        if (Equal(IsThere,null)) {\r\n          // If not, create the object\r\n          create (o)\r\n          CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n        }\r\n      }\r\n    }\r\n    player.grid_coordinates = null\r\n    // Split the save code up into all objects. Then parse through the value of each object attribute\r\n    SavedObjectList = Split(SaveCode, D1)\r\n    foreach (o, SavedObjectList) {\r\n      Skip_Att = False\r\n      objelements = Split(o, D2)\r\n      objectname = ListItem (objelements, 0)\r\n      object = GetObject (objectname)\r\n      attributename = ListItem (objelements, 1)\r\n      fullname = objectname+\".\"+attributename\r\n      preload_att_value = GetAttribute (object, attributename)\r\n      att_datatype = ListItem (objelements, 2)\r\n      if (ListCount(objelements)=3) {\r\n        att_value = \"\"\r\n      }\r\n      else {\r\n        att_value = ListItem (objelements, 3)\r\n      }\r\n      // Check that the attribute is supported\r\n      if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n        msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n        Skip_Att = True\r\n        SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n      }\r\n      // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n      att_value_obj = att_value\r\n      if (att_datatype=\"object\") {\r\n        if (StartsWith(att_value,\"Object: \")) {\r\n          att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n        }\r\n        else {\r\n          att_value_obj = GetObject(att_value)\r\n        }\r\n      }\r\n      else if (att_datatype=\"boolean\") {\r\n        if (att_value=\"True\") {\r\n          att_value_obj = True\r\n        }\r\n        else {\r\n          att_value_obj = False\r\n        }\r\n      }\r\n      else if (att_datatype=\"int\") {\r\n        att_value_obj = ToInt(att_value)\r\n      }\r\n      else if (att_datatype=\"double\") {\r\n        att_value_obj = ToDouble(att_value)\r\n      }\r\n      else if (att_datatype=\"stringlist\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewStringList()\r\n        }\r\n        else {\r\n          att_value_obj = Split (att_value, D3)\r\n          // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n          list remove (att_value_obj, \" \")\r\n        }\r\n      }\r\n      else if (att_datatype=\"objectlist\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewObjectList()\r\n        }\r\n        else {\r\n          att_value_obj = NewObjectList()\r\n          objlistlist = Split (att_value, D3)\r\n          foreach (olt, objlistlist) {\r\n            // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n            if (StartsWith(olt,\"Object: \")) {\r\n              value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n              if (not value=null) {\r\n                list add (att_value_obj, value)\r\n              }\r\n              else {\r\n                msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"stringdictionary\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewStringDictionary()\r\n        }\r\n        else {\r\n          att_value_obj = NewStringDictionary()\r\n          // Add dictionary values from SaveGame\r\n          dictrows = Split(att_value, \";\")\r\n          foreach (kv, dictrows) {\r\n            if (DebugMode) {\r\n              msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n            }\r\n            KeyValList = Split(kv,\" = \")\r\n            key = ListItem(KeyValList, 0)\r\n            value = ListItem(KeyValList, 1)\r\n            DictionaryAdd (att_value_obj, key, value)\r\n          }\r\n        }\r\n      }\r\n      else if (att_datatype=\"objectdictionary\") {\r\n        if (att_value=\"\") {\r\n          att_value_obj = NewObjectDictionary()\r\n        }\r\n        else {\r\n          att_value_obj = NewObjectDictionary()\r\n          dictrows = Split(att_value, \";\")\r\n          foreach (kv, dictrows) {\r\n            if (DebugMode) {\r\n              msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n            }\r\n            KeyValList = Split(kv,\" = \")\r\n            key = ListItem(KeyValList, 0)\r\n            obj = ListItem(KeyValList, 1)\r\n            if (StartsWith(obj,\"Object: \")) {\r\n              value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              value = obj\r\n            }\r\n            if (not value=null) {\r\n              DictionaryAdd (att_value_obj, key, value)\r\n            }\r\n            else {\r\n              msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n              SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (objectname=GamePOVName and attributename=\"parent\") {\r\n        // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n        Skip_Att = True\r\n        GamePOVParent = att_value_obj\r\n      }\r\n      // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n      if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n        if (Equal(preload_att_value,null)) {\r\n          if (DebugMode) {\r\n            msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n          }\r\n          preload_att_value = \"null\"\r\n        }\r\n        // Msgs for debugging:\r\n        if (DebugMode) {\r\n          msg (\"objectname=\"+objectname)\r\n          msg (\"attributename=\"+attributename)\r\n          msg (\"att_datatype=\"+att_datatype)\r\n          msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n          if (Equal(preload_att_value,\"null\")) {\r\n            msg (\"preload_att_datatype=null\")\r\n          }\r\n          else {\r\n            msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n          }\r\n          msg (\"att_value=\"+ToString(att_value))\r\n          msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n          msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n          msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n          msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n          msg (\"<br>\")\r\n        }\r\n        // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n        if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n          if (DebugMode) {\r\n            msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n          }\r\n          // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n          cha = \"changed\" + attributename\r\n          if (HasAttribute (object, cha)) {\r\n            // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n            scr = GetAttribute (object, cha)\r\n            set (object, cha, bla)\r\n          }\r\n          // Update the attributes in the game with those from the SaveCode...\r\n          if (att_datatype=\"boolean\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"object\") {\r\n            set (object, attributename, att_value_obj)\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            // NOTE TO DEVELOPER:\r\n            // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n            // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n            // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n            // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n            if (upgradesave = True) {\r\n              // This section will trigger if the player is loading a save from a previous game version\r\n              ReplaceContents = True\r\n            }\r\n            else {\r\n              // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n              ReplaceContents = True\r\n            }\r\n            if (att_datatype=\"stringlist\") {\r\n              if (ReplaceContents = True) {\r\n                // Completely replace stringlist contents with those found in the SaveCode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                FinalList = NewStringList()\r\n                // Retrieve the contents of the existing list\r\n                PreLoadList = preload_att_value\r\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                // Remove duplicates\r\n                CompactList = ListCompact (CombinedList)\r\n                // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                foreach (olt, CompactList) {\r\n                  list add (FinalList, olt)\r\n                }\r\n                set (object, attributename, FinalList)\r\n              }\r\n            }\r\n            else if (att_datatype=\"objectlist\") {\r\n              if (ReplaceContents = True) {\r\n                // Completely replace objectlist contents with those found in the SaveCode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                // Retrieve the contents of the existing list\r\n                PreLoadList = preload_att_value\r\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                // Remove duplicates\r\n                FinalList = ObjectListCompact (CombinedList)\r\n                set (object, attributename, FinalList)\r\n              }\r\n            }\r\n            else if (att_datatype=\"stringdictionary\") {\r\n              if (ReplaceContents = True) {\r\n                // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                set (object, attributename, att_value_obj)\r\n                Dummy = NewStringDictionary()\r\n              }\r\n              else {\r\n                // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                Dummy = preload_att_value\r\n                // Add dictionary values from SaveGame\r\n                dictrows = Split(att_value, \";\")\r\n                foreach (kv, dictrows) {\r\n                  KeyValList = Split(kv,\" = \")\r\n                  key = ListItem(KeyValList, 0)\r\n                  value = ListItem(KeyValList, 1)\r\n                  DictionaryAdd (Dummy, key, value)\r\n                }\r\n                set (object, attributename, Dummy)\r\n              }\r\n            }\r\n            else if (att_datatype=\"objectdictionary\") {\r\n              if (upgradesave = False) {\r\n                // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else {\r\n                // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                Dummy = preload_att_value\r\n                // Add dictionary values from SaveGame\r\n                dictrows = Split(att_value, \";\")\r\n                foreach (kv, dictrows) {\r\n                  KeyValList = Split(kv,\" = \")\r\n                  key = ListItem(KeyValList, 0)\r\n                  value = ListItem(KeyValList, 1)\r\n                  if (StartsWith(value,\"Object: \")) {\r\n                    value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                  }\r\n                  DictionaryAdd (Dummy, key, value)\r\n                }\r\n                set (object, attributename, Dummy)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"string\") {\r\n            set (object, attributename, att_value)\r\n          }\r\n          else {\r\n            error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n          }\r\n          if (HasAttribute (object, cha)) {\r\n            // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n            set (object, cha, scr)\r\n            scr => {\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n    // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n    AllSavedGrids = Split(GridGInfo,D4)\r\n    if (DebugMode) {\r\n      msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n    }\r\n    foreach (A, AllSavedGrids) {\r\n      UDictionary = NewDictionary()\r\n      ItemAndValue = Split(A,\"&%&\")\r\n      ObjAndAtt = ListItem(ItemAndValue,0)\r\n      ObjAndAtt = Split(ObjAndAtt,D2)\r\n      objectname = ListItem(ObjAndAtt,0)\r\n      attributename = ListItem(ObjAndAtt,1)\r\n      object = GetObject(objectname)\r\n      GridVals = ListItem(ItemAndValue,1)\r\n      GridVals = Split(GridVals,D1)\r\n      foreach (B, GridVals) {\r\n        UKeyAndUVal = Split(B,D2)\r\n        UKey = ListItem(UKeyAndUVal,0)\r\n        UVal = ListItem(UKeyAndUVal,1)\r\n        UVal = Split(UVal,D3)\r\n        LDictionary = NewDictionary()\r\n        foreach (C, UVal) {\r\n          LkeyAndLval = Split(C,\" = \")\r\n          Lkey = ListItem(LkeyAndLval,0)\r\n          LvalAndType = ListItem(LkeyAndLval,1)\r\n          LvalAndType = Split(LvalAndType,\":\")\r\n          Lval_str = ListItem(LvalAndType,0)\r\n          LType = ListItem(LvalAndType,1)\r\n          if (LType=\"int\") {\r\n            Lval = ToInt(Lval_str)\r\n          }\r\n          else if (LType=\"double\") {\r\n            Lval = ToDouble(Lval_str)\r\n          }\r\n          else if (LType=\"boolean\") {\r\n            if (Lval_str=\"True\") {\r\n              Lval = True\r\n            }\r\n            else {\r\n              Lval = False\r\n            }\r\n          }\r\n          else {\r\n            error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n          }\r\n          DictionaryAdd (LDictionary, Lkey, Lval)\r\n        }\r\n        DictionaryAdd (UDictionary, UKey, LDictionary)\r\n      }\r\n      if (DebugMode) {\r\n        msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n      }\r\n      set (object, attributename, UDictionary)\r\n    }\r\n    // Destroy any objects that the player destroyed during their saved game, if any\r\n    if (ListCount(DestroyedList)>0) {\r\n      foreach (o, DestroyedList) {\r\n        // Check that objects still exist...\r\n        IsThere = GetObject(o)\r\n        if (not Equal(IsThere,null)) {\r\n          // If its there, destroy the object\r\n          destroy (o)\r\n          DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n        }\r\n      }\r\n    }\r\n    if (DebugMode) {\r\n      msg (\"Created objects: \"+CreatedObjDebugList)\r\n      msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n      msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n    }\r\n    // Finally, update game.pov.parent and game.pov\r\n    set (GamePOVObject, \"parent\", GamePOVParent)\r\n    game.pov = GamePOVObject\r\n    // player.grid_coordinates = null\r\n    JS.Grid_ClearAllLayers ()\r\n    Grid_Redraw\r\n    Grid_DrawPlayerInRoom (game.pov.parent)\r\n    ClearScreen\r\n    ShowRoomDescription\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _GetSaveGameCodeDelims_ function code:</h3>\r\n\r\n(Function below is new with v3.0)\r\n\r\n<details>\r\n\r\n```\r\n// GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\r\n// Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\nDelimList = NewStringList()\r\nSaveString = SaveGameCode(False)\r\n// Retrieve delimiters from end of SaveString\r\nDls = Right(SaveString,4)\r\nD1 = Mid (Dls, 1, 1)\r\nD2 = Mid (Dls, 2, 1)\r\nD3 = Mid (Dls, 3, 1)\r\nD4 = Mid (Dls, 4, 1)\r\n// Add to list\r\nlist add (DelimList, D1)\r\nlist add (DelimList, D2)\r\nlist add (DelimList, D3)\r\nlist add (DelimList, D4)\r\n// Return the list of delimiters as a string list\r\nreturn (DelimList)\r\n```\r\n\r\n</details>\r\n\r\n<h3>The _GetSaveCheckpointDelims_ function code:</h3>\r\n\r\n(Function below is new with v3.0)\r\n\r\n<details>\r\n\r\n```\r\n// GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\r\n// Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\nDelimList = NewStringList()\r\nSaveString = SaveCheckpoint(\"\")\r\n// Retrieve delimiters from end of SaveString\r\nDls = Right(SaveString,4)\r\nD1 = Mid (Dls, 1, 1)\r\nD2 = Mid (Dls, 2, 1)\r\nD3 = Mid (Dls, 3, 1)\r\nD4 = Mid (Dls, 4, 1)\r\n// Add to list\r\nlist add (DelimList, D1)\r\nlist add (DelimList, D2)\r\nlist add (DelimList, D3)\r\nlist add (DelimList, D4)\r\n// Return the list of delimiters as a string list\r\nreturn (DelimList)\r\n```\r\n\r\n</details>\r\n\r\n<h3>The code for the entire test game:</h3>\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.8.6836.13983-->\r\n<asl version=\"580\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Save Testing\">\r\n    <gameid>932164b2-0eae-47d6-94b4-402d8a2238d9</gameid>\r\n    <version>3.0</version>\r\n    <firstpublished>2022</firstpublished>\r\n    <feature_devmode />\r\n    <attr name=\"devmode_setinitscript\" type=\"boolean\">false</attr>\r\n    <attr name=\"devmode_changepovpos\" type=\"boolean\">false</attr>\r\n    <devmode_setverbs />\r\n    <gridmap />\r\n    <showscore type=\"boolean\">false</showscore>\r\n    <showhealth type=\"boolean\">false</showhealth>\r\n    <showmoney type=\"boolean\">false</showmoney>\r\n    <attr name=\"feature_limitinventory\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_lightdark\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_asktell\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_annotations\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_advancedwearables\" type=\"boolean\">false</attr>\r\n    <attr name=\"feature_advancedscripts\" type=\"boolean\">false</attr>\r\n    <appendobjectdescription type=\"boolean\">false</appendobjectdescription>\r\n    <allowlookdirections type=\"boolean\">false</allowlookdirections>\r\n    <multiplecommands type=\"boolean\">false</multiplecommands>\r\n    <command_newline />\r\n    <clearscreenonroomenter type=\"boolean\">false</clearscreenonroomenter>\r\n    <autodisplayverbs />\r\n    <author>Leviathon</author>\r\n    <start type=\"script\">\r\n      // Initialization script for SaveLoadCode functionality...\r\n      // Create a list of all object and exit names present in game at start. This way we can keep track of which objects/exits the player has created/destroyed while playing by comparing to this list when saving/loading.\r\n      set (game, \"StartingObjStrList\", NewStringList ())\r\n      foreach (startobj, AllObjects()) {\r\n        list add (game.StartingObjStrList, startobj.name)\r\n      }\r\n      foreach (startobj, AllExits()) {\r\n        list add (game.StartingObjStrList, startobj.name)\r\n      }\r\n      set (game, \"checkpoints\", NewStringDictionary())\r\n      // End of SaveLoadCode initialization script\r\n    </start>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <isroom />\r\n    <description><![CDATA[This is the starting room of the SaveLoadCode functionality demo.<br/><br/>Type \"SaveCode\" at any time to create a save code, allowing you to load later. Copy the code to a notepad document to save it for later!<br/><br/>Type \"LoadCode\" at any time to load a previously saved code. Paste in your previously-saved save code to load your game!]]></description>\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n      <StringAttribute>Stringy Bingy</StringAttribute>\r\n      <alias>Francis</alias>\r\n      <ObjectListRedux type=\"objectlist\"></ObjectListRedux>\r\n    </object>\r\n    <object name=\"BoingoBall\">\r\n      <inherit name=\"editor_object\" />\r\n      <IsBall />\r\n      <MemoryDict type=\"stringdictionary\">\r\n        <item>\r\n          <key>Mem1</key>\r\n          <value>Memories of 1</value>\r\n        </item>\r\n        <item>\r\n          <key>Mem2</key>\r\n          <value>Memories of 2</value>\r\n        </item>\r\n      </MemoryDict>\r\n      <ListOfString type=\"stringlist\">\r\n        <value>Brock</value>\r\n        <value>Misty</value>\r\n        <value>Ash</value>\r\n        <value>Pikachu</value>\r\n      </ListOfString>\r\n      <look>This is an object with a bunch of attributes attached to it. The SaveGameCode and LoadGameCode functions will save all its attributes and update them on load if they've changed.</look>\r\n    </object>\r\n    <exit name=\"KeyRoomDoor\" alias=\"east\" to=\"Key Room\">\r\n      <inherit name=\"eastdirection\" />\r\n      <locked />\r\n      <runscript />\r\n      <script type=\"script\"><![CDATA[\r\n        if (DoorKey.parent=game.pov and this.locked=true) {\r\n          msg (\"<i>You unlock the door and enter</i>\")\r\n          this.locked = false\r\n          game.pov.parent = Key Room\r\n        }\r\n        else if (this.locked=true) {\r\n          msg (\"That way is locked.\")\r\n        }\r\n        else {\r\n          game.pov.parent = Key Room\r\n        }\r\n      ]]></script>\r\n    </exit>\r\n    <exit alias=\"north\" to=\"SideRoom\">\r\n      <inherit name=\"northdirection\" />\r\n    </exit>\r\n    <object name=\"DoorKey\">\r\n      <inherit name=\"editor_object\" />\r\n      <take />\r\n      <alias>Key</alias>\r\n      <feature_usegive />\r\n      <use type=\"script\"><![CDATA[\r\n        if (game.pov.parent=room and KeyRoomDoor.locked=True) {\r\n          msg (\"<i>Using the key, you unlock the door!</i>\")\r\n          KeyRoomDoor.locked = False\r\n          msg (\"<br>As you walk through the door, the key disintegrates in your hand, <i>destroying</i> it. (i.e. The Key object itself has been destroyed. If you type 'SaveCode' now, when you load that save the Key will still be destroyed!)\")\r\n          destroy (\"DoorKey\")\r\n        }\r\n        else if (game.pov.parent=room and KeyRoomDoor.locked=False) {\r\n          msg (\"<i>The door is already unlocked!</i>\")\r\n        }\r\n        else {\r\n          msg (\"<i>There are no locks to use this on here!</i>\")\r\n        }\r\n      ]]></use>\r\n    </object>\r\n    <object name=\"SaveCheckpoint Button\">\r\n      <inherit name=\"editor_object\" />\r\n      <look><![CDATA[Using this button will create a checkpoint! Using it more than once will overwrite the existing checkpoint.<br/><br/>If you find the LoadCheckpoint Button, you can then load the checkpoint created here.]]></look>\r\n      <feature_usegive />\r\n      <displayverbs type=\"stringlist\">\r\n        <value>Look at</value>\r\n        <value>Use</value>\r\n      </displayverbs>\r\n      <use type=\"script\">\r\n        SaveCheckpoint (\"Checkpoint\")\r\n      </use>\r\n    </object>\r\n  </object>\r\n  <object name=\"Key Room\">\r\n    <inherit name=\"editor_room\" />\r\n    <description><![CDATA[You made it in!<br/><br/>If you save now and load from a new game, this room will still be unlocked!]]></description>\r\n    <enter type=\"script\">\r\n    </enter>\r\n    <firstenter type=\"script\">\r\n    </firstenter>\r\n    <exit alias=\"west\" to=\"room\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"SideRoom\">\r\n    <inherit name=\"editor_room\" />\r\n    <description><![CDATA[A side room. When you load, this room will show up on the map since you've explored it now! (It was harder to make this happen than you think it would be...)<br/><br/>{here DoorKey:You see a {object:DoorKey} on the floor!}]]></description>\r\n    <exit alias=\"south\" to=\"room\">\r\n      <inherit name=\"southdirection\" />\r\n    </exit>\r\n    <exit alias=\"west\" to=\"OtherSideRoom\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n    <exit alias=\"down\" to=\"Basement\">\r\n      <inherit name=\"downdirection\" />\r\n    </exit>\r\n    <object name=\"LoadCheckpoint Button\">\r\n      <inherit name=\"editor_object\" />\r\n      <feature_usegive />\r\n      <use type=\"script\">\r\n        LoadCheckpoint (\"Checkpoint\")\r\n      </use>\r\n      <displayverbs type=\"stringlist\">\r\n        <value>Look at</value>\r\n        <value>Use</value>\r\n      </displayverbs>\r\n      <look>Using this button will load the checkpoint created by the SaveCheckpoint Button (if one was created...)</look>\r\n    </object>\r\n  </object>\r\n  <object name=\"OtherSideRoom\">\r\n    <inherit name=\"editor_room\" />\r\n    <exit alias=\"east\" to=\"SideRoom\">\r\n      <inherit name=\"eastdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"Basement\">\r\n    <inherit name=\"editor_room\" />\r\n    <attr name=\"grid_fill\">Teal</attr>\r\n    <exit alias=\"up\" to=\"SideRoom\">\r\n      <inherit name=\"updirection\" />\r\n    </exit>\r\n    <exit alias=\"east\" to=\"Basement Side\">\r\n      <inherit name=\"eastdirection\" />\r\n    </exit>\r\n  </object>\r\n  <object name=\"Basement Side\">\r\n    <inherit name=\"editor_room\" />\r\n    <attr name=\"grid_fill\">Teal</attr>\r\n    <exit alias=\"west\" to=\"Basement\">\r\n      <inherit name=\"westdirection\" />\r\n    </exit>\r\n  </object>\r\n  <command>\r\n    <pattern>SaveCode</pattern>\r\n    <script>\r\n      SuppressTurnscripts\r\n      SaveGameCode (True)\r\n    </script>\r\n  </command>\r\n  <command>\r\n    <pattern>LoadCode</pattern>\r\n    <script>\r\n      SuppressTurnscripts\r\n      JS.LoadGamePrompt ()\r\n    </script>\r\n  </command>\r\n  <function name=\"LoadGameCode\" parameters=\"SaveGameCodeDecoded\"><![CDATA[\r\n    // LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\r\n    SuppressTurnscripts\r\n    // NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\r\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\n    OldestAllowedVersion = 2.0\r\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\n    DebugMode = False\r\n    // Msg for Debugging:\r\n    if (DebugMode) {\r\n      msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n    }\r\n    // Set up other variables for later\r\n    bla => {\r\n    }\r\n    upgradesave = False\r\n    Proceed = False\r\n    SkippedAttList = \"\"\r\n    CreatedObjDebugList = \"\"\r\n    DestroyedObjDebugList = \"\"\r\n    // Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\r\n    CheckForCheck = Right(SaveGameCodeDecoded,2)\r\n    if (CheckForCheck=\"✓✓\") {\r\n      upgradesave = True\r\n      SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\r\n    }\r\n    // Retrieve delimiters from end of SaveGameCodeDecoded\r\n    Dls = Right(SaveGameCodeDecoded,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Remove delimiters from end of SaveGameCode\r\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n    // Special logic to extract saved game.checkpoints attribute\r\n    D4toD1 = D4+D3+D2+D1\r\n    CheckpointSplit = Split(SaveCode, D4toD1)\r\n    SaveCode = ListItem(CheckpointSplit,0)\r\n    CheckpointKeys = ListItem(CheckpointSplit,1)\r\n    // If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\r\n    if (not CheckpointKeys=\"\") {\r\n      CheckpointKeyList = Split(CheckpointKeys, D3)\r\n      game.checkpoints = NewStringDictionary()\r\n      for (xx, 0, ListCount(CheckpointKeyList)-1) {\r\n        key = ListItem(CheckpointKeyList,xx)\r\n        val = ListItem(CheckpointSplit,xx+1)\r\n        DictionaryAdd (game.checkpoints, key, val)\r\n      }\r\n    }\r\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n    }\r\n    CDList = Split(CreatedDestroyedInfo,D1)\r\n    CSection = ListItem (CDList, 0)\r\n    DSection = ListItem (CDList, 1)\r\n    if (CSection=\"\") {\r\n      CreatedList = NewStringList()\r\n    }\r\n    else {\r\n      CreatedList = Split (CSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (CreatedList, \" \")\r\n    }\r\n    if (DSection=\"\") {\r\n      DestroyedList = NewStringList()\r\n    }\r\n    else {\r\n      DestroyedList = Split (DSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (DestroyedList, \" \")\r\n    }\r\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>GridGInfo: \"+GridGInfo)\r\n    }\r\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\n    if (DebugMode) {\r\n      msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n    }\r\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\n    GameIdDelim = Instr (SaveCode, D1)\r\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\n    GameIdObjectEl = ListItem (GameInfo,0)\r\n    GameIdElements = Split(GameIdObjectEl,D2)\r\n    Loaded_GameId = ListItem (GameIdElements, 3)\r\n    GameVerObjectEl = ListItem (GameInfo,1)\r\n    GameVerElements = Split(GameVerObjectEl,D2)\r\n    VersionString = ListItem (GameVerElements, 3)\r\n    Loaded_GameVersion = ToDouble(VersionString)\r\n    GamePOVObjectEl = ListItem (GameInfo,2)\r\n    GamePOVElements = Split(GamePOVObjectEl,D2)\r\n    GamePOVName = ListItem (GamePOVElements, 3)\r\n    if (StartsWith(GamePOVName,\"Object: \")) {\r\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n    }\r\n    GamePOVObject = GetObject (GamePOVName)\r\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n    // Check that the save belongs to this game by comparing gameIds\r\n    if (not Loaded_GameId=game.gameid) {\r\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n    }\r\n    else {\r\n      // Compare version of game in SaveCode to version of game loading it\r\n      ThisGame_GameVersion = ToDouble(game.version)\r\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n      }\r\n      else {\r\n        OldestAllowedVersion_Double = OldestAllowedVersion\r\n      }\r\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n      if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n        if (upgradesave = False) {\r\n          if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n            msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br><br>Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\r\n            // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\r\n            create (\"SaveGameDecodedObj\")\r\n            set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\r\n            ShowMenu (\"\", Split(\"Yes;No\"), false) {\r\n              switch (result) {\r\n                case (\"Yes\") {\r\n                  SuppressTurnscripts\r\n                  msg (\"Save code identified! Proceeding with load, please wait...\")\r\n                  OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\r\n                  LoadGameCode (OlderSaveCode)\r\n                  destroy (\"SaveGameDecodedObj\")\r\n                }\r\n                case (\"No\") {\r\n                  SuppressTurnscripts\r\n                  msg (\"Load Aborted.\")\r\n                  destroy (\"SaveGameDecodedObj\")\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n          }\r\n        }\r\n        else {\r\n          msg (\"Applying savecode from older version...\")\r\n          Proceed = True\r\n        }\r\n      }\r\n      else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n      }\r\n      else {\r\n        msg (\"Proceeding with load...\")\r\n        Proceed = True\r\n      }\r\n      if (Proceed=True) {\r\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n        if (ListCount(CreatedList)>0) {\r\n          foreach (o, CreatedList) {\r\n            // Check that objects don't already exist...\r\n            IsThere = GetObject(o)\r\n            if (Equal(IsThere,null)) {\r\n              // If not, create the object\r\n              create (o)\r\n              CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        player.grid_coordinates = null\r\n        // Split the save code up into all objects. Then parse through the value of each object attribute\r\n        SavedObjectList = Split(SaveCode, D1)\r\n        foreach (o, SavedObjectList) {\r\n          Skip_Att = False\r\n          objelements = Split(o, D2)\r\n          objectname = ListItem (objelements, 0)\r\n          object = GetObject (objectname)\r\n          attributename = ListItem (objelements, 1)\r\n          fullname = objectname+\".\"+attributename\r\n          preload_att_value = GetAttribute (object, attributename)\r\n          att_datatype = ListItem (objelements, 2)\r\n          if (ListCount(objelements)=3) {\r\n            att_value = \"\"\r\n          }\r\n          else {\r\n            att_value = ListItem (objelements, 3)\r\n          }\r\n          // Check that the attribute is supported\r\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n            Skip_Att = True\r\n            SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n          }\r\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n          att_value_obj = att_value\r\n          if (att_datatype=\"object\") {\r\n            if (StartsWith(att_value,\"Object: \")) {\r\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              att_value_obj = GetObject(att_value)\r\n            }\r\n          }\r\n          else if (att_datatype=\"boolean\") {\r\n            if (att_value=\"True\") {\r\n              att_value_obj = True\r\n            }\r\n            else {\r\n              att_value_obj = False\r\n            }\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            att_value_obj = ToInt(att_value)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            att_value_obj = ToDouble(att_value)\r\n          }\r\n          else if (att_datatype=\"stringlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringList()\r\n            }\r\n            else {\r\n              att_value_obj = Split (att_value, D3)\r\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n              list remove (att_value_obj, \" \")\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectList()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectList()\r\n              objlistlist = Split (att_value, D3)\r\n              foreach (olt, objlistlist) {\r\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n                if (StartsWith(olt,\"Object: \")) {\r\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n                  if (not value=null) {\r\n                    list add (att_value_obj, value)\r\n                  }\r\n                  else {\r\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewStringDictionary()\r\n              // Add dictionary values from SaveGame\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                value = ListItem(KeyValList, 1)\r\n                DictionaryAdd (att_value_obj, key, value)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectDictionary()\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                obj = ListItem(KeyValList, 1)\r\n                if (StartsWith(obj,\"Object: \")) {\r\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                }\r\n                else {\r\n                  value = obj\r\n                }\r\n                if (not value=null) {\r\n                  DictionaryAdd (att_value_obj, key, value)\r\n                }\r\n                else {\r\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (objectname=GamePOVName and attributename=\"parent\") {\r\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n            Skip_Att = True\r\n            GamePOVParent = att_value_obj\r\n          }\r\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n            if (Equal(preload_att_value,null)) {\r\n              if (DebugMode) {\r\n                msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n              }\r\n              preload_att_value = \"null\"\r\n            }\r\n            // Msgs for debugging:\r\n            if (DebugMode) {\r\n              msg (\"objectname=\"+objectname)\r\n              msg (\"attributename=\"+attributename)\r\n              msg (\"att_datatype=\"+att_datatype)\r\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n              if (Equal(preload_att_value,\"null\")) {\r\n                msg (\"preload_att_datatype=null\")\r\n              }\r\n              else {\r\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n              }\r\n              msg (\"att_value=\"+ToString(att_value))\r\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n              msg (\"<br>\")\r\n            }\r\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n              if (DebugMode) {\r\n                msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n              }\r\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n              cha = \"changed\" + attributename\r\n              if (HasAttribute (object, cha)) {\r\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n                scr = GetAttribute (object, cha)\r\n                set (object, cha, bla)\r\n              }\r\n              // Update the attributes in the game with those from the SaveCode...\r\n              if (att_datatype=\"boolean\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"int\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"double\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"object\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n                // NOTE TO DEVELOPER:\r\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n                if (upgradesave = True) {\r\n                  // This section will trigger if the player is loading a save from a previous game version\r\n                  ReplaceContents = True\r\n                }\r\n                else {\r\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n                  ReplaceContents = True\r\n                }\r\n                if (att_datatype=\"stringlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace stringlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                    FinalList = NewStringList()\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    CompactList = ListCompact (CombinedList)\r\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                    foreach (olt, CompactList) {\r\n                      list add (FinalList, olt)\r\n                    }\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace objectlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    FinalList = ObjectListCompact (CombinedList)\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"stringdictionary\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                    Dummy = NewStringDictionary()\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectdictionary\") {\r\n                  if (upgradesave = False) {\r\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      if (StartsWith(value,\"Object: \")) {\r\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                      }\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n              }\r\n              else if (att_datatype=\"string\") {\r\n                set (object, attributename, att_value)\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n              }\r\n              if (HasAttribute (object, cha)) {\r\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n                set (object, cha, scr)\r\n                scr => {\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n        AllSavedGrids = Split(GridGInfo,D4)\r\n        if (DebugMode) {\r\n          msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n        }\r\n        foreach (A, AllSavedGrids) {\r\n          UDictionary = NewDictionary()\r\n          ItemAndValue = Split(A,\"&%&\")\r\n          ObjAndAtt = ListItem(ItemAndValue,0)\r\n          ObjAndAtt = Split(ObjAndAtt,D2)\r\n          objectname = ListItem(ObjAndAtt,0)\r\n          attributename = ListItem(ObjAndAtt,1)\r\n          object = GetObject(objectname)\r\n          GridVals = ListItem(ItemAndValue,1)\r\n          GridVals = Split(GridVals,D1)\r\n          foreach (B, GridVals) {\r\n            UKeyAndUVal = Split(B,D2)\r\n            UKey = ListItem(UKeyAndUVal,0)\r\n            UVal = ListItem(UKeyAndUVal,1)\r\n            UVal = Split(UVal,D3)\r\n            LDictionary = NewDictionary()\r\n            foreach (C, UVal) {\r\n              LkeyAndLval = Split(C,\" = \")\r\n              Lkey = ListItem(LkeyAndLval,0)\r\n              LvalAndType = ListItem(LkeyAndLval,1)\r\n              LvalAndType = Split(LvalAndType,\":\")\r\n              Lval_str = ListItem(LvalAndType,0)\r\n              LType = ListItem(LvalAndType,1)\r\n              if (LType=\"int\") {\r\n                Lval = ToInt(Lval_str)\r\n              }\r\n              else if (LType=\"double\") {\r\n                Lval = ToDouble(Lval_str)\r\n              }\r\n              else if (LType=\"boolean\") {\r\n                if (Lval_str=\"True\") {\r\n                  Lval = True\r\n                }\r\n                else {\r\n                  Lval = False\r\n                }\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n              }\r\n              DictionaryAdd (LDictionary, Lkey, Lval)\r\n            }\r\n            DictionaryAdd (UDictionary, UKey, LDictionary)\r\n          }\r\n          if (DebugMode) {\r\n            msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n          }\r\n          set (object, attributename, UDictionary)\r\n        }\r\n        // Destroy any objects that the player destroyed during their saved game, if any\r\n        if (ListCount(DestroyedList)>0) {\r\n          foreach (o, DestroyedList) {\r\n            // Check that objects still exist...\r\n            IsThere = GetObject(o)\r\n            if (not Equal(IsThere,null)) {\r\n              // If its there, destroy the object\r\n              destroy (o)\r\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        msg (\"Load complete!\")\r\n        if (DebugMode) {\r\n          msg (\"Created objects: \"+CreatedObjDebugList)\r\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n          msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n        }\r\n        // Finally, update game.pov.parent and game.pov\r\n        wait {\r\n          set (GamePOVObject, \"parent\", GamePOVParent)\r\n          game.pov = GamePOVObject\r\n          // player.grid_coordinates = null\r\n          JS.Grid_ClearAllLayers ()\r\n          Grid_Redraw\r\n          Grid_DrawPlayerInRoom (game.pov.parent)\r\n          ClearScreen\r\n          ShowRoomDescription\r\n        }\r\n      }\r\n    }\r\n  ]]></function>\r\n  <function name=\"SaveGameCode\" parameters=\"ShowCodePopupFlag\" type=\"string\"><![CDATA[\r\n    // SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\r\n    // The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\r\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\n    SuppressTurnscripts\r\n    // Make sure ShowCodePopupFlag is of type 'boolean'\r\n    if (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\r\n      X = TypeOf(ShowCodePopupFlag)\r\n      error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    SaveString = \"\"\r\n    CreatedObj = NewStringList()\r\n    DestroyedObj = NewStringList()\r\n    // Set delimiters.\r\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\n    D1 = \"|\"\r\n    D2 = \"$\"\r\n    D3 = \";\"\r\n    D4 = \"@\"\r\n    // Save the player's current map before saving\r\n    // Make sure first two entries are gameid and version (for load function)\r\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n    // Record all changable object attributes\r\n    foreach (o, AllObjects()) {\r\n      objectname = o.name\r\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n            // Confirm there are no banned delimiters in the list entries\r\n            v = GetAttribute (o, attributename)\r\n            if (ListCount(v)>0) {\r\n              if (att_datatype=\"stringlist\") {\r\n                foreach (listcheck, v) {\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n            // Confirm there are no banned delimiters in the dictionary entries\r\n            v = GetAttribute (o, attributename)\r\n            if (DictionaryCount(v)>0) {\r\n              foreach (dictkey, v) {\r\n                if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                }\r\n                if (att_datatype=\"stringdictionary\") {\r\n                  dictitm = DictionaryItem (v, dictkey)\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (o, AllExits()) {\r\n      objectname = o.name\r\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (turnscript, AllTurnScripts()) {\r\n      // Check for which turnscripts are enabled/disabled\r\n      if (GetBoolean(turnscript, \"enabled\")) {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n      }\r\n      else {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n      }\r\n    }\r\n    // Determine if any objects were destroyed by the player since game start...\r\n    foreach (objectname, game.StartingObjStrList) {\r\n      IsThere = GetObject(objectname)\r\n      if (Equal(IsThere,null)) {\r\n        list add (DestroyedObj, objectname)\r\n      }\r\n    }\r\n    // Save the game.timeelapsed attribute\r\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\r\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\n    if (HasAttribute (game, \"SaveAtts\")) {\r\n      SaveAttType = TypeOf(game.SaveAtts)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveAtts)>0) {\r\n          foreach (x, game.SaveAtts) {\r\n            AttValue = GetAttribute (game, x)\r\n            att_datatype = TypeOf(AttValue)\r\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n            }\r\n            else if (Equal(x,\"checkpoints\")) {\r\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n            }\r\n            else if (Equal(AttValue,null)) {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\n    if (HasAttribute (game, \"SaveTimers\")) {\r\n      SaveAttType = TypeOf(game.SaveTimers)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveTimers)>0) {\r\n          foreach (x, game.SaveTimers) {\r\n            T = GetObject(x)\r\n            if (not Equal(T,null)) {\r\n              TimerName = x.name\r\n              TimerValue1 = x.trigger\r\n              TimerValue2 = x.interval\r\n              TimerValue3 = x.enabled\r\n              TimerValue1Type = TypeOf(TimerValue1)\r\n              TimerValue2Type = TypeOf(TimerValue2)\r\n              TimerValue3Type = TypeOf(TimerValue3)\r\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\n    foreach (o, AllObjects()) {\r\n      foreach (attributename, GetAttributeNames(o,false)) {\r\n        objectname = o.name\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add on the list of created/destroyed objects...\r\n    X = ToString(CreatedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    X = ToString(DestroyedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n    // Special logic needed in order to save the game.checkpoints attribute\r\n    D4toD1 = D4+D3+D2+D1\r\n    if (HasAttribute(game,\"checkpoints\")) {\r\n      if (DictionaryCount(game.checkpoints)>0) {\r\n        KeyList = \"\"\r\n        CheckValList = \"\"\r\n        foreach (k, game.checkpoints) {\r\n          KeyList = KeyList+k+D3\r\n          val = DictionaryItem(game.checkpoints, k)\r\n          CheckValList = CheckValList+val+D4toD1\r\n        }\r\n        // Remove final D3 from KeyList string and final D4toD1 from CheckValList\r\n        KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\r\n        CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\r\n        // Add game.checkpoints data to SaveString\r\n        SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\r\n      }\r\n      else {\r\n        // If game.checkpoints empty, just add D4toD1 to SaveString.\r\n        SaveString = SaveString+D4toD1\r\n      }\r\n    }\r\n    else {\r\n      // If game.checkpoints non-existant, just add D4toD1 to SaveString.\r\n      SaveString = SaveString+D4toD1\r\n    }\r\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\n    SaveString = SaveString+D1+D2+D3+D4\r\n    // msg for Debugging:\r\n    // msg (SaveString+\"<br><br>\")\r\n    if (ShowCodePopupFlag=True) {\r\n      // Create save code and present to player in textbox\r\n      JS.CreateSaveCode (SaveString)\r\n      JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\r\n    }\r\n    return (SaveString)\r\n  ]]></function>\r\n  <function name=\"SaveCheckpoint\" parameters=\"CheckpointName\" type=\"string\"><![CDATA[\r\n    // SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\r\n    // The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\r\n    // If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\r\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\r\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\r\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\r\n    SuppressTurnscripts\r\n    // Check if game.checkpoints exists. If not, create it.\r\n    if (not HasAttribute(game, \"checkpoints\")) {\r\n      set (game, \"checkpoints\", NewStringDictionary())\r\n    }\r\n    // Make sure CheckpointName input is of 'string' datatype\r\n    if (not TypeOf(CheckpointName)=\"string\") {\r\n      X = TypeOf(CheckpointName)\r\n      error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    SaveString = \"\"\r\n    CreatedObj = NewStringList()\r\n    DestroyedObj = NewStringList()\r\n    // Set delimiters.\r\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\r\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\r\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\r\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\r\n    D1 = \"|\"\r\n    D2 = \"$\"\r\n    D3 = \";\"\r\n    D4 = \"@\"\r\n    // Save the player's current map before saving\r\n    // Make sure first two entries are gameid and version (for load function)\r\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\r\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\r\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\r\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\r\n    // Record all changable object attributes\r\n    foreach (o, AllObjects()) {\r\n      objectname = o.name\r\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n            // Confirm there are no banned delimiters in the list entries\r\n            v = GetAttribute (o, attributename)\r\n            if (ListCount(v)>0) {\r\n              if (att_datatype=\"stringlist\") {\r\n                foreach (listcheck, v) {\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(listcheck,D1)>0 or Instr(listcheck,D2)>0 or Instr(listcheck,D3)>0 or Instr(listcheck,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n            // Confirm there are no banned delimiters in the dictionary entries\r\n            v = GetAttribute (o, attributename)\r\n            if (DictionaryCount(v)>0) {\r\n              foreach (dictkey, v) {\r\n                if (Instr(dictkey,D1)>0 or Instr(dictkey,D2)>0 or Instr(dictkey,D3)>0 or Instr(dictkey,D4)>0) {\r\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                }\r\n                if (att_datatype=\"stringdictionary\") {\r\n                  dictitm = DictionaryItem (v, dictkey)\r\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\r\n                  if (Instr(dictitm,D1)>0 or Instr(dictitm,D2)>0 or Instr(dictitm,D3)>0 or Instr(dictitm,D4)>0) {\r\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (o, AllExits()) {\r\n      objectname = o.name\r\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\r\n      if (not ListContains(game.StartingObjStrList, objectname)) {\r\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\r\n        if (not ListContains(CreatedObj, objectname)) {\r\n          list add (CreatedObj, objectname)\r\n        }\r\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\r\n        IncludeTypeFlag = True\r\n      }\r\n      else {\r\n        IncludeTypeFlag = False\r\n      }\r\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\r\n          if (att_datatype=\"object\") {\r\n            v = GetAttribute (o, attributename)\r\n            att_value = v.name\r\n          }\r\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n          }\r\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n            X = ToString(GetAttribute (o, attributename))\r\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\r\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\r\n          }\r\n          else {\r\n            att_value = ToString(GetAttribute (o, attributename))\r\n          }\r\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\r\n          if (Instr(objectname,D1)>0 or Instr(objectname,D2)>0 or Instr(objectname,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(attributename,D1)>0 or Instr(attributename,D2)>0 or Instr(attributename,D3)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\r\n          }\r\n          else if (Instr(att_value,D1)>0 or Instr(att_value,D2)>0 or Instr(objectname,D4)>0) {\r\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\r\n          }\r\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\r\n        }\r\n      }\r\n    }\r\n    foreach (turnscript, AllTurnScripts()) {\r\n      // Check for which turnscripts are enabled/disabled\r\n      if (GetBoolean(turnscript, \"enabled\")) {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\r\n      }\r\n      else {\r\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\r\n      }\r\n    }\r\n    // Determine if any objects were destroyed by the player since game start...\r\n    foreach (objectname, game.StartingObjStrList) {\r\n      IsThere = GetObject(objectname)\r\n      if (Equal(IsThere,null)) {\r\n        list add (DestroyedObj, objectname)\r\n      }\r\n    }\r\n    // Save the game.timeelapsed attribute\r\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\r\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\r\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\r\n    if (HasAttribute (game, \"SaveAtts\")) {\r\n      SaveAttType = TypeOf(game.SaveAtts)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveAtts)>0) {\r\n          foreach (x, game.SaveAtts) {\r\n            AttValue = GetAttribute (game, x)\r\n            att_datatype = TypeOf(AttValue)\r\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\r\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\r\n            }\r\n            else if (Equal(x,\"checkpoints\")) {\r\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\r\n            }\r\n            else if (Equal(AttValue,null)) {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\r\n    if (HasAttribute (game, \"SaveTimers\")) {\r\n      SaveAttType = TypeOf(game.SaveTimers)\r\n      if (SaveAttType=\"stringlist\") {\r\n        if (ListCount(game.SaveTimers)>0) {\r\n          foreach (x, game.SaveTimers) {\r\n            T = GetObject(x)\r\n            if (not Equal(T,null)) {\r\n              TimerName = x.name\r\n              TimerValue1 = x.trigger\r\n              TimerValue2 = x.interval\r\n              TimerValue3 = x.enabled\r\n              TimerValue1Type = TypeOf(TimerValue1)\r\n              TimerValue2Type = TypeOf(TimerValue2)\r\n              TimerValue3Type = TypeOf(TimerValue3)\r\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\r\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\r\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\r\n            }\r\n            else {\r\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\r\n      }\r\n    }\r\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\r\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\r\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\r\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\r\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\r\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\r\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\r\n    foreach (o, AllObjects()) {\r\n      foreach (attributename, GetAttributeNames(o,false)) {\r\n        objectname = o.name\r\n        fullname = objectname+\".\"+attributename\r\n        att_datatype = ToString(TypeOf(o, attributename))\r\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\r\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\r\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\r\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&%&\"\r\n          foreach (UKey, GetAttribute(o, attributename)) {\r\n            SaveString = SaveString+UKey+D2\r\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\r\n            foreach (Lkey, UVal) {\r\n              Lval = DictionaryItem(UVal, Lkey)\r\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\r\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\r\n            }\r\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Add on the list of created/destroyed objects...\r\n    X = ToString(CreatedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    X = ToString(DestroyedObj)\r\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\r\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\r\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\r\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\r\n    SaveString = SaveString+D1+D2+D3+D4\r\n    // msg for Debugging:\r\n    // msg (SaveString+\"<br><br>\")\r\n    // Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\r\n    if (not CheckpointName=\"\") {\r\n      DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\r\n    }\r\n    return (SaveString)\r\n  ]]></function>\r\n  <function name=\"LoadCheckpoint\" parameters=\"CheckpointName\"><![CDATA[\r\n    // LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\r\n    // Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\r\n    SuppressTurnscripts\r\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\r\n    OldestAllowedVersion = 2.0\r\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\r\n    DebugMode = False\r\n    // Msg for Debugging:\r\n    if (DebugMode) {\r\n      msg (\"<br>Full decoded SaveCode:<br>\"+SaveGameCodeDecoded)\r\n    }\r\n    // Make sure CheckpointName input is of type 'string'\r\n    if (not TypeOf(CheckpointName)=\"string\") {\r\n      X = TypeOf(CheckpointName)\r\n      error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\r\n    }\r\n    // Retrieve SaveString from game.checkpoints dictionary\r\n    if (HasAttribute(game, \"checkpoints\")) {\r\n      if (DictionaryContains(game.checkpoints, CheckpointName)) {\r\n        SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\r\n      }\r\n      else {\r\n        error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\r\n      }\r\n    }\r\n    else {\r\n      error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\r\n    }\r\n    // Set up other variables for later\r\n    bla => {\r\n    }\r\n    upgradesave = False\r\n    Proceed = False\r\n    SkippedAttList = \"\"\r\n    CreatedObjDebugList = \"\"\r\n    DestroyedObjDebugList = \"\"\r\n    // Retrieve delimiters from end of SaveGameCodeDecoded\r\n    Dls = Right(SaveGameCodeDecoded,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Remove delimiters from end of SaveGameCode\r\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\r\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\r\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\r\n    }\r\n    CDList = Split(CreatedDestroyedInfo,D1)\r\n    CSection = ListItem (CDList, 0)\r\n    DSection = ListItem (CDList, 1)\r\n    if (CSection=\"\") {\r\n      CreatedList = NewStringList()\r\n    }\r\n    else {\r\n      CreatedList = Split (CSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (CreatedList, \" \")\r\n    }\r\n    if (DSection=\"\") {\r\n      DestroyedList = NewStringList()\r\n    }\r\n    else {\r\n      DestroyedList = Split (DSection, D3)\r\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n      list remove (DestroyedList, \" \")\r\n    }\r\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\r\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\r\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\r\n    if (DebugMode) {\r\n      msg (\"<br>GridGInfo: \"+GridGInfo)\r\n    }\r\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 & D4 delimiter separating the grid_coordinates from the rest of the attributes\r\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\r\n    if (DebugMode) {\r\n      msg (\"<br>SaveCode w/o player.grid_coordinate or create/destroy info:<br>\"+SaveCode)\r\n    }\r\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\r\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\r\n    GameIdDelim = Instr (SaveCode, D1)\r\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\r\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\r\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\r\n    GameIdObjectEl = ListItem (GameInfo,0)\r\n    GameIdElements = Split(GameIdObjectEl,D2)\r\n    Loaded_GameId = ListItem (GameIdElements, 3)\r\n    GameVerObjectEl = ListItem (GameInfo,1)\r\n    GameVerElements = Split(GameVerObjectEl,D2)\r\n    VersionString = ListItem (GameVerElements, 3)\r\n    Loaded_GameVersion = ToDouble(VersionString)\r\n    GamePOVObjectEl = ListItem (GameInfo,2)\r\n    GamePOVElements = Split(GamePOVObjectEl,D2)\r\n    GamePOVName = ListItem (GamePOVElements, 3)\r\n    if (StartsWith(GamePOVName,\"Object: \")) {\r\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\r\n    }\r\n    GamePOVObject = GetObject (GamePOVName)\r\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\r\n    // Check that the save belongs to this game by comparing gameIds\r\n    if (not Loaded_GameId=game.gameid) {\r\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\r\n    }\r\n    else {\r\n      // Compare version of game in SaveCode to version of game loading it\r\n      ThisGame_GameVersion = ToDouble(game.version)\r\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\r\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\r\n      }\r\n      else {\r\n        OldestAllowedVersion_Double = OldestAllowedVersion\r\n      }\r\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\r\n      if (Loaded_GameVersion<ThisGame_GameVersion) {\r\n        if (OldestAllowedVersion_Double<=Loaded_GameVersion) {\r\n          upgradesave = True\r\n          Proceed = True\r\n        }\r\n        else {\r\n          error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"<br><br>Loading aborted...\")\r\n        }\r\n      }\r\n      else if (Loaded_GameVersion>ThisGame_GameVersion) {\r\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.<br>Saved Game: v\"+ToString(Loaded_GameVersion)+\"<br>This Game: v\"+ToString(ThisGame_GameVersion)+\"<br>Please try a different SaveCode or use an updated game file.<br><br>Load aborted.\")\r\n      }\r\n      else {\r\n        Proceed = True\r\n      }\r\n      if (Proceed=True) {\r\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\r\n        if (ListCount(CreatedList)>0) {\r\n          foreach (o, CreatedList) {\r\n            // Check that objects don't already exist...\r\n            IsThere = GetObject(o)\r\n            if (Equal(IsThere,null)) {\r\n              // If not, create the object\r\n              create (o)\r\n              CreatedObjDebugList = CreatedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        player.grid_coordinates = null\r\n        // Split the save code up into all objects. Then parse through the value of each object attribute\r\n        SavedObjectList = Split(SaveCode, D1)\r\n        foreach (o, SavedObjectList) {\r\n          Skip_Att = False\r\n          objelements = Split(o, D2)\r\n          objectname = ListItem (objelements, 0)\r\n          object = GetObject (objectname)\r\n          attributename = ListItem (objelements, 1)\r\n          fullname = objectname+\".\"+attributename\r\n          preload_att_value = GetAttribute (object, attributename)\r\n          att_datatype = ListItem (objelements, 2)\r\n          if (ListCount(objelements)=3) {\r\n            att_value = \"\"\r\n          }\r\n          else {\r\n            att_value = ListItem (objelements, 3)\r\n          }\r\n          // Check that the attribute is supported\r\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\r\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\r\n            Skip_Att = True\r\n            SkippedAttList = SkippedAttList+fullname+\"<br>\"\r\n          }\r\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\r\n          att_value_obj = att_value\r\n          if (att_datatype=\"object\") {\r\n            if (StartsWith(att_value,\"Object: \")) {\r\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\r\n            }\r\n            else {\r\n              att_value_obj = GetObject(att_value)\r\n            }\r\n          }\r\n          else if (att_datatype=\"boolean\") {\r\n            if (att_value=\"True\") {\r\n              att_value_obj = True\r\n            }\r\n            else {\r\n              att_value_obj = False\r\n            }\r\n          }\r\n          else if (att_datatype=\"int\") {\r\n            att_value_obj = ToInt(att_value)\r\n          }\r\n          else if (att_datatype=\"double\") {\r\n            att_value_obj = ToDouble(att_value)\r\n          }\r\n          else if (att_datatype=\"stringlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringList()\r\n            }\r\n            else {\r\n              att_value_obj = Split (att_value, D3)\r\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\r\n              list remove (att_value_obj, \" \")\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectlist\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectList()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectList()\r\n              objlistlist = Split (att_value, D3)\r\n              foreach (olt, objlistlist) {\r\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\r\n                if (StartsWith(olt,\"Object: \")) {\r\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\r\n                  if (not value=null) {\r\n                    list add (att_value_obj, value)\r\n                  }\r\n                  else {\r\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\r\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"stringdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewStringDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewStringDictionary()\r\n              // Add dictionary values from SaveGame\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                value = ListItem(KeyValList, 1)\r\n                DictionaryAdd (att_value_obj, key, value)\r\n              }\r\n            }\r\n          }\r\n          else if (att_datatype=\"objectdictionary\") {\r\n            if (att_value=\"\") {\r\n              att_value_obj = NewObjectDictionary()\r\n            }\r\n            else {\r\n              att_value_obj = NewObjectDictionary()\r\n              dictrows = Split(att_value, \";\")\r\n              foreach (kv, dictrows) {\r\n                if (DebugMode) {\r\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\r\n                }\r\n                KeyValList = Split(kv,\" = \")\r\n                key = ListItem(KeyValList, 0)\r\n                obj = ListItem(KeyValList, 1)\r\n                if (StartsWith(obj,\"Object: \")) {\r\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                }\r\n                else {\r\n                  value = obj\r\n                }\r\n                if (not value=null) {\r\n                  DictionaryAdd (att_value_obj, key, value)\r\n                }\r\n                else {\r\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\r\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"<br>\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (objectname=GamePOVName and attributename=\"parent\") {\r\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\r\n            Skip_Att = True\r\n            GamePOVParent = att_value_obj\r\n          }\r\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\r\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\r\n            if (Equal(preload_att_value,null)) {\r\n              if (DebugMode) {\r\n                msg (\"<br>ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!<br>\")\r\n              }\r\n              preload_att_value = \"null\"\r\n            }\r\n            // Msgs for debugging:\r\n            if (DebugMode) {\r\n              msg (\"objectname=\"+objectname)\r\n              msg (\"attributename=\"+attributename)\r\n              msg (\"att_datatype=\"+att_datatype)\r\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\r\n              if (Equal(preload_att_value,\"null\")) {\r\n                msg (\"preload_att_datatype=null\")\r\n              }\r\n              else {\r\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\r\n              }\r\n              msg (\"att_value=\"+ToString(att_value))\r\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\r\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\r\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\r\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\r\n              msg (\"<br>\")\r\n            }\r\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\r\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\r\n              if (DebugMode) {\r\n                msg (\"Updating attribute: \"+fullname+\"<br><br>\")\r\n              }\r\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\r\n              cha = \"changed\" + attributename\r\n              if (HasAttribute (object, cha)) {\r\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\r\n                scr = GetAttribute (object, cha)\r\n                set (object, cha, bla)\r\n              }\r\n              // Update the attributes in the game with those from the SaveCode...\r\n              if (att_datatype=\"boolean\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"int\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"double\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"object\") {\r\n                set (object, attributename, att_value_obj)\r\n              }\r\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\r\n                // NOTE TO DEVELOPER:\r\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\r\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\r\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\r\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\r\n                if (upgradesave = True) {\r\n                  // This section will trigger if the player is loading a save from a previous game version\r\n                  ReplaceContents = True\r\n                }\r\n                else {\r\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\r\n                  ReplaceContents = True\r\n                }\r\n                if (att_datatype=\"stringlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace stringlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\r\n                    FinalList = NewStringList()\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    CompactList = ListCompact (CombinedList)\r\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\r\n                    foreach (olt, CompactList) {\r\n                      list add (FinalList, olt)\r\n                    }\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectlist\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Completely replace objectlist contents with those found in the SaveCode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\r\n                    // Retrieve the contents of the existing list\r\n                    PreLoadList = preload_att_value\r\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\r\n                    // Remove duplicates\r\n                    FinalList = ObjectListCompact (CombinedList)\r\n                    set (object, attributename, FinalList)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"stringdictionary\") {\r\n                  if (ReplaceContents = True) {\r\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                    Dummy = NewStringDictionary()\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n                else if (att_datatype=\"objectdictionary\") {\r\n                  if (upgradesave = False) {\r\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\r\n                    set (object, attributename, att_value_obj)\r\n                  }\r\n                  else {\r\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\r\n                    Dummy = preload_att_value\r\n                    // Add dictionary values from SaveGame\r\n                    dictrows = Split(att_value, \";\")\r\n                    foreach (kv, dictrows) {\r\n                      KeyValList = Split(kv,\" = \")\r\n                      key = ListItem(KeyValList, 0)\r\n                      value = ListItem(KeyValList, 1)\r\n                      if (StartsWith(value,\"Object: \")) {\r\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\r\n                      }\r\n                      DictionaryAdd (Dummy, key, value)\r\n                    }\r\n                    set (object, attributename, Dummy)\r\n                  }\r\n                }\r\n              }\r\n              else if (att_datatype=\"string\") {\r\n                set (object, attributename, att_value)\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\r\n              }\r\n              if (HasAttribute (object, cha)) {\r\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\r\n                set (object, cha, scr)\r\n                scr => {\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\r\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&%&Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\r\n        AllSavedGrids = Split(GridGInfo,D4)\r\n        if (DebugMode) {\r\n          msg (\"<br>AllSavedGrids: \"+ToString(AllSavedGrids))\r\n        }\r\n        foreach (A, AllSavedGrids) {\r\n          UDictionary = NewDictionary()\r\n          ItemAndValue = Split(A,\"&%&\")\r\n          ObjAndAtt = ListItem(ItemAndValue,0)\r\n          ObjAndAtt = Split(ObjAndAtt,D2)\r\n          objectname = ListItem(ObjAndAtt,0)\r\n          attributename = ListItem(ObjAndAtt,1)\r\n          object = GetObject(objectname)\r\n          GridVals = ListItem(ItemAndValue,1)\r\n          GridVals = Split(GridVals,D1)\r\n          foreach (B, GridVals) {\r\n            UKeyAndUVal = Split(B,D2)\r\n            UKey = ListItem(UKeyAndUVal,0)\r\n            UVal = ListItem(UKeyAndUVal,1)\r\n            UVal = Split(UVal,D3)\r\n            LDictionary = NewDictionary()\r\n            foreach (C, UVal) {\r\n              LkeyAndLval = Split(C,\" = \")\r\n              Lkey = ListItem(LkeyAndLval,0)\r\n              LvalAndType = ListItem(LkeyAndLval,1)\r\n              LvalAndType = Split(LvalAndType,\":\")\r\n              Lval_str = ListItem(LvalAndType,0)\r\n              LType = ListItem(LvalAndType,1)\r\n              if (LType=\"int\") {\r\n                Lval = ToInt(Lval_str)\r\n              }\r\n              else if (LType=\"double\") {\r\n                Lval = ToDouble(Lval_str)\r\n              }\r\n              else if (LType=\"boolean\") {\r\n                if (Lval_str=\"True\") {\r\n                  Lval = True\r\n                }\r\n                else {\r\n                  Lval = False\r\n                }\r\n              }\r\n              else {\r\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\r\n              }\r\n              DictionaryAdd (LDictionary, Lkey, Lval)\r\n            }\r\n            DictionaryAdd (UDictionary, UKey, LDictionary)\r\n          }\r\n          if (DebugMode) {\r\n            msg (\"<br>\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\r\n          }\r\n          set (object, attributename, UDictionary)\r\n        }\r\n        // Destroy any objects that the player destroyed during their saved game, if any\r\n        if (ListCount(DestroyedList)>0) {\r\n          foreach (o, DestroyedList) {\r\n            // Check that objects still exist...\r\n            IsThere = GetObject(o)\r\n            if (not Equal(IsThere,null)) {\r\n              // If its there, destroy the object\r\n              destroy (o)\r\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"<br>\"\r\n            }\r\n          }\r\n        }\r\n        if (DebugMode) {\r\n          msg (\"Created objects: \"+CreatedObjDebugList)\r\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\r\n          msg (\"Skipped Attributes:<br>\"+SkippedAttList)\r\n        }\r\n        // Finally, update game.pov.parent and game.pov\r\n        set (GamePOVObject, \"parent\", GamePOVParent)\r\n        game.pov = GamePOVObject\r\n        // player.grid_coordinates = null\r\n        JS.Grid_ClearAllLayers ()\r\n        Grid_Redraw\r\n        Grid_DrawPlayerInRoom (game.pov.parent)\r\n        ClearScreen\r\n        ShowRoomDescription\r\n      }\r\n    }\r\n  ]]></function>\r\n  <function name=\"GetSaveGameCodeDelims\" type=\"stringlist\">\r\n    // GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\r\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\n    DelimList = NewStringList()\r\n    SaveString = SaveGameCode(False)\r\n    // Retrieve delimiters from end of SaveString\r\n    Dls = Right(SaveString,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Add to list\r\n    list add (DelimList, D1)\r\n    list add (DelimList, D2)\r\n    list add (DelimList, D3)\r\n    list add (DelimList, D4)\r\n    // Return the list of delimiters as a string list\r\n    return (DelimList)\r\n  </function>\r\n  <function name=\"GetSaveCheckpointDelims\" type=\"stringlist\">\r\n    // GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\r\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\r\n    DelimList = NewStringList()\r\n    SaveString = SaveCheckpoint(\"\")\r\n    // Retrieve delimiters from end of SaveString\r\n    Dls = Right(SaveString,4)\r\n    D1 = Mid (Dls, 1, 1)\r\n    D2 = Mid (Dls, 2, 1)\r\n    D3 = Mid (Dls, 3, 1)\r\n    D4 = Mid (Dls, 4, 1)\r\n    // Add to list\r\n    list add (DelimList, D1)\r\n    list add (DelimList, D2)\r\n    list add (DelimList, D3)\r\n    list add (DelimList, D4)\r\n    // Return the list of delimiters as a string list\r\n    return (DelimList)\r\n  </function>\r\n  <javascript src=\"SaveLoadJavaCode.js\" />\r\n</asl>\r\n```\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>Hello everyone!</p>\n<p>Been a big fan of text adventure games for a while, but just recently decided to try my hand at making one of my own! One of the things I wanted to be able to do with my game was give the player the ability to save their game and resume playing even on a future version of the game.</p>\n<p>I considered using the SaveLoad library created by Pix (<a href=\"https://github.com/ThePix/quest/wiki/Library:-Save-and-Load\">https://github.com/ThePix/quest/wiki/Library:-Save-and-Load</a>), but unfortunately some of its limitations didn't quite work for what I had in mind. In particular, I wanted the player to be able to save their game to an actual file that could then be loaded on either the online player or desktop player. The solution I came up with was a copy/pastable code that could then be saved locally, but you may prefer Pix's cleaner in-game save/load menu solution. Additionally, I wanted to be able to change the player object (game.pov) mid-game, which is unfortunately a limitation of Pix's library.</p>\n<p>Besides that, one of the primary differences between Pix's SaveLoad library and mine is that their library saves objects explicitly, rather than procedurally, which allows the author to ensure they're ONLY saving the attributes they want to in exchange for some extra legwork. My library, on the other hand, grabs everything it can, then excludes the attributes you don't want. This means that although my library is (theoretically) easier to integrate into existing games, extra care may be required to ensure you're saving all the attributes you truly want to (especially when it comes to ensuring compatibility between saves). I highly recommend checking out Pix's library as well as mine, as both have their merits!</p>\n<p>This may be something that others have already encountered and come up with solutions for, but I wasn't able to find any concrete examples in my online or forum searches, so I figured I would share my solution here in case others would like to use it as well!</p>\n<p>What I came up with is a system to save and load the player's game by creating a <b>SaveGameCode</b> function that collects nearly every attribute in the player's game, as well as a <b>LoadGameCode</b> function that parses out the saved code to update any changed attributes. Paired with some javascript to add a popup UI for the functions as well as base64 encoding (to limit the player's ability to directly edit savegames), I tried to keep everything as modular as possible, with self-explanatory comments, so others could use it too.</p>\n<h2>What do these functions do?</h2>\n<p>These functions allow you to save your game in the form of a base64-encoded code. This code can be saved locally, then copied into the load function to allow the player to load their game.</p>\n<p>What this means is that players can play the game online, save their progress to a save code, then load and resume that progress on a desktop version of the same game, or vice-versa. This also means that saves can be stored SEPARATELY from the rest of the Quest game, potentially allowing a player to continue their old save even on a new version of the game (provided you, as the author, account for that, but more on that in the wiki). Furthermore, loading a save code is typically MUCH faster than loading a traditional Quest 5.8 save, as traditional Quest saves save the ENTIRE game each time (and thus require you to load the entire game each time).</p>\n<h3>The <em>SaveGameCode</em> function</h3>\n<p>I encourage you to look at the source code to learn more, but at a high level the SaveGameCode function works by parsing through all objects, exits, and turnscripts in the game to save as many changeable attributes as possible in the form of a long 'SaveString'. There are some limitations to this (see the 'Limitations' section in the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a>), but for most applications the SaveString that is created is enough to completely recreate the player's game state when fed back in to the LoadGameCode function. And all of this happens more or less <strong><em>automatically</em></strong> after installing the functions and javascript, so it can potentially be added on to nearly any existing game (barring limitations)!</p>\n<h3>The <em>LoadGameCode</em> function</h3>\n<p>You probably can guess, but the <em>LoadGameCode</em> function is responsible for parsing a given SaveString created by the SaveGameCode function, converting it back into usable object and attribute data, and updating the corresponding attributes in the game to recreate the player's saved state. There's a bit more to it, but that's the high-level explanation. To learn more, I again highly recommend checking out the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> and/or source code!</p>\n<h3>The <em>SaveLoadJavaCode.js</em> javascript</h3>\n<p>In addition to those two functions, I also included some additional javascript functions for converting the savecode to/from Base64 encoding (to make it a little harder to 'cheat' by editing your save state), as well as provide a nice UI for presenting the savecode and a nice UI for the player to paste existing savecodes into.</p>\n<h3><strong>New v3.0 Functions:</strong></h3>\n<details>\n<h3>The <em>SaveCheckpoints</em> function</h3>\n<p>SaveCheckpoint works very similarly to SaveGameCode, except instead of saving the SaveString to present it to the player, it instead will save a SaveString to a game.checkpoints stringdictionary. If game.checkpoints does not exist when SaveCheckpoints is called, then it will create it.</p>\n<p>This is useful for saving checkpoints internally that can then be loaded internally using the LoadCheckpoint function.</p>\n<p>See the <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">wiki</a> for more details.</p>\n<h3>The <em>LoadCheckpoint</em> function</h3>\n<p>LoadCheckpoint works very similarly to LoadGameCode, except it will not print any messages and it will not overwrite existing checkpoint data. It will also only load existing checkpoints. If it cannot find a matching checkpoint in game.checkpoints, it will throw an error.</p>\n<p>Useful for loading internally-created checkpoints (i.e. after a \"you have died! Would you like to reload before you died?\" type screen, for instance).</p>\n<h3>The <em>GetSaveGameCodeDelims</em> function</h3>\n<p>GetSaveGameCodeDelims() returns a stringlist of the delimiters used by the SaveGameCode function.</p>\n<p>Useful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveGameCode contain a banned delimiter, the game will not save/load properly.</p>\n<h3>The <em>GetSaveCheckpointDelims</em> function</h3>\n<p>GetSaveCheckpointDelims() returns a stringlist of the delimiters used by the SaveCheckpoint function.</p>\n<p>Useful for checking whether a user-entered input contains a banned delimiter before letting them change an attribute, (i.e. like in a \"enter your name\" screen taking user input to change the player.alias attribute). As a reminder, if any attributes saved by SaveCheckpoint contain a banned delimiter, the game will not save/load checkpoints properly.</p>\n</details>\n<hr>\nI've now completed the wiki page for these functions. Check it out if you're interested, as it goes into great detail regarding how to use these functions in your game, their limitations, workarounds, etc: <a href=\"https://github.com/Leviathon44/SaveLoadCode/wiki\">https://github.com/Leviathon44/SaveLoadCode/wiki</a>\n<p>I also created a small test game to show off the functionality here: <a href=\"http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/\">http://textadventures.co.uk/games/view/gsxdvwowaumaamc28spsga/</a></p>\n<p>I've also set up a git repository with these functions and commands drawn up in a library, 'SaveLoadCodeFunctionsLibrary.aslx', and the required javascript, 'SaveLoadJavaCode.js', here: <a href=\"https://github.com/Leviathon44/SaveLoadCode\">https://github.com/Leviathon44/SaveLoadCode</a>.</p>\n<p>The code is also posted farther down in this post, if you'd rather scroll than click the link.</p>\n<p>Special thanks to KV, mrangel, and Pix! I never spoke to any of you directly, but your forum posts and functions over the years were a valuable resource in getting this made! I hope others find this useful!</p>\n<hr>\n<h3>The SaveGameCode and LoadGameCode functions require the following javascript, 'SaveLoadJavaCode.js':</h3>\n<details>\n<p>(Disclaimer: I am not super familiar to javascript, so I apologize if it's not as clean as it could be)</p>\n<pre><code>//Converts Strings to Base64 for the SaveGame code functionality\nfunction showPopupSave(text) {\n    try {\n\t//Original Popup Function Courtesy of KV. Altered slightly for our specific save code popup.\n\t$('#msgboxCaption').html(text);\n\n    var msgboxOptions = {\n        modal: true,\n        autoOpen: false,\n        title: \"Save Game Code\",\n        width: \"650px\",\n        height: \"auto\",\n        buttons: [\n\t\t\t{\n\t\t\t    text: 'Copy To Clipboard',\n\t\t\t    //click: function () { $(this).dialog('close'); }\n\t\t\t\tclick: function () {  \n\t\t\t\t\t// Select the SaveCode text  \n\t\t\t\t\tvar SaveCode = document.querySelector('#msgboxCaption');  \n\t\t\t\t\tvar range = document.createRange();  \n\t\t\t\t\trange.selectNode(SaveCode);  \n\t\t\t\t\twindow.getSelection().addRange(range);  \n\n\t\t\t\t\ttry {  \n\t\t\t\t\t\t// Execute the copy command on selected text\n\t\t\t\t\t\tvar successful = document.execCommand('copy');  \n\t\t\t\t\t\t//var msg = successful ? 'successful' : 'unsuccessful';  \n\t\t\t\t\t\t//console.log('Copy email command was ' + msg);  \n\t\t\t\t\t} \t\t\t\t\t\n\t\t\t\t\tcatch(err) {  \n\t\t\t\t\t//console.log('Oops, unable to copy');  \n\t\t\t\t\t}  \n\n\t\t\t\t\t// Remove the selections \n\t\t\t\t\twindow.getSelection().removeAllRanges();  \n}\n\t\t\t},\n        ],\n        closeOnEscape: false,\n    };\n\n    $('#msgbox').dialog(msgboxOptions);\n    $('#msgbox').dialog('open');\n\t}\n\tcatch(err) {\n\t\tASLEvent(\"Log\", err);\n\t}\n};\n\nfunction ConvertToBase64(string) {\n  if (string != null &amp;&amp; string != \"\") {\n\t  try {\n\t    conversion = btoa(string)\n\t  }\n\t  catch(err) {\n\t\tconversion = \"Error: \"+err\n\t  }\n\t  finally {\n        return conversion;\n\t\t//ASLEvent(\"Log\", conversion);\t//For Debugging\n\t  }\n  }\n}\n\nfunction ConvertFromBase64(string) {\n\tif (string != null &amp;&amp; string != \"\") {\n      try {\n\t    conversion = atob(string)\n\t  }\n\t  catch(err) {\n\t\tconversion = \"Error: \"+err\n\t  }\n\t  finally {\n        return conversion;\n\t\t//ASLEvent(\"Log\", conversion);\t//For Debugging\n\t  }\n    }\n}\n\nfunction CreateSaveCode(string) {\n\t//Convert the saved attribute data to Base64 to make it harder for the player to manually alter\n\t//converted = ConvertToBase64(string);\n\tconverted = compressToBase64(string)\n\t//Post the created Save Code to the player for them to copy and save\n\tshowPopupSave(converted);\n}\n\nfunction LoadSaveCode(LoadCode) {\n\t//Check if loaded code is encoded in Base64. The SaveGame() code has game.gameid as it's first parameter, so if first 4 characters are \"game\", assume it hasn't been encoded.\n\tfirst4char = LoadCode.substring(0, 4);\n\tif (first4char == \"game\") {\n\t\tvar P = LoadCode\n\t}\n\telse {\n\t\t//var P = ConvertFromBase64(LoadCode)\n\t\tvar P = decompressFromBase64(LoadCode)\n\t}\n\t//Send the loadcode back to the LoadGame() function in Quest\n\tASLEvent(\"LoadGameCode\", P);\n}\n\nfunction LoadGamePrompt() {\n\t$('#msgboxCaption').html(\"&lt;form id='LoadCodeForm'&gt;&lt;textarea id='LoadCodeBox' cols='55' rows='11' style='overflow:auto;max-width:100%'&gt;&lt;/textarea&gt;&lt;/form&gt;\");\n\n    var msgboxOptions = {\n        modal: true,\n        autoOpen: false,\n        title: \"Paste SaveCode to Load\",\n\t\twidth: \"650px\",\n        buttons: [\n\t\t\t{\n\t\t\t    text: 'Load Saved Game',\n\t\t\t\tclick: function () {  \n\t\t\t\t\t// On click, retrieve the pasted load code from the textbox   \n\t\t\t\t\tvar LoadCode = $(\"#LoadCodeBox\").val();\n\t\t\t\t\tif (LoadCode != null &amp;&amp; LoadCode != \"\") {\n\t\t\t\t\t  $(this).dialog('close');\n\t\t\t\t\t  //document.getElementById(\"#LoadCodeForm\").submit();\n\t\t\t\t\t  //var LoadCode = document.getElementById('#LoadCodeBox').value;\n\t\t\t\t\t  LoadSaveCode(LoadCode);\n\t\t\t\t\t}\n}\n\t\t\t},\n        ],\n        closeOnEscape: false,\n    };\n\n    $('#msgbox').dialog(msgboxOptions);\n    $('#msgbox').dialog('open');\n};\n\n\n// The below is adapted from Pieroxy's LZ-string javascript library. An excerpt from LZ-string was pulled in and adapted to allow for string compression to cut down on the length of the savecode (especially when the savecode contains multiple checkpoints)...\n\n// Copyright (c) 2013 Pieroxy &lt;pieroxy@pieroxy.net&gt;\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\n\nfunction getBaseValue(alphabet, character) {\n  var f = String.fromCharCode;\n  var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n  var baseReverseDic = {};\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i&lt;alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nfunction compressToBase64(input) {\n    try {\n\t  var f = String.fromCharCode;\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n      var baseReverseDic = {};\n      if (input == null) return \"\";\n      var res = _compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n      switch (res.length % 4) { // To produce valid Base64\n      default: // When could this happen ?\n      case 0 : return res;\n      case 1 : return res+\"===\";\n      case 2 : return res+\"==\";\n      case 3 : return res+\"=\";\n      }\n    }\n\tcatch(err) {\n\treturn \"Error: \"+err;\n\t}\n}\n\nfunction decompressFromBase64(input) {\n    try {\n\t  var f = String.fromCharCode;\n      var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n      var baseReverseDic = {};\n      if (input == null) return \"\";\n      if (input == \"\") return null;\n      return _decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n    }\n\tcatch(err) {\n\t  return \"Error: \"+err;\n\t}\n}\n\nfunction compress(uncompressed) {\n    return _compress(uncompressed, 16, function(a){return f(a);});\n}\n   \nfunction _compress(uncompressed, bitsPerChar, getCharFromInt) {\n  try {\n\tvar f = String.fromCharCode;\n    var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n    var baseReverseDic = {};\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii &lt; uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)&lt;256) {\n            for (i=0 ; i&lt;context_numBits ; i++) {\n              context_data_val = (context_data_val &lt;&lt; 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i&lt;8 ; i++) {\n              context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value &gt;&gt; 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i&lt;context_numBits ; i++) {\n              context_data_val = (context_data_val &lt;&lt; 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i&lt;16 ; i++) {\n              context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value &gt;&gt; 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i&lt;context_numBits ; i++) {\n            context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value &gt;&gt; 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)&lt;256) {\n          for (i=0 ; i&lt;context_numBits ; i++) {\n            context_data_val = (context_data_val &lt;&lt; 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i&lt;8 ; i++) {\n            context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value &gt;&gt; 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i&lt;context_numBits ; i++) {\n            context_data_val = (context_data_val &lt;&lt; 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i&lt;16 ; i++) {\n            context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value &gt;&gt; 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i&lt;context_numBits ; i++) {\n          context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value &gt;&gt; 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i&lt;context_numBits ; i++) {\n      context_data_val = (context_data_val &lt;&lt; 1) | (value&amp;1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value &gt;&gt; 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val &lt;&lt; 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  }\n  catch(err) {\n    return \"Error: \"+err;\n  }\n}\n\nfunction decompress(compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return _decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n}\n\nfunction _decompress(length, resetValue, getNextValue) {\n  try {\n\tvar f = String.fromCharCode;\n    var keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\n    var baseReverseDic = {};\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i &lt; 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val &amp; data.position;\n      data.position &gt;&gt;= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb&gt;0 ? 1 : 0) * power;\n      power &lt;&lt;= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val &amp; data.position;\n            data.position &gt;&gt;= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb&gt;0 ? 1 : 0) * power;\n            power &lt;&lt;= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val &amp; data.position;\n            data.position &gt;&gt;= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb&gt;0 ? 1 : 0) * power;\n            power &lt;&lt;= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index &gt; length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val &amp; data.position;\n        data.position &gt;&gt;= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb&gt;0 ? 1 : 0) * power;\n        power &lt;&lt;= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val &amp; data.position;\n            data.position &gt;&gt;= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb&gt;0 ? 1 : 0) * power;\n            power &lt;&lt;= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val &amp; data.position;\n            data.position &gt;&gt;= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb&gt;0 ? 1 : 0) * power;\n            power &lt;&lt;= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n  catch(err) {\n\treturn \"Error: \"+err;\n  }\n}\n</code></pre>\n</details>\n<p></p><h3>The <em>SaveGameCode</em> function code:</h3><p></p>\n<p>(Function below has been updated to v3.0)</p>\n<details>\n<pre><code>// SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\n// The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\n// Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n// Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n// Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\nSuppressTurnscripts\n// Make sure ShowCodePopupFlag is of type 'boolean'\nif (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\n  X = TypeOf(ShowCodePopupFlag)\n  error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\n}\nSaveString = \"\"\nCreatedObj = NewStringList()\nDestroyedObj = NewStringList()\n// Set delimiters.\n// WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n// WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n// D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n// D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\nD1 = \"|\"\nD2 = \"$\"\nD3 = \";\"\nD4 = \"@\"\n// Save the player's current map before saving\n// Make sure first two entries are gameid and version (for load function)\nSaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\nSaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n// Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\nSaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n// Record all changable object attributes\nforeach (o, AllObjects()) {\n  objectname = o.name\n  // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n  if (not ListContains(game.StartingObjStrList, objectname)) {\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n    if (not ListContains(CreatedObj, objectname)) {\n      list add (CreatedObj, objectname)\n    }\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n    IncludeTypeFlag = True\n  }\n  else {\n    IncludeTypeFlag = False\n  }\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n      if (att_datatype=\"object\") {\n        v = GetAttribute (o, attributename)\n        att_value = v.name\n      }\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n        // Confirm there are no banned delimiters in the list entries\n        v = GetAttribute (o, attributename)\n        if (ListCount(v)&gt;0) {\n          if (att_datatype=\"stringlist\") {\n            foreach (listcheck, v) {\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n              if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n              }\n            }\n          }\n        }\n      }\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n        // Confirm there are no banned delimiters in the dictionary entries\n        v = GetAttribute (o, attributename)\n        if (DictionaryCount(v)&gt;0) {\n          foreach (dictkey, v) {\n            if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n              error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n            }\n            if (att_datatype=\"stringdictionary\") {\n              dictitm = DictionaryItem (v, dictkey)\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n              if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n              }\n            }\n          }\n        }\n      }\n      else {\n        att_value = ToString(GetAttribute (o, attributename))\n      }\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n      if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n      }\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n    }\n  }\n}\nforeach (o, AllExits()) {\n  objectname = o.name\n  // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n  if (not ListContains(game.StartingObjStrList, objectname)) {\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n    if (not ListContains(CreatedObj, objectname)) {\n      list add (CreatedObj, objectname)\n    }\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n    IncludeTypeFlag = True\n  }\n  else {\n    IncludeTypeFlag = False\n  }\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n      if (att_datatype=\"object\") {\n        v = GetAttribute (o, attributename)\n        att_value = v.name\n      }\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n      }\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n      }\n      else {\n        att_value = ToString(GetAttribute (o, attributename))\n      }\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n      if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n      }\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n    }\n  }\n}\nforeach (turnscript, AllTurnScripts()) {\n  // Check for which turnscripts are enabled/disabled\n  if (GetBoolean(turnscript, \"enabled\")) {\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n  }\n  else {\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n  }\n}\n// Determine if any objects were destroyed by the player since game start...\nforeach (objectname, game.StartingObjStrList) {\n  IsThere = GetObject(objectname)\n  if (Equal(IsThere,null)) {\n    list add (DestroyedObj, objectname)\n  }\n}\n// Save the game.timeelapsed attribute\nSaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n// Check if game.SaveAtts and/or game.SaveTimers exists.\n// game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\nif (HasAttribute (game, \"SaveAtts\")) {\n  SaveAttType = TypeOf(game.SaveAtts)\n  if (SaveAttType=\"stringlist\") {\n    if (ListCount(game.SaveAtts)&gt;0) {\n      foreach (x, game.SaveAtts) {\n        AttValue = GetAttribute (game, x)\n        att_datatype = TypeOf(AttValue)\n        if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n          SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n        }\n        else if (Equal(x,\"checkpoints\")) {\n          error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n        }\n        else if (Equal(AttValue,null)) {\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n        }\n        else {\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n        }\n      }\n    }\n  }\n  else {\n    error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n  }\n}\n// game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\nif (HasAttribute (game, \"SaveTimers\")) {\n  SaveAttType = TypeOf(game.SaveTimers)\n  if (SaveAttType=\"stringlist\") {\n    if (ListCount(game.SaveTimers)&gt;0) {\n      foreach (x, game.SaveTimers) {\n        T = GetObject(x)\n        if (not Equal(T,null)) {\n          TimerName = x.name\n          TimerValue1 = x.trigger\n          TimerValue2 = x.interval\n          TimerValue3 = x.enabled\n          TimerValue1Type = TypeOf(TimerValue1)\n          TimerValue2Type = TypeOf(TimerValue2)\n          TimerValue3Type = TypeOf(TimerValue3)\n          SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n          SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n          SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n        }\n        else {\n          error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n        }\n      }\n    }\n  }\n  else {\n    error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n  }\n}\n// If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n// *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n// The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n// For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n// DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n// Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n// grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\nforeach (o, AllObjects()) {\n  foreach (attributename, GetAttributeNames(o,false)) {\n    objectname = o.name\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n      // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n      foreach (UKey, GetAttribute(o, attributename)) {\n        SaveString = SaveString+UKey+D2\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n        foreach (Lkey, UVal) {\n          Lval = DictionaryItem(UVal, Lkey)\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n        }\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n      }\n    }\n    else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n      // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n      foreach (UKey, GetAttribute(o, attributename)) {\n        SaveString = SaveString+UKey+D2\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n        foreach (Lkey, UVal) {\n          Lval = DictionaryItem(UVal, Lkey)\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n        }\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n      }\n    }\n  }\n}\n// Add on the list of created/destroyed objects...\nX = ToString(CreatedObj)\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\nCreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\nX = ToString(DestroyedObj)\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\nDestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\nSaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n// Special logic needed in order to save the game.checkpoints attribute\nD4toD1 = D4+D3+D2+D1\nif (HasAttribute(game,\"checkpoints\")) {\n  if (DictionaryCount(game.checkpoints)&gt;0) {\n    KeyList = \"\"\n    CheckValList = \"\"\n    foreach (k, game.checkpoints) {\n      KeyList = KeyList+k+D3\n      val = DictionaryItem(game.checkpoints, k)\n      CheckValList = CheckValList+val+D4toD1\n    }\n    // Remove final D3 from KeyList string and final D4toD1 from CheckValList\n    KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\n    CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\n    // Add game.checkpoints data to SaveString\n    SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\n  }\n  else {\n    // If game.checkpoints empty, just add D4toD1 to SaveString.\n    SaveString = SaveString+D4toD1\n  }\n}\nelse {\n  // If game.checkpoints non-existant, just add D4toD1 to SaveString.\n  SaveString = SaveString+D4toD1\n}\n// Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\nSaveString = SaveString+D1+D2+D3+D4\n// msg for Debugging:\n// msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\nif (ShowCodePopupFlag=True) {\n  // Create save code and present to player in textbox\n  JS.CreateSaveCode (SaveString)\n  JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\n}\nreturn (SaveString)\n</code></pre>\n</details>\n<p></p><h3>The <em>LoadGameCode</em> function code:</h3><p></p>\n<p>(Function below has been updated to v3.0.)</p>\n<details>\n<pre><code>// LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\nSuppressTurnscripts\n// NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\n// TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\nOldestAllowedVersion = 0.0\n// TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\nDebugMode = False\n// Msg for Debugging:\nif (DebugMode) {\n  msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n}\n// Set up other variables for later\nbla =&gt; {\n}\nupgradesave = False\nProceed = False\nSkippedAttList = \"\"\nCreatedObjDebugList = \"\"\nDestroyedObjDebugList = \"\"\n// Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\nCheckForCheck = Right(SaveGameCodeDecoded,2)\nif (CheckForCheck=\"✓✓\") {\n  upgradesave = True\n  SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\n}\n// Retrieve delimiters from end of SaveGameCodeDecoded\nDls = Right(SaveGameCodeDecoded,4)\nD1 = Mid (Dls, 1, 1)\nD2 = Mid (Dls, 2, 1)\nD3 = Mid (Dls, 3, 1)\nD4 = Mid (Dls, 4, 1)\n// Remove delimiters from end of SaveGameCode\nSaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n// Special logic to extract saved game.checkpoints attribute\nD4toD1 = D4+D3+D2+D1\nCheckpointSplit = Split(SaveCode, D4toD1)\nSaveCode = ListItem(CheckpointSplit,0)\nCheckpointKeys = ListItem(CheckpointSplit,1)\n// If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\nif (not CheckpointKeys=\"\") {\n  CheckpointKeyList = Split(CheckpointKeys, D3)\n  game.checkpoints = NewStringDictionary()\n  for (xx, 0, ListCount(CheckpointKeyList)-1) {\n    key = ListItem(CheckpointKeyList,xx)\n    val = ListItem(CheckpointSplit,xx+1)\n    DictionaryAdd (game.checkpoints, key, val)\n  }\n}\n// Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\nCreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\nif (DebugMode) {\n  msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n}\nCDList = Split(CreatedDestroyedInfo,D1)\nCSection = ListItem (CDList, 0)\nDSection = ListItem (CDList, 1)\nif (CSection=\"\") {\n  CreatedList = NewStringList()\n}\nelse {\n  CreatedList = Split (CSection, D3)\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n  list remove (CreatedList, \" \")\n}\nif (DSection=\"\") {\n  DestroyedList = NewStringList()\n}\nelse {\n  DestroyedList = Split (DSection, D3)\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n  list remove (DestroyedList, \" \")\n}\n// Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n// Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\nGridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\nif (DebugMode) {\n  msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n}\n// Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\nif (DebugMode) {\n  msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n}\n// Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n// Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\nGameIdDelim = Instr (SaveCode, D1)\nGameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\nGamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\nGameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\nGameIdObjectEl = ListItem (GameInfo,0)\nGameIdElements = Split(GameIdObjectEl,D2)\nLoaded_GameId = ListItem (GameIdElements, 3)\nGameVerObjectEl = ListItem (GameInfo,1)\nGameVerElements = Split(GameVerObjectEl,D2)\nVersionString = ListItem (GameVerElements, 3)\nLoaded_GameVersion = ToDouble(VersionString)\nGamePOVObjectEl = ListItem (GameInfo,2)\nGamePOVElements = Split(GamePOVObjectEl,D2)\nGamePOVName = ListItem (GamePOVElements, 3)\nif (StartsWith(GamePOVName,\"Object: \")) {\n  GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n}\nGamePOVObject = GetObject (GamePOVName)\nGamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n// Check that the save belongs to this game by comparing gameIds\nif (not Loaded_GameId=game.gameid) {\n  error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n}\nelse {\n  // Compare version of game in SaveCode to version of game loading it\n  ThisGame_GameVersion = ToDouble(game.version)\n  if (not TypeOf(OldestAllowedVersion)=\"double\") {\n    OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n  }\n  else {\n    OldestAllowedVersion_Double = OldestAllowedVersion\n  }\n  // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n  if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n    if (upgradesave = False) {\n      if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n        msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;&lt;br&gt;Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\n        // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\n        create (\"SaveGameDecodedObj\")\n        set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\n        ShowMenu (\"\", Split(\"Yes;No\"), false) {\n          switch (result) {\n            case (\"Yes\") {\n              SuppressTurnscripts\n              msg (\"Save code identified! Proceeding with load, please wait...\")\n              OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\n              LoadGameCode (OlderSaveCode)\n              destroy (\"SaveGameDecodedObj\")\n            }\n            case (\"No\") {\n              SuppressTurnscripts\n              msg (\"Load Aborted.\")\n              destroy (\"SaveGameDecodedObj\")\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n      }\n    }\n    else {\n      msg (\"Applying savecode from older version...\")\n      Proceed = True\n    }\n  }\n  else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n    error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n  }\n  else {\n    msg (\"Proceeding with load...\")\n    Proceed = True\n  }\n  if (Proceed=True) {\n    // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n    if (ListCount(CreatedList)&gt;0) {\n      foreach (o, CreatedList) {\n        // Check that objects don't already exist...\n        IsThere = GetObject(o)\n        if (Equal(IsThere,null)) {\n          // If not, create the object\n          create (o)\n          CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n        }\n      }\n    }\n    player.grid_coordinates = null\n    // Split the save code up into all objects. Then parse through the value of each object attribute\n    SavedObjectList = Split(SaveCode, D1)\n    foreach (o, SavedObjectList) {\n      Skip_Att = False\n      objelements = Split(o, D2)\n      objectname = ListItem (objelements, 0)\n      object = GetObject (objectname)\n      attributename = ListItem (objelements, 1)\n      fullname = objectname+\".\"+attributename\n      preload_att_value = GetAttribute (object, attributename)\n      att_datatype = ListItem (objelements, 2)\n      if (ListCount(objelements)=3) {\n        att_value = \"\"\n      }\n      else {\n        att_value = ListItem (objelements, 3)\n      }\n      // Check that the attribute is supported\n      if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n        msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n        Skip_Att = True\n        SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n      }\n      // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n      att_value_obj = att_value\n      if (att_datatype=\"object\") {\n        if (StartsWith(att_value,\"Object: \")) {\n          att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n        }\n        else {\n          att_value_obj = GetObject(att_value)\n        }\n      }\n      else if (att_datatype=\"boolean\") {\n        if (att_value=\"True\") {\n          att_value_obj = True\n        }\n        else {\n          att_value_obj = False\n        }\n      }\n      else if (att_datatype=\"int\") {\n        att_value_obj = ToInt(att_value)\n      }\n      else if (att_datatype=\"double\") {\n        att_value_obj = ToDouble(att_value)\n      }\n      else if (att_datatype=\"stringlist\") {\n        if (att_value=\"\") {\n          att_value_obj = NewStringList()\n        }\n        else {\n          att_value_obj = Split (att_value, D3)\n          // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n          list remove (att_value_obj, \" \")\n        }\n      }\n      else if (att_datatype=\"objectlist\") {\n        if (att_value=\"\") {\n          att_value_obj = NewObjectList()\n        }\n        else {\n          att_value_obj = NewObjectList()\n          objlistlist = Split (att_value, D3)\n          foreach (olt, objlistlist) {\n            // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n            if (StartsWith(olt,\"Object: \")) {\n              value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n              if (not value=null) {\n                list add (att_value_obj, value)\n              }\n              else {\n                msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n              }\n            }\n          }\n        }\n      }\n      else if (att_datatype=\"stringdictionary\") {\n        if (att_value=\"\") {\n          att_value_obj = NewStringDictionary()\n        }\n        else {\n          att_value_obj = NewStringDictionary()\n          // Add dictionary values from SaveGame\n          dictrows = Split(att_value, \";\")\n          foreach (kv, dictrows) {\n            if (DebugMode) {\n              msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n            }\n            KeyValList = Split(kv,\" = \")\n            key = ListItem(KeyValList, 0)\n            value = ListItem(KeyValList, 1)\n            DictionaryAdd (att_value_obj, key, value)\n          }\n        }\n      }\n      else if (att_datatype=\"objectdictionary\") {\n        if (att_value=\"\") {\n          att_value_obj = NewObjectDictionary()\n        }\n        else {\n          att_value_obj = NewObjectDictionary()\n          dictrows = Split(att_value, \";\")\n          foreach (kv, dictrows) {\n            if (DebugMode) {\n              msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n            }\n            KeyValList = Split(kv,\" = \")\n            key = ListItem(KeyValList, 0)\n            obj = ListItem(KeyValList, 1)\n            if (StartsWith(obj,\"Object: \")) {\n              value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n            }\n            else {\n              value = obj\n            }\n            if (not value=null) {\n              DictionaryAdd (att_value_obj, key, value)\n            }\n            else {\n              msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n              SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n            }\n          }\n        }\n      }\n      if (objectname=GamePOVName and attributename=\"parent\") {\n        // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n        Skip_Att = True\n        GamePOVParent = att_value_obj\n      }\n      // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n      if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n        if (Equal(preload_att_value,null)) {\n          if (DebugMode) {\n            msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n          }\n          preload_att_value = \"null\"\n        }\n        // Msgs for debugging:\n        if (DebugMode) {\n          msg (\"objectname=\"+objectname)\n          msg (\"attributename=\"+attributename)\n          msg (\"att_datatype=\"+att_datatype)\n          msg (\"preload_att_value=\"+ToString(preload_att_value))\n          if (Equal(preload_att_value,\"null\")) {\n            msg (\"preload_att_datatype=null\")\n          }\n          else {\n            msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n          }\n          msg (\"att_value=\"+ToString(att_value))\n          msg (\"att_value_obj=\"+ToString(att_value_obj))\n          msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n          msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n          msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n          msg (\"&lt;br&gt;\")\n        }\n        // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n        if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n          if (DebugMode) {\n            msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n          }\n          // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n          cha = \"changed\" + attributename\n          if (HasAttribute (object, cha)) {\n            // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n            scr = GetAttribute (object, cha)\n            set (object, cha, bla)\n          }\n          // Update the attributes in the game with those from the SaveCode...\n          if (att_datatype=\"boolean\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"int\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"double\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"object\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            // NOTE TO DEVELOPER:\n            // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n            // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n            // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n            // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n            if (upgradesave = True) {\n              // This section will trigger if the player is loading a save from a previous game version\n              ReplaceContents = True\n            }\n            else {\n              // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n              ReplaceContents = True\n            }\n            if (att_datatype=\"stringlist\") {\n              if (ReplaceContents = True) {\n                // Completely replace stringlist contents with those found in the SaveCode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved stringlist TO the existing stringlist in-game\n                FinalList = NewStringList()\n                // Retrieve the contents of the existing list\n                PreLoadList = preload_att_value\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\n                // Remove duplicates\n                CompactList = ListCompact (CombinedList)\n                // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                foreach (olt, CompactList) {\n                  list add (FinalList, olt)\n                }\n                set (object, attributename, FinalList)\n              }\n            }\n            else if (att_datatype=\"objectlist\") {\n              if (ReplaceContents = True) {\n                // Completely replace objectlist contents with those found in the SaveCode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved objectlist TO the existing objectlist in-game\n                // Retrieve the contents of the existing list\n                PreLoadList = preload_att_value\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\n                // Remove duplicates\n                FinalList = ObjectListCompact (CombinedList)\n                set (object, attributename, FinalList)\n              }\n            }\n            else if (att_datatype=\"stringdictionary\") {\n              if (ReplaceContents = True) {\n                // Then completely overwrite existing stringdictionary contents with those in the savecode\n                set (object, attributename, att_value_obj)\n                Dummy = NewStringDictionary()\n              }\n              else {\n                // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                Dummy = preload_att_value\n                // Add dictionary values from SaveGame\n                dictrows = Split(att_value, \";\")\n                foreach (kv, dictrows) {\n                  KeyValList = Split(kv,\" = \")\n                  key = ListItem(KeyValList, 0)\n                  value = ListItem(KeyValList, 1)\n                  DictionaryAdd (Dummy, key, value)\n                }\n                set (object, attributename, Dummy)\n              }\n            }\n            else if (att_datatype=\"objectdictionary\") {\n              if (upgradesave = False) {\n                // Then completely overwrite existing objectdictionary contents with those in the savecode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                Dummy = preload_att_value\n                // Add dictionary values from SaveGame\n                dictrows = Split(att_value, \";\")\n                foreach (kv, dictrows) {\n                  KeyValList = Split(kv,\" = \")\n                  key = ListItem(KeyValList, 0)\n                  value = ListItem(KeyValList, 1)\n                  if (StartsWith(value,\"Object: \")) {\n                    value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                  }\n                  DictionaryAdd (Dummy, key, value)\n                }\n                set (object, attributename, Dummy)\n              }\n            }\n          }\n          else if (att_datatype=\"string\") {\n            set (object, attributename, att_value)\n          }\n          else {\n            error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n          }\n          if (HasAttribute (object, cha)) {\n            // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n            set (object, cha, scr)\n            scr =&gt; {\n            }\n          }\n        }\n      }\n    }\n    // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n    // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n    AllSavedGrids = Split(GridGInfo,D4)\n    if (DebugMode) {\n      msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n    }\n    foreach (A, AllSavedGrids) {\n      UDictionary = NewDictionary()\n      ItemAndValue = Split(A,\"&amp;%&amp;\")\n      ObjAndAtt = ListItem(ItemAndValue,0)\n      ObjAndAtt = Split(ObjAndAtt,D2)\n      objectname = ListItem(ObjAndAtt,0)\n      attributename = ListItem(ObjAndAtt,1)\n      object = GetObject(objectname)\n      GridVals = ListItem(ItemAndValue,1)\n      GridVals = Split(GridVals,D1)\n      foreach (B, GridVals) {\n        UKeyAndUVal = Split(B,D2)\n        UKey = ListItem(UKeyAndUVal,0)\n        UVal = ListItem(UKeyAndUVal,1)\n        UVal = Split(UVal,D3)\n        LDictionary = NewDictionary()\n        foreach (C, UVal) {\n          LkeyAndLval = Split(C,\" = \")\n          Lkey = ListItem(LkeyAndLval,0)\n          LvalAndType = ListItem(LkeyAndLval,1)\n          LvalAndType = Split(LvalAndType,\":\")\n          Lval_str = ListItem(LvalAndType,0)\n          LType = ListItem(LvalAndType,1)\n          if (LType=\"int\") {\n            Lval = ToInt(Lval_str)\n          }\n          else if (LType=\"double\") {\n            Lval = ToDouble(Lval_str)\n          }\n          else if (LType=\"boolean\") {\n            if (Lval_str=\"True\") {\n              Lval = True\n            }\n            else {\n              Lval = False\n            }\n          }\n          else {\n            error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n          }\n          DictionaryAdd (LDictionary, Lkey, Lval)\n        }\n        DictionaryAdd (UDictionary, UKey, LDictionary)\n      }\n      if (DebugMode) {\n        msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n      }\n      set (object, attributename, UDictionary)\n    }\n    // Destroy any objects that the player destroyed during their saved game, if any\n    if (ListCount(DestroyedList)&gt;0) {\n      foreach (o, DestroyedList) {\n        // Check that objects still exist...\n        IsThere = GetObject(o)\n        if (not Equal(IsThere,null)) {\n          // If its there, destroy the object\n          destroy (o)\n          DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n        }\n      }\n    }\n    msg (\"Load complete!\")\n    if (DebugMode) {\n      msg (\"Created objects: \"+CreatedObjDebugList)\n      msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n      msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n    }\n    // Finally, update game.pov.parent and game.pov\n    wait {\n      set (GamePOVObject, \"parent\", GamePOVParent)\n      game.pov = GamePOVObject\n      // player.grid_coordinates = null\n      JS.Grid_ClearAllLayers ()\n      Grid_Redraw\n      Grid_DrawPlayerInRoom (game.pov.parent)\n      ClearScreen\n      ShowRoomDescription\n    }\n  }\n}\n</code></pre>\n</details>\n<p></p><h3>The <em>SaveCheckpoint</em> function code:</h3><p></p>\n<p>(Function below is new with v3.0)</p>\n<details>\n<pre><code>// SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\n// The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\n// If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\n// Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n// Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n// Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\nSuppressTurnscripts\n// Check if game.checkpoints exists. If not, create it.\nif (not HasAttribute(game, \"checkpoints\")) {\n  set (game, \"checkpoints\", NewStringDictionary())\n}\n// Make sure CheckpointName input is of 'string' datatype\nif (not TypeOf(CheckpointName)=\"string\") {\n  X = TypeOf(CheckpointName)\n  error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n}\nSaveString = \"\"\nCreatedObj = NewStringList()\nDestroyedObj = NewStringList()\n// Set delimiters.\n// WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n// WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n// D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n// D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\nD1 = \"|\"\nD2 = \"$\"\nD3 = \";\"\nD4 = \"@\"\n// Save the player's current map before saving\n// Make sure first two entries are gameid and version (for load function)\nSaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\nSaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n// Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\nSaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n// Record all changable object attributes\nforeach (o, AllObjects()) {\n  objectname = o.name\n  // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n  if (not ListContains(game.StartingObjStrList, objectname)) {\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n    if (not ListContains(CreatedObj, objectname)) {\n      list add (CreatedObj, objectname)\n    }\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n    IncludeTypeFlag = True\n  }\n  else {\n    IncludeTypeFlag = False\n  }\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n      if (att_datatype=\"object\") {\n        v = GetAttribute (o, attributename)\n        att_value = v.name\n      }\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n        // Confirm there are no banned delimiters in the list entries\n        v = GetAttribute (o, attributename)\n        if (ListCount(v)&gt;0) {\n          if (att_datatype=\"stringlist\") {\n            foreach (listcheck, v) {\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n              if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n              }\n            }\n          }\n        }\n      }\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n        // Confirm there are no banned delimiters in the dictionary entries\n        v = GetAttribute (o, attributename)\n        if (DictionaryCount(v)&gt;0) {\n          foreach (dictkey, v) {\n            if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n              error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n            }\n            if (att_datatype=\"stringdictionary\") {\n              dictitm = DictionaryItem (v, dictkey)\n              // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n              if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n              }\n            }\n          }\n        }\n      }\n      else {\n        att_value = ToString(GetAttribute (o, attributename))\n      }\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n      if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n      }\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n    }\n  }\n}\nforeach (o, AllExits()) {\n  objectname = o.name\n  // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n  if (not ListContains(game.StartingObjStrList, objectname)) {\n    // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n    if (not ListContains(CreatedObj, objectname)) {\n      list add (CreatedObj, objectname)\n    }\n    // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n    IncludeTypeFlag = True\n  }\n  else {\n    IncludeTypeFlag = False\n  }\n  foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n      if (att_datatype=\"object\") {\n        v = GetAttribute (o, attributename)\n        att_value = v.name\n      }\n      else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n      }\n      else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n        X = ToString(GetAttribute (o, attributename))\n        // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n        att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n      }\n      else {\n        att_value = ToString(GetAttribute (o, attributename))\n      }\n      // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n      if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n      }\n      else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n        error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n      }\n      SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n    }\n  }\n}\nforeach (turnscript, AllTurnScripts()) {\n  // Check for which turnscripts are enabled/disabled\n  if (GetBoolean(turnscript, \"enabled\")) {\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n  }\n  else {\n    SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n  }\n}\n// Determine if any objects were destroyed by the player since game start...\nforeach (objectname, game.StartingObjStrList) {\n  IsThere = GetObject(objectname)\n  if (Equal(IsThere,null)) {\n    list add (DestroyedObj, objectname)\n  }\n}\n// Save the game.timeelapsed attribute\nSaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n// Check if game.SaveAtts and/or game.SaveTimers exists.\n// game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\nif (HasAttribute (game, \"SaveAtts\")) {\n  SaveAttType = TypeOf(game.SaveAtts)\n  if (SaveAttType=\"stringlist\") {\n    if (ListCount(game.SaveAtts)&gt;0) {\n      foreach (x, game.SaveAtts) {\n        AttValue = GetAttribute (game, x)\n        att_datatype = TypeOf(AttValue)\n        if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n          SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n        }\n        else if (Equal(x,\"checkpoints\")) {\n          error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n        }\n        else if (Equal(AttValue,null)) {\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n        }\n        else {\n          error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n        }\n      }\n    }\n  }\n  else {\n    error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n  }\n}\n// game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\nif (HasAttribute (game, \"SaveTimers\")) {\n  SaveAttType = TypeOf(game.SaveTimers)\n  if (SaveAttType=\"stringlist\") {\n    if (ListCount(game.SaveTimers)&gt;0) {\n      foreach (x, game.SaveTimers) {\n        T = GetObject(x)\n        if (not Equal(T,null)) {\n          TimerName = x.name\n          TimerValue1 = x.trigger\n          TimerValue2 = x.interval\n          TimerValue3 = x.enabled\n          TimerValue1Type = TypeOf(TimerValue1)\n          TimerValue2Type = TypeOf(TimerValue2)\n          TimerValue3Type = TypeOf(TimerValue3)\n          SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n          SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n          SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n        }\n        else {\n          error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n        }\n      }\n    }\n  }\n  else {\n    error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n  }\n}\n// If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n// *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n// The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n// For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n// DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n// Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n// grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\nforeach (o, AllObjects()) {\n  foreach (attributename, GetAttributeNames(o,false)) {\n    objectname = o.name\n    fullname = objectname+\".\"+attributename\n    att_datatype = ToString(TypeOf(o, attributename))\n    if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n      // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n      foreach (UKey, GetAttribute(o, attributename)) {\n        SaveString = SaveString+UKey+D2\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n        foreach (Lkey, UVal) {\n          Lval = DictionaryItem(UVal, Lkey)\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n        }\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n      }\n    }\n    else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n      // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n      SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n      foreach (UKey, GetAttribute(o, attributename)) {\n        SaveString = SaveString+UKey+D2\n        UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n        foreach (Lkey, UVal) {\n          Lval = DictionaryItem(UVal, Lkey)\n          Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n          SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n        }\n        SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n      }\n    }\n  }\n}\n// Add on the list of created/destroyed objects...\nX = ToString(CreatedObj)\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\nCreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\nX = ToString(DestroyedObj)\n// Cut off the \"List: \" string that preceeds its values when you use the ToString() command\nDestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\nSaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n// Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\nSaveString = SaveString+D1+D2+D3+D4\n// msg for Debugging:\n// msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\n// Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\nif (not CheckpointName=\"\") {\n  DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\n}\nreturn (SaveString)\n</code></pre>\n</details>\n<p></p><h3>The <em>LoadCheckpoint</em> function code:</h3><p></p>\n<p>(Function below is new with v3.0)</p>\n<details>\n<pre><code>// LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\n// Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\nSuppressTurnscripts\n// TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\nOldestAllowedVersion = 2.0\n// TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\nDebugMode = False\n// Msg for Debugging:\nif (DebugMode) {\n  msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n}\n// Make sure CheckpointName input is of type 'string'\nif (not TypeOf(CheckpointName)=\"string\") {\n  X = TypeOf(CheckpointName)\n  error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n}\n// Retrieve SaveString from game.checkpoints dictionary\nif (HasAttribute(game, \"checkpoints\")) {\n  if (DictionaryContains(game.checkpoints, CheckpointName)) {\n    SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\n  }\n  else {\n    error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\n  }\n}\nelse {\n  error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\n}\n// Set up other variables for later\nbla =&gt; {\n}\nupgradesave = False\nProceed = False\nSkippedAttList = \"\"\nCreatedObjDebugList = \"\"\nDestroyedObjDebugList = \"\"\n// Retrieve delimiters from end of SaveGameCodeDecoded\nDls = Right(SaveGameCodeDecoded,4)\nD1 = Mid (Dls, 1, 1)\nD2 = Mid (Dls, 2, 1)\nD3 = Mid (Dls, 3, 1)\nD4 = Mid (Dls, 4, 1)\n// Remove delimiters from end of SaveGameCode\nSaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n// Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\nCreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\nif (DebugMode) {\n  msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n}\nCDList = Split(CreatedDestroyedInfo,D1)\nCSection = ListItem (CDList, 0)\nDSection = ListItem (CDList, 1)\nif (CSection=\"\") {\n  CreatedList = NewStringList()\n}\nelse {\n  CreatedList = Split (CSection, D3)\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n  list remove (CreatedList, \" \")\n}\nif (DSection=\"\") {\n  DestroyedList = NewStringList()\n}\nelse {\n  DestroyedList = Split (DSection, D3)\n  // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n  list remove (DestroyedList, \" \")\n}\n// Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n// Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\nGridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\nif (DebugMode) {\n  msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n}\n// Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\nSaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\nif (DebugMode) {\n  msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n}\n// Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n// Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\nGameIdDelim = Instr (SaveCode, D1)\nGameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\nGamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\nGameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\nGameIdObjectEl = ListItem (GameInfo,0)\nGameIdElements = Split(GameIdObjectEl,D2)\nLoaded_GameId = ListItem (GameIdElements, 3)\nGameVerObjectEl = ListItem (GameInfo,1)\nGameVerElements = Split(GameVerObjectEl,D2)\nVersionString = ListItem (GameVerElements, 3)\nLoaded_GameVersion = ToDouble(VersionString)\nGamePOVObjectEl = ListItem (GameInfo,2)\nGamePOVElements = Split(GamePOVObjectEl,D2)\nGamePOVName = ListItem (GamePOVElements, 3)\nif (StartsWith(GamePOVName,\"Object: \")) {\n  GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n}\nGamePOVObject = GetObject (GamePOVName)\nGamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n// Check that the save belongs to this game by comparing gameIds\nif (not Loaded_GameId=game.gameid) {\n  error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n}\nelse {\n  // Compare version of game in SaveCode to version of game loading it\n  ThisGame_GameVersion = ToDouble(game.version)\n  if (not TypeOf(OldestAllowedVersion)=\"double\") {\n    OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n  }\n  else {\n    OldestAllowedVersion_Double = OldestAllowedVersion\n  }\n  // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n  if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n    if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n      upgradesave = True\n      Proceed = True\n    }\n    else {\n      error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n    }\n  }\n  else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n    error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n  }\n  else {\n    Proceed = True\n  }\n  if (Proceed=True) {\n    // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n    if (ListCount(CreatedList)&gt;0) {\n      foreach (o, CreatedList) {\n        // Check that objects don't already exist...\n        IsThere = GetObject(o)\n        if (Equal(IsThere,null)) {\n          // If not, create the object\n          create (o)\n          CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n        }\n      }\n    }\n    player.grid_coordinates = null\n    // Split the save code up into all objects. Then parse through the value of each object attribute\n    SavedObjectList = Split(SaveCode, D1)\n    foreach (o, SavedObjectList) {\n      Skip_Att = False\n      objelements = Split(o, D2)\n      objectname = ListItem (objelements, 0)\n      object = GetObject (objectname)\n      attributename = ListItem (objelements, 1)\n      fullname = objectname+\".\"+attributename\n      preload_att_value = GetAttribute (object, attributename)\n      att_datatype = ListItem (objelements, 2)\n      if (ListCount(objelements)=3) {\n        att_value = \"\"\n      }\n      else {\n        att_value = ListItem (objelements, 3)\n      }\n      // Check that the attribute is supported\n      if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n        msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n        Skip_Att = True\n        SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n      }\n      // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n      att_value_obj = att_value\n      if (att_datatype=\"object\") {\n        if (StartsWith(att_value,\"Object: \")) {\n          att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n        }\n        else {\n          att_value_obj = GetObject(att_value)\n        }\n      }\n      else if (att_datatype=\"boolean\") {\n        if (att_value=\"True\") {\n          att_value_obj = True\n        }\n        else {\n          att_value_obj = False\n        }\n      }\n      else if (att_datatype=\"int\") {\n        att_value_obj = ToInt(att_value)\n      }\n      else if (att_datatype=\"double\") {\n        att_value_obj = ToDouble(att_value)\n      }\n      else if (att_datatype=\"stringlist\") {\n        if (att_value=\"\") {\n          att_value_obj = NewStringList()\n        }\n        else {\n          att_value_obj = Split (att_value, D3)\n          // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n          list remove (att_value_obj, \" \")\n        }\n      }\n      else if (att_datatype=\"objectlist\") {\n        if (att_value=\"\") {\n          att_value_obj = NewObjectList()\n        }\n        else {\n          att_value_obj = NewObjectList()\n          objlistlist = Split (att_value, D3)\n          foreach (olt, objlistlist) {\n            // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n            if (StartsWith(olt,\"Object: \")) {\n              value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n              if (not value=null) {\n                list add (att_value_obj, value)\n              }\n              else {\n                msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n              }\n            }\n          }\n        }\n      }\n      else if (att_datatype=\"stringdictionary\") {\n        if (att_value=\"\") {\n          att_value_obj = NewStringDictionary()\n        }\n        else {\n          att_value_obj = NewStringDictionary()\n          // Add dictionary values from SaveGame\n          dictrows = Split(att_value, \";\")\n          foreach (kv, dictrows) {\n            if (DebugMode) {\n              msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n            }\n            KeyValList = Split(kv,\" = \")\n            key = ListItem(KeyValList, 0)\n            value = ListItem(KeyValList, 1)\n            DictionaryAdd (att_value_obj, key, value)\n          }\n        }\n      }\n      else if (att_datatype=\"objectdictionary\") {\n        if (att_value=\"\") {\n          att_value_obj = NewObjectDictionary()\n        }\n        else {\n          att_value_obj = NewObjectDictionary()\n          dictrows = Split(att_value, \";\")\n          foreach (kv, dictrows) {\n            if (DebugMode) {\n              msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n            }\n            KeyValList = Split(kv,\" = \")\n            key = ListItem(KeyValList, 0)\n            obj = ListItem(KeyValList, 1)\n            if (StartsWith(obj,\"Object: \")) {\n              value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n            }\n            else {\n              value = obj\n            }\n            if (not value=null) {\n              DictionaryAdd (att_value_obj, key, value)\n            }\n            else {\n              msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n              SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n            }\n          }\n        }\n      }\n      if (objectname=GamePOVName and attributename=\"parent\") {\n        // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n        Skip_Att = True\n        GamePOVParent = att_value_obj\n      }\n      // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n      if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n        if (Equal(preload_att_value,null)) {\n          if (DebugMode) {\n            msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n          }\n          preload_att_value = \"null\"\n        }\n        // Msgs for debugging:\n        if (DebugMode) {\n          msg (\"objectname=\"+objectname)\n          msg (\"attributename=\"+attributename)\n          msg (\"att_datatype=\"+att_datatype)\n          msg (\"preload_att_value=\"+ToString(preload_att_value))\n          if (Equal(preload_att_value,\"null\")) {\n            msg (\"preload_att_datatype=null\")\n          }\n          else {\n            msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n          }\n          msg (\"att_value=\"+ToString(att_value))\n          msg (\"att_value_obj=\"+ToString(att_value_obj))\n          msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n          msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n          msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n          msg (\"&lt;br&gt;\")\n        }\n        // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n        if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n          if (DebugMode) {\n            msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n          }\n          // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n          cha = \"changed\" + attributename\n          if (HasAttribute (object, cha)) {\n            // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n            scr = GetAttribute (object, cha)\n            set (object, cha, bla)\n          }\n          // Update the attributes in the game with those from the SaveCode...\n          if (att_datatype=\"boolean\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"int\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"double\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"object\") {\n            set (object, attributename, att_value_obj)\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            // NOTE TO DEVELOPER:\n            // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n            // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n            // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n            // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n            if (upgradesave = True) {\n              // This section will trigger if the player is loading a save from a previous game version\n              ReplaceContents = True\n            }\n            else {\n              // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n              ReplaceContents = True\n            }\n            if (att_datatype=\"stringlist\") {\n              if (ReplaceContents = True) {\n                // Completely replace stringlist contents with those found in the SaveCode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved stringlist TO the existing stringlist in-game\n                FinalList = NewStringList()\n                // Retrieve the contents of the existing list\n                PreLoadList = preload_att_value\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\n                // Remove duplicates\n                CompactList = ListCompact (CombinedList)\n                // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                foreach (olt, CompactList) {\n                  list add (FinalList, olt)\n                }\n                set (object, attributename, FinalList)\n              }\n            }\n            else if (att_datatype=\"objectlist\") {\n              if (ReplaceContents = True) {\n                // Completely replace objectlist contents with those found in the SaveCode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved objectlist TO the existing objectlist in-game\n                // Retrieve the contents of the existing list\n                PreLoadList = preload_att_value\n                CombinedList = ListCombine (PreLoadList, att_value_obj)\n                // Remove duplicates\n                FinalList = ObjectListCompact (CombinedList)\n                set (object, attributename, FinalList)\n              }\n            }\n            else if (att_datatype=\"stringdictionary\") {\n              if (ReplaceContents = True) {\n                // Then completely overwrite existing stringdictionary contents with those in the savecode\n                set (object, attributename, att_value_obj)\n                Dummy = NewStringDictionary()\n              }\n              else {\n                // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                Dummy = preload_att_value\n                // Add dictionary values from SaveGame\n                dictrows = Split(att_value, \";\")\n                foreach (kv, dictrows) {\n                  KeyValList = Split(kv,\" = \")\n                  key = ListItem(KeyValList, 0)\n                  value = ListItem(KeyValList, 1)\n                  DictionaryAdd (Dummy, key, value)\n                }\n                set (object, attributename, Dummy)\n              }\n            }\n            else if (att_datatype=\"objectdictionary\") {\n              if (upgradesave = False) {\n                // Then completely overwrite existing objectdictionary contents with those in the savecode\n                set (object, attributename, att_value_obj)\n              }\n              else {\n                // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                Dummy = preload_att_value\n                // Add dictionary values from SaveGame\n                dictrows = Split(att_value, \";\")\n                foreach (kv, dictrows) {\n                  KeyValList = Split(kv,\" = \")\n                  key = ListItem(KeyValList, 0)\n                  value = ListItem(KeyValList, 1)\n                  if (StartsWith(value,\"Object: \")) {\n                    value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                  }\n                  DictionaryAdd (Dummy, key, value)\n                }\n                set (object, attributename, Dummy)\n              }\n            }\n          }\n          else if (att_datatype=\"string\") {\n            set (object, attributename, att_value)\n          }\n          else {\n            error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n          }\n          if (HasAttribute (object, cha)) {\n            // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n            set (object, cha, scr)\n            scr =&gt; {\n            }\n          }\n        }\n      }\n    }\n    // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n    // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n    AllSavedGrids = Split(GridGInfo,D4)\n    if (DebugMode) {\n      msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n    }\n    foreach (A, AllSavedGrids) {\n      UDictionary = NewDictionary()\n      ItemAndValue = Split(A,\"&amp;%&amp;\")\n      ObjAndAtt = ListItem(ItemAndValue,0)\n      ObjAndAtt = Split(ObjAndAtt,D2)\n      objectname = ListItem(ObjAndAtt,0)\n      attributename = ListItem(ObjAndAtt,1)\n      object = GetObject(objectname)\n      GridVals = ListItem(ItemAndValue,1)\n      GridVals = Split(GridVals,D1)\n      foreach (B, GridVals) {\n        UKeyAndUVal = Split(B,D2)\n        UKey = ListItem(UKeyAndUVal,0)\n        UVal = ListItem(UKeyAndUVal,1)\n        UVal = Split(UVal,D3)\n        LDictionary = NewDictionary()\n        foreach (C, UVal) {\n          LkeyAndLval = Split(C,\" = \")\n          Lkey = ListItem(LkeyAndLval,0)\n          LvalAndType = ListItem(LkeyAndLval,1)\n          LvalAndType = Split(LvalAndType,\":\")\n          Lval_str = ListItem(LvalAndType,0)\n          LType = ListItem(LvalAndType,1)\n          if (LType=\"int\") {\n            Lval = ToInt(Lval_str)\n          }\n          else if (LType=\"double\") {\n            Lval = ToDouble(Lval_str)\n          }\n          else if (LType=\"boolean\") {\n            if (Lval_str=\"True\") {\n              Lval = True\n            }\n            else {\n              Lval = False\n            }\n          }\n          else {\n            error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n          }\n          DictionaryAdd (LDictionary, Lkey, Lval)\n        }\n        DictionaryAdd (UDictionary, UKey, LDictionary)\n      }\n      if (DebugMode) {\n        msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n      }\n      set (object, attributename, UDictionary)\n    }\n    // Destroy any objects that the player destroyed during their saved game, if any\n    if (ListCount(DestroyedList)&gt;0) {\n      foreach (o, DestroyedList) {\n        // Check that objects still exist...\n        IsThere = GetObject(o)\n        if (not Equal(IsThere,null)) {\n          // If its there, destroy the object\n          destroy (o)\n          DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n        }\n      }\n    }\n    if (DebugMode) {\n      msg (\"Created objects: \"+CreatedObjDebugList)\n      msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n      msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n    }\n    // Finally, update game.pov.parent and game.pov\n    set (GamePOVObject, \"parent\", GamePOVParent)\n    game.pov = GamePOVObject\n    // player.grid_coordinates = null\n    JS.Grid_ClearAllLayers ()\n    Grid_Redraw\n    Grid_DrawPlayerInRoom (game.pov.parent)\n    ClearScreen\n    ShowRoomDescription\n  }\n}\n</code></pre>\n</details>\n<p></p><h3>The <em>GetSaveGameCodeDelims</em> function code:</h3><p></p>\n<p>(Function below is new with v3.0)</p>\n<details>\n<pre><code>// GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\n// Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\nDelimList = NewStringList()\nSaveString = SaveGameCode(False)\n// Retrieve delimiters from end of SaveString\nDls = Right(SaveString,4)\nD1 = Mid (Dls, 1, 1)\nD2 = Mid (Dls, 2, 1)\nD3 = Mid (Dls, 3, 1)\nD4 = Mid (Dls, 4, 1)\n// Add to list\nlist add (DelimList, D1)\nlist add (DelimList, D2)\nlist add (DelimList, D3)\nlist add (DelimList, D4)\n// Return the list of delimiters as a string list\nreturn (DelimList)\n</code></pre>\n</details>\n<p></p><h3>The <em>GetSaveCheckpointDelims</em> function code:</h3><p></p>\n<p>(Function below is new with v3.0)</p>\n<details>\n<pre><code>// GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\n// Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\nDelimList = NewStringList()\nSaveString = SaveCheckpoint(\"\")\n// Retrieve delimiters from end of SaveString\nDls = Right(SaveString,4)\nD1 = Mid (Dls, 1, 1)\nD2 = Mid (Dls, 2, 1)\nD3 = Mid (Dls, 3, 1)\nD4 = Mid (Dls, 4, 1)\n// Add to list\nlist add (DelimList, D1)\nlist add (DelimList, D2)\nlist add (DelimList, D3)\nlist add (DelimList, D4)\n// Return the list of delimiters as a string list\nreturn (DelimList)\n</code></pre>\n</details>\n<p></p><h3>The code for the entire test game:</h3><p></p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.8.6836.13983--&gt;\n&lt;asl version=\"580\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Save Testing\"&gt;\n    &lt;gameid&gt;932164b2-0eae-47d6-94b4-402d8a2238d9&lt;/gameid&gt;\n    &lt;version&gt;3.0&lt;/version&gt;\n    &lt;firstpublished&gt;2022&lt;/firstpublished&gt;\n    &lt;feature_devmode /&gt;\n    &lt;attr name=\"devmode_setinitscript\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"devmode_changepovpos\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;devmode_setverbs /&gt;\n    &lt;gridmap /&gt;\n    &lt;showscore type=\"boolean\"&gt;false&lt;/showscore&gt;\n    &lt;showhealth type=\"boolean\"&gt;false&lt;/showhealth&gt;\n    &lt;showmoney type=\"boolean\"&gt;false&lt;/showmoney&gt;\n    &lt;attr name=\"feature_limitinventory\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_lightdark\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_asktell\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_annotations\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_advancedwearables\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;attr name=\"feature_advancedscripts\" type=\"boolean\"&gt;false&lt;/attr&gt;\n    &lt;appendobjectdescription type=\"boolean\"&gt;false&lt;/appendobjectdescription&gt;\n    &lt;allowlookdirections type=\"boolean\"&gt;false&lt;/allowlookdirections&gt;\n    &lt;multiplecommands type=\"boolean\"&gt;false&lt;/multiplecommands&gt;\n    &lt;command_newline /&gt;\n    &lt;clearscreenonroomenter type=\"boolean\"&gt;false&lt;/clearscreenonroomenter&gt;\n    &lt;autodisplayverbs /&gt;\n    &lt;author&gt;Leviathon&lt;/author&gt;\n    &lt;start type=\"script\"&gt;\n      // Initialization script for SaveLoadCode functionality...\n      // Create a list of all object and exit names present in game at start. This way we can keep track of which objects/exits the player has created/destroyed while playing by comparing to this list when saving/loading.\n      set (game, \"StartingObjStrList\", NewStringList ())\n      foreach (startobj, AllObjects()) {\n        list add (game.StartingObjStrList, startobj.name)\n      }\n      foreach (startobj, AllExits()) {\n        list add (game.StartingObjStrList, startobj.name)\n      }\n      set (game, \"checkpoints\", NewStringDictionary())\n      // End of SaveLoadCode initialization script\n    &lt;/start&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;isroom /&gt;\n    &lt;description&gt;&lt;![CDATA[This is the starting room of the SaveLoadCode functionality demo.&lt;br/&gt;&lt;br/&gt;Type \"SaveCode\" at any time to create a save code, allowing you to load later. Copy the code to a notepad document to save it for later!&lt;br/&gt;&lt;br/&gt;Type \"LoadCode\" at any time to load a previously saved code. Paste in your previously-saved save code to load your game!]]&gt;&lt;/description&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n      &lt;StringAttribute&gt;Stringy Bingy&lt;/StringAttribute&gt;\n      &lt;alias&gt;Francis&lt;/alias&gt;\n      &lt;ObjectListRedux type=\"objectlist\"&gt;&lt;/ObjectListRedux&gt;\n    &lt;/object&gt;\n    &lt;object name=\"BoingoBall\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;IsBall /&gt;\n      &lt;MemoryDict type=\"stringdictionary\"&gt;\n        &lt;item&gt;\n          &lt;key&gt;Mem1&lt;/key&gt;\n          &lt;value&gt;Memories of 1&lt;/value&gt;\n        &lt;/item&gt;\n        &lt;item&gt;\n          &lt;key&gt;Mem2&lt;/key&gt;\n          &lt;value&gt;Memories of 2&lt;/value&gt;\n        &lt;/item&gt;\n      &lt;/MemoryDict&gt;\n      &lt;ListOfString type=\"stringlist\"&gt;\n        &lt;value&gt;Brock&lt;/value&gt;\n        &lt;value&gt;Misty&lt;/value&gt;\n        &lt;value&gt;Ash&lt;/value&gt;\n        &lt;value&gt;Pikachu&lt;/value&gt;\n      &lt;/ListOfString&gt;\n      &lt;look&gt;This is an object with a bunch of attributes attached to it. The SaveGameCode and LoadGameCode functions will save all its attributes and update them on load if they've changed.&lt;/look&gt;\n    &lt;/object&gt;\n    &lt;exit name=\"KeyRoomDoor\" alias=\"east\" to=\"Key Room\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n      &lt;locked /&gt;\n      &lt;runscript /&gt;\n      &lt;script type=\"script\"&gt;&lt;![CDATA[\n        if (DoorKey.parent=game.pov and this.locked=true) {\n          msg (\"&lt;i&gt;You unlock the door and enter&lt;/i&gt;\")\n          this.locked = false\n          game.pov.parent = Key Room\n        }\n        else if (this.locked=true) {\n          msg (\"That way is locked.\")\n        }\n        else {\n          game.pov.parent = Key Room\n        }\n      ]]&gt;&lt;/script&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"north\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"northdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;object name=\"DoorKey\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;take /&gt;\n      &lt;alias&gt;Key&lt;/alias&gt;\n      &lt;feature_usegive /&gt;\n      &lt;use type=\"script\"&gt;&lt;![CDATA[\n        if (game.pov.parent=room and KeyRoomDoor.locked=True) {\n          msg (\"&lt;i&gt;Using the key, you unlock the door!&lt;/i&gt;\")\n          KeyRoomDoor.locked = False\n          msg (\"&lt;br&gt;As you walk through the door, the key disintegrates in your hand, &lt;i&gt;destroying&lt;/i&gt; it. (i.e. The Key object itself has been destroyed. If you type 'SaveCode' now, when you load that save the Key will still be destroyed!)\")\n          destroy (\"DoorKey\")\n        }\n        else if (game.pov.parent=room and KeyRoomDoor.locked=False) {\n          msg (\"&lt;i&gt;The door is already unlocked!&lt;/i&gt;\")\n        }\n        else {\n          msg (\"&lt;i&gt;There are no locks to use this on here!&lt;/i&gt;\")\n        }\n      ]]&gt;&lt;/use&gt;\n    &lt;/object&gt;\n    &lt;object name=\"SaveCheckpoint Button\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;look&gt;&lt;![CDATA[Using this button will create a checkpoint! Using it more than once will overwrite the existing checkpoint.&lt;br/&gt;&lt;br/&gt;If you find the LoadCheckpoint Button, you can then load the checkpoint created here.]]&gt;&lt;/look&gt;\n      &lt;feature_usegive /&gt;\n      &lt;displayverbs type=\"stringlist\"&gt;\n        &lt;value&gt;Look at&lt;/value&gt;\n        &lt;value&gt;Use&lt;/value&gt;\n      &lt;/displayverbs&gt;\n      &lt;use type=\"script\"&gt;\n        SaveCheckpoint (\"Checkpoint\")\n      &lt;/use&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Key Room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;description&gt;&lt;![CDATA[You made it in!&lt;br/&gt;&lt;br/&gt;If you save now and load from a new game, this room will still be unlocked!]]&gt;&lt;/description&gt;\n    &lt;enter type=\"script\"&gt;\n    &lt;/enter&gt;\n    &lt;firstenter type=\"script\"&gt;\n    &lt;/firstenter&gt;\n    &lt;exit alias=\"west\" to=\"room\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"SideRoom\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;description&gt;&lt;![CDATA[A side room. When you load, this room will show up on the map since you've explored it now! (It was harder to make this happen than you think it would be...)&lt;br/&gt;&lt;br/&gt;{here DoorKey:You see a {object:DoorKey} on the floor!}]]&gt;&lt;/description&gt;\n    &lt;exit alias=\"south\" to=\"room\"&gt;\n      &lt;inherit name=\"southdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"west\" to=\"OtherSideRoom\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"down\" to=\"Basement\"&gt;\n      &lt;inherit name=\"downdirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;object name=\"LoadCheckpoint Button\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;feature_usegive /&gt;\n      &lt;use type=\"script\"&gt;\n        LoadCheckpoint (\"Checkpoint\")\n      &lt;/use&gt;\n      &lt;displayverbs type=\"stringlist\"&gt;\n        &lt;value&gt;Look at&lt;/value&gt;\n        &lt;value&gt;Use&lt;/value&gt;\n      &lt;/displayverbs&gt;\n      &lt;look&gt;Using this button will load the checkpoint created by the SaveCheckpoint Button (if one was created...)&lt;/look&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"OtherSideRoom\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;exit alias=\"east\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Basement\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;attr name=\"grid_fill\"&gt;Teal&lt;/attr&gt;\n    &lt;exit alias=\"up\" to=\"SideRoom\"&gt;\n      &lt;inherit name=\"updirection\" /&gt;\n    &lt;/exit&gt;\n    &lt;exit alias=\"east\" to=\"Basement Side\"&gt;\n      &lt;inherit name=\"eastdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;object name=\"Basement Side\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;attr name=\"grid_fill\"&gt;Teal&lt;/attr&gt;\n    &lt;exit alias=\"west\" to=\"Basement\"&gt;\n      &lt;inherit name=\"westdirection\" /&gt;\n    &lt;/exit&gt;\n  &lt;/object&gt;\n  &lt;command&gt;\n    &lt;pattern&gt;SaveCode&lt;/pattern&gt;\n    &lt;script&gt;\n      SuppressTurnscripts\n      SaveGameCode (True)\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;command&gt;\n    &lt;pattern&gt;LoadCode&lt;/pattern&gt;\n    &lt;script&gt;\n      SuppressTurnscripts\n      JS.LoadGamePrompt ()\n    &lt;/script&gt;\n  &lt;/command&gt;\n  &lt;function name=\"LoadGameCode\" parameters=\"SaveGameCodeDecoded\"&gt;&lt;![CDATA[\n    // LoadGameCode(SaveGameCodeDecoded) function to load a SaveGameCode save-state. Takes a decoded (not in base64) SaveGameCode created by SaveGameCode and decoded from base64 by java functions. Requires SaveLoadJavaCode.js in order to function!\n    SuppressTurnscripts\n    // NOTE: Requires either JS.LoadSaveCode to be called with a SaveGameCode as an input parameter, or JS.LoadGamePrompt to be called elsewhere (i.e. by a custom \"LoadGame\" command), which will make a popup appear for the player to enter their SaveCode, eventually piping it to this function.\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\n    OldestAllowedVersion = 2.0\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\n    DebugMode = False\n    // Msg for Debugging:\n    if (DebugMode) {\n      msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n    }\n    // Set up other variables for later\n    bla =&gt; {\n    }\n    upgradesave = False\n    Proceed = False\n    SkippedAttList = \"\"\n    CreatedObjDebugList = \"\"\n    DestroyedObjDebugList = \"\"\n    // Check for a \"✓✓\" at the end of the SaveGameCodeDecoded string. If it's there, then the function knows this savecode is for an older game version. \"But how do we know that ✓✓ isn't being used as a custom delimiter?\" Because custom delimiters can only be one character long and two delimiters cannot be the same. Also ✓ (theoretically) cannot be converted to base64, so the user would get an error trying to make a SaveGameCode with ✓ as a delimiter.\n    CheckForCheck = Right(SaveGameCodeDecoded,2)\n    if (CheckForCheck=\"✓✓\") {\n      upgradesave = True\n      SaveGameCodeDecoded = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-2)\n    }\n    // Retrieve delimiters from end of SaveGameCodeDecoded\n    Dls = Right(SaveGameCodeDecoded,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Remove delimiters from end of SaveGameCode\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n    // Special logic to extract saved game.checkpoints attribute\n    D4toD1 = D4+D3+D2+D1\n    CheckpointSplit = Split(SaveCode, D4toD1)\n    SaveCode = ListItem(CheckpointSplit,0)\n    CheckpointKeys = ListItem(CheckpointSplit,1)\n    // If CheckpointKeys not an empty string, then that means there was game.checkpoints data saved. Extract it.\n    if (not CheckpointKeys=\"\") {\n      CheckpointKeyList = Split(CheckpointKeys, D3)\n      game.checkpoints = NewStringDictionary()\n      for (xx, 0, ListCount(CheckpointKeyList)-1) {\n        key = ListItem(CheckpointKeyList,xx)\n        val = ListItem(CheckpointSplit,xx+1)\n        DictionaryAdd (game.checkpoints, key, val)\n      }\n    }\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n    }\n    CDList = Split(CreatedDestroyedInfo,D1)\n    CSection = ListItem (CDList, 0)\n    DSection = ListItem (CDList, 1)\n    if (CSection=\"\") {\n      CreatedList = NewStringList()\n    }\n    else {\n      CreatedList = Split (CSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (CreatedList, \" \")\n    }\n    if (DSection=\"\") {\n      DestroyedList = NewStringList()\n    }\n    else {\n      DestroyedList = Split (DSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (DestroyedList, \" \")\n    }\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n    }\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n    }\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\n    GameIdDelim = Instr (SaveCode, D1)\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\n    GameIdObjectEl = ListItem (GameInfo,0)\n    GameIdElements = Split(GameIdObjectEl,D2)\n    Loaded_GameId = ListItem (GameIdElements, 3)\n    GameVerObjectEl = ListItem (GameInfo,1)\n    GameVerElements = Split(GameVerObjectEl,D2)\n    VersionString = ListItem (GameVerElements, 3)\n    Loaded_GameVersion = ToDouble(VersionString)\n    GamePOVObjectEl = ListItem (GameInfo,2)\n    GamePOVElements = Split(GamePOVObjectEl,D2)\n    GamePOVName = ListItem (GamePOVElements, 3)\n    if (StartsWith(GamePOVName,\"Object: \")) {\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n    }\n    GamePOVObject = GetObject (GamePOVName)\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n    // Check that the save belongs to this game by comparing gameIds\n    if (not Loaded_GameId=game.gameid) {\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n    }\n    else {\n      // Compare version of game in SaveCode to version of game loading it\n      ThisGame_GameVersion = ToDouble(game.version)\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n      }\n      else {\n        OldestAllowedVersion_Double = OldestAllowedVersion\n      }\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n      if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n        if (upgradesave = False) {\n          if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n            msg (\"WARNING! The SaveCode you are attempting to load is from an older game version.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;&lt;br&gt;Would you like to attempt to upgrade this save to the current version? (Results may vary...)\")\n            // Need to save SaveGameCodeDecoded as an attribute temporarily so it can be used by the ShowMenu function\n            create (\"SaveGameDecodedObj\")\n            set (SaveGameDecodedObj, \"value\", SaveGameCodeDecoded)\n            ShowMenu (\"\", Split(\"Yes;No\"), false) {\n              switch (result) {\n                case (\"Yes\") {\n                  SuppressTurnscripts\n                  msg (\"Save code identified! Proceeding with load, please wait...\")\n                  OlderSaveCode = SaveGameDecodedObj.value+\"✓✓\"\n                  LoadGameCode (OlderSaveCode)\n                  destroy (\"SaveGameDecodedObj\")\n                }\n                case (\"No\") {\n                  SuppressTurnscripts\n                  msg (\"Load Aborted.\")\n                  destroy (\"SaveGameDecodedObj\")\n                }\n              }\n            }\n          }\n          else {\n            error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n          }\n        }\n        else {\n          msg (\"Applying savecode from older version...\")\n          Proceed = True\n        }\n      }\n      else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n      }\n      else {\n        msg (\"Proceeding with load...\")\n        Proceed = True\n      }\n      if (Proceed=True) {\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n        if (ListCount(CreatedList)&gt;0) {\n          foreach (o, CreatedList) {\n            // Check that objects don't already exist...\n            IsThere = GetObject(o)\n            if (Equal(IsThere,null)) {\n              // If not, create the object\n              create (o)\n              CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        player.grid_coordinates = null\n        // Split the save code up into all objects. Then parse through the value of each object attribute\n        SavedObjectList = Split(SaveCode, D1)\n        foreach (o, SavedObjectList) {\n          Skip_Att = False\n          objelements = Split(o, D2)\n          objectname = ListItem (objelements, 0)\n          object = GetObject (objectname)\n          attributename = ListItem (objelements, 1)\n          fullname = objectname+\".\"+attributename\n          preload_att_value = GetAttribute (object, attributename)\n          att_datatype = ListItem (objelements, 2)\n          if (ListCount(objelements)=3) {\n            att_value = \"\"\n          }\n          else {\n            att_value = ListItem (objelements, 3)\n          }\n          // Check that the attribute is supported\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n            Skip_Att = True\n            SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n          }\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n          att_value_obj = att_value\n          if (att_datatype=\"object\") {\n            if (StartsWith(att_value,\"Object: \")) {\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n            }\n            else {\n              att_value_obj = GetObject(att_value)\n            }\n          }\n          else if (att_datatype=\"boolean\") {\n            if (att_value=\"True\") {\n              att_value_obj = True\n            }\n            else {\n              att_value_obj = False\n            }\n          }\n          else if (att_datatype=\"int\") {\n            att_value_obj = ToInt(att_value)\n          }\n          else if (att_datatype=\"double\") {\n            att_value_obj = ToDouble(att_value)\n          }\n          else if (att_datatype=\"stringlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringList()\n            }\n            else {\n              att_value_obj = Split (att_value, D3)\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n              list remove (att_value_obj, \" \")\n            }\n          }\n          else if (att_datatype=\"objectlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectList()\n            }\n            else {\n              att_value_obj = NewObjectList()\n              objlistlist = Split (att_value, D3)\n              foreach (olt, objlistlist) {\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n                if (StartsWith(olt,\"Object: \")) {\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n                  if (not value=null) {\n                    list add (att_value_obj, value)\n                  }\n                  else {\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringDictionary()\n            }\n            else {\n              att_value_obj = NewStringDictionary()\n              // Add dictionary values from SaveGame\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                value = ListItem(KeyValList, 1)\n                DictionaryAdd (att_value_obj, key, value)\n              }\n            }\n          }\n          else if (att_datatype=\"objectdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectDictionary()\n            }\n            else {\n              att_value_obj = NewObjectDictionary()\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                obj = ListItem(KeyValList, 1)\n                if (StartsWith(obj,\"Object: \")) {\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                }\n                else {\n                  value = obj\n                }\n                if (not value=null) {\n                  DictionaryAdd (att_value_obj, key, value)\n                }\n                else {\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                }\n              }\n            }\n          }\n          if (objectname=GamePOVName and attributename=\"parent\") {\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n            Skip_Att = True\n            GamePOVParent = att_value_obj\n          }\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n            if (Equal(preload_att_value,null)) {\n              if (DebugMode) {\n                msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n              }\n              preload_att_value = \"null\"\n            }\n            // Msgs for debugging:\n            if (DebugMode) {\n              msg (\"objectname=\"+objectname)\n              msg (\"attributename=\"+attributename)\n              msg (\"att_datatype=\"+att_datatype)\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\n              if (Equal(preload_att_value,\"null\")) {\n                msg (\"preload_att_datatype=null\")\n              }\n              else {\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n              }\n              msg (\"att_value=\"+ToString(att_value))\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n              msg (\"&lt;br&gt;\")\n            }\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n              if (DebugMode) {\n                msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n              }\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n              cha = \"changed\" + attributename\n              if (HasAttribute (object, cha)) {\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n                scr = GetAttribute (object, cha)\n                set (object, cha, bla)\n              }\n              // Update the attributes in the game with those from the SaveCode...\n              if (att_datatype=\"boolean\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"int\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"double\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"object\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n                // NOTE TO DEVELOPER:\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n                if (upgradesave = True) {\n                  // This section will trigger if the player is loading a save from a previous game version\n                  ReplaceContents = True\n                }\n                else {\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n                  ReplaceContents = True\n                }\n                if (att_datatype=\"stringlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace stringlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\n                    FinalList = NewStringList()\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    CompactList = ListCompact (CombinedList)\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                    foreach (olt, CompactList) {\n                      list add (FinalList, olt)\n                    }\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"objectlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace objectlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    FinalList = ObjectListCompact (CombinedList)\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"stringdictionary\") {\n                  if (ReplaceContents = True) {\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                    Dummy = NewStringDictionary()\n                  }\n                  else {\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n                else if (att_datatype=\"objectdictionary\") {\n                  if (upgradesave = False) {\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      if (StartsWith(value,\"Object: \")) {\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                      }\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n              }\n              else if (att_datatype=\"string\") {\n                set (object, attributename, att_value)\n              }\n              else {\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n              }\n              if (HasAttribute (object, cha)) {\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n                set (object, cha, scr)\n                scr =&gt; {\n                }\n              }\n            }\n          }\n        }\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n        AllSavedGrids = Split(GridGInfo,D4)\n        if (DebugMode) {\n          msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n        }\n        foreach (A, AllSavedGrids) {\n          UDictionary = NewDictionary()\n          ItemAndValue = Split(A,\"&amp;%&amp;\")\n          ObjAndAtt = ListItem(ItemAndValue,0)\n          ObjAndAtt = Split(ObjAndAtt,D2)\n          objectname = ListItem(ObjAndAtt,0)\n          attributename = ListItem(ObjAndAtt,1)\n          object = GetObject(objectname)\n          GridVals = ListItem(ItemAndValue,1)\n          GridVals = Split(GridVals,D1)\n          foreach (B, GridVals) {\n            UKeyAndUVal = Split(B,D2)\n            UKey = ListItem(UKeyAndUVal,0)\n            UVal = ListItem(UKeyAndUVal,1)\n            UVal = Split(UVal,D3)\n            LDictionary = NewDictionary()\n            foreach (C, UVal) {\n              LkeyAndLval = Split(C,\" = \")\n              Lkey = ListItem(LkeyAndLval,0)\n              LvalAndType = ListItem(LkeyAndLval,1)\n              LvalAndType = Split(LvalAndType,\":\")\n              Lval_str = ListItem(LvalAndType,0)\n              LType = ListItem(LvalAndType,1)\n              if (LType=\"int\") {\n                Lval = ToInt(Lval_str)\n              }\n              else if (LType=\"double\") {\n                Lval = ToDouble(Lval_str)\n              }\n              else if (LType=\"boolean\") {\n                if (Lval_str=\"True\") {\n                  Lval = True\n                }\n                else {\n                  Lval = False\n                }\n              }\n              else {\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n              }\n              DictionaryAdd (LDictionary, Lkey, Lval)\n            }\n            DictionaryAdd (UDictionary, UKey, LDictionary)\n          }\n          if (DebugMode) {\n            msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n          }\n          set (object, attributename, UDictionary)\n        }\n        // Destroy any objects that the player destroyed during their saved game, if any\n        if (ListCount(DestroyedList)&gt;0) {\n          foreach (o, DestroyedList) {\n            // Check that objects still exist...\n            IsThere = GetObject(o)\n            if (not Equal(IsThere,null)) {\n              // If its there, destroy the object\n              destroy (o)\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        msg (\"Load complete!\")\n        if (DebugMode) {\n          msg (\"Created objects: \"+CreatedObjDebugList)\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n          msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n        }\n        // Finally, update game.pov.parent and game.pov\n        wait {\n          set (GamePOVObject, \"parent\", GamePOVParent)\n          game.pov = GamePOVObject\n          // player.grid_coordinates = null\n          JS.Grid_ClearAllLayers ()\n          Grid_Redraw\n          Grid_DrawPlayerInRoom (game.pov.parent)\n          ClearScreen\n          ShowRoomDescription\n        }\n      }\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"SaveGameCode\" parameters=\"ShowCodePopupFlag\" type=\"string\"&gt;&lt;![CDATA[\n    // SaveGameCode(ShowCodePopupFlag) Function to collect changeable attributes into a string in order to generate a SaveCode for LoadGameCode to load.\n    // The ShowCodePopupFlag input parameter is a boolean value. If TRUE, then the function will present the player with a popup window containing their encoded save code. If FALSE, the function will instead RETURN the SaveString (so if X=SaveGameCode(False), then X will equal the generated SaveString).\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\n    SuppressTurnscripts\n    // Make sure ShowCodePopupFlag is of type 'boolean'\n    if (not TypeOf(ShowCodePopupFlag)=\"boolean\") {\n      X = TypeOf(ShowCodePopupFlag)\n      error (\"ERROR: SaveGameCode function expected input 'ShowCodePopupFlag' to be of type 'boolean', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    SaveString = \"\"\n    CreatedObj = NewStringList()\n    DestroyedObj = NewStringList()\n    // Set delimiters.\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\n    D1 = \"|\"\n    D2 = \"$\"\n    D3 = \";\"\n    D4 = \"@\"\n    // Save the player's current map before saving\n    // Make sure first two entries are gameid and version (for load function)\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n    // Record all changable object attributes\n    foreach (o, AllObjects()) {\n      objectname = o.name\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n            // Confirm there are no banned delimiters in the list entries\n            v = GetAttribute (o, attributename)\n            if (ListCount(v)&gt;0) {\n              if (att_datatype=\"stringlist\") {\n                foreach (listcheck, v) {\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n            // Confirm there are no banned delimiters in the dictionary entries\n            v = GetAttribute (o, attributename)\n            if (DictionaryCount(v)&gt;0) {\n              foreach (dictkey, v) {\n                if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                }\n                if (att_datatype=\"stringdictionary\") {\n                  dictitm = DictionaryItem (v, dictkey)\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (o, AllExits()) {\n      objectname = o.name\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (turnscript, AllTurnScripts()) {\n      // Check for which turnscripts are enabled/disabled\n      if (GetBoolean(turnscript, \"enabled\")) {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n      }\n      else {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n      }\n    }\n    // Determine if any objects were destroyed by the player since game start...\n    foreach (objectname, game.StartingObjStrList) {\n      IsThere = GetObject(objectname)\n      if (Equal(IsThere,null)) {\n        list add (DestroyedObj, objectname)\n      }\n    }\n    // Save the game.timeelapsed attribute\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\n    if (HasAttribute (game, \"SaveAtts\")) {\n      SaveAttType = TypeOf(game.SaveAtts)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveAtts)&gt;0) {\n          foreach (x, game.SaveAtts) {\n            AttValue = GetAttribute (game, x)\n            att_datatype = TypeOf(AttValue)\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n            }\n            else if (Equal(x,\"checkpoints\")) {\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n            }\n            else if (Equal(AttValue,null)) {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n            }\n            else {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n      }\n    }\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\n    if (HasAttribute (game, \"SaveTimers\")) {\n      SaveAttType = TypeOf(game.SaveTimers)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveTimers)&gt;0) {\n          foreach (x, game.SaveTimers) {\n            T = GetObject(x)\n            if (not Equal(T,null)) {\n              TimerName = x.name\n              TimerValue1 = x.trigger\n              TimerValue2 = x.interval\n              TimerValue3 = x.enabled\n              TimerValue1Type = TypeOf(TimerValue1)\n              TimerValue2Type = TypeOf(TimerValue2)\n              TimerValue3Type = TypeOf(TimerValue3)\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n            }\n            else {\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n      }\n    }\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\n    foreach (o, AllObjects()) {\n      foreach (attributename, GetAttributeNames(o,false)) {\n        objectname = o.name\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n      }\n    }\n    // Add on the list of created/destroyed objects...\n    X = ToString(CreatedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    X = ToString(DestroyedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n    // Special logic needed in order to save the game.checkpoints attribute\n    D4toD1 = D4+D3+D2+D1\n    if (HasAttribute(game,\"checkpoints\")) {\n      if (DictionaryCount(game.checkpoints)&gt;0) {\n        KeyList = \"\"\n        CheckValList = \"\"\n        foreach (k, game.checkpoints) {\n          KeyList = KeyList+k+D3\n          val = DictionaryItem(game.checkpoints, k)\n          CheckValList = CheckValList+val+D4toD1\n        }\n        // Remove final D3 from KeyList string and final D4toD1 from CheckValList\n        KeyList = Left(KeyList, LengthOf(KeyList)-LengthOf(D3))\n        CheckValList = Left(CheckValList, LengthOf(CheckValList)-LengthOf(D4toD1))\n        // Add game.checkpoints data to SaveString\n        SaveString = SaveString+D4toD1+KeyList+D4toD1+CheckValList\n      }\n      else {\n        // If game.checkpoints empty, just add D4toD1 to SaveString.\n        SaveString = SaveString+D4toD1\n      }\n    }\n    else {\n      // If game.checkpoints non-existant, just add D4toD1 to SaveString.\n      SaveString = SaveString+D4toD1\n    }\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\n    SaveString = SaveString+D1+D2+D3+D4\n    // msg for Debugging:\n    // msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\n    if (ShowCodePopupFlag=True) {\n      // Create save code and present to player in textbox\n      JS.CreateSaveCode (SaveString)\n      JS.setCss (\"#msgbox\", \"word-wrap:break-word;max-height:250px;\")\n    }\n    return (SaveString)\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"SaveCheckpoint\" parameters=\"CheckpointName\" type=\"string\"&gt;&lt;![CDATA[\n    // SaveCheckpoint(CheckPointName) Function to locally save checkpoints to the game.checkpoints parameter. Functionally works just like SaveGameCode (minus saving game.checkpoints), except it does not convert the SaveString to base64 or present the SaveCode to the player, instead storing it in the game.checkpoints stringdictionary.\n    // The CheckpointName input parameter is a string value that will become the Key in the game.checkpoints string dictionary for the generated checkpoint SaveString value. If the CheckpointName already exists in game.checkpoints, then this function will overwrite it, allowing checkpoint names to be re-used multiple times.\n    // If CheckpointName=\"\", then the SaveString will simply be returned as an output, rather than saved to game.checkpoints.\n    // Will not save non-string/non-object lists/dictionaries (with grid_coordinates as an exception), will not save script attributes, will not save script dictionaries, will not save delegate attributes, will not save command patterns, will not save the \"look\" attribute (as it should not change), and will not save the \"description\" attribute (as it should not change).\n    // Will not grab any other attributes attached to the \"game\" object except for game.gameid, game.version, game.pov, and game.timeelapsed. IF YOU WOULD LIKE TO SAVE ANY ADDITIONAL ATTRIBUTES ATTACHED TO \"game\", you will need to add the attribute names to a game.SaveAtts STRINGLIST attribute OR EDIT THIS FUNCTION TO CALL THEM OUT SPECIFICALLY. If you'd like to go the latter route I've noted the section below where I would recommend adding custom \"game\" attributes with a ***\n    // Will not save timer status UNLESS the names of the timers are added to a game.SaveTimers STRINGLIST attribute OR YOU EDIT THIS FUNCTION DIRECTLY! If you want to go the latter route, I would recommend adding these to the section below marked with ***\n    SuppressTurnscripts\n    // Check if game.checkpoints exists. If not, create it.\n    if (not HasAttribute(game, \"checkpoints\")) {\n      set (game, \"checkpoints\", NewStringDictionary())\n    }\n    // Make sure CheckpointName input is of 'string' datatype\n    if (not TypeOf(CheckpointName)=\"string\") {\n      X = TypeOf(CheckpointName)\n      error (\"ERROR: SaveCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    SaveString = \"\"\n    CreatedObj = NewStringList()\n    DestroyedObj = NewStringList()\n    // Set delimiters.\n    // WARNING: D1 or D2 CANNOT be present in any object names, attribute names, or attribute values that you intend to save. Otherwise, the save will not load properly.\n    // WARNING: D3 CANNOT be present in any object names or attribute names, but CAN be present in an attribute's value. This is because D3 MUST be the delimiter used to separate List entries in order to load lists properly\n    // D1 delimiter will separate full object attributes, D2 delimiter will separate the data that comprises an attribute.\n    // D3 is not set by this function, but instead is what the LoadGame() function will assume separates all list entries. As a reminder, by-default Quest will use ; as the List delimiter.\n    D1 = \"|\"\n    D2 = \"$\"\n    D3 = \";\"\n    D4 = \"@\"\n    // Save the player's current map before saving\n    // Make sure first two entries are gameid and version (for load function)\n    SaveString = SaveString+\"game\"+D2+\"gameid\"+D2+\"string\"+D2+game.gameid+D1\n    SaveString = SaveString+\"game\"+D2+\"version\"+D2+\"string\"+D2+game.version+D1\n    // Grab current active player (game.pov). This way the LoadGame knows who the player object is and to update its parent last\n    SaveString = SaveString+\"game\"+D2+\"pov\"+D2+\"object\"+D2+game.pov+D1\n    // Record all changable object attributes\n    foreach (o, AllObjects()) {\n      objectname = o.name\n      // Check to see if object was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n            // Confirm there are no banned delimiters in the list entries\n            v = GetAttribute (o, attributename)\n            if (ListCount(v)&gt;0) {\n              if (att_datatype=\"stringlist\") {\n                foreach (listcheck, v) {\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(listcheck,D1)&gt;0 or Instr(listcheck,D2)&gt;0 or Instr(listcheck,D3)&gt;0 or Instr(listcheck,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" list entry '\"+listcheck+\"'! Consider editting SaveGameCode function to change delimiters, or renaming list entry. Current banned list entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n            // Confirm there are no banned delimiters in the dictionary entries\n            v = GetAttribute (o, attributename)\n            if (DictionaryCount(v)&gt;0) {\n              foreach (dictkey, v) {\n                if (Instr(dictkey,D1)&gt;0 or Instr(dictkey,D2)&gt;0 or Instr(dictkey,D3)&gt;0 or Instr(dictkey,D4)&gt;0) {\n                  error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key '\"+dictkey+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary key. Current banned dictionary key delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                }\n                if (att_datatype=\"stringdictionary\") {\n                  dictitm = DictionaryItem (v, dictkey)\n                  // Check if there are delimiters in the names of the list entries. If so, warn the player that their save won't work.\n                  if (Instr(dictitm,D1)&gt;0 or Instr(dictitm,D2)&gt;0 or Instr(dictitm,D3)&gt;0 or Instr(dictitm,D4)&gt;0) {\n                    error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" dictionary key.value '\"+dictkey+\".\"+dictitm+\"'! Consider editting SaveGameCode function to change delimiters, or renaming dictionary value. Current banned dictionary entry delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n                  }\n                }\n              }\n            }\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object.Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (o, AllExits()) {\n      objectname = o.name\n      // Check to see if exit was created by player mid-game by comparing to the objectlist at start of game\n      if (not ListContains(game.StartingObjStrList, objectname)) {\n        // Then object was created by player. Double-check that it isn't already in CreatedObj list. If not, add it.\n        if (not ListContains(CreatedObj, objectname)) {\n          list add (CreatedObj, objectname)\n        }\n        // If the object was created mid-game, then we might want to capture additional inherited type info to help when it gets recreated on load...\n        IncludeTypeFlag = True\n      }\n      else {\n        IncludeTypeFlag = False\n      }\n      foreach (attributename, GetAttributeNames(o,IncludeTypeFlag)) {\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\" and not att_datatype=\"command pattern\" and not attributename=\"look\" and not attributename=\"description\") {\n          if (att_datatype=\"object\") {\n            v = GetAttribute (o, attributename)\n            att_value = v.name\n          }\n          else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n          }\n          else if (att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n            X = ToString(GetAttribute (o, attributename))\n            // Cut off the \"Dictionary: \" string that preceeds its values when you use the ToString() command\n            att_value = Right(X,LengthOf(X)-LengthOf(\"Dictionary: \"))\n          }\n          else {\n            att_value = ToString(GetAttribute (o, attributename))\n          }\n          // Check if there are delimiters in any of the names/values. If so, warn the player that their save won't work.\n          if (Instr(objectname,D1)&gt;0 or Instr(objectname,D2)&gt;0 or Instr(objectname,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" object name! Consider editting SaveGameCode function to change delimiters, or renaming object. Current banned objectname delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(attributename,D1)&gt;0 or Instr(attributename,D2)&gt;0 or Instr(attributename,D3)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute name! Consider editting SaveGameCode function to change delimiters, or renaming attribute. Current banned attributename delimiters: \"+D1+\" \"+D2+\" \"+D3+\" \"+D4)\n          }\n          else if (Instr(att_value,D1)&gt;0 or Instr(att_value,D2)&gt;0 or Instr(objectname,D4)&gt;0) {\n            error (\"ERROR: Banned delimiter detected in \\\"\"+fullname+\"\\\" attribute value! Consider editting SaveGameCode function to change delimiters, or changing attribute value. Current banned attribute value delimiters: \"+D1+\" \"+D2+\" \"+D4)\n          }\n          SaveString = SaveString+objectname+D2+attributename+D2+att_datatype+D2+att_value+D1\n        }\n      }\n    }\n    foreach (turnscript, AllTurnScripts()) {\n      // Check for which turnscripts are enabled/disabled\n      if (GetBoolean(turnscript, \"enabled\")) {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"True\"+D1\n      }\n      else {\n        SaveString = SaveString+turnscript.name+D2+\"enabled\"+D2+\"boolean\"+D2+\"False\"+D1\n      }\n    }\n    // Determine if any objects were destroyed by the player since game start...\n    foreach (objectname, game.StartingObjStrList) {\n      IsThere = GetObject(objectname)\n      if (Equal(IsThere,null)) {\n        list add (DestroyedObj, objectname)\n      }\n    }\n    // Save the game.timeelapsed attribute\n    SaveString = SaveString+\"game\"+D2+\"timeelapsed\"+D2+\"int\"+D2+ToString(game.timeelapsed)+D1\n    // Check if game.SaveAtts and/or game.SaveTimers exists.\n    // game.SaveAtts is expected to be a stringlist containing a list of game attributes to save.\n    if (HasAttribute (game, \"SaveAtts\")) {\n      SaveAttType = TypeOf(game.SaveAtts)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveAtts)&gt;0) {\n          foreach (x, game.SaveAtts) {\n            AttValue = GetAttribute (game, x)\n            att_datatype = TypeOf(AttValue)\n            if (not Equal(AttValue,null) and not Equal(x,\"checkpoints\") and not att_datatype=\"script\" and not att_datatype=\"scriptdictionary\" and not att_datatype=\"dictionary\" and not att_datatype=\"list\" and not att_datatype=\"delegate\"and not att_datatype=\"command pattern\") {\n              SaveString = SaveString+\"game\"+D2+x+D2+att_datatype+D2+ToString(AttValue)+D1\n            }\n            else if (Equal(x,\"checkpoints\")) {\n              error (\"ERROR: game.SaveAtts - Banned attribute 'checkpoints' found in game.SaveAtts. game.checkpoints cannot be saved using game.SaveAtts!\")\n            }\n            else if (Equal(AttValue,null)) {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not found attached to game object!\")\n            }\n            else {\n              error (\"ERROR: game.SaveAtts - Attribute entry '\"+x+\"' not allowed. SaveGameCode cannot save attributes of type: \"+att_datatype)\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveAtts expected to be a stringlist containing a list of game attributes to save. Instead, game.SaveAtts found is of datatype: \"+SaveAttType)\n      }\n    }\n    // game.SaveTimers is expected to be an stringlist containing a list of the names of all timers in the game that the author wants to save (ideally, all timers in the game).\n    if (HasAttribute (game, \"SaveTimers\")) {\n      SaveAttType = TypeOf(game.SaveTimers)\n      if (SaveAttType=\"stringlist\") {\n        if (ListCount(game.SaveTimers)&gt;0) {\n          foreach (x, game.SaveTimers) {\n            T = GetObject(x)\n            if (not Equal(T,null)) {\n              TimerName = x.name\n              TimerValue1 = x.trigger\n              TimerValue2 = x.interval\n              TimerValue3 = x.enabled\n              TimerValue1Type = TypeOf(TimerValue1)\n              TimerValue2Type = TypeOf(TimerValue2)\n              TimerValue3Type = TypeOf(TimerValue3)\n              SaveString = SaveString+TimerName+D2+\"trigger\"+D2+TimerValue1Type+D2+ToString(TimerValue1)+D1\n              SaveString = SaveString+TimerName+D2+\"interval\"+D2+TimerValue2Type+D2+ToString(TimerValue2)+D1\n              SaveString = SaveString+TimerName+D2+\"enabled\"+D2+TimerValue3Type+D2+ToString(TimerValue3)+D1\n            }\n            else {\n              error (\"ERROR: game.SaveTimers - Timer named '\"+x+\"' not found!\")\n            }\n          }\n        }\n      }\n      else {\n        error (\"ERROR: game.SaveTimers expected to be a stringlist containing a list of the names of timers. Instead, game.SaveTimers found is of datatype: \"+SaveAttType)\n      }\n    }\n    // If neither of those attributes exist, then the developer can also add their own custom attributes to save using the template below...\n    // *** TO DEVELOPER: Recommend putting timer status and other \"game\" attributes that can change based on user action during the game in this function below:\n    // The template to save additional attributes is SaveString=SaveString+{string objectname}+D2+{string attributename}+D2+{datatype string}+D2+ToString({attribute value})+D1\n    // For example, to save the \"timer.enabled\" attribute for a timer named BeeTimer: SaveString=SaveString+\"BeeTimer\"+D2+\"enabled\"+D2+\"boolean\"+D2+ToString(BeeTimer.enabled)+D1\n    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // DO NOT APPEND THE SAVESTRING WITH ANY ADDITIONAL ATTRIBUTES BELOW THIS POINT. The game.pov.grid_coordinates, Created/Destroyed objectlist, and delimiters MUST be added on last in order for the LoadGame() Function to load properly.\n    // Save the player.grid_coordinates so the player's map is saved. Because it is a dictionary of dictionaries, it must be saved in a special way...\n    // grid_coordinates will be saved in form: \"StuffBefore|@ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\"\n    foreach (o, AllObjects()) {\n      foreach (attributename, GetAttributeNames(o,false)) {\n        objectname = o.name\n        fullname = objectname+\".\"+attributename\n        att_datatype = ToString(TypeOf(o, attributename))\n        if (att_datatype=\"dictionary\" and StartsWith(attributename,\"saved_map_for_\")) {\n          // ASSUMES THAT ANY SAVED MAP DATA (for teleporting and keeping your map) STARTS WITH 'saved_map_for'. This follows the naming convention recommended by https://docs.textadventures.co.uk/quest/showing_a_map.html\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n        else if (att_datatype=\"dictionary\" and attributename=\"grid_coordinates\") {\n          // Save the current map. Typically this is game.pov.grid_coordinates, but if player character can change, there may be multiple occurences of 'grid_coordinates'. Save them all.\n          SaveString = SaveString + D4 + objectname + D2 + attributename + \"&amp;%&amp;\"\n          foreach (UKey, GetAttribute(o, attributename)) {\n            SaveString = SaveString+UKey+D2\n            UVal = DictionaryItem(GetAttribute(o, attributename), UKey)\n            foreach (Lkey, UVal) {\n              Lval = DictionaryItem(UVal, Lkey)\n              Lval = ToString(Lval)+\":\"+ToString(TypeOf(Lval))\n              SaveString = SaveString+Lkey+\" = \"+ToString(Lval)+D3\n            }\n            SaveString = Left(SaveString,(LengthOf(SaveString)-1))+D1\n          }\n        }\n      }\n    }\n    // Add on the list of created/destroyed objects...\n    X = ToString(CreatedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    CreatedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    X = ToString(DestroyedObj)\n    // Cut off the \"List: \" string that preceeds its values when you use the ToString() command\n    DestroyedObjStr = Right(X,LengthOf(X)-LengthOf(\"List: \"))\n    SaveString = SaveString+D4+CreatedObjStr+D1+DestroyedObjStr\n    // Append the end of the SaveString with the delimiters used, so LoadGame() knows what delimiter maps to what...\n    SaveString = SaveString+D1+D2+D3+D4\n    // msg for Debugging:\n    // msg (SaveString+\"&lt;br&gt;&lt;br&gt;\")\n    // Save SaveString to game.checkpoints if CheckpointName not empty. Else if CheckpointName=\"\", then simply return the SaveString.\n    if (not CheckpointName=\"\") {\n      DictionaryAdd (game.checkpoints, CheckpointName, SaveString)\n    }\n    return (SaveString)\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"LoadCheckpoint\" parameters=\"CheckpointName\"&gt;&lt;![CDATA[\n    // LoadCheckpoint(CheckpointName) function to load a SaveCheckpoint checkpoint. Works similarly to LoadGameCode except it does not print any messages to the player. Also will not prompt the player if a save is found to be from an older version, it will just load according to the OldestAllowedVersion variable.\n    // Input CheckpointName is the name of a checkpoint saved in the game.checkpoints stringdictionary attribute that you would like to load.\n    SuppressTurnscripts\n    // TO DEVELOPER: Set the OldestAllowedVersion to the oldest compatible game version that a player can load saved game data from. Setting OldestAllowedVersion=0 will essentially allow the player to load saves from any old version. Setting OldestAllowedVersion=game.version will make it so the player can ONLY load saves from the current game version.\n    OldestAllowedVersion = 2.0\n    // TO DEVELOPER: Setting DebugMode to 'True' will enable the printing of debug messages to the screen when running. Very useful for testing out the function if you've made any custom edits for compatibility or the like.\n    DebugMode = False\n    // Msg for Debugging:\n    if (DebugMode) {\n      msg (\"&lt;br&gt;Full decoded SaveCode:&lt;br&gt;\"+SaveGameCodeDecoded)\n    }\n    // Make sure CheckpointName input is of type 'string'\n    if (not TypeOf(CheckpointName)=\"string\") {\n      X = TypeOf(CheckpointName)\n      error (\"ERROR: LoadCheckpoint function expected input 'CheckpointName' to be of type 'string', but instead recieved an input of type '\"+X+\"'!\")\n    }\n    // Retrieve SaveString from game.checkpoints dictionary\n    if (HasAttribute(game, \"checkpoints\")) {\n      if (DictionaryContains(game.checkpoints, CheckpointName)) {\n        SaveGameCodeDecoded = DictionaryItem(game.checkpoints, CheckpointName)\n      }\n      else {\n        error (\"ERROR: Checkpoint named '\"+CheckpointName+\"' not found!\")\n      }\n    }\n    else {\n      error (\"ERROR: Cannot load checkpoint as game.checkpoints attribute does not exist!\")\n    }\n    // Set up other variables for later\n    bla =&gt; {\n    }\n    upgradesave = False\n    Proceed = False\n    SkippedAttList = \"\"\n    CreatedObjDebugList = \"\"\n    DestroyedObjDebugList = \"\"\n    // Retrieve delimiters from end of SaveGameCodeDecoded\n    Dls = Right(SaveGameCodeDecoded,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Remove delimiters from end of SaveGameCode\n    SaveCode = Left(SaveGameCodeDecoded, LengthOf(SaveGameCodeDecoded)-(LengthOf(Dls)))\n    // Extract the Created/Destroyed object lists. The START of the created/destroyed section should be after the LAST D4 delimiter...\n    CreatedDestroyedInfo = Right(SaveCode, LengthOf(SaveCode)-InstrRev(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;CreatedDestroyedInfo: \"+CreatedDestroyedInfo)\n    }\n    CDList = Split(CreatedDestroyedInfo,D1)\n    CSection = ListItem (CDList, 0)\n    DSection = ListItem (CDList, 1)\n    if (CSection=\"\") {\n      CreatedList = NewStringList()\n    }\n    else {\n      CreatedList = Split (CSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (CreatedList, \" \")\n    }\n    if (DSection=\"\") {\n      DestroyedList = NewStringList()\n    }\n    else {\n      DestroyedList = Split (DSection, D3)\n      // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n      list remove (DestroyedList, \" \")\n    }\n    // Remove Created/Destroyed list from end of SaveCode, also removing the final D1 and D4 delimiter...\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(CreatedDestroyedInfo)+2))\n    // Extract the player.grid_coordinates info separately from the rest of the savecode. It has special rules for decoding it since it is a dictionary of dictionaries.\n    GridGInfo = Right(SaveCode, LengthOf(SaveCode)-Instr(SaveCode, D4))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;GridGInfo: \"+GridGInfo)\n    }\n    // Remove player.grid_coordinates info from end of SaveCode also remove the final D1 &amp; D4 delimiter separating the grid_coordinates from the rest of the attributes\n    SaveCode = Left(SaveCode, LengthOf(SaveCode)-(LengthOf(GridGInfo)+2))\n    if (DebugMode) {\n      msg (\"&lt;br&gt;SaveCode w/o player.grid_coordinate or create/destroy info:&lt;br&gt;\"+SaveCode)\n    }\n    // Note: if the \"SaveCode\" begins with the word \"Error:\", then an error was encountered when trying to convert from Base64.\n    // Extract SaveCode game info. This includes the gameid, game version, and current player (game.pov)...\n    GameIdDelim = Instr (SaveCode, D1)\n    GameVersionDelim = Instr(GameIdDelim+1,SaveCode,D1)\n    GamePOVDelim = Instr(GameVersionDelim+1,SaveCode,D1)\n    GameInfo = Split(Left(SaveCode,GamePOVDelim-1),D1)\n    GameIdObjectEl = ListItem (GameInfo,0)\n    GameIdElements = Split(GameIdObjectEl,D2)\n    Loaded_GameId = ListItem (GameIdElements, 3)\n    GameVerObjectEl = ListItem (GameInfo,1)\n    GameVerElements = Split(GameVerObjectEl,D2)\n    VersionString = ListItem (GameVerElements, 3)\n    Loaded_GameVersion = ToDouble(VersionString)\n    GamePOVObjectEl = ListItem (GameInfo,2)\n    GamePOVElements = Split(GamePOVObjectEl,D2)\n    GamePOVName = ListItem (GamePOVElements, 3)\n    if (StartsWith(GamePOVName,\"Object: \")) {\n      GamePOVName = Right(GamePOVName,LengthOf(GamePOVName)-LengthOf(\"Object: \"))\n    }\n    GamePOVObject = GetObject (GamePOVName)\n    GamePOVParent = GetAttribute (GamePOVObject, \"parent\")\n    // Check that the save belongs to this game by comparing gameIds\n    if (not Loaded_GameId=game.gameid) {\n      error (\"Load Aborted: SaveCode not identified by this game. GameID mismatch.\")\n    }\n    else {\n      // Compare version of game in SaveCode to version of game loading it\n      ThisGame_GameVersion = ToDouble(game.version)\n      if (not TypeOf(OldestAllowedVersion)=\"double\") {\n        OldestAllowedVersion_Double = ToDouble(OldestAllowedVersion)\n      }\n      else {\n        OldestAllowedVersion_Double = OldestAllowedVersion\n      }\n      // If upgrading from an old game version, then arbitrarily set Loaded_GameVersion to ThisGameVersion to proceed.\n      if (Loaded_GameVersion&lt;ThisGame_GameVersion) {\n        if (OldestAllowedVersion_Double&lt;=Loaded_GameVersion) {\n          upgradesave = True\n          Proceed = True\n        }\n        else {\n          error (\"ERROR: The SaveCode you are attempting to load is from an INCOMPATIBLE older game version, and thus cannot be loaded by this version of the game.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Oldest Compatible Version: v\"+ToString(OldestAllowedVersion)+\"&lt;br&gt;&lt;br&gt;Loading aborted...\")\n        }\n      }\n      else if (Loaded_GameVersion&gt;ThisGame_GameVersion) {\n        error (\"ERROR: The SaveCode you are attempting to load is from a newer version of this game and is not compatible.&lt;br&gt;Saved Game: v\"+ToString(Loaded_GameVersion)+\"&lt;br&gt;This Game: v\"+ToString(ThisGame_GameVersion)+\"&lt;br&gt;Please try a different SaveCode or use an updated game file.&lt;br&gt;&lt;br&gt;Load aborted.\")\n      }\n      else {\n        Proceed = True\n      }\n      if (Proceed=True) {\n        // Create any objects noted in the CreatedList, if there are any, so their relevant attributes can be added without error...\n        if (ListCount(CreatedList)&gt;0) {\n          foreach (o, CreatedList) {\n            // Check that objects don't already exist...\n            IsThere = GetObject(o)\n            if (Equal(IsThere,null)) {\n              // If not, create the object\n              create (o)\n              CreatedObjDebugList = CreatedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        player.grid_coordinates = null\n        // Split the save code up into all objects. Then parse through the value of each object attribute\n        SavedObjectList = Split(SaveCode, D1)\n        foreach (o, SavedObjectList) {\n          Skip_Att = False\n          objelements = Split(o, D2)\n          objectname = ListItem (objelements, 0)\n          object = GetObject (objectname)\n          attributename = ListItem (objelements, 1)\n          fullname = objectname+\".\"+attributename\n          preload_att_value = GetAttribute (object, attributename)\n          att_datatype = ListItem (objelements, 2)\n          if (ListCount(objelements)=3) {\n            att_value = \"\"\n          }\n          else {\n            att_value = ListItem (objelements, 3)\n          }\n          // Check that the attribute is supported\n          if (not att_datatype=\"string\" and not att_datatype=\"boolean\" and not att_datatype=\"object\" and not att_datatype=\"int\" and not att_datatype=\"double\" and not att_datatype=\"stringlist\" and not att_datatype=\"objectlist\" and not att_datatype=\"stringdictionary\" and not att_datatype=\"objectdictionary\") {\n            msg (\"WARNING! Unsupported datatype \\\"\"+att_datatype+\"\\\" detected in SaveCode attribute \\\"\"+fullname+\"\\\"! Skipping and moving on to next attribute...\")\n            Skip_Att = True\n            SkippedAttList = SkippedAttList+fullname+\"&lt;br&gt;\"\n          }\n          // Convert the string attribute value and convert it to the datatype that it actually needs to be. This att_value_obj variable will also be directly compared to preload_att_value to determine if the pre- and post- load values are equal or not...\n          att_value_obj = att_value\n          if (att_datatype=\"object\") {\n            if (StartsWith(att_value,\"Object: \")) {\n              att_value_obj = GetObject(Right(att_value,LengthOf(att_value)-LengthOf(\"Object: \")))\n            }\n            else {\n              att_value_obj = GetObject(att_value)\n            }\n          }\n          else if (att_datatype=\"boolean\") {\n            if (att_value=\"True\") {\n              att_value_obj = True\n            }\n            else {\n              att_value_obj = False\n            }\n          }\n          else if (att_datatype=\"int\") {\n            att_value_obj = ToInt(att_value)\n          }\n          else if (att_datatype=\"double\") {\n            att_value_obj = ToDouble(att_value)\n          }\n          else if (att_datatype=\"stringlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringList()\n            }\n            else {\n              att_value_obj = Split (att_value, D3)\n              // The way the lists are saved, when you load it, a blank entry will be created. Let's remove that...\n              list remove (att_value_obj, \" \")\n            }\n          }\n          else if (att_datatype=\"objectlist\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectList()\n            }\n            else {\n              att_value_obj = NewObjectList()\n              objlistlist = Split (att_value, D3)\n              foreach (olt, objlistlist) {\n                // Need to remove the \"Object: \" that will preceed each entry, and turn the string entry into the actual object before re-adding to list. We put it into the following \"if\" statement in order to exclude the blank list entry that gets created at the end of the list by loading\n                if (StartsWith(olt,\"Object: \")) {\n                  value = GetObject(Right(olt,LengthOf(olt)-LengthOf(\"Object: \")))\n                  if (not value=null) {\n                    list add (att_value_obj, value)\n                  }\n                  else {\n                    msg (\"WARNING! Object \\\"\"+olt+\"\\\" detected in saved objectlist \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+olt+\"\\\" not added to list! Loaded game may not work properly!\")\n                    SkippedAttList = SkippedAttList+\"Objectlist '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                  }\n                }\n              }\n            }\n          }\n          else if (att_datatype=\"stringdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewStringDictionary()\n            }\n            else {\n              att_value_obj = NewStringDictionary()\n              // Add dictionary values from SaveGame\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"StringDict '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                value = ListItem(KeyValList, 1)\n                DictionaryAdd (att_value_obj, key, value)\n              }\n            }\n          }\n          else if (att_datatype=\"objectdictionary\") {\n            if (att_value=\"\") {\n              att_value_obj = NewObjectDictionary()\n            }\n            else {\n              att_value_obj = NewObjectDictionary()\n              dictrows = Split(att_value, \";\")\n              foreach (kv, dictrows) {\n                if (DebugMode) {\n                  msg (\"ObjDict  '\"+fullname+\"' key-value: \"+ToString(kv))\n                }\n                KeyValList = Split(kv,\" = \")\n                key = ListItem(KeyValList, 0)\n                obj = ListItem(KeyValList, 1)\n                if (StartsWith(obj,\"Object: \")) {\n                  value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                }\n                else {\n                  value = obj\n                }\n                if (not value=null) {\n                  DictionaryAdd (att_value_obj, key, value)\n                }\n                else {\n                  msg (\"WARNING! Object \\\"\"+obj+\"\\\" detected in saved objectdictionary \\\"\"+fullname+\"\\\" does not exist! Object \\\"\"+obj+\"\\\" not added to dictionary! Loaded game may not work properly!\")\n                  SkippedAttList = SkippedAttList+\"Objectdictionary '\"+fullname+\"' item: \"+olt+\"&lt;br&gt;\"\n                }\n              }\n            }\n          }\n          if (objectname=GamePOVName and attributename=\"parent\") {\n            // Check that the attribute is NOT game.pov.parent. If so, we want to make sure that gets updated last\n            Skip_Att = True\n            GamePOVParent = att_value_obj\n          }\n          // Make sure the object you are trying to add/update the attribute to exists, otherwise you'd get an error trying to update/create its attribute. If the attribute doesn't exist but the object does, then this function will create it. Also, don't update the game.version or game.pov: The game.version should not be updated from the savecode if you're loading from a previous version, and the game.pov is updated last.\n          if (not Equal(object,null) and not Equal(att_value_obj,null) and not fullname=\"game.gameid\" and not fullname=\"game.version\" and not fullname=\"game.pov\" and not Skip_Att=True) {\n            if (Equal(preload_att_value,null)) {\n              if (DebugMode) {\n                msg (\"&lt;br&gt;ATTENTION: Attribute '\"+fullname+\"' does NOT exist in current game, but its parent object '\"+objectname+\"' does, so attribute will be created!&lt;br&gt;\")\n              }\n              preload_att_value = \"null\"\n            }\n            // Msgs for debugging:\n            if (DebugMode) {\n              msg (\"objectname=\"+objectname)\n              msg (\"attributename=\"+attributename)\n              msg (\"att_datatype=\"+att_datatype)\n              msg (\"preload_att_value=\"+ToString(preload_att_value))\n              if (Equal(preload_att_value,\"null\")) {\n                msg (\"preload_att_datatype=null\")\n              }\n              else {\n                msg (\"preload_att_datatype=\"+TypeOf(preload_att_value))\n              }\n              msg (\"att_value=\"+ToString(att_value))\n              msg (\"att_value_obj=\"+ToString(att_value_obj))\n              msg (\"isEqual att_value=preload_att_value?: \"+ToString(Equal(att_value,preload_att_value)))\n              msg (\"isEqual att_value_obj=preload_att_value?: \"+ToString(Equal(att_value_obj,preload_att_value)))\n              msg (\"isEqual ToString(att_value_obj)=ToString(preload_att_value)?: \"+ToString(Equal(ToString(att_value_obj),ToString(preload_att_value))))\n              msg (\"&lt;br&gt;\")\n            }\n            // If attributes are already equal to those in the savecode, no need to change them. Else, change 'em.\n            if (not Equal(att_value,preload_att_value) and not Equal(att_value_obj,preload_att_value) and not Equal(ToString(att_value_obj),ToString(preload_att_value))) {\n              if (DebugMode) {\n                msg (\"Updating attribute: \"+fullname+\"&lt;br&gt;&lt;br&gt;\")\n              }\n              // Check if attribute has an associated change script. If so, this section will make sure that setting the attribute on load WON'T activate its associate turnscript\n              cha = \"changed\" + attributename\n              if (HasAttribute (object, cha)) {\n                // If the attribute DOES have an associated change script, temporarily blank it out so it does not execute during loading\n                scr = GetAttribute (object, cha)\n                set (object, cha, bla)\n              }\n              // Update the attributes in the game with those from the SaveCode...\n              if (att_datatype=\"boolean\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"int\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"double\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"object\") {\n                set (object, attributename, att_value_obj)\n              }\n              else if (att_datatype=\"stringlist\" or att_datatype=\"objectlist\" or att_datatype=\"stringdictionary\" or att_datatype=\"objectdictionary\") {\n                // NOTE TO DEVELOPER:\n                // Alter the following logic below to fit your needs. Especially important to make sure this works properly for YOUR game for compatibility between game versions!\n                // If ReplaceContents = True, then any list or dictionary in your game will be COMPLETELY REPLACED by its corresponding list/dictionary from the savecode.\n                // If ReplaceContents = False, then the list/dictionary contents in the SaveCode will be ADDED to the existing corresponding list/dictionary. NOTE: When adding to an existing list/dict, the code, as-written, will REMOVE ANY DUPLICATES from the lists/dictionaries! ALSO, be careful where you allow LoadGame() to be called in cases where ReplaceContents=False, ESPECIALLY if the list/dict contents can change through the course of the game! Calling this LoadGameCode function only from a titlescreen (before any lists/dictionaries have changed), for instance, may be one possible way to account for this.\n                // ReplaceContents=True by default, but this may not be desirable in all cases (i.e. if you updated the contents of a permanent dictionary/list between versions), so it is up to YOU to ensure this section behaves as you want it to. Remember that the \"object\" and \"attributename\" variables exist at this point to call out specific list/dictionary objects.\n                if (upgradesave = True) {\n                  // This section will trigger if the player is loading a save from a previous game version\n                  ReplaceContents = True\n                }\n                else {\n                  // If this savecode is NOT coming from a previous game version, then I assume it is safe to completely replace the existing dictionary with the saved one.\n                  ReplaceContents = True\n                }\n                if (att_datatype=\"stringlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace stringlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved stringlist TO the existing stringlist in-game\n                    FinalList = NewStringList()\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    CompactList = ListCompact (CombinedList)\n                    // CompactList will be a generic \"list\" type object, need to convert it back to a stringlist...\n                    foreach (olt, CompactList) {\n                      list add (FinalList, olt)\n                    }\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"objectlist\") {\n                  if (ReplaceContents = True) {\n                    // Completely replace objectlist contents with those found in the SaveCode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectlist TO the existing objectlist in-game\n                    // Retrieve the contents of the existing list\n                    PreLoadList = preload_att_value\n                    CombinedList = ListCombine (PreLoadList, att_value_obj)\n                    // Remove duplicates\n                    FinalList = ObjectListCompact (CombinedList)\n                    set (object, attributename, FinalList)\n                  }\n                }\n                else if (att_datatype=\"stringdictionary\") {\n                  if (ReplaceContents = True) {\n                    // Then completely overwrite existing stringdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                    Dummy = NewStringDictionary()\n                  }\n                  else {\n                    // Add the contents of the saved stringdictionary TO the existing stringdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n                else if (att_datatype=\"objectdictionary\") {\n                  if (upgradesave = False) {\n                    // Then completely overwrite existing objectdictionary contents with those in the savecode\n                    set (object, attributename, att_value_obj)\n                  }\n                  else {\n                    // Add the contents of the saved objectdictionary TO the existing objectdictionary in-game\n                    Dummy = preload_att_value\n                    // Add dictionary values from SaveGame\n                    dictrows = Split(att_value, \";\")\n                    foreach (kv, dictrows) {\n                      KeyValList = Split(kv,\" = \")\n                      key = ListItem(KeyValList, 0)\n                      value = ListItem(KeyValList, 1)\n                      if (StartsWith(value,\"Object: \")) {\n                        value = GetObject(Right(value,LengthOf(value)-LengthOf(\"Object: \")))\n                      }\n                      DictionaryAdd (Dummy, key, value)\n                    }\n                    set (object, attributename, Dummy)\n                  }\n                }\n              }\n              else if (att_datatype=\"string\") {\n                set (object, attributename, att_value)\n              }\n              else {\n                error (\"ERROR: Unsupported object type detected in SaveCode: \"+fullname+\" of \"+att_datatype+\" datatype.\")\n              }\n              if (HasAttribute (object, cha)) {\n                // If a change script exists for this attribute, set change script back to original value after attribute has been changed\n                set (object, cha, scr)\n                scr =&gt; {\n                }\n              }\n            }\n          }\n        }\n        // Extract and update map data from saved grid_coordinates. Because grid_coordinates is a dictionary of dictionaries, it needed to be saved in a special way. Thus, it needs to be loaded in a special way as well.\n        // If D1=|,D2=$,D3=;,and D4=@, then grid_coordinates will be saved in form: \"ObjectOwner$MapAttributeName&amp;%&amp;Key1$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;|Key2$Lkey1 = Lvalue1:type;Lkey2 = Lvalue2:type;Lkey3 = Lvalue3:type|\" etc.\n        AllSavedGrids = Split(GridGInfo,D4)\n        if (DebugMode) {\n          msg (\"&lt;br&gt;AllSavedGrids: \"+ToString(AllSavedGrids))\n        }\n        foreach (A, AllSavedGrids) {\n          UDictionary = NewDictionary()\n          ItemAndValue = Split(A,\"&amp;%&amp;\")\n          ObjAndAtt = ListItem(ItemAndValue,0)\n          ObjAndAtt = Split(ObjAndAtt,D2)\n          objectname = ListItem(ObjAndAtt,0)\n          attributename = ListItem(ObjAndAtt,1)\n          object = GetObject(objectname)\n          GridVals = ListItem(ItemAndValue,1)\n          GridVals = Split(GridVals,D1)\n          foreach (B, GridVals) {\n            UKeyAndUVal = Split(B,D2)\n            UKey = ListItem(UKeyAndUVal,0)\n            UVal = ListItem(UKeyAndUVal,1)\n            UVal = Split(UVal,D3)\n            LDictionary = NewDictionary()\n            foreach (C, UVal) {\n              LkeyAndLval = Split(C,\" = \")\n              Lkey = ListItem(LkeyAndLval,0)\n              LvalAndType = ListItem(LkeyAndLval,1)\n              LvalAndType = Split(LvalAndType,\":\")\n              Lval_str = ListItem(LvalAndType,0)\n              LType = ListItem(LvalAndType,1)\n              if (LType=\"int\") {\n                Lval = ToInt(Lval_str)\n              }\n              else if (LType=\"double\") {\n                Lval = ToDouble(Lval_str)\n              }\n              else if (LType=\"boolean\") {\n                if (Lval_str=\"True\") {\n                  Lval = True\n                }\n                else {\n                  Lval = False\n                }\n              }\n              else {\n                error (\"ERROR: Unsupported datatype found in \"+objectname+\".\"+attributename+\"! Datatype '\"+LType+\"' not supported!\")\n              }\n              DictionaryAdd (LDictionary, Lkey, Lval)\n            }\n            DictionaryAdd (UDictionary, UKey, LDictionary)\n          }\n          if (DebugMode) {\n            msg (\"&lt;br&gt;\"+objectname+\".\"+attributename+\" UDictionary: \"+ToString(UDictionary))\n          }\n          set (object, attributename, UDictionary)\n        }\n        // Destroy any objects that the player destroyed during their saved game, if any\n        if (ListCount(DestroyedList)&gt;0) {\n          foreach (o, DestroyedList) {\n            // Check that objects still exist...\n            IsThere = GetObject(o)\n            if (not Equal(IsThere,null)) {\n              // If its there, destroy the object\n              destroy (o)\n              DestroyedObjDebugList = DestroyedObjDebugList+o+\"&lt;br&gt;\"\n            }\n          }\n        }\n        if (DebugMode) {\n          msg (\"Created objects: \"+CreatedObjDebugList)\n          msg (\"Destroyed objects: \"+DestroyedObjDebugList)\n          msg (\"Skipped Attributes:&lt;br&gt;\"+SkippedAttList)\n        }\n        // Finally, update game.pov.parent and game.pov\n        set (GamePOVObject, \"parent\", GamePOVParent)\n        game.pov = GamePOVObject\n        // player.grid_coordinates = null\n        JS.Grid_ClearAllLayers ()\n        Grid_Redraw\n        Grid_DrawPlayerInRoom (game.pov.parent)\n        ClearScreen\n        ShowRoomDescription\n      }\n    }\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"GetSaveGameCodeDelims\" type=\"stringlist\"&gt;\n    // GetSaveGameCodeDelims() function that returns the delimiters used by the SaveGameCode function in a stringlist in the order [D1,D2,D3,D4].\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\n    DelimList = NewStringList()\n    SaveString = SaveGameCode(False)\n    // Retrieve delimiters from end of SaveString\n    Dls = Right(SaveString,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Add to list\n    list add (DelimList, D1)\n    list add (DelimList, D2)\n    list add (DelimList, D3)\n    list add (DelimList, D4)\n    // Return the list of delimiters as a string list\n    return (DelimList)\n  &lt;/function&gt;\n  &lt;function name=\"GetSaveCheckpointDelims\" type=\"stringlist\"&gt;\n    // GetSaveCheckpointDelims() function that returns the delimiters used by the SaveCheckpoint function in a stringlist in the order [D1,D2,D3,D4].\n    // Useful for getting a list of delimiters to ban from user-entered fields (i.e. \"enter your name\")\n    DelimList = NewStringList()\n    SaveString = SaveCheckpoint(\"\")\n    // Retrieve delimiters from end of SaveString\n    Dls = Right(SaveString,4)\n    D1 = Mid (Dls, 1, 1)\n    D2 = Mid (Dls, 2, 1)\n    D3 = Mid (Dls, 3, 1)\n    D4 = Mid (Dls, 4, 1)\n    // Add to list\n    list add (DelimList, D1)\n    list add (DelimList, D2)\n    list add (DelimList, D3)\n    list add (DelimList, D4)\n    // Return the list of delimiters as a string list\n    return (DelimList)\n  &lt;/function&gt;\n  &lt;javascript src=\"SaveLoadJavaCode.js\" /&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n\n",
      "PostDate": "2022-03-07T05:45:27.4748492Z",
      "LastEditDate": "2022-03-13T04:14:58.420309Z",
      "link": null
    },
    {
      "PostId": "fb61ec16-8863-46bd-9ab1-8e40b8539c00",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "That is excellent!\r\n\r\nThe Wiki says this will not work with the online version, but here you say it does. Do you mean it does not work with the online editor, but does with the player? It should be possible to get JavaScript working with the online editor, but I have to admit it is a while since I used it, and cannot remember what the issues are now.\r\n\r\n> I considered using the SaveLoad library created by Pix (https://github.com/ThePix/quest/wiki/Library:-Save-and-Load), but unfortunately some of its limitations didn't quite work for what I had in mind.\r\n\r\nMight be worth saying what the differences are so people can make an informed choice between the two. Looks like one is that yours tries to guess what to save, while mine, the author has to be explicit, which I appreciate is extra work for authors.",
      "EditableFormat": "markdown",
      "HTML": "<p>That is excellent!</p>\n<p>The Wiki says this will not work with the online version, but here you say it does. Do you mean it does not work with the online editor, but does with the player? It should be possible to get JavaScript working with the online editor, but I have to admit it is a while since I used it, and cannot remember what the issues are now.</p>\n<blockquote>\n<p>I considered using the SaveLoad library created by Pix (https://github.com/ThePix/quest/wiki/Library:-Save-and-Load), but unfortunately some of its limitations didn't quite work for what I had in mind.</p>\n</blockquote>\n<p>Might be worth saying what the differences are so people can make an informed choice between the two. Looks like one is that yours tries to guess what to save, while mine, the author has to be explicit, which I appreciate is extra work for authors.</p>\n\n",
      "PostDate": "2022-03-08T07:48:25.3728935Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e7c06fe2-943b-484f-9895-6fc806f7cc3c",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks Pix! Your praise means a lot!\r\n>The Wiki says this will not work with the online version, but here you say it does. Do you mean it does not work with the online editor, but does with the player?\r\n\r\nYes, I've confirmed that it DOES work with the online player, it's the online editor I'm less sure of. Like you said, whether I can add the custom javascript online is the primary roadblock in determining whether it would be online-editor-compatible.\r\n\r\nI tried last night but I was unable to get the online editor running to figure out whether I could get the javascript added, but my assumption (based on the \"Using Javascript\" quest documentation) was that the online editor and custom javascript might not mix well, though I hope I'm wrong! \r\n\r\nIf I can get the online editor running later today, I'll dig a bit more to see if there's a way to get the javascript in the online editor. I'd love for it to work in the online editor as well, so I'll happily update the wiki and this post if I figure out how to do so!\r\n\r\n\r\n> Might be worth saying what the differences are so people can make an informed choice between the two. Looks like one is that yours tries to guess what to save, while mine, the author has to be explicit, which I appreciate is extra work for authors\r\n\r\nAlso yes, that's a good idea. I'll go ahead and updated the above post to include that info!\r\n\r\nI apologize if my post came off as me trying to say my library was better, because that's certainly not my intent. I think both our save/load libraries are great depending on what the user wants to do. Calling out attributes explicitly in yours, rather than procedurally in mine, for instance, certainly makes it a lot easier to be sure only certain attributes are updated when saving. I also feel like your library might be a bit more user-friendly to those uncomfortable/unfamiliar with coding, as adapting my functions to save more attributes generally requires editting the functions directly.\r\n\r\nOne of the biggest differences that led me to try making my own library was that I wanted the ability to create a save and store it as a separate file to the user's computer, both in the desktop and online player. I spent a while trying to figure out how to get Quest to create this file on it's own (I dug deep into KV's Log function source code and forum posts to try to see if I could come up with something) before eventually settling on having the user copy/paste the save data themselves.\r\nI also plan on changing the game.pov several times in my game, so I wanted to be sure I accounted for that as well.\r\n\r\nAfter work, I'll dig into both the online editor and our two libraries and update the post/wiki to capture what I find!",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks Pix! Your praise means a lot!</p>\n<blockquote>\n<p>The Wiki says this will not work with the online version, but here you say it does. Do you mean it does not work with the online editor, but does with the player?</p>\n</blockquote>\n<p>Yes, I've confirmed that it DOES work with the online player, it's the online editor I'm less sure of. Like you said, whether I can add the custom javascript online is the primary roadblock in determining whether it would be online-editor-compatible.</p>\n<p>I tried last night but I was unable to get the online editor running to figure out whether I could get the javascript added, but my assumption (based on the \"Using Javascript\" quest documentation) was that the online editor and custom javascript might not mix well, though I hope I'm wrong!</p>\n<p>If I can get the online editor running later today, I'll dig a bit more to see if there's a way to get the javascript in the online editor. I'd love for it to work in the online editor as well, so I'll happily update the wiki and this post if I figure out how to do so!</p>\n<blockquote>\n<p>Might be worth saying what the differences are so people can make an informed choice between the two. Looks like one is that yours tries to guess what to save, while mine, the author has to be explicit, which I appreciate is extra work for authors</p>\n</blockquote>\n<p>Also yes, that's a good idea. I'll go ahead and updated the above post to include that info!</p>\n<p>I apologize if my post came off as me trying to say my library was better, because that's certainly not my intent. I think both our save/load libraries are great depending on what the user wants to do. Calling out attributes explicitly in yours, rather than procedurally in mine, for instance, certainly makes it a lot easier to be sure only certain attributes are updated when saving. I also feel like your library might be a bit more user-friendly to those uncomfortable/unfamiliar with coding, as adapting my functions to save more attributes generally requires editting the functions directly.</p>\n<p>One of the biggest differences that led me to try making my own library was that I wanted the ability to create a save and store it as a separate file to the user's computer, both in the desktop and online player. I spent a while trying to figure out how to get Quest to create this file on it's own (I dug deep into KV's Log function source code and forum posts to try to see if I could come up with something) before eventually settling on having the user copy/paste the save data themselves.<br>\nI also plan on changing the game.pov several times in my game, so I wanted to be sure I accounted for that as well.</p>\n<p>After work, I'll dig into both the online editor and our two libraries and update the post/wiki to capture what I find!</p>\n\n",
      "PostDate": "2022-03-08T18:09:21.8866344Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5ddce051-79d1-46e6-8f4a-55fb16fa125f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I had a quick look through the code… looks like you've got quite a lot of different delimiters. I tried doing this a while back, and rather than sticking to fixed delimiters, decided to prefix each value with a base64 number for its length. Works out surprisingly simple for some things (like allowing more complex list/dictionary structures; which I tend to use for a lot of things)\r\n\r\nDo you have any plans to add support for created/destroyed objects?",
      "EditableFormat": "markdown",
      "HTML": "<p>I had a quick look through the code… looks like you've got quite a lot of different delimiters. I tried doing this a while back, and rather than sticking to fixed delimiters, decided to prefix each value with a base64 number for its length. Works out surprisingly simple for some things (like allowing more complex list/dictionary structures; which I tend to use for a lot of things)</p>\n<p>Do you have any plans to add support for created/destroyed objects?</p>\n\n",
      "PostDate": "2022-03-08T23:17:25.6149722Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "741f7019-d397-4025-b2cd-4b09e9cdaf07",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">I tried doing this a while back, and rather than sticking to fixed delimiters, decided to prefix each value with a base64 number for its length. \r\n\r\nAh! This is a great idea! Unfortunately I'm in too deep with my delimiters to change it now, but if I could go back in time I might have ended up going with this instead. \r\n\r\n>Do you have any plans to add support for created/destroyed objects?\r\n\r\nHonestly, I could probably add support for created objects very easily. The function already makes a check to see if an object found in the SaveString is present in the current game (if it isn't then object will equal `null`), so all it would take is adding an `else if (object=null or preload_att_value=null) {Create object}` statement onto that logic.\r\n\r\nDestroyed objects would be a little trickier, however, since if they aren't in the SaveString, that could mean they were destroyed OR excluded intentionally. I could probably come up with something where I have LoadGameCode generate a SaveString for the _current_ game, then compare the pre-load SaveString to the one that's being loaded to determine which objects are missing and should be destroyed.\r\n\r\nThe bigger issue, however, is that I could only really modularize create/destroy support for saves of the SAME game version. If an object exists in a SaveString and doesn't exist in the game at time of load, then you can **only** assume that the object _should_ exist (and thus the function should create it) **if** both the save and the game you're loading to are the same version. If you're loading an old save into a new game version, that same object might not exist because it was intentionally removed in the latest version. Similarly, if an object doesn't exist in the SaveString but DOES exist in a newer version of the game, we certainly don't want the function to destroy all the new objects we introduced with the latest version.\r\n\r\nIf you think it'd be worthwhile, I could add a flag to LoadGameCode to allow create/destroy support for loading **when the versions are equal**, but I'd have to think long and hard to figure out how to properly apply modular support for created/destroyed objects that still allows for old-save-compatibility. \r\n\r\nThis might be an example where editing the function to fit the conditions of your specific game may be easier than trying to come up with a modular solution at all... Definitely something to think about, though!",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I tried doing this a while back, and rather than sticking to fixed delimiters, decided to prefix each value with a base64 number for its length.</p>\n</blockquote>\n<p>Ah! This is a great idea! Unfortunately I'm in too deep with my delimiters to change it now, but if I could go back in time I might have ended up going with this instead.</p>\n<blockquote>\n<p>Do you have any plans to add support for created/destroyed objects?</p>\n</blockquote>\n<p>Honestly, I could probably add support for created objects very easily. The function already makes a check to see if an object found in the SaveString is present in the current game (if it isn't then object will equal <code>null</code>), so all it would take is adding an <code>else if (object=null or preload_att_value=null) {Create object}</code> statement onto that logic.</p>\n<p>Destroyed objects would be a little trickier, however, since if they aren't in the SaveString, that could mean they were destroyed OR excluded intentionally. I could probably come up with something where I have LoadGameCode generate a SaveString for the <em>current</em> game, then compare the pre-load SaveString to the one that's being loaded to determine which objects are missing and should be destroyed.</p>\n<p>The bigger issue, however, is that I could only really modularize create/destroy support for saves of the SAME game version. If an object exists in a SaveString and doesn't exist in the game at time of load, then you can <strong>only</strong> assume that the object <em>should</em> exist (and thus the function should create it) <strong>if</strong> both the save and the game you're loading to are the same version. If you're loading an old save into a new game version, that same object might not exist because it was intentionally removed in the latest version. Similarly, if an object doesn't exist in the SaveString but DOES exist in a newer version of the game, we certainly don't want the function to destroy all the new objects we introduced with the latest version.</p>\n<p>If you think it'd be worthwhile, I could add a flag to LoadGameCode to allow create/destroy support for loading <strong>when the versions are equal</strong>, but I'd have to think long and hard to figure out how to properly apply modular support for created/destroyed objects that still allows for old-save-compatibility.</p>\n<p>This might be an example where editing the function to fit the conditions of your specific game may be easier than trying to come up with a modular solution at all... Definitely something to think about, though!</p>\n\n",
      "PostDate": "2022-03-09T02:05:01.9385194Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "aaf78955-571a-45fc-9514-8221ad08ac31",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> The bigger issue, however, is that I could only really modularize create/destroy support for saves of the SAME game version. If an object exists in a SaveString and doesn't exist in the game at time of load, then you can only assume that the object should exist (and thus the function should create it) if both the save and the game you're loading to are the same version. If you're loading an old save into a new game version, that same object might not exist because it was intentionally removed in the latest version. Similarly, if an object doesn't exist in the SaveString but DOES exist in a newer version of the game, we certainly don't want the function to destroy all the new objects we introduced with the latest version.\r\n\r\nMy approach to that was to have an initialisation script that makes a list of the names of all objects when the game starts. When saving, start by comparing that list to the objects that currently exist. So you're explicitly saving a list of objects that have been created/destroyed between game start and game saved; rather than comparing objects that exist in the old and new versions.\r\n\r\nThis also means that you don't run into problems where an objectlist somewhere contains a newly created object – because you can create all the new objects at the start, ensuring they exist before adding them to other attributes.\r\n\r\n(I went way too deep down this rabbithole; building a serialised string of all objects at the start of the game, and then having the savestring only encode the ones that had changed when saving. That probably adds too much to the complexity for most uses, although it can shrink the resulting save string. With regard to making the string smaller, I tried using a library called LZString.js so that the save string is compressed before converting to base64 (or to UTF16; you can reduce the output string length by about 60% if you use an encoding scheme that includes Chinese characters instead of just ASCII)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>The bigger issue, however, is that I could only really modularize create/destroy support for saves of the SAME game version. If an object exists in a SaveString and doesn't exist in the game at time of load, then you can only assume that the object should exist (and thus the function should create it) if both the save and the game you're loading to are the same version. If you're loading an old save into a new game version, that same object might not exist because it was intentionally removed in the latest version. Similarly, if an object doesn't exist in the SaveString but DOES exist in a newer version of the game, we certainly don't want the function to destroy all the new objects we introduced with the latest version.</p>\n</blockquote>\n<p>My approach to that was to have an initialisation script that makes a list of the names of all objects when the game starts. When saving, start by comparing that list to the objects that currently exist. So you're explicitly saving a list of objects that have been created/destroyed between game start and game saved; rather than comparing objects that exist in the old and new versions.</p>\n<p>This also means that you don't run into problems where an objectlist somewhere contains a newly created object – because you can create all the new objects at the start, ensuring they exist before adding them to other attributes.</p>\n<p>(I went way too deep down this rabbithole; building a serialised string of all objects at the start of the game, and then having the savestring only encode the ones that had changed when saving. That probably adds too much to the complexity for most uses, although it can shrink the resulting save string. With regard to making the string smaller, I tried using a library called LZString.js so that the save string is compressed before converting to base64 (or to UTF16; you can reduce the output string length by about 60% if you use an encoding scheme that includes Chinese characters instead of just ASCII)</p>\n\n",
      "PostDate": "2022-03-09T10:25:39.4609465Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "cf5ea753-bb32-4000-bab9-f318a6b30185",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">My approach to that was to have an initialisation script that makes a list of the names of all objects when the game starts. When saving, start by comparing that list to the objects that currently exist. So you're explicitly saving a list of objects that have been created/destroyed between game start and game saved; rather than comparing objects that exist in the old and new versions.\r\n\r\nThis... could actually work quite well.\r\n\r\nThere would still be issues if the objects that can be created/destroyed during gameplay changes between game versions, but that would be much easier for the author to keep track of when making edits for compatibility...\r\n\r\nLet me try something real quick!",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>My approach to that was to have an initialisation script that makes a list of the names of all objects when the game starts. When saving, start by comparing that list to the objects that currently exist. So you're explicitly saving a list of objects that have been created/destroyed between game start and game saved; rather than comparing objects that exist in the old and new versions.</p>\n</blockquote>\n<p>This... could actually work quite well.</p>\n<p>There would still be issues if the objects that can be created/destroyed during gameplay changes between game versions, but that would be much easier for the author to keep track of when making edits for compatibility...</p>\n<p>Let me try something real quick!</p>\n\n",
      "PostDate": "2022-03-09T22:25:28.4988941Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e158c1a6-88ee-48c4-8c00-958b9e3c987d",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I also handled game updates when increasing the version; I made a scriptdictionary where the keys are version numbers. When loading a save, it would do something like:\r\n<pre><code>\r\nfound = false\r\nforeach (key, game.loadscripts) {\r\n  if (<em style=\"color: green\">version_from_save_file</em> = key) {\r\n    found = true\r\n  }\r\n  if (found) {\r\n    invoke (ScriptDictionaryItem (game.loadscripts, key))\r\n  }\r\n}</code></pre>\r\nThat way, you have a dictionary that looks something like:\r\n```\r\n<loadscripts type=\"scriptdictionary\">\r\n  <item key=\"1\">\r\n    // This script updates a v1 save to v2\r\n  </item>\r\n  <item key=\"2\">\r\n  </item>\r\n  <item key=\"3\">\r\n    // This script updates a v2 or v3 save to v4\r\n  </item>\r\n  <item key=\"4\">\r\n    // As v4 is the current version, this script can do anything that needs to happen when loading a saved game\r\n    mag (\"Welcome back! Here's a reminder of your current objectives:\")\r\n    DisplayCurrentSidequests()\r\n  </item>\r\n</loadscripts>\r\n```\r\nMay seem a little over-engineered, but I think that progressive updates like this would make it easier for a developer to keep track of all the different changes that might have been made to the game.",
      "EditableFormat": "markdown",
      "HTML": "<p>I also handled game updates when increasing the version; I made a scriptdictionary where the keys are version numbers. When loading a save, it would do something like:</p>\n<pre><code>\nfound = false\nforeach (key, game.loadscripts) {\n  if (<em style=\"color: green\">version_from_save_file</em> = key) {\n    found = true\n  }\n  if (found) {\n    invoke (ScriptDictionaryItem (game.loadscripts, key))\n  }\n}</code></pre>\n<p>That way, you have a dictionary that looks something like:</p>\n<pre><code>&lt;loadscripts type=\"scriptdictionary\"&gt;\n  &lt;item key=\"1\"&gt;\n    // This script updates a v1 save to v2\n  &lt;/item&gt;\n  &lt;item key=\"2\"&gt;\n  &lt;/item&gt;\n  &lt;item key=\"3\"&gt;\n    // This script updates a v2 or v3 save to v4\n  &lt;/item&gt;\n  &lt;item key=\"4\"&gt;\n    // As v4 is the current version, this script can do anything that needs to happen when loading a saved game\n    mag (\"Welcome back! Here's a reminder of your current objectives:\")\n    DisplayCurrentSidequests()\n  &lt;/item&gt;\n&lt;/loadscripts&gt;\n</code></pre>\n<p>May seem a little over-engineered, but I think that progressive updates like this would make it easier for a developer to keep track of all the different changes that might have been made to the game.</p>\n\n",
      "PostDate": "2022-03-09T23:03:36.3780459Z",
      "LastEditDate": "2022-03-09T23:04:33.293348Z",
      "link": null
    },
    {
      "PostId": "7a0c265a-512b-486f-8f49-d0a5f5ada052",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Using a script dictionary to help organize and stagger version compatibility is a great idea! I may end up using that idea to maintain compatibility between my own game's versions. \r\n\r\nI'm a bit fried right now, so I may or may not consider building something like that into the library itself, but I may just leave it as an exercise for the author. With your permission, may I add it as a possible suggestion/example to the \"Tips for Compatibility\" section in the library's wiki?\r\n\r\nIn other news, I've updated the SaveLoadCode library to v2.0. It can now handle created/destroyed objects! I've updated the original post and the test game as well to show off the new feature. Thanks for the idea, mrangel!",
      "EditableFormat": "markdown",
      "HTML": "<p>Using a script dictionary to help organize and stagger version compatibility is a great idea! I may end up using that idea to maintain compatibility between my own game's versions.</p>\n<p>I'm a bit fried right now, so I may or may not consider building something like that into the library itself, but I may just leave it as an exercise for the author. With your permission, may I add it as a possible suggestion/example to the \"Tips for Compatibility\" section in the library's wiki?</p>\n<p>In other news, I've updated the SaveLoadCode library to v2.0. It can now handle created/destroyed objects! I've updated the original post and the test game as well to show off the new feature. Thanks for the idea, mrangel!</p>\n\n",
      "PostDate": "2022-03-10T04:11:00.9102622Z",
      "LastEditDate": "2022-03-10T04:13:04.7404824Z",
      "link": null
    },
    {
      "PostId": "bf23c691-0e00-4b99-a8e7-55a7cba67d6d",
      "UserId": 581452,
      "Username": "Leviathon",
      "AvatarUrl": "https://secure.gravatar.com/avatar/b70281225e26c938429c720cbbe2a522?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hello again! Made one more update (v3.0 now) to the library to add in some more functionality. Namely:\r\n* Support for new game list attributes to help the author save game attributes and timers (see wiki for more details):\r\n    * `game.SaveAtts`\r\n    * `game.SaveTimers`\r\nNow the player can simply add the names of additional game attributes they would like to save to `game.SaveAtts` and the SaveGameCode/SaveCheckpoint functions will save them automatically. Similarly, the player can add the names of any timers created to a `game.SaveTimers` attribute to save the status of their timers.\r\n\r\n\r\n* Added additional validation checks to ensure that no banned delimiters are present in list or dictionary entries at time of saving.\r\n\r\n* SaveGameCode now has a `ShowCodePopupFlag` boolean input parameter. When `SaveGameCode(True)` is called, the SaveCode popup box will appear as before. When `SaveGameCode(False)` is called, the popup box will NOT appear.\r\n\r\n* SaveGameCode now returns the SaveString as an output. (i.e. If you set `X=SaveGameCode(False)` or `X=SaveGameCode(True)`, then `X` will equal the generated SaveString before it gets encoded to base64)\r\n\r\n* New `SaveCheckpoint(CheckpointName)` and `LoadCheckpoint(CheckpointName)` functions! These functions allow you to save and load local checkpoints. See wiki for more details.\r\n\r\n* After adding checkpoints, the savecodes increased drastically in size, so I decided to take mrangel's advice and compress the SaveCode. The created SaveCode is now compressed (using excerpt from LZ-string library) to cut down on the length/filesize of the SaveString. This is especially useful now since adding the SaveCheckpoint function (as the savecode filesize would increase drastically with each checkpoint saved without compression).\r\n\r\n* New `GetSaveGameCodeDelims()` function. This function returns a stringlist of delimiters used by the SaveGameCode function. Useful for allowing you to check if user-entered input (i.e. like a \"type in your name\" input) contains a banned delimiter that would cause issues saving later.\r\n\r\n* New `GetSaveCheckpointDelims()` function. This function returns a stringlist of delimiters used by the SaveCheckpoint function. Useful for allowing you to check if user-entered input (i.e. like a \"type in your name\" input) contains a banned delimiter that would cause issues saving later.\r\n\r\nI feel like the library is now in a pretty good state functionality-wise, so this will likely be my last update for a while. Now that it's stable I will probably make a post over in the Libraries and Code Samples forum for posterity. Any additional updates to this library will likely be posted <a href=\"http://textadventures.co.uk/forum/samples/topic/nog_dxhdaeqzltv314mp1q/\">there</a>, instead of here.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hello again! Made one more update (v3.0 now) to the library to add in some more functionality. Namely:</p>\n<ul>\n<li>Support for new game list attributes to help the author save game attributes and timers (see wiki for more details):\n<ul>\n<li><code>game.SaveAtts</code></li>\n<li><code>game.SaveTimers</code><br>\nNow the player can simply add the names of additional game attributes they would like to save to <code>game.SaveAtts</code> and the SaveGameCode/SaveCheckpoint functions will save them automatically. Similarly, the player can add the names of any timers created to a <code>game.SaveTimers</code> attribute to save the status of their timers.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p>Added additional validation checks to ensure that no banned delimiters are present in list or dictionary entries at time of saving.</p>\n</li>\n<li>\n<p>SaveGameCode now has a <code>ShowCodePopupFlag</code> boolean input parameter. When <code>SaveGameCode(True)</code> is called, the SaveCode popup box will appear as before. When <code>SaveGameCode(False)</code> is called, the popup box will NOT appear.</p>\n</li>\n<li>\n<p>SaveGameCode now returns the SaveString as an output. (i.e. If you set <code>X=SaveGameCode(False)</code> or <code>X=SaveGameCode(True)</code>, then <code>X</code> will equal the generated SaveString before it gets encoded to base64)</p>\n</li>\n<li>\n<p>New <code>SaveCheckpoint(CheckpointName)</code> and <code>LoadCheckpoint(CheckpointName)</code> functions! These functions allow you to save and load local checkpoints. See wiki for more details.</p>\n</li>\n<li>\n<p>After adding checkpoints, the savecodes increased drastically in size, so I decided to take mrangel's advice and compress the SaveCode. The created SaveCode is now compressed (using excerpt from LZ-string library) to cut down on the length/filesize of the SaveString. This is especially useful now since adding the SaveCheckpoint function (as the savecode filesize would increase drastically with each checkpoint saved without compression).</p>\n</li>\n<li>\n<p>New <code>GetSaveGameCodeDelims()</code> function. This function returns a stringlist of delimiters used by the SaveGameCode function. Useful for allowing you to check if user-entered input (i.e. like a \"type in your name\" input) contains a banned delimiter that would cause issues saving later.</p>\n</li>\n<li>\n<p>New <code>GetSaveCheckpointDelims()</code> function. This function returns a stringlist of delimiters used by the SaveCheckpoint function. Useful for allowing you to check if user-entered input (i.e. like a \"type in your name\" input) contains a banned delimiter that would cause issues saving later.</p>\n</li>\n</ul>\n<p>I feel like the library is now in a pretty good state functionality-wise, so this will likely be my last update for a while. Now that it's stable I will probably make a post over in the Libraries and Code Samples forum for posterity. Any additional updates to this library will likely be posted <a href=\"http://textadventures.co.uk/forum/samples/topic/nog_dxhdaeqzltv314mp1q/\">there</a>, instead of here.</p>\n\n",
      "PostDate": "2022-03-13T04:25:29.1561025Z",
      "LastEditDate": "2022-03-13T04:33:09.925053Z",
      "link": null
    }
  ]
}
