{
  "Topic": {
    "TopicId": "wycandddg0chz1cs2m5mvg",
    "ForumId": "10",
    "Title": "unique aliases",
    "LastUpdated": "2017-09-09T10:00:54.948075Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "51928971-1e95-4397-9d43-ddc8ef6e8671",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I'm still playing around with some of the parser stuff, but that's a big project. In the mean time, I'm coming up against a problem with the 'toy' game I'm building. I realise that if I can get my modified ```GetScope()``` working, I'll be able to do this in a much simpler way.\r\n\r\n(Here's an explanation of the problem, and my thought process as I look for solutions; feel free to skim it, because the question's all the way down at the end)\r\n```\r\n> Put potato in chest\r\nPlease choose which 'potato' you mean:\r\n1: potato\r\n2: potato\r\n3: potatoes\r\n4: potatoes\r\n5: potatoes\r\n6: pile of potatoes\r\n```\r\n(this is in the middle of a puzzle where your character is inexplicably restricted to transferring potatoes between containers all at once. The classic puzzle where you've got a 3 pint jug and a 5 pint jug, and you have to measure 4 pints of water. So obviously, not being able to distinguish the potatoes is a pain)\r\n\r\nOkay then… I can solve this. I can have a script give each pile of potatoes a unique name.\r\n```\r\nswitch (this.parent) {\r\n  case (pov.parent) {\r\n    suffix = \"on the floor\"\r\n  }\r\n  case (pov) {\r\n    suffix = \"in your pocket\"\r\n  }\r\n  default {\r\n    if (GetBoolean (this.parent, \"is_character\")) {\r\n      suffix = GetDisplayName(this.parent)+\"’s\"\r\n    }\r\n    else if (HasAttribute (this.parent, \"open\")) {\r\n      suffix = \"in the \"+GetDisplayName(this.parent)\r\n    }\r\n    else {\r\n      suffix = \"on the \"+GetDisplayName(this.parent)\r\n    }\r\n  }\r\n}\r\nthis.alias = this.basename + \" (\"+suffix+\")\"\r\n```\r\nOr something like that; just thinking about this so far. No sense implementing it yet, if it's going to turn out I can't use it.\r\n\r\nOkay… I want to have a different alias for disambiguation, than what is displayed when looking at the room or at a container. Fine, I can do that.\r\nWhat I do is, I make that script to make the names unambiguous. I set it as a turn script, which every turn looks at the current visible scope (room and inventory), identifies any items which have the same alias, and adds a suffix to them. Actually, it probably makes sense to add the alias-with-suffix to an object's ```alt``` first; and then for each item with a duplicate alias, change the displayed alias to any unique entries in the ```alt``` list.\r\n\r\nI'm implementing a function ```GetUniqueAlias(object, objectlist scope)```; which should return one of the object's aliases, not shared by any other item in the scope. As it stands, I can have a turn script loop over the currently visible objects changing their aliases (and presumably switching back to the default name if there's no colliding names). When I've solved the much more complex problem (a bodged set of workarounds to let me override ```GetScope()```), I'll be able to have GetScope() call GetUniqueAlias(), removing the need to actually change the object's alias (and meaning that it will only add a suffix if there's duplicate items within the current command's scope).\r\n\r\nBut for now, I still have one problem:\r\n```\r\nYou are in a test room.\r\nYou can see a potato (on the floor), a banana and a sturdy table (on which there is a potato (on the sturdy table), a silver plate (on which there is six potatoes (on the silver plate)) and a treasure chest (in which there is a potato (in the treasure chest)))\r\n```\r\n\r\nArgh.\r\n**Q1**: Is there a way to change the alias of an item for the purposes of commands, but show a different one in object lists?\r\nI know there's a separate ```alias``` and ```listalias``` (I'm currently using listalias to indent items that are in nested containers, to make the inventory easier to parse at a glance). But I don't think there's any alternates that are looked at either by the scripts in CoreParser, or by FormatObjectList. If there is, it makes this a whole lot easier.\r\n\r\nIf not… I override the 'look' and 'lookat' commands, so that they set the alias of everything in scope back to its basename, then include the standard 'look' behaviour, then add the suffixes back on. But that doesn't help when you're walking into a new room. Unless I untick \"Show room description when entering a room\", and add it back into the \"Script when entering a room\" box.\r\n**Q2**: Will this work? Is it worth sinking a couple of hours into, or will I find out that it doesn't work?\r\n**Q3**: Will changing the room descriptions like that cause any problems I haven't thought about?\r\n**Q4**: Is it likely to be easier just to leave this until I can include it in my modified version of the parser?\r\n\r\nOh, and it's good that I wrote this. Because while I was writing this out, I spotted something  hadn't thought about before. I have an object alias \"potatoes (in box)\". So if the player types ```put potatoes (in box) in chest```, will it parse correctly? Or will it ask which potatoes you mean and then complain that you can't see a \"box) in chest\"? Does the parser attempt to cope with this at all? I don't think I've seen backtracking in the code I've looked over so far. It's unlikely to come up, because a player is only likely to see those names in the disambiguation menu, but I'm still interested to know.\r\n\r\nAnd if you read this far, thanks :)",
      "EditableFormat": "markdown",
      "HTML": "<p>I'm still playing around with some of the parser stuff, but that's a big project. In the mean time, I'm coming up against a problem with the 'toy' game I'm building. I realise that if I can get my modified <code>GetScope()</code> working, I'll be able to do this in a much simpler way.</p>\n<p>(Here's an explanation of the problem, and my thought process as I look for solutions; feel free to skim it, because the question's all the way down at the end)</p>\n<pre><code>&gt; Put potato in chest\nPlease choose which 'potato' you mean:\n1: potato\n2: potato\n3: potatoes\n4: potatoes\n5: potatoes\n6: pile of potatoes\n</code></pre>\n<p>(this is in the middle of a puzzle where your character is inexplicably restricted to transferring potatoes between containers all at once. The classic puzzle where you've got a 3 pint jug and a 5 pint jug, and you have to measure 4 pints of water. So obviously, not being able to distinguish the potatoes is a pain)</p>\n<p>Okay then… I can solve this. I can have a script give each pile of potatoes a unique name.</p>\n<pre><code>switch (this.parent) {\n  case (pov.parent) {\n    suffix = \"on the floor\"\n  }\n  case (pov) {\n    suffix = \"in your pocket\"\n  }\n  default {\n    if (GetBoolean (this.parent, \"is_character\")) {\n      suffix = GetDisplayName(this.parent)+\"’s\"\n    }\n    else if (HasAttribute (this.parent, \"open\")) {\n      suffix = \"in the \"+GetDisplayName(this.parent)\n    }\n    else {\n      suffix = \"on the \"+GetDisplayName(this.parent)\n    }\n  }\n}\nthis.alias = this.basename + \" (\"+suffix+\")\"\n</code></pre>\n<p>Or something like that; just thinking about this so far. No sense implementing it yet, if it's going to turn out I can't use it.</p>\n<p>Okay… I want to have a different alias for disambiguation, than what is displayed when looking at the room or at a container. Fine, I can do that.<br>\nWhat I do is, I make that script to make the names unambiguous. I set it as a turn script, which every turn looks at the current visible scope (room and inventory), identifies any items which have the same alias, and adds a suffix to them. Actually, it probably makes sense to add the alias-with-suffix to an object's <code>alt</code> first; and then for each item with a duplicate alias, change the displayed alias to any unique entries in the <code>alt</code> list.</p>\n<p>I'm implementing a function <code>GetUniqueAlias(object, objectlist scope)</code>; which should return one of the object's aliases, not shared by any other item in the scope. As it stands, I can have a turn script loop over the currently visible objects changing their aliases (and presumably switching back to the default name if there's no colliding names). When I've solved the much more complex problem (a bodged set of workarounds to let me override <code>GetScope()</code>), I'll be able to have GetScope() call GetUniqueAlias(), removing the need to actually change the object's alias (and meaning that it will only add a suffix if there's duplicate items within the current command's scope).</p>\n<p>But for now, I still have one problem:</p>\n<pre><code>You are in a test room.\nYou can see a potato (on the floor), a banana and a sturdy table (on which there is a potato (on the sturdy table), a silver plate (on which there is six potatoes (on the silver plate)) and a treasure chest (in which there is a potato (in the treasure chest)))\n</code></pre>\n<p>Argh.<br>\n<strong>Q1</strong>: Is there a way to change the alias of an item for the purposes of commands, but show a different one in object lists?<br>\nI know there's a separate <code>alias</code> and <code>listalias</code> (I'm currently using listalias to indent items that are in nested containers, to make the inventory easier to parse at a glance). But I don't think there's any alternates that are looked at either by the scripts in CoreParser, or by FormatObjectList. If there is, it makes this a whole lot easier.</p>\n<p>If not… I override the 'look' and 'lookat' commands, so that they set the alias of everything in scope back to its basename, then include the standard 'look' behaviour, then add the suffixes back on. But that doesn't help when you're walking into a new room. Unless I untick \"Show room description when entering a room\", and add it back into the \"Script when entering a room\" box.<br>\n<strong>Q2</strong>: Will this work? Is it worth sinking a couple of hours into, or will I find out that it doesn't work?<br>\n<strong>Q3</strong>: Will changing the room descriptions like that cause any problems I haven't thought about?<br>\n<strong>Q4</strong>: Is it likely to be easier just to leave this until I can include it in my modified version of the parser?</p>\n<p>Oh, and it's good that I wrote this. Because while I was writing this out, I spotted something  hadn't thought about before. I have an object alias \"potatoes (in box)\". So if the player types <code>put potatoes (in box) in chest</code>, will it parse correctly? Or will it ask which potatoes you mean and then complain that you can't see a \"box) in chest\"? Does the parser attempt to cope with this at all? I don't think I've seen backtracking in the code I've looked over so far. It's unlikely to come up, because a player is only likely to see those names in the disambiguation menu, but I'm still interested to know.</p>\n<p>And if you read this far, thanks :)</p>\n\n",
      "PostDate": "2017-09-09T10:00:54.948075Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "87acc465-201b-48b5-8c3f-dffc099d5167",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I would try overriding `FormatObjectList` to use a different attribute. Not sure if it would work, but I think tha would be easier than changing the parser side.",
      "EditableFormat": "markdown",
      "HTML": "<p>I would try overriding <code>FormatObjectList</code> to use a different attribute. Not sure if it would work, but I think tha would be easier than changing the parser side.</p>\n\n",
      "PostDate": "2017-09-09T10:12:49.6727331Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3fdd4cb9-00c8-4619-a343-fb3ccdac8002",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@Pixie\r\nThat's what I was thinking. The simplest way I could think of to do that is overriding both 'look' commands, changing the aliases back to their basenames, calling the standard command, and then re-adding the suffixes where necessary.\r\n(Really hate not being able to override functions directly)",
      "EditableFormat": "markdown",
      "HTML": "<p>@Pixie<br>\nThat's what I was thinking. The simplest way I could think of to do that is overriding both 'look' commands, changing the aliases back to their basenames, calling the standard command, and then re-adding the suffixes where necessary.<br>\n(Really hate not being able to override functions directly)</p>\n\n",
      "PostDate": "2017-09-09T10:21:13.9017896Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
