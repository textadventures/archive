{
  "Topic": {
    "TopicId": "49x-ux7hp0cpzvdonr8uqg",
    "ForumId": "10",
    "Title": "Help with Linked Lists in Quest",
    "LastUpdated": "2021-06-13T08:45:52.4211737Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "3263d660-9b6d-4dbf-8733-032cd9ad422f",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Okay. . .\r\n\r\nI find linked lists fascinating. I want to make sure I understand them; so, I am now trying to make them work in Quest.\r\n\r\nThis *might* be working, but I can't check it.\r\n\r\n1. If I uncomment either line: ```msg (room.linked1)``` or ```msg (node)``` (you'll see where I have them commented out), Quest freezes up.\r\n\r\n2. If I open the debugger and select the ```room``` object, Quest freezes up.\r\n\r\nSomething is throwing something for a \"loop\", but I'm not sure if that's good or bad? (Probably bad.)\r\n\r\n---\r\nThe code:\r\n\r\n```\r\n<!--Saved by Quest 5.8.7753.35184-->\r\n<asl version=\"580\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Linked Lists\">\r\n    <gameid>7c9cbb79-8d5c-4b8b-82d3-1a1aef796b7d</gameid>\r\n    <version>0.2</version>\r\n    <firstpublished>2021</firstpublished>\r\n    <start type=\"script\">\r\n      node1 = NewListNode (\"first\")\r\n      room.linked1 = NewLinkedList()\r\n      LinkedListAdd (room.linked1, node1)\r\n      node2 = NewListNode(\"second\")\r\n      LinkedListAdd (room.linked1, node2)\r\n      // msg (room.linked1)\r\n    </start>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <isroom />\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n    </object>\r\n  </object>\r\n  <function name=\"NewListNode\" parameters=\"value\" type=\"dictionary\">\r\n    node = NewDictionary()\r\n    DictionaryAdd (node, \"value\", value)\r\n    DictionaryAdd (node, \"next\", \"null\")\r\n    DictionaryAdd (node, \"previous\", \"null\")\r\n    return (node)\r\n  </function>\r\n  <function name=\"NewLinkedList\" type=\"dictionary\">\r\n    ll = NewDictionary()\r\n    DictionaryAdd (ll, \"head\", \"null\")\r\n    DictionaryAdd (ll, \"length\", 0)\r\n    return (ll)\r\n  </function>\r\n  <function name=\"LinkedListAdd\" parameters=\"ll, node\">\r\n    if (ll[\"head\"] = \"null\") {\r\n      DictionaryAdd (ll, \"head\", node)\r\n      int = ll[\"length\"]\r\n      DictionaryAdd (ll, \"length\", int + 1)\r\n    }\r\n    else {\r\n      msg (\"Finding last node. . .\")\r\n      current = ll[\"head\"]\r\n      next = current[\"next\"]\r\n      while (not next = \"null\") {\r\n        current = next\r\n        next = current[\"next\"]\r\n      }\r\n      msg (\"Last node found.\")\r\n      msg (current)\r\n      msg (\"Adding new node. . .\")\r\n      DictionaryAdd (current, \"next\", node)\r\n      msg (\"current:\")\r\n      msg (current)\r\n      DictionaryAdd (node, \"previous\", current)\r\n      // msg (\"new:\")\r\n      // msg (node)\r\n      int = ll[\"length\"]\r\n      DictionaryAdd (ll, \"length\", int + 1)\r\n      msg (\"Done.\")\r\n    }\r\n  </function>\r\n</asl>\r\n```\r\n\r\n---\r\nOUTPUT\r\n\r\n```\r\nFinding last node. . .\r\nLast node found.\r\nDictionary: value = first;next = null;previous = null\r\nAdding new node. . .\r\ncurrent:\r\nDictionary: value = first;next = Dictionary: value = second;next = null;previous = null;previous = null\r\nDone.\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Okay. . .</p>\n<p>I find linked lists fascinating. I want to make sure I understand them; so, I am now trying to make them work in Quest.</p>\n<p>This <em>might</em> be working, but I can't check it.</p>\n<ol>\n<li>\n<p>If I uncomment either line: <code>msg (room.linked1)</code> or <code>msg (node)</code> (you'll see where I have them commented out), Quest freezes up.</p>\n</li>\n<li>\n<p>If I open the debugger and select the <code>room</code> object, Quest freezes up.</p>\n</li>\n</ol>\n<p>Something is throwing something for a \"loop\", but I'm not sure if that's good or bad? (Probably bad.)</p>\n<hr>\n<p>The code:</p>\n<pre><code>&lt;!--Saved by Quest 5.8.7753.35184--&gt;\n&lt;asl version=\"580\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Linked Lists\"&gt;\n    &lt;gameid&gt;7c9cbb79-8d5c-4b8b-82d3-1a1aef796b7d&lt;/gameid&gt;\n    &lt;version&gt;0.2&lt;/version&gt;\n    &lt;firstpublished&gt;2021&lt;/firstpublished&gt;\n    &lt;start type=\"script\"&gt;\n      node1 = NewListNode (\"first\")\n      room.linked1 = NewLinkedList()\n      LinkedListAdd (room.linked1, node1)\n      node2 = NewListNode(\"second\")\n      LinkedListAdd (room.linked1, node2)\n      // msg (room.linked1)\n    &lt;/start&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;isroom /&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;function name=\"NewListNode\" parameters=\"value\" type=\"dictionary\"&gt;\n    node = NewDictionary()\n    DictionaryAdd (node, \"value\", value)\n    DictionaryAdd (node, \"next\", \"null\")\n    DictionaryAdd (node, \"previous\", \"null\")\n    return (node)\n  &lt;/function&gt;\n  &lt;function name=\"NewLinkedList\" type=\"dictionary\"&gt;\n    ll = NewDictionary()\n    DictionaryAdd (ll, \"head\", \"null\")\n    DictionaryAdd (ll, \"length\", 0)\n    return (ll)\n  &lt;/function&gt;\n  &lt;function name=\"LinkedListAdd\" parameters=\"ll, node\"&gt;\n    if (ll[\"head\"] = \"null\") {\n      DictionaryAdd (ll, \"head\", node)\n      int = ll[\"length\"]\n      DictionaryAdd (ll, \"length\", int + 1)\n    }\n    else {\n      msg (\"Finding last node. . .\")\n      current = ll[\"head\"]\n      next = current[\"next\"]\n      while (not next = \"null\") {\n        current = next\n        next = current[\"next\"]\n      }\n      msg (\"Last node found.\")\n      msg (current)\n      msg (\"Adding new node. . .\")\n      DictionaryAdd (current, \"next\", node)\n      msg (\"current:\")\n      msg (current)\n      DictionaryAdd (node, \"previous\", current)\n      // msg (\"new:\")\n      // msg (node)\n      int = ll[\"length\"]\n      DictionaryAdd (ll, \"length\", int + 1)\n      msg (\"Done.\")\n    }\n  &lt;/function&gt;\n&lt;/asl&gt;\n</code></pre>\n<hr>\n<p>OUTPUT</p>\n<pre><code>Finding last node. . .\nLast node found.\nDictionary: value = first;next = null;previous = null\nAdding new node. . .\ncurrent:\nDictionary: value = first;next = Dictionary: value = second;next = null;previous = null;previous = null\nDone.\n</code></pre>\n\n",
      "PostDate": "2021-06-13T08:45:52.4211737Z",
      "LastEditDate": "2021-06-13T08:48:21.3615328Z",
      "link": null
    },
    {
      "PostId": "885ae27f-ad88-4b28-8826-c166fe8b1c76",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> If I uncomment either line: msg (room.linked1) or msg (node) (you'll see where I have them commented out), Quest freezes up\r\n\r\nThe problem is with your previous/next links.\r\n\r\nQuest attempts to write dictionaries out in full when you `msg` them.\r\n\r\n> Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = …\r\n\r\nOr indented a little so it's clearer…\r\n\r\nDictionary:\r\n* value = first;\r\n* next = Dictionary:\r\n    * value = second;\r\n    * next = null;\r\n    * prev = Dictionary:\r\n        * value = first;\r\n        * next = Dictionary:\r\n            * value = second;\r\n            * next = null;\r\n            * prev = Dictionary:\r\n                * …ad infinitum\r\n\r\nI think the same will be true with the XML when saving a game.\r\n\r\nMight be better creating an object for each node… something like (off the top of my head):\r\n```\r\n<function name=\"NewLinkedList\" type=\"object\">\r\n  name = GetUniqueElementName(\"linkedlist\")\r\n  create (name)\r\n  list = GetObject(name)\r\n  list.length = 0\r\n  return (list)\r\n</function>\r\n\r\n<type name=\"listnode\">\r\n  <attr name=\"value\" />\r\n</type>\r\n\r\n<function name=\"LinkedListAdd\" parameters=\"ll, value\" type=\"object\">\r\n  node = null\r\n  if (TypeOf (value) = \"object\") {\r\n    if (DoesInherit (value, \"listnode\")) {\r\n      node = value\r\n      LinkedListRemove (node)\r\n    }\r\n  }\r\n  if (node = null) {\r\n    name = GetUniqueElementName (\"listnode\")\r\n    node = GetObject (name, \"listnode\")\r\n    name.value = value\r\n  }\r\n  if (ll = null) {\r\n    ll = NewLinkedList()\r\n  }\r\n  node.list = ll\r\n  if (not HasObject (ll, \"head\")) {\r\n    ll.head = node\r\n  }\r\n  if (HasObject (ll, \"tail\")) {\r\n    node.prev = ll.tail\r\n  }\r\n  ll.tail = node\r\n  ll.length = ll.length + 1\r\n  return (ll)\r\n</function>\r\n\r\n<function name=\"LinkedListRemove\" parameters=\"node\">\r\n  if (HasObject (node, \"list\")) {\r\n    if (HasObject (node, \"next\")) {\r\n      node.next.prev = node.prev\r\n      node.next = null\r\n    }\r\n    else {\r\n      node.list.tail = node.prev\r\n    }\r\n    if (HasObject (node, \"prev\")) {\r\n      node.prev.next = node.next\r\n      node.prev = null\r\n    }\r\n    else {\r\n      node.list.head = node.next\r\n    }\r\n    node.list.length = node.list.length - 1\r\n    node.list = null\r\n  }\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>If I uncomment either line: msg (room.linked1) or msg (node) (you'll see where I have them commented out), Quest freezes up</p>\n</blockquote>\n<p>The problem is with your previous/next links.</p>\n<p>Quest attempts to write dictionaries out in full when you <code>msg</code> them.</p>\n<blockquote>\n<p>Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = Dictionary: value = first;next = Dictionary: value = second; next = null; prev = …</p>\n</blockquote>\n<p>Or indented a little so it's clearer…</p>\n<p>Dictionary:</p>\n<ul>\n<li>value = first;</li>\n<li>next = Dictionary:\n<ul>\n<li>value = second;</li>\n<li>next = null;</li>\n<li>prev = Dictionary:\n<ul>\n<li>value = first;</li>\n<li>next = Dictionary:\n<ul>\n<li>value = second;</li>\n<li>next = null;</li>\n<li>prev = Dictionary:\n<ul>\n<li>…ad infinitum</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>I think the same will be true with the XML when saving a game.</p>\n<p>Might be better creating an object for each node… something like (off the top of my head):</p>\n<pre><code>&lt;function name=\"NewLinkedList\" type=\"object\"&gt;\n  name = GetUniqueElementName(\"linkedlist\")\n  create (name)\n  list = GetObject(name)\n  list.length = 0\n  return (list)\n&lt;/function&gt;\n\n&lt;type name=\"listnode\"&gt;\n  &lt;attr name=\"value\" /&gt;\n&lt;/type&gt;\n\n&lt;function name=\"LinkedListAdd\" parameters=\"ll, value\" type=\"object\"&gt;\n  node = null\n  if (TypeOf (value) = \"object\") {\n    if (DoesInherit (value, \"listnode\")) {\n      node = value\n      LinkedListRemove (node)\n    }\n  }\n  if (node = null) {\n    name = GetUniqueElementName (\"listnode\")\n    node = GetObject (name, \"listnode\")\n    name.value = value\n  }\n  if (ll = null) {\n    ll = NewLinkedList()\n  }\n  node.list = ll\n  if (not HasObject (ll, \"head\")) {\n    ll.head = node\n  }\n  if (HasObject (ll, \"tail\")) {\n    node.prev = ll.tail\n  }\n  ll.tail = node\n  ll.length = ll.length + 1\n  return (ll)\n&lt;/function&gt;\n\n&lt;function name=\"LinkedListRemove\" parameters=\"node\"&gt;\n  if (HasObject (node, \"list\")) {\n    if (HasObject (node, \"next\")) {\n      node.next.prev = node.prev\n      node.next = null\n    }\n    else {\n      node.list.tail = node.prev\n    }\n    if (HasObject (node, \"prev\")) {\n      node.prev.next = node.next\n      node.prev = null\n    }\n    else {\n      node.list.head = node.next\n    }\n    node.list.length = node.list.length - 1\n    node.list = null\n  }\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2021-06-13T09:09:49.0484422Z",
      "LastEditDate": "2021-06-13T09:33:54.4063402Z",
      "link": null
    },
    {
      "PostId": "083b550f-d812-4a39-b76b-3759d94d1c6a",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Might be better creating an object for each node… \r\n\r\nHehehe.\r\n\r\nI ended up changing everything to objects last night.\r\n\r\nI decided it was working with the dictionaries, and that's why trying to look at the dictionaries threw Quest for a loop.\r\n\r\nHere's what I ended up doing (far from the final version):\r\n\r\n<details>\r\n\r\n```\r\n<!--Saved by Quest 5.8.7753.35184-->\r\n<asl version=\"580\">\r\n  <include ref=\"English.aslx\" />\r\n  <include ref=\"Core.aslx\" />\r\n  <game name=\"Linked Lists\">\r\n    <gameid>7c9cbb79-8d5c-4b8b-82d3-1a1aef796b7d</gameid>\r\n    <version>0.4</version>\r\n    <firstpublished>2021</firstpublished>\r\n    <start type=\"script\">\r\n      node1 = NewListNode (\"first\")\r\n      ll = NewLinkedList()\r\n      LinkedListAdd (ll, node1)\r\n      node2 = NewListNode(\"second\")\r\n      LinkedListAdd (ll, node2)\r\n      msg (ll)\r\n      node3 = NewListNode(\"second\")\r\n      LinkedListAdd (ll, node3)\r\n      msg (ll)\r\n      ll2 = NewLinkedList()\r\n      node4 = NewListNode(\"fourth\")\r\n      LinkedListAdd (ll2, node4)\r\n      msg (ll2.first)\r\n      node5 = NewListNode(\"fifth\")\r\n      LinkedListAdd (ll2, node5)\r\n      msg (ll2.rest)\r\n      LinkedListRemove (ll, node2)\r\n      msg (ll)\r\n      msg (\"AllLinkedLists():\")\r\n      msg (AllLinkedLists())\r\n    </start>\r\n  </game>\r\n  <object name=\"room\">\r\n    <inherit name=\"editor_room\" />\r\n    <isroom />\r\n    <object name=\"player\">\r\n      <inherit name=\"editor_object\" />\r\n      <inherit name=\"editor_player\" />\r\n    </object>\r\n  </object>\r\n  <object name=\"LinkedLists\">\r\n    <inherit name=\"editor_object\" />\r\n  </object>\r\n  <function name=\"NewListNode\" parameters=\"value\" type=\"object\">\r\n    node = GetObject (value)\r\n    if (not TypeOf(node) = \"object\") {\r\n      create (value)\r\n      node = GetObject (value)\r\n    }\r\n    else {\r\n      node = CloneObject (node)\r\n    }\r\n    node.value = value\r\n    node.previous = false\r\n    node.next = false\r\n    node.listnode = true\r\n    return (node)\r\n  </function>\r\n  <function name=\"NewLinkedListBak\" type=\"dictionary\">\r\n    ll = NewDictionary()\r\n    DictionaryAdd (ll, \"head\", false)\r\n    DictionaryAdd (ll, \"length\", 0)\r\n    return (ll)\r\n  </function>\r\n  <function name=\"LinkedListAddBak\" parameters=\"ll, node\">\r\n    if (not TypeOf(ll[\"head\"]) = \"object\") {\r\n      DictionaryAdd (ll, \"head\", node)\r\n      int = ll[\"length\"]\r\n      DictionaryAdd (ll, \"length\", int + 1)\r\n      DictionaryAdd (ll, \"first\", First(ll))\r\n      DictionaryAdd (ll, \"rest\", \"null\")\r\n      DictionaryAdd (ll, \"tail\", node)\r\n    }\r\n    else {\r\n      current = ll[\"head\"]\r\n      next = current.next\r\n      while (TypeOf(next) = \"object\") {\r\n        current = next\r\n        next = current.next\r\n      }\r\n      current.next = node\r\n      node.previous = current\r\n      int = ll[\"length\"]\r\n      DictionaryAdd (ll, node.name, node)\r\n      DictionaryAdd (ll, \"length\", int + 1)\r\n      DictionaryAdd (ll, \"tail\", node)\r\n      if (not TypeOf(ll[\"rest\"]) = \"object\") {\r\n        first = ll[\"head\"]\r\n        rest = first.next\r\n        DictionaryAdd (ll, \"rest\", rest)\r\n      }\r\n    }\r\n  </function>\r\n  <function name=\"LinkedListRemove\" parameters=\"ll, node\">\r\n    node.parent = null\r\n    node.next.previous = node.previous\r\n    node.previous.next = node.next\r\n    if (ll.tail = node) {\r\n      ll.tail = node.previous\r\n    }\r\n    if (ll.rest = node) {\r\n      ll.rest = node.next\r\n    }\r\n    if (ll.head = node) {\r\n      ll.head = false\r\n    }\r\n    ll.length = ll.length - 1\r\n  </function>\r\n  <function name=\"First\" parameters=\"ll\" type=\"object\">\r\n    return (ll[\"head\"])\r\n  </function>\r\n  <function name=\"Rest\" parameters=\"ll\" type=\"object\">\r\n  </function>\r\n  <function name=\"NewLinkedList\" type=\"object\"><![CDATA[\r\n    name = GetUniqueElementName (\"LinkedList1\")\r\n    create (name)\r\n    ll = GetObject (name)\r\n    ll.head = false\r\n    ll.changedhead => {\r\n      this.first = this.head\r\n      this.rest = this.head.next\r\n    }\r\n    ll.first = ll.head\r\n    ll.rest = false\r\n    ll.tail = false\r\n    ll.length = 0\r\n    ll.parent = LinkedLists\r\n    return (ll)\r\n  ]]></function>\r\n  <function name=\"LinkedListAdd\" parameters=\"ll, node\">\r\n    if (not TypeOf(ll.head) = \"object\") {\r\n      ll.head = node\r\n      ll.length = ll.length + 1\r\n      ll.rest = false\r\n      ll.tail = node\r\n    }\r\n    else {\r\n      current = ll.head\r\n      next = current.next\r\n      while (TypeOf(next) = \"object\") {\r\n        current = next\r\n        next = current.next\r\n      }\r\n      current.next = node\r\n      node.previous = current\r\n      node.parent = ll\r\n      ll.length = ll.length + 1\r\n      ll.tail = node\r\n      if (not TypeOf(ll.rest) = \"object\") {\r\n        first = ll.head\r\n        rest = first.next\r\n        ll.rest = rest\r\n      }\r\n    }\r\n  </function>\r\n  <function name=\"AllLinkedLists\" type=\"objectlist\">\r\n    return (GetDirectChildren (LinkedLists))\r\n  </function>\r\n</asl>\r\n```\r\n\r\n</details>\r\n\r\n---\r\nMixing objects and dictionaries, as in your example, is probably the best route.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Might be better creating an object for each node…</p>\n</blockquote>\n<p>Hehehe.</p>\n<p>I ended up changing everything to objects last night.</p>\n<p>I decided it was working with the dictionaries, and that's why trying to look at the dictionaries threw Quest for a loop.</p>\n<p>Here's what I ended up doing (far from the final version):</p>\n<details>\n<pre><code>&lt;!--Saved by Quest 5.8.7753.35184--&gt;\n&lt;asl version=\"580\"&gt;\n  &lt;include ref=\"English.aslx\" /&gt;\n  &lt;include ref=\"Core.aslx\" /&gt;\n  &lt;game name=\"Linked Lists\"&gt;\n    &lt;gameid&gt;7c9cbb79-8d5c-4b8b-82d3-1a1aef796b7d&lt;/gameid&gt;\n    &lt;version&gt;0.4&lt;/version&gt;\n    &lt;firstpublished&gt;2021&lt;/firstpublished&gt;\n    &lt;start type=\"script\"&gt;\n      node1 = NewListNode (\"first\")\n      ll = NewLinkedList()\n      LinkedListAdd (ll, node1)\n      node2 = NewListNode(\"second\")\n      LinkedListAdd (ll, node2)\n      msg (ll)\n      node3 = NewListNode(\"second\")\n      LinkedListAdd (ll, node3)\n      msg (ll)\n      ll2 = NewLinkedList()\n      node4 = NewListNode(\"fourth\")\n      LinkedListAdd (ll2, node4)\n      msg (ll2.first)\n      node5 = NewListNode(\"fifth\")\n      LinkedListAdd (ll2, node5)\n      msg (ll2.rest)\n      LinkedListRemove (ll, node2)\n      msg (ll)\n      msg (\"AllLinkedLists():\")\n      msg (AllLinkedLists())\n    &lt;/start&gt;\n  &lt;/game&gt;\n  &lt;object name=\"room\"&gt;\n    &lt;inherit name=\"editor_room\" /&gt;\n    &lt;isroom /&gt;\n    &lt;object name=\"player\"&gt;\n      &lt;inherit name=\"editor_object\" /&gt;\n      &lt;inherit name=\"editor_player\" /&gt;\n    &lt;/object&gt;\n  &lt;/object&gt;\n  &lt;object name=\"LinkedLists\"&gt;\n    &lt;inherit name=\"editor_object\" /&gt;\n  &lt;/object&gt;\n  &lt;function name=\"NewListNode\" parameters=\"value\" type=\"object\"&gt;\n    node = GetObject (value)\n    if (not TypeOf(node) = \"object\") {\n      create (value)\n      node = GetObject (value)\n    }\n    else {\n      node = CloneObject (node)\n    }\n    node.value = value\n    node.previous = false\n    node.next = false\n    node.listnode = true\n    return (node)\n  &lt;/function&gt;\n  &lt;function name=\"NewLinkedListBak\" type=\"dictionary\"&gt;\n    ll = NewDictionary()\n    DictionaryAdd (ll, \"head\", false)\n    DictionaryAdd (ll, \"length\", 0)\n    return (ll)\n  &lt;/function&gt;\n  &lt;function name=\"LinkedListAddBak\" parameters=\"ll, node\"&gt;\n    if (not TypeOf(ll[\"head\"]) = \"object\") {\n      DictionaryAdd (ll, \"head\", node)\n      int = ll[\"length\"]\n      DictionaryAdd (ll, \"length\", int + 1)\n      DictionaryAdd (ll, \"first\", First(ll))\n      DictionaryAdd (ll, \"rest\", \"null\")\n      DictionaryAdd (ll, \"tail\", node)\n    }\n    else {\n      current = ll[\"head\"]\n      next = current.next\n      while (TypeOf(next) = \"object\") {\n        current = next\n        next = current.next\n      }\n      current.next = node\n      node.previous = current\n      int = ll[\"length\"]\n      DictionaryAdd (ll, node.name, node)\n      DictionaryAdd (ll, \"length\", int + 1)\n      DictionaryAdd (ll, \"tail\", node)\n      if (not TypeOf(ll[\"rest\"]) = \"object\") {\n        first = ll[\"head\"]\n        rest = first.next\n        DictionaryAdd (ll, \"rest\", rest)\n      }\n    }\n  &lt;/function&gt;\n  &lt;function name=\"LinkedListRemove\" parameters=\"ll, node\"&gt;\n    node.parent = null\n    node.next.previous = node.previous\n    node.previous.next = node.next\n    if (ll.tail = node) {\n      ll.tail = node.previous\n    }\n    if (ll.rest = node) {\n      ll.rest = node.next\n    }\n    if (ll.head = node) {\n      ll.head = false\n    }\n    ll.length = ll.length - 1\n  &lt;/function&gt;\n  &lt;function name=\"First\" parameters=\"ll\" type=\"object\"&gt;\n    return (ll[\"head\"])\n  &lt;/function&gt;\n  &lt;function name=\"Rest\" parameters=\"ll\" type=\"object\"&gt;\n  &lt;/function&gt;\n  &lt;function name=\"NewLinkedList\" type=\"object\"&gt;&lt;![CDATA[\n    name = GetUniqueElementName (\"LinkedList1\")\n    create (name)\n    ll = GetObject (name)\n    ll.head = false\n    ll.changedhead =&gt; {\n      this.first = this.head\n      this.rest = this.head.next\n    }\n    ll.first = ll.head\n    ll.rest = false\n    ll.tail = false\n    ll.length = 0\n    ll.parent = LinkedLists\n    return (ll)\n  ]]&gt;&lt;/function&gt;\n  &lt;function name=\"LinkedListAdd\" parameters=\"ll, node\"&gt;\n    if (not TypeOf(ll.head) = \"object\") {\n      ll.head = node\n      ll.length = ll.length + 1\n      ll.rest = false\n      ll.tail = node\n    }\n    else {\n      current = ll.head\n      next = current.next\n      while (TypeOf(next) = \"object\") {\n        current = next\n        next = current.next\n      }\n      current.next = node\n      node.previous = current\n      node.parent = ll\n      ll.length = ll.length + 1\n      ll.tail = node\n      if (not TypeOf(ll.rest) = \"object\") {\n        first = ll.head\n        rest = first.next\n        ll.rest = rest\n      }\n    }\n  &lt;/function&gt;\n  &lt;function name=\"AllLinkedLists\" type=\"objectlist\"&gt;\n    return (GetDirectChildren (LinkedLists))\n  &lt;/function&gt;\n&lt;/asl&gt;\n</code></pre>\n</details>\n<hr>\n<p>Mixing objects and dictionaries, as in your example, is probably the best route.</p>\n\n",
      "PostDate": "2021-06-13T16:50:13.9809818Z",
      "LastEditDate": "2021-06-13T17:04:47.7807361Z",
      "link": null
    },
    {
      "PostId": "2f074a66-fcd3-44fa-87f1-888570485f9b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ummm…\r\n>      node = GetObject (value)\r\n>        if (not TypeOf(node) = \"object\") {\r\n>          create (value)\r\n>          node = GetObject (value)\r\n>        }\r\n>        else {\r\n>          node = CloneObject (node)\r\n>        }\r\n\r\nIf the value passed to the function is an object, you clone it before adding it to the list? That seems a little unstable.\r\n\r\nIf you're storing in-game objects like rooms in a linked list, this means that functions like `AllRooms()`, `AllExits()` or `AllNpcs()` will now return both the object, and its list node.\r\n\r\nAnd you haven't handled the case where the value isn't a valid object name, such as \"7\" or \"someimage.png\".",
      "EditableFormat": "markdown",
      "HTML": "<p>Ummm…</p>\n<blockquote>\n<pre><code> node = GetObject (value)\n   if (not TypeOf(node) = \"object\") {\n     create (value)\n     node = GetObject (value)\n   }\n   else {\n     node = CloneObject (node)\n   }\n</code></pre>\n</blockquote>\n<p>If the value passed to the function is an object, you clone it before adding it to the list? That seems a little unstable.</p>\n<p>If you're storing in-game objects like rooms in a linked list, this means that functions like <code>AllRooms()</code>, <code>AllExits()</code> or <code>AllNpcs()</code> will now return both the object, and its list node.</p>\n<p>And you haven't handled the case where the value isn't a valid object name, such as \"7\" or \"someimage.png\".</p>\n\n",
      "PostDate": "2021-06-13T17:19:21.7396254Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "01dd1470-d23a-4d59-8506-314959094312",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yeah... I noticed a few other issues in my \"all objects\" version, too.\r\n\r\nAfter some waffles, I'm going to use your functions and play around with it that way.",
      "EditableFormat": "markdown",
      "HTML": "<p>Yeah... I noticed a few other issues in my \"all objects\" version, too.</p>\n<p>After some waffles, I'm going to use your functions and play around with it that way.</p>\n\n",
      "PostDate": "2021-06-13T17:36:17.1800593Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f80870d5-123e-4e7f-8952-071298eba2b6",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmm… I think there might be a little problem with handling list nodes in this way. You need to be careful when removing objects from a list, because the node will still be there. In some cases this might be beneficial. For example, you could remove a node from one list, store it somewhere temporarily, and then add it to a different list. But there's no easy way to do garbage collection, so there may be orphaned nodes lying around all over the place.\r\n\r\nThis could let you do some interesting things that a standard Quest list can't. For example:\r\n```\r\n<function name=\"LinkedListRemove\" parameters=\"node\">\r\n  if (HasObject (node, \"list\") and LinkedListContains (node.list, node)) {\r\n    if (HasObject (node, \"next\")) {\r\n      node.next.prev = node.prev\r\n    }\r\n    else {\r\n      node.list.tail = node.prev\r\n    }\r\n    if (HasObject (node, \"prev\")) {\r\n      node.prev.next = node.next\r\n    }\r\n    else {\r\n      node.list.head = node.next\r\n    }\r\n    node.list.length = node.list.length - 1\r\n  }\r\n</function>\r\n\r\n<function name=\"LinkedListContains\" parameters=\"ll, node\" type=\"boolean\">\r\n  if (node = null or ll = null) {\r\n    return (false)\r\n  }\r\n  if (not node.list = ll) {\r\n    return (false)\r\n  }\r\n  scan = ll.head\r\n  while (not scan = null) {\r\n    if (Equal (scan, node) or Equal (scan.value, node)) {\r\n      return (true)\r\n    }\r\n    scan = scan.next\r\n  }\r\n  return (false)\r\n</function>\r\n\r\n<function name=\"LinkedListRemovedNodes\" parameters=\"ll\" type=\"objectlist\">\r\n  result = FilterByAttribute (FilterByType (AllObjects(), \"listnode\"), \"list\", ll)\r\n  node = ll.head\r\n  while (not node=null) {\r\n    list remove (result, node)\r\n    node = node.next\r\n  }\r\n  return (result)\r\n</function>\r\n\r\n<function name=\"LinkedListUnremove\" parameters=\"node\" type=\"object\">\r\n  if (not HasObject (node, \"list\")) {\r\n    ll = NewLinkedList()\r\n    LinkedListAdd (ll, node)\r\n  }\r\n  else {\r\n    ll = node.list\r\n    if (not HasObject (ll, \"head\")) {\r\n      // list is empty\r\n      ll.head = node\r\n      ll.tail = node\r\n      node.next = null\r\n      node.prev = null\r\n      return (ll)\r\n    }\r\n    else if (LinkedListContains (ll, node.prev)) {\r\n      node.next = node.prev.next\r\n      if (HasObject (node, \"next\")) {\r\n        node.next.prev = node\r\n      }\r\n      else {\r\n        ll.tail = node\r\n      }\r\n      node.prev.next = node\r\n      ll.length = ll.length + 1\r\n    }\r\n    else if (LinkedListContains (ll, node.next)) {\r\n      node.prev = node.next.prev\r\n      if (HasObject (node, \"prev\")) {\r\n        node.prev.next = node\r\n      }\r\n      else {\r\n        ll.head = node\r\n      }\r\n      node.next.prev = node\r\n      ll.length = ll.length + 1\r\n    }\r\n    else {\r\n      LinkedListAdd (ll, node)\r\n    }\r\n  }\r\n  return (ll)\r\n</function>\r\n\r\n<function name=\"LinkedListShuffle\" parameters=\"ll\">\r\n  if (ll.length < 2) {\r\n    return()\r\n  }\r\n\r\n  node = ll.head\r\n  swap = node.next\r\n  for (i, 0, GetRandomInt(ll.length, 2*ll.length) * GetRandomInt (2, ll.length)) {\r\n    while (RandomChance (65)) {\r\n      node = swap\r\n      if (HasObject (node, \"next\")) {\r\n        swap = node.next\r\n      }\r\n      else {\r\n        swap = ll.head\r\n      }\r\n    }\r\n    swap.prev = node.prev\r\n    node.next = swap.next\r\n    if (ll.tail = node) {\r\n      ll.tail = swap\r\n      ll.head = node\r\n      node.prev = null\r\n      swap.next = null\r\n    }\r\n    else {\r\n      node.prev = swap\r\n      swap.next = node\r\n    }\r\n    if (HasObject (swap, \"prev\")) swap.prev.next = swap\r\n    if (HasObject (node, \"next\")) node.next.prev = node\r\n  }\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmm… I think there might be a little problem with handling list nodes in this way. You need to be careful when removing objects from a list, because the node will still be there. In some cases this might be beneficial. For example, you could remove a node from one list, store it somewhere temporarily, and then add it to a different list. But there's no easy way to do garbage collection, so there may be orphaned nodes lying around all over the place.</p>\n<p>This could let you do some interesting things that a standard Quest list can't. For example:</p>\n<pre><code>&lt;function name=\"LinkedListRemove\" parameters=\"node\"&gt;\n  if (HasObject (node, \"list\") and LinkedListContains (node.list, node)) {\n    if (HasObject (node, \"next\")) {\n      node.next.prev = node.prev\n    }\n    else {\n      node.list.tail = node.prev\n    }\n    if (HasObject (node, \"prev\")) {\n      node.prev.next = node.next\n    }\n    else {\n      node.list.head = node.next\n    }\n    node.list.length = node.list.length - 1\n  }\n&lt;/function&gt;\n\n&lt;function name=\"LinkedListContains\" parameters=\"ll, node\" type=\"boolean\"&gt;\n  if (node = null or ll = null) {\n    return (false)\n  }\n  if (not node.list = ll) {\n    return (false)\n  }\n  scan = ll.head\n  while (not scan = null) {\n    if (Equal (scan, node) or Equal (scan.value, node)) {\n      return (true)\n    }\n    scan = scan.next\n  }\n  return (false)\n&lt;/function&gt;\n\n&lt;function name=\"LinkedListRemovedNodes\" parameters=\"ll\" type=\"objectlist\"&gt;\n  result = FilterByAttribute (FilterByType (AllObjects(), \"listnode\"), \"list\", ll)\n  node = ll.head\n  while (not node=null) {\n    list remove (result, node)\n    node = node.next\n  }\n  return (result)\n&lt;/function&gt;\n\n&lt;function name=\"LinkedListUnremove\" parameters=\"node\" type=\"object\"&gt;\n  if (not HasObject (node, \"list\")) {\n    ll = NewLinkedList()\n    LinkedListAdd (ll, node)\n  }\n  else {\n    ll = node.list\n    if (not HasObject (ll, \"head\")) {\n      // list is empty\n      ll.head = node\n      ll.tail = node\n      node.next = null\n      node.prev = null\n      return (ll)\n    }\n    else if (LinkedListContains (ll, node.prev)) {\n      node.next = node.prev.next\n      if (HasObject (node, \"next\")) {\n        node.next.prev = node\n      }\n      else {\n        ll.tail = node\n      }\n      node.prev.next = node\n      ll.length = ll.length + 1\n    }\n    else if (LinkedListContains (ll, node.next)) {\n      node.prev = node.next.prev\n      if (HasObject (node, \"prev\")) {\n        node.prev.next = node\n      }\n      else {\n        ll.head = node\n      }\n      node.next.prev = node\n      ll.length = ll.length + 1\n    }\n    else {\n      LinkedListAdd (ll, node)\n    }\n  }\n  return (ll)\n&lt;/function&gt;\n\n&lt;function name=\"LinkedListShuffle\" parameters=\"ll\"&gt;\n  if (ll.length &lt; 2) {\n    return()\n  }\n\n  node = ll.head\n  swap = node.next\n  for (i, 0, GetRandomInt(ll.length, 2*ll.length) * GetRandomInt (2, ll.length)) {\n    while (RandomChance (65)) {\n      node = swap\n      if (HasObject (node, \"next\")) {\n        swap = node.next\n      }\n      else {\n        swap = ll.head\n      }\n    }\n    swap.prev = node.prev\n    node.next = swap.next\n    if (ll.tail = node) {\n      ll.tail = swap\n      ll.head = node\n      node.prev = null\n      swap.next = null\n    }\n    else {\n      node.prev = swap\n      swap.next = node\n    }\n    if (HasObject (swap, \"prev\")) swap.prev.next = swap\n    if (HasObject (node, \"next\")) node.next.prev = node\n  }\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2021-06-13T18:55:19.0237366Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "de457f73-0d9d-439c-8e12-8b3ba42f9805",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "More silliness, Quest style:\r\n```\r\n<type name=\"listnode\">\r\n  <changednext type=\"script\">\r\n    if (this.next = null) {\r\n      oldvalue.prev = null\r\n    }\r\n    else {\r\n      if (IsDefined (\"oldvalue\")) {\r\n        oldvalue.prev = this.next.prev\r\n      }\r\n      this.next.prev = this\r\n    }\r\n  </changednext>\r\n\r\n  <changedprev type=\"script\">\r\n    if (this.prev = null) {\r\n      oldvalue.next = null\r\n    }\r\n    else {\r\n      if (IsDefined (\"oldvalue\")) {\r\n        oldvalue.next = this.prev.next\r\n      }\r\n      this.prev.next = this\r\n    }\r\n  </changedprev>\r\n</type>\r\n```\r\n\r\nMakes the add/remove code a whole lot simpler. Doesn't work with the undeleting silliness above, but it means that changing the next or prev attributes will automatically sort itself out. It can do some crazy things, but sometimes that's what you want.\r\n```\r\nnode_a.next = node_b\r\n```\r\nIf node A is in a list somewhere before node B, this line will neatly remove all elements between them\r\nIf node B is before node A, this will remove them (and everything between them) from the list, and make it into a new 'loop' list.\r\nIf they're in separate lists, this will split the lists (after A and before B) and swap round their second halfs.\r\n\r\nThis stuff will mess up metadata (like `length` and `tail`) in the list object. So if you're doing stuff like this, it might be better to ignore the list object completely, and treat any node as if it is a list. For example:\r\n```\r\n<function name=\"PrintLinkedList\" parameters=\"list\">\r\n  node = list\r\n output = \"<ul>\"\r\n  while (not node = null) {\r\n    output = output + \"<li>\" + node.value + \"</li>\"\r\n    node = node.next\r\n    if (node = list) {\r\n      output = output + \"<li><em>\" + node.value + \" and so on for infinity</em></li>\"\r\n      node = null\r\n    }\r\n  }\r\n  msg (output + \"</li>\")\r\n</function>\r\n```\r\nThis takes a listnode as a parameter, and prints a list of all the values found from that point up to the end of the list. If the list is a loop, it will go round until it reaches the same point again.\r\n\r\nFor example:\r\n```\r\ncreate(\"spring\", \"listnode\")\r\nspring.value = \"Spring!!!\"\r\ncreate(\"summer\", \"listnode\")\r\nsummer.value = \"Hotness\"\r\nsummer.prev = spring\r\ncreate(\"autumn\", \"listnode\")\r\nautumn.value = \"Fall\"\r\nautumn.prev = summer\r\ncreate(\"winter\", \"listnode\")\r\nwinter.value = \"Brrrrr\"\r\nautumn.next = winter\r\nwinter.next = spring\r\nPrintLinkedList (winter)\r\n```\r\nwill generate:\r\n<ul style=\"border: 1px dotted darkgreen\"><li>Brrrrr</li><li>Spring!!!</li><li>Hotness</li><li>Fall</li><li><em>Brrrrr and so on for infinity</em></li></ul>",
      "EditableFormat": "markdown",
      "HTML": "<p>More silliness, Quest style:</p>\n<pre><code>&lt;type name=\"listnode\"&gt;\n  &lt;changednext type=\"script\"&gt;\n    if (this.next = null) {\n      oldvalue.prev = null\n    }\n    else {\n      if (IsDefined (\"oldvalue\")) {\n        oldvalue.prev = this.next.prev\n      }\n      this.next.prev = this\n    }\n  &lt;/changednext&gt;\n\n  &lt;changedprev type=\"script\"&gt;\n    if (this.prev = null) {\n      oldvalue.next = null\n    }\n    else {\n      if (IsDefined (\"oldvalue\")) {\n        oldvalue.next = this.prev.next\n      }\n      this.prev.next = this\n    }\n  &lt;/changedprev&gt;\n&lt;/type&gt;\n</code></pre>\n<p>Makes the add/remove code a whole lot simpler. Doesn't work with the undeleting silliness above, but it means that changing the next or prev attributes will automatically sort itself out. It can do some crazy things, but sometimes that's what you want.</p>\n<pre><code>node_a.next = node_b\n</code></pre>\n<p>If node A is in a list somewhere before node B, this line will neatly remove all elements between them<br>\nIf node B is before node A, this will remove them (and everything between them) from the list, and make it into a new 'loop' list.<br>\nIf they're in separate lists, this will split the lists (after A and before B) and swap round their second halfs.</p>\n<p>This stuff will mess up metadata (like <code>length</code> and <code>tail</code>) in the list object. So if you're doing stuff like this, it might be better to ignore the list object completely, and treat any node as if it is a list. For example:</p>\n<pre><code>&lt;function name=\"PrintLinkedList\" parameters=\"list\"&gt;\n  node = list\n output = \"&lt;ul&gt;\"\n  while (not node = null) {\n    output = output + \"&lt;li&gt;\" + node.value + \"&lt;/li&gt;\"\n    node = node.next\n    if (node = list) {\n      output = output + \"&lt;li&gt;&lt;em&gt;\" + node.value + \" and so on for infinity&lt;/em&gt;&lt;/li&gt;\"\n      node = null\n    }\n  }\n  msg (output + \"&lt;/li&gt;\")\n&lt;/function&gt;\n</code></pre>\n<p>This takes a listnode as a parameter, and prints a list of all the values found from that point up to the end of the list. If the list is a loop, it will go round until it reaches the same point again.</p>\n<p>For example:</p>\n<pre><code>create(\"spring\", \"listnode\")\nspring.value = \"Spring!!!\"\ncreate(\"summer\", \"listnode\")\nsummer.value = \"Hotness\"\nsummer.prev = spring\ncreate(\"autumn\", \"listnode\")\nautumn.value = \"Fall\"\nautumn.prev = summer\ncreate(\"winter\", \"listnode\")\nwinter.value = \"Brrrrr\"\nautumn.next = winter\nwinter.next = spring\nPrintLinkedList (winter)\n</code></pre>\n<p>will generate:</p>\n<ul style=\"border: 1px dotted darkgreen\"><li>Brrrrr</li><li>Spring!!!</li><li>Hotness</li><li>Fall</li><li><em>Brrrrr and so on for infinity</em></li></ul>\n\n",
      "PostDate": "2021-06-13T19:40:13.9358365Z",
      "LastEditDate": "2021-06-13T19:45:57.9625118Z",
      "link": null
    }
  ]
}
