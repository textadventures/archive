{
  "Topic": {
    "TopicId": "um5i9g6fik26bv9xj9tlxw",
    "ForumId": "10",
    "Title": "Issue with speak to",
    "LastUpdated": "2018-09-26T05:15:59.5934731Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "0a7cd907-abb2-4896-98f7-59b17556c3ee",
      "UserId": 142763,
      "Username": "Forgewright",
      "AvatarUrl": "http://i.imgur.com/Ea6HecZb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "When you speak to anyone in the game and you have not created a response, the game will respond:\r\n\"He saies nothing.\"\r\nCan the spelling of \"says\" get a fix?",
      "EditableFormat": "markdown",
      "HTML": "<p>When you speak to anyone in the game and you have not created a response, the game will respond:<br>\n\"He saies nothing.\"<br>\nCan the spelling of \"says\" get a fix?</p>\n\n",
      "PostDate": "2018-09-26T05:15:59.5934731Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "782e6e38-3281-430a-acb7-f099ea0eef70",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Someone else already pointed this out. On the previous version, I pointed out that it should be \"tries\" rather than \"trys\" (which is now fixed) and \"switches\" instead of \"switchs\" (which still doesn't work).\r\n\r\nIn the last thread I suggested a change which would make these work correctly and also allow the user to add more irregular verbs if there's any I missed.\r\n\r\nHere's a version with a little more thought in it; putting all the data into dictionaries.\r\n\r\n```\r\n<function name=\"Conjugate\" type=\"string\" parameters=\"obj, verb\">\r\n  genders = LCase(obj.gender)\r\n  if (genders = \"he\" or genders = \"she\") {\r\n    genders = genders + \";it\"\r\n  }\r\n  cmd = GetObject (verb)\r\n  foreach (gender, Split(genders)) {\r\n    if (not cmd = null and HasString (cmd, \"conjugate_\"+gender)) {\r\n      return (GetString (cmd, \"conjugate_\"+gender))\r\n    }\r\n    dict = GetAttribute (game, \"conjugations_\"+gender)\r\n    if (not dict = null) {\r\n      if (DictionaryContains (dict, verb)) {\r\n        return (DictionaryItem (dict, verb))\r\n      }\r\n      foreach (ending, game.conjugations) {\r\n        if (Left (ending, 1) = \"@\" and EndsWith (verb, Mid (ending, 2))) {\r\n          return (Conjugate (obj, Left (verb, LengthOf(verb) - LengthOf(ending) + 1)) + DictionaryItem (dict, ending))\r\n        }\r\n        else if (Left (ending, 1) = \"*\" and EndsWith (verb, Mid (ending, 2))) {\r\n          return (Left (verb, LengthOf(verb) - LengthOf(ending) + 1) + DictionaryItem (dict, ending))\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return (verb)\r\n</function>\r\n```\r\n\r\nAnd then a couple of dictionaries on the game object, allowing for easy creation of fictional irregular verbs:\r\n```\r\n<attr name=\"conjugations_i\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>am</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_you\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_we\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_they\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_it\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>is</value></item>\r\n  <item><key>have</key><value>has</value></item>\r\n  <item><key>*ay</key><value>ays</value></item>\r\n  <item><key>*oy</key><value>oys</value></item>\r\n  <item><key>*ey</key><value>eys</value></item>\r\n  <item><key>*y</key><value>ies</value></item>\r\n  <item><key>*ss</key><value>sses</value></item>\r\n  <item><key>*s</key><value>sses</value></item>\r\n  <item><key>*sh</key><value>shes</value></item>\r\n  <item><key>*ch</key><value>ches</value></item>\r\n  <item><key>*o</key><value>oes</value></item>\r\n  <item><key>*x</key><value>xes</value></item>\r\n  <item><key>*z</key><value>zes</value></item>\r\n  <item><key>*</key><value>s</value></item>\r\n</attr>\r\n```\r\nWith this function, the dictionaries control verb conjugation\r\n\r\nIf you want to, you could add entries like `<item><key>@ with</key><value> with</value></item>` so that Conjugate will work properly if given a verb with a preposition. This would make it a lot more useful to anyone who's making more advanced NPCs, because you could use it directly with most things from displayverbs.",
      "EditableFormat": "markdown",
      "HTML": "<p>Someone else already pointed this out. On the previous version, I pointed out that it should be \"tries\" rather than \"trys\" (which is now fixed) and \"switches\" instead of \"switchs\" (which still doesn't work).</p>\n<p>In the last thread I suggested a change which would make these work correctly and also allow the user to add more irregular verbs if there's any I missed.</p>\n<p>Here's a version with a little more thought in it; putting all the data into dictionaries.</p>\n<pre><code>&lt;function name=\"Conjugate\" type=\"string\" parameters=\"obj, verb\"&gt;\n  genders = LCase(obj.gender)\n  if (genders = \"he\" or genders = \"she\") {\n    genders = genders + \";it\"\n  }\n  cmd = GetObject (verb)\n  foreach (gender, Split(genders)) {\n    if (not cmd = null and HasString (cmd, \"conjugate_\"+gender)) {\n      return (GetString (cmd, \"conjugate_\"+gender))\n    }\n    dict = GetAttribute (game, \"conjugations_\"+gender)\n    if (not dict = null) {\n      if (DictionaryContains (dict, verb)) {\n        return (DictionaryItem (dict, verb))\n      }\n      foreach (ending, game.conjugations) {\n        if (Left (ending, 1) = \"@\" and EndsWith (verb, Mid (ending, 2))) {\n          return (Conjugate (obj, Left (verb, LengthOf(verb) - LengthOf(ending) + 1)) + DictionaryItem (dict, ending))\n        }\n        else if (Left (ending, 1) = \"*\" and EndsWith (verb, Mid (ending, 2))) {\n          return (Left (verb, LengthOf(verb) - LengthOf(ending) + 1) + DictionaryItem (dict, ending))\n        }\n      }\n    }\n  }\n  return (verb)\n&lt;/function&gt;\n</code></pre>\n<p>And then a couple of dictionaries on the game object, allowing for easy creation of fictional irregular verbs:</p>\n<pre><code>&lt;attr name=\"conjugations_i\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;am&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_you\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_we\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_they\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_it\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;is&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;have&lt;/key&gt;&lt;value&gt;has&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ay&lt;/key&gt;&lt;value&gt;ays&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*oy&lt;/key&gt;&lt;value&gt;oys&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ey&lt;/key&gt;&lt;value&gt;eys&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*y&lt;/key&gt;&lt;value&gt;ies&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ss&lt;/key&gt;&lt;value&gt;sses&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*s&lt;/key&gt;&lt;value&gt;sses&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*sh&lt;/key&gt;&lt;value&gt;shes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ch&lt;/key&gt;&lt;value&gt;ches&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*o&lt;/key&gt;&lt;value&gt;oes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*x&lt;/key&gt;&lt;value&gt;xes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*z&lt;/key&gt;&lt;value&gt;zes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*&lt;/key&gt;&lt;value&gt;s&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n</code></pre>\n<p>With this function, the dictionaries control verb conjugation</p>\n<p>If you want to, you could add entries like <code>&lt;item&gt;&lt;key&gt;@ with&lt;/key&gt;&lt;value&gt; with&lt;/value&gt;&lt;/item&gt;</code> so that Conjugate will work properly if given a verb with a preposition. This would make it a lot more useful to anyone who's making more advanced NPCs, because you could use it directly with most things from displayverbs.</p>\n\n",
      "PostDate": "2018-09-26T09:57:45.4174685Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "33e22ec4-4de2-4add-86a1-611f3585e042",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(Here's a further thought, which might make the same Conjugate function work well enough for all languages rather than having a different one in every language library:\r\n\r\n```\r\n        else if (StartsWith (ending, \"/\")) {\r\n          parts = Split (Mid (ending, 2), \"/\")\r\n          pattern = \"(?<fullmatch>\" + ListItem (parts, 0) + \")\"\r\n          if (ListCount (parts) > 1) {\r\n            continue = (Instr (ListItem (parts, 1), \"+\") > 0)\r\n            repeat = (Instr (ListItem (parts, 1), \"g\") > 0)\r\n            expr = (Instr (ListItem (parts, 1), \"e\") > 0)\r\n          }\r\n          else {\r\n            continue = false\r\n            repeat = false\r\n            expr = false\r\n          }\r\n          if (IsRegexMatch (pattern, verb)) {\r\n            processed = \"\"\r\n            processing = verb\r\n            while (IsRegexMatch (pattern, processing)) {\r\n              matches = Populate (pattern, processing)\r\n              startpos = Instr (processing, DictionaryItem (matches, fullmatch))\r\n              endpos = startpos + LengthOf (DictionaryItem (matches, fullmatch))\r\n              processed = processed + Left (processing, startpos - 1)\r\n              replacement = DictionaryItem (dict, ending)\r\n              if (expr) {\r\n                replacement = eval (replacement, matches)\r\n              }\r\n              processing = replacement + Mid (processing, endpos)\r\n              if (endpos = startpos or not repeat) {\r\n                processed = processed + processing\r\n                processing = \"\"\r\n                pattern = \".\"\r\n              }\r\n            }\r\n            if (continue) {\r\n              verb = processed\r\n            }\r\n            else {\r\n              return (processed)\r\n            }\r\n          }\r\n        }\r\n```\r\nAllowing the dictionary keys to be regular expressions, making for arbitrarily complex rules for how to conjugate a verb.",
      "EditableFormat": "markdown",
      "HTML": "<p>(Here's a further thought, which might make the same Conjugate function work well enough for all languages rather than having a different one in every language library:</p>\n<pre><code>        else if (StartsWith (ending, \"/\")) {\n          parts = Split (Mid (ending, 2), \"/\")\n          pattern = \"(?&lt;fullmatch&gt;\" + ListItem (parts, 0) + \")\"\n          if (ListCount (parts) &gt; 1) {\n            continue = (Instr (ListItem (parts, 1), \"+\") &gt; 0)\n            repeat = (Instr (ListItem (parts, 1), \"g\") &gt; 0)\n            expr = (Instr (ListItem (parts, 1), \"e\") &gt; 0)\n          }\n          else {\n            continue = false\n            repeat = false\n            expr = false\n          }\n          if (IsRegexMatch (pattern, verb)) {\n            processed = \"\"\n            processing = verb\n            while (IsRegexMatch (pattern, processing)) {\n              matches = Populate (pattern, processing)\n              startpos = Instr (processing, DictionaryItem (matches, fullmatch))\n              endpos = startpos + LengthOf (DictionaryItem (matches, fullmatch))\n              processed = processed + Left (processing, startpos - 1)\n              replacement = DictionaryItem (dict, ending)\n              if (expr) {\n                replacement = eval (replacement, matches)\n              }\n              processing = replacement + Mid (processing, endpos)\n              if (endpos = startpos or not repeat) {\n                processed = processed + processing\n                processing = \"\"\n                pattern = \".\"\n              }\n            }\n            if (continue) {\n              verb = processed\n            }\n            else {\n              return (processed)\n            }\n          }\n        }\n</code></pre>\n<p>Allowing the dictionary keys to be regular expressions, making for arbitrarily complex rules for how to conjugate a verb.</p>\n\n",
      "PostDate": "2018-09-26T10:16:53.3478602Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bb2abea9-bdf1-40ae-867e-9714848ac3ca",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have uploaded a revision to Github, so this will be fixed when Quest is next updated.",
      "EditableFormat": "markdown",
      "HTML": "<p>I have uploaded a revision to Github, so this will be fixed when Quest is next updated.</p>\n\n",
      "PostDate": "2018-09-26T13:51:27.4700305Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "bfae3cd9-6d39-4476-af24-1247c51afd77",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Looking again at the English template (trying to make it easier to make the player \"I\" or \"he\" just by changing the player object's gender; I note that if I replace all \"You\" in the templates with a WriteVerb call, the most common verbs it'll be conjugating are \"can\" and \"can't\", both of which need special cases in the dictionary.\r\n\r\nI'm looking at a little tweak to WriteVerb as well:\r\n```\r\n    <function name=\"WriteVerb\" type=\"string\" parameters=\"obj, verb\">\r\n        result = Conjugate(obj, verb)\r\n        if (not UCase (Left (result, 1)) = LCase (Left (result, 1))) {\r\n            result = \" \" + result\r\n        }\r\n        return (CapFirst(obj.gender) + result)\r\n    </function>\r\n    \r\n    <attr name=\"conjugations_i\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>am</value></item>\r\n  <item><key>'be</key><value>'m</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_you\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n  <item><key>'be</key><value>'re</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_we\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n  <item><key>'be</key><value>'re</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_they\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>are</value></item>\r\n  <item><key>'be</key><value>'re</value></item>\r\n</attr>\r\n\r\n<attr name=\"conjugations_it\" type=\"stringdictionary\">\r\n  <item><key>be</key><value>is</value></item>\r\n  <item><key>have</key><value>has</value></item>\r\n  <item><key>can</key><value>can</value></item>\r\n  <item><key>mould</key><value>moulds</value></item>\r\n  <item><key>*ould</key><value>ould</value></item>\r\n  <item><key>must</key><value>must</value></item>\r\n  <item><key>can't</key><value>can't</value></item>\r\n  <item><key>won't</key><value>won't</value></item>\r\n  <item><key>cannot</key><value>cannot</value></item>\r\n  <item><key>@n't</key><value>n't</value></item>\r\n  <item><key>'ve</key><value>'s</value></item>\r\n  <item><key>'be</key><value>'s</value></item>\r\n  <item><key>*ay</key><value>ays</value></item>\r\n  <item><key>*oy</key><value>oys</value></item>\r\n  <item><key>*ey</key><value>eys</value></item>\r\n  <item><key>*y</key><value>ies</value></item>\r\n  <item><key>*ss</key><value>sses</value></item>\r\n  <item><key>*s</key><value>sses</value></item>\r\n  <item><key>*sh</key><value>shes</value></item>\r\n  <item><key>*ch</key><value>ches</value></item>\r\n  <item><key>*o</key><value>oes</value></item>\r\n  <item><key>*x</key><value>xes</value></item>\r\n  <item><key>*z</key><value>zes</value></item>\r\n  <item><key>*</key><value>s</value></item>\r\n</attr>\r\n```\r\n\r\nThis way, you can use `WriteVerb (object, \"'ve\")` to get \"I've\", \"You've\", or \"He's\" correctly; and `WriteVerb (object, \"'be\")` with an apostrophe will give \"I'm\", \"You're\", or \"He's\". Added a few more exceptions (like can, must, could, would, and should, and an entry for `@n't` to handle hasn't, doesn't, and similar.)",
      "EditableFormat": "markdown",
      "HTML": "<p>Looking again at the English template (trying to make it easier to make the player \"I\" or \"he\" just by changing the player object's gender; I note that if I replace all \"You\" in the templates with a WriteVerb call, the most common verbs it'll be conjugating are \"can\" and \"can't\", both of which need special cases in the dictionary.</p>\n<p>I'm looking at a little tweak to WriteVerb as well:</p>\n<pre><code>    &lt;function name=\"WriteVerb\" type=\"string\" parameters=\"obj, verb\"&gt;\n        result = Conjugate(obj, verb)\n        if (not UCase (Left (result, 1)) = LCase (Left (result, 1))) {\n            result = \" \" + result\n        }\n        return (CapFirst(obj.gender) + result)\n    &lt;/function&gt;\n    \n    &lt;attr name=\"conjugations_i\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;am&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'be&lt;/key&gt;&lt;value&gt;'m&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_you\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'be&lt;/key&gt;&lt;value&gt;'re&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_we\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'be&lt;/key&gt;&lt;value&gt;'re&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_they\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;are&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'be&lt;/key&gt;&lt;value&gt;'re&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n\n&lt;attr name=\"conjugations_it\" type=\"stringdictionary\"&gt;\n  &lt;item&gt;&lt;key&gt;be&lt;/key&gt;&lt;value&gt;is&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;have&lt;/key&gt;&lt;value&gt;has&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;can&lt;/key&gt;&lt;value&gt;can&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;mould&lt;/key&gt;&lt;value&gt;moulds&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ould&lt;/key&gt;&lt;value&gt;ould&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;must&lt;/key&gt;&lt;value&gt;must&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;can't&lt;/key&gt;&lt;value&gt;can't&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;won't&lt;/key&gt;&lt;value&gt;won't&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;cannot&lt;/key&gt;&lt;value&gt;cannot&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;@n't&lt;/key&gt;&lt;value&gt;n't&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'ve&lt;/key&gt;&lt;value&gt;'s&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;'be&lt;/key&gt;&lt;value&gt;'s&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ay&lt;/key&gt;&lt;value&gt;ays&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*oy&lt;/key&gt;&lt;value&gt;oys&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ey&lt;/key&gt;&lt;value&gt;eys&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*y&lt;/key&gt;&lt;value&gt;ies&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ss&lt;/key&gt;&lt;value&gt;sses&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*s&lt;/key&gt;&lt;value&gt;sses&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*sh&lt;/key&gt;&lt;value&gt;shes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*ch&lt;/key&gt;&lt;value&gt;ches&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*o&lt;/key&gt;&lt;value&gt;oes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*x&lt;/key&gt;&lt;value&gt;xes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*z&lt;/key&gt;&lt;value&gt;zes&lt;/value&gt;&lt;/item&gt;\n  &lt;item&gt;&lt;key&gt;*&lt;/key&gt;&lt;value&gt;s&lt;/value&gt;&lt;/item&gt;\n&lt;/attr&gt;\n</code></pre>\n<p>This way, you can use <code>WriteVerb (object, \"'ve\")</code> to get \"I've\", \"You've\", or \"He's\" correctly; and <code>WriteVerb (object, \"'be\")</code> with an apostrophe will give \"I'm\", \"You're\", or \"He's\". Added a few more exceptions (like can, must, could, would, and should, and an entry for <code>@n't</code> to handle hasn't, doesn't, and similar.)</p>\n\n",
      "PostDate": "2018-10-17T10:12:40.0318028Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "81de0db0-6934-476a-bc94-a97d351463db",
      "UserId": 384785,
      "Username": "KiraSnowye",
      "AvatarUrl": "https://secure.gravatar.com/avatar/9f708125de261bcf6c6f79d0e84f5b58?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hello mrangel,\r\n\r\nWhere exactly should this code show up to display this? I mean, where do we put it? How?",
      "EditableFormat": "markdown",
      "HTML": "<p>Hello mrangel,</p>\n<p>Where exactly should this code show up to display this? I mean, where do we put it? How?</p>\n\n",
      "PostDate": "2018-11-08T03:13:11.1649932Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f1f503ab-b038-4fff-b57f-0483769664f2",
      "UserId": 199273,
      "Username": "DavyB",
      "AvatarUrl": "http://i.imgur.com/8BcaZCyb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This has come up a few times. In general, if you are happy to work at the underlying code level you can change any of the default responses. For DefaultSpeakTo my preference is:\r\n```\r\n<dynamictemplate name=\"DefaultSpeakTo\">\"You get no response.\"</dynamictemplate>\r\n```\r\nJust add this line with whatever wording you prefer to your code.",
      "EditableFormat": "markdown",
      "HTML": "<p>This has come up a few times. In general, if you are happy to work at the underlying code level you can change any of the default responses. For DefaultSpeakTo my preference is:</p>\n<pre><code>&lt;dynamictemplate name=\"DefaultSpeakTo\"&gt;\"You get no response.\"&lt;/dynamictemplate&gt;\n</code></pre>\n<p>Just add this line with whatever wording you prefer to your code.</p>\n\n",
      "PostDate": "2018-11-08T07:50:13.6557164Z",
      "LastEditDate": "2018-11-08T07:50:57.4064638Z",
      "link": null
    },
    {
      "PostId": "3b69fa31-fa0d-4db5-afae-2150306e53f9",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@KiraSnowye\r\nThe code in my last few posts is intended to replace the WriteVerb and Conjugate functions in the file `English.aslx`. I posted a couple of different versions of the dictionaries as I worked on it.\r\n\r\nI've uploaded <a href=\"http://mrangel.info/English_mods.aslx\">a library</a> including this code, which I hope you might be able to add to a game. This is basically my modifications to the English language pack, including both the verb fixes, and removing \"You\" from a lot of the messages so that you can make the game first person more easily.",
      "EditableFormat": "markdown",
      "HTML": "<p>@KiraSnowye<br>\nThe code in my last few posts is intended to replace the WriteVerb and Conjugate functions in the file <code>English.aslx</code>. I posted a couple of different versions of the dictionaries as I worked on it.</p>\n<p>I've uploaded <a href=\"http://mrangel.info/English_mods.aslx\">a library</a> including this code, which I hope you might be able to add to a game. This is basically my modifications to the English language pack, including both the verb fixes, and removing \"You\" from a lot of the messages so that you can make the game first person more easily.</p>\n\n",
      "PostDate": "2018-11-08T09:23:31.6984436Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4ec7905e-1dd7-4d7f-8de4-d38af7b6010d",
      "UserId": 384785,
      "Username": "KiraSnowye",
      "AvatarUrl": "https://secure.gravatar.com/avatar/9f708125de261bcf6c6f79d0e84f5b58?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@mrangel\r\nSo, this is only an addition to the ```English.aslx```, and not necessarily a change of that specific file, yes? Does this entirely fix the error of the \"Speak to\" command in which DisplayVerbs can sync with this specific type? Or, is this more of a change in how it's executed?",
      "EditableFormat": "markdown",
      "HTML": "<p>@mrangel<br>\nSo, this is only an addition to the <code>English.aslx</code>, and not necessarily a change of that specific file, yes? Does this entirely fix the error of the \"Speak to\" command in which DisplayVerbs can sync with this specific type? Or, is this more of a change in how it's executed?</p>\n\n",
      "PostDate": "2018-11-09T14:58:41.6794073Z",
      "LastEditDate": "2018-11-09T14:59:12.4641098Z",
      "link": null
    }
  ]
}
