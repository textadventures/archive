{
  "Topic": {
    "TopicId": "eb_d1mywremouqzi7oumza",
    "ForumId": "10",
    "Title": "Can you set up an alchemy system using the 'Show Menu' function?",
    "LastUpdated": "2020-05-15T16:17:24.3247699Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "e7678500-09e2-41bd-83ed-08824c86bd4b",
      "UserId": 233882,
      "Username": "lucidaxe",
      "AvatarUrl": "https://secure.gravatar.com/avatar/ad8a6ec8e410fc0c58b0efb85e20450e?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hi!\r\n\r\nI'm hoping to create a game with an 'alchemy' system that allows the player to create potions. This system would use the 'Show Menu' function to allow the player to pick the desired potion they want to create by using two ingredients.\r\n\r\nI envision it to work as follows. Once the player has gathered an ingredient, that ingredient is visible in their inventory with an 'alchemy' verb attached. Let's say the example name of an ingredient is Ingredient1.\r\nWhen clicking 'alchemy' or typing in 'alchemy [ingredient]', the game checks what combinations of X amount of Ingredient1 with X amount of Ingredient2 (or 3, or 4, ...) can create a specific potion. The game also checks how much of Ingredient1, and Ingredient2, 3, 4... the player currently has (does the player even have enough of that ingredient to make any potions?). (As a side note, I'm also open to suggestions as to how this process can be coded.) \r\nWhen the game has determined what types of potions, if any, the player can currently create using X amount of Ingredient1 (and X amount of other ingredients), it shows the player a menu. Example:\r\n\r\n---\r\nUsing Ingredient1, you can currently make the following potions:\r\n\r\n- 1 x Ingredient1 + 3 x Ingredient2:\r\nCLICKABLE BUTTON: Potion A\r\n\r\n- 3 x Ingredient1 + 2 x Ingredient3:\r\nCLICKABLE BUTTON: Potion B\r\n\r\n---\r\n\r\nOnly potions that can actually be made given the current amounts of ingredients the player has, are displayed as options. Then when the player clicks on 'Potion A', for example, the game shows another menu.\r\n\r\n---\r\nYou want to create Potion A. You can create at maximum [some calculated amount] of this item. Each item will take 1 x Ingredient1 + 3 x Ingredient2 to create.\r\nHow many would you like to create?\r\nINPUT FIELD: ...\r\n\r\n---\r\n\r\nHowever, it is very unclear to me how you are supposed to get the game to display the various button texts, especially if these texts have to be dynamically 'generated' from checks and calculations that the game performs. I'm also not entirely sure how I could get the game to take the player input from the first menu and let it serve as a starting point for setting up the second menu appearance. After which, the game has to remove the appropriate amount of ingredient items and add the appropriate amount of potion items to the player's inventory.\r\n\r\nCould someone explain, perhaps with an example of what the code would look like? Or do you have suggestions as to how I could arrange the system better? Please let me know.\r\n\r\nHope you all have a wonderful day!",
      "EditableFormat": "markdown",
      "HTML": "<p>Hi!</p>\n<p>I'm hoping to create a game with an 'alchemy' system that allows the player to create potions. This system would use the 'Show Menu' function to allow the player to pick the desired potion they want to create by using two ingredients.</p>\n<p>I envision it to work as follows. Once the player has gathered an ingredient, that ingredient is visible in their inventory with an 'alchemy' verb attached. Let's say the example name of an ingredient is Ingredient1.<br>\nWhen clicking 'alchemy' or typing in 'alchemy [ingredient]', the game checks what combinations of X amount of Ingredient1 with X amount of Ingredient2 (or 3, or 4, ...) can create a specific potion. The game also checks how much of Ingredient1, and Ingredient2, 3, 4... the player currently has (does the player even have enough of that ingredient to make any potions?). (As a side note, I'm also open to suggestions as to how this process can be coded.)<br>\nWhen the game has determined what types of potions, if any, the player can currently create using X amount of Ingredient1 (and X amount of other ingredients), it shows the player a menu. Example:</p>\n<hr>\n<p>Using Ingredient1, you can currently make the following potions:</p>\n<ul>\n<li>\n<p>1 x Ingredient1 + 3 x Ingredient2:<br>\nCLICKABLE BUTTON: Potion A</p>\n</li>\n<li>\n<p>3 x Ingredient1 + 2 x Ingredient3:<br>\nCLICKABLE BUTTON: Potion B</p>\n</li>\n</ul>\n<hr>\n<p>Only potions that can actually be made given the current amounts of ingredients the player has, are displayed as options. Then when the player clicks on 'Potion A', for example, the game shows another menu.</p>\n<hr>\n<p>You want to create Potion A. You can create at maximum [some calculated amount] of this item. Each item will take 1 x Ingredient1 + 3 x Ingredient2 to create.<br>\nHow many would you like to create?<br>\nINPUT FIELD: ...</p>\n<hr>\n<p>However, it is very unclear to me how you are supposed to get the game to display the various button texts, especially if these texts have to be dynamically 'generated' from checks and calculations that the game performs. I'm also not entirely sure how I could get the game to take the player input from the first menu and let it serve as a starting point for setting up the second menu appearance. After which, the game has to remove the appropriate amount of ingredient items and add the appropriate amount of potion items to the player's inventory.</p>\n<p>Could someone explain, perhaps with an example of what the code would look like? Or do you have suggestions as to how I could arrange the system better? Please let me know.</p>\n<p>Hope you all have a wonderful day!</p>\n\n",
      "PostDate": "2020-05-15T16:17:24.3247699Z",
      "LastEditDate": "2020-05-15T16:34:55.9159357Z",
      "link": null
    },
    {
      "PostId": "72c67ce2-a786-437b-80d3-b16fdd08e50c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I would say that's not going to be hard, but will be quite a lot of effort.\r\n\r\nThere are a few main ways to do something like that, with multiple menus. The first would be to put attributes on some object (usually the game, or maybe the alchemy command) to keep track of what objects the player was working with. The second would be to make the menu options contain all the details. By using a stringdictionary for the menu options, you can have the result containing as much detail as you need.\r\n\r\nThe third option is the one I'd use, but that doesn't use `ShowMenu`.\r\n\r\n<details><summary>Click for more if you're interested in how I'd do this</summary>\r\n\r\nYou can have a command that allows you to enter different versions of a command, with more details in.\r\n\r\nFor example, you could have an alchemy command that lets the player enter `alchemy object1`, or `alchemy object1 with object2`, or `alchemy 4 object1 with 2 object2`.\r\n\r\nIn the first two cases, the command would respond by giving the player a list of possible options, each of which includes a command link. So they type the first option, or use the verb menu on an object, and it tells them what they can combine it with. Each option includes a command link that would effectively type \"alchemy object1 with object2\", or \"alchemy object1 with object4\".\r\n\r\nThen when they click one of those (or type the command like that), it checks the numbers and prints out another list of options with the numbers in.\r\n\r\nClicking (or typing) the command with the number of items in signals that the player knows what they're doing, and actually does the alchemy.\r\n\r\nThis way, you don't need to track any state, because the command contains all the information you need.\r\n</details>\r\n\r\nIn any case, how you actually implement this would depend on how you're handling multiple items, and how you're choosing to store the recipes. It's likely to end up being quite a lot of code, but none of it particularly complex. It's just a case of breaking the process down into a lot of smaller steps.\r\n\r\nI'd show you a crafting system I quickly threw together last time someone asked about something similar; but that worked a little differently (commands were \"craft\" to get a list of known recipes, \"craft (objectname)\" to choose what to make, and \"craft (number) (object)\" to confirm)",
      "EditableFormat": "markdown",
      "HTML": "<p>I would say that's not going to be hard, but will be quite a lot of effort.</p>\n<p>There are a few main ways to do something like that, with multiple menus. The first would be to put attributes on some object (usually the game, or maybe the alchemy command) to keep track of what objects the player was working with. The second would be to make the menu options contain all the details. By using a stringdictionary for the menu options, you can have the result containing as much detail as you need.</p>\n<p>The third option is the one I'd use, but that doesn't use <code>ShowMenu</code>.</p>\n<details><summary>Click for more if you're interested in how I'd do this</summary>\n<p>You can have a command that allows you to enter different versions of a command, with more details in.</p>\n<p>For example, you could have an alchemy command that lets the player enter <code>alchemy object1</code>, or <code>alchemy object1 with object2</code>, or <code>alchemy 4 object1 with 2 object2</code>.</p>\n<p>In the first two cases, the command would respond by giving the player a list of possible options, each of which includes a command link. So they type the first option, or use the verb menu on an object, and it tells them what they can combine it with. Each option includes a command link that would effectively type \"alchemy object1 with object2\", or \"alchemy object1 with object4\".</p>\n<p>Then when they click one of those (or type the command like that), it checks the numbers and prints out another list of options with the numbers in.</p>\n<p>Clicking (or typing) the command with the number of items in signals that the player knows what they're doing, and actually does the alchemy.</p>\n<p>This way, you don't need to track any state, because the command contains all the information you need.</p>\n</details>\n<p>In any case, how you actually implement this would depend on how you're handling multiple items, and how you're choosing to store the recipes. It's likely to end up being quite a lot of code, but none of it particularly complex. It's just a case of breaking the process down into a lot of smaller steps.</p>\n<p>I'd show you a crafting system I quickly threw together last time someone asked about something similar; but that worked a little differently (commands were \"craft\" to get a list of known recipes, \"craft (objectname)\" to choose what to make, and \"craft (number) (object)\" to confirm)</p>\n\n",
      "PostDate": "2020-05-15T22:52:47.747063Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "44412860-ee1d-47f4-879c-2e7f63ab4d4b",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is a very good idea!",
      "EditableFormat": "markdown",
      "HTML": "<p>This is a very good idea!</p>\n\n",
      "PostDate": "2020-05-16T00:30:04.6431762Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "24f8929f-fadd-43f8-b10b-9b5a1e0fae5e",
      "UserId": 233882,
      "Username": "lucidaxe",
      "AvatarUrl": "https://secure.gravatar.com/avatar/ad8a6ec8e410fc0c58b0efb85e20450e?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thank you very much for the response! It's given me a few things to consider.\r\n\r\nI do want to keep the system as simple and efficient for the user as possible (i.e. for the type of game I have in mind, they don't need to go through the lists of recipes and then manually calculate and type out how to combine the ingredients by typing in 'alchemy 4 X with 5 Y'). But you've given me good ideas to fiddle around with! If I find that it might help, I may ask about that crafting system later.\r\n\r\nThanks again!",
      "EditableFormat": "markdown",
      "HTML": "<p>Thank you very much for the response! It's given me a few things to consider.</p>\n<p>I do want to keep the system as simple and efficient for the user as possible (i.e. for the type of game I have in mind, they don't need to go through the lists of recipes and then manually calculate and type out how to combine the ingredients by typing in 'alchemy 4 X with 5 Y'). But you've given me good ideas to fiddle around with! If I find that it might help, I may ask about that crafting system later.</p>\n<p>Thanks again!</p>\n\n",
      "PostDate": "2020-05-16T10:26:34.6801638Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ff639fb7-ad5b-45d8-9d78-a4b876ec8dd5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK… I should be able to come up with this pretty quickly.\r\n(Note: I'm assuming that alchemy can include any number of ingredients, not just 2. It's one of those weird situations where the code is actually simpler for \"any number\" than it is for a specific number)\r\n\r\nHere's an example. I'm assuming that\r\n\r\n* You have a room the player can't reach called RECIPES, which contains all the objects they can make. (These objects will be cloned into the player's inventory when created)\r\n* The craftable objects have a dictionary attribute `ingredients`, whose keys are object names and values are the number required\r\n* As you mentioned that the player can use more than one of an ingredient, I assumed that these are all clones of an original ingredient; created using `CloneObject` and related functions. (note that this won't work with the bare `clone` function)\r\n\r\nThe `alchemy` command has the pattern `alchemy #object#`, and the following script.\r\n```\r\nif (not ListContains (ScopeReachableInventory(), object)) {\r\n  msg (\"You haven't got \" + object.article + \".\")\r\n}\r\nelse if (not HasObject (object, \"prototype\")) {\r\n  msg (Capfirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\r\n}\r\nelse {\r\n  // first, check how many of the ingredient we have\r\n  ingredient = object.prototype\r\n  number = ListCount (FilterByAttribute (ScopeReachable(), \"prototype\", ingredient))\r\n  // then start making a list of recipes we can make using it\r\n  recipes = NewStringDictionary()\r\n  found_recipes = false\r\n  // I'm also making a list of missing ingredients, for a more informative message if the player can't make anything.\r\n  missing = NewObjectList()\r\n  foreach (recipe, GetDirectChildren(RECIPES)) {\r\n    if (TypeOf (recipe, \"ingredients\") = \"dictionary\") {\r\n      if (DictionaryContains (recipe.ingredients, ingredient.name)) {\r\n        // we've found a recipe that uses this object; do we have enough ingredients?\r\n        can_make = true\r\n        option_text = \"\"\r\n        foreach (other_ingredient, recipe.ingredients) {\r\n          if (DictionaryItem (recipe.ingredients, other_ingredient) > ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (other_ingredient)))) {\r\n            can_make = false\r\n            list add (missing, GetObject (other_ingredient))\r\n          }\r\n          else {\r\n            if (not option_text = \"\") {\r\n              option_text = option_text + \", \"\r\n            }\r\n            option_text = option_text + ToString (DictionaryItem (recipe.ingredients, other_ingredient)) + \"x \" + GetDisplayName (GetObject (other_ingredient))\r\n          }\r\n        }\r\n        if (can_make) {\r\n          dictionary add (recipes, recipe.name, option_text + \": \" + GetDisplayName (recipe))\r\n          found_recipes = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (found_recipes) {\r\n    // We now know which recipes can be made with this ingredient; so show the menu\r\n    ShowMenu (\"Using {object:\"+ingredient.name + \"}, you can currently make the following potions:\", recipes, true) {\r\n      // check what the player is trying to make, and store that for after we got the number\r\n      recipe = GetObject (result)\r\n      game.current_alchemy_recipe = recipe\r\n      // Then make the message to tell them how many they can make:\r\n      ingredients = NewStringList()\r\n      max_number = ListCount (ScopeReachableInventory())\r\n      foreach (ingredient_name, recipe.ingredients) {\r\n        number_needed = DictionaryItem (recipe.ingredients, ingredient_name)\r\n        number_got = ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name)))\r\n        if (max_number > number_got / number_needed) {\r\n          max_number = number_got / number_needed\r\n        }\r\n        list add (ingredients, ToString(number_needed) + \"x \" + GetDisplayAlias (GetObject (ingredient_name)))\r\n      }\r\n      msg (\"You want to create \" + GetDisplayAlias (recipe) + \". You can create at maximum \" + max_number + \" of this item. Each item will take \" Join (ingredients, \"+\") + \" to create.\")\r\n      msg (\"How many would you like to create?\")\r\n      get input {\r\n        recipe = game.current_alchemy_recipe\r\n        if (not IsInt (result)) {\r\n          msg (CapFirst (result) + \" is not a number.\")\r\n        }\r\n        else if (IsRegexMatch (\"^\\s*(-|0*\\s*$)\", result)) {\r\n          msg (\"You didn't enter a number greater than zero.\")\r\n        }\r\n        else {\r\n          number = ToInt (result)\r\n          // now, we can check again if the player has enough ingredients for the number they entered\r\n          ingredients_used = NewStringList()\r\n          failed = false\r\n          foreach (ingredient_name, recipe.ingredients) {\r\n            number_needed = DictionaryItem (recipe.ingredients, ingredient_name) * number\r\n            current_ingredients = FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name))\r\n            if (ListCount (current_ingredients) >= number_needed) {\r\n              foreach (i, 0, number_needed - 1) {\r\n                list add (ingredients_used, GetString (ListItem (current_ingredients, i), \"name\"))\r\n              }\r\n            }\r\n            else {\r\n              failed = true\r\n              msg (\"You don't have enough \" + GetDisplayAlias (GetObject (ingredient_name)) + \".\")\r\n            }\r\n          }\r\n          if (not failed) {\r\n            msg (\"You create \" + number + \"× \" + GetDisplayAlias (recipe))\r\n            for (i, 0, number - 1) {\r\n              CloneObjectAndMove (recipe, game.pov)\r\n            }\r\n            foreach (ingredient, ingredients_used) {\r\n              destroy (ingredient)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // The following line is an ugly hack to change which part of the menu options is the link. Don't be surprised if you can't follow the code:\r\n    JS.eval(\"$('#\" + game.menuoutputsection + \" a.cmdlink').each(function () {var l=$(this).css({display:'block',marginLeft:'3em'});l.text(l.text().replace(/^.+: /,function (t) {l.parent().prepend(t);return('');});});\")\r\n    if (ListCount (missing) > 0) {\r\n      msg (\"To unlock other recipes, try gathering more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\r\n    }\r\n  }\r\n  else if (ListCount (missing) > 0) {\r\n    msg (\"You can't make anything unless you gather more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\r\n  }\r\n  else {\r\n    msg (CapFirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\r\n  }\r\n}\r\n```\r\n\r\nIf you're doing this in the web editor, then you might need to add a list of ingredients in your start script. Like this:\r\n```\r\nPotion A.ingredients = NewDictionary()\r\ndictionary add (Potion A.ingredients, \"ingredient1\", 2)\r\ndictionary add (Potion A.ingredients, \"ingredient2\", 4)\r\n\r\nPotion B.ingredients = NewDictionary()\r\ndictionary add (Potion B.ingredients, \"ingredient1\", 3)\r\ndictionary add (Potion B.ingredients, \"ingredient4\", 1)\r\n\r\nPotion C.ingredients = NewDictionary()\r\ndictionary add (Potion C.ingredients, \"ingredient2\", 1)\r\ndictionary add (Potion C.ingredients, \"ingredient3\", 1)\r\ndictionary add (Potion C.ingredients, \"ingredient4\", 1)\r\n```\r\nand so on.\r\nOn the desktop editor, I think you can do this on the potion's \"Attributes\" tab; but I don't use Windows so don't have access to the desktop version of Quest.\r\nNote that this code uses object *names* rather than their aliases (just in case they're different)\r\n\r\nHope the code is all correct and typo-free. I just typed it straight out in the forum, so haven't tested it.",
      "EditableFormat": "markdown",
      "HTML": "<p>OK… I should be able to come up with this pretty quickly.<br>\n(Note: I'm assuming that alchemy can include any number of ingredients, not just 2. It's one of those weird situations where the code is actually simpler for \"any number\" than it is for a specific number)</p>\n<p>Here's an example. I'm assuming that</p>\n<ul>\n<li>You have a room the player can't reach called RECIPES, which contains all the objects they can make. (These objects will be cloned into the player's inventory when created)</li>\n<li>The craftable objects have a dictionary attribute <code>ingredients</code>, whose keys are object names and values are the number required</li>\n<li>As you mentioned that the player can use more than one of an ingredient, I assumed that these are all clones of an original ingredient; created using <code>CloneObject</code> and related functions. (note that this won't work with the bare <code>clone</code> function)</li>\n</ul>\n<p>The <code>alchemy</code> command has the pattern <code>alchemy #object#</code>, and the following script.</p>\n<pre><code>if (not ListContains (ScopeReachableInventory(), object)) {\n  msg (\"You haven't got \" + object.article + \".\")\n}\nelse if (not HasObject (object, \"prototype\")) {\n  msg (Capfirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\n}\nelse {\n  // first, check how many of the ingredient we have\n  ingredient = object.prototype\n  number = ListCount (FilterByAttribute (ScopeReachable(), \"prototype\", ingredient))\n  // then start making a list of recipes we can make using it\n  recipes = NewStringDictionary()\n  found_recipes = false\n  // I'm also making a list of missing ingredients, for a more informative message if the player can't make anything.\n  missing = NewObjectList()\n  foreach (recipe, GetDirectChildren(RECIPES)) {\n    if (TypeOf (recipe, \"ingredients\") = \"dictionary\") {\n      if (DictionaryContains (recipe.ingredients, ingredient.name)) {\n        // we've found a recipe that uses this object; do we have enough ingredients?\n        can_make = true\n        option_text = \"\"\n        foreach (other_ingredient, recipe.ingredients) {\n          if (DictionaryItem (recipe.ingredients, other_ingredient) &gt; ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (other_ingredient)))) {\n            can_make = false\n            list add (missing, GetObject (other_ingredient))\n          }\n          else {\n            if (not option_text = \"\") {\n              option_text = option_text + \", \"\n            }\n            option_text = option_text + ToString (DictionaryItem (recipe.ingredients, other_ingredient)) + \"x \" + GetDisplayName (GetObject (other_ingredient))\n          }\n        }\n        if (can_make) {\n          dictionary add (recipes, recipe.name, option_text + \": \" + GetDisplayName (recipe))\n          found_recipes = true\n        }\n      }\n    }\n  }\n  if (found_recipes) {\n    // We now know which recipes can be made with this ingredient; so show the menu\n    ShowMenu (\"Using {object:\"+ingredient.name + \"}, you can currently make the following potions:\", recipes, true) {\n      // check what the player is trying to make, and store that for after we got the number\n      recipe = GetObject (result)\n      game.current_alchemy_recipe = recipe\n      // Then make the message to tell them how many they can make:\n      ingredients = NewStringList()\n      max_number = ListCount (ScopeReachableInventory())\n      foreach (ingredient_name, recipe.ingredients) {\n        number_needed = DictionaryItem (recipe.ingredients, ingredient_name)\n        number_got = ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name)))\n        if (max_number &gt; number_got / number_needed) {\n          max_number = number_got / number_needed\n        }\n        list add (ingredients, ToString(number_needed) + \"x \" + GetDisplayAlias (GetObject (ingredient_name)))\n      }\n      msg (\"You want to create \" + GetDisplayAlias (recipe) + \". You can create at maximum \" + max_number + \" of this item. Each item will take \" Join (ingredients, \"+\") + \" to create.\")\n      msg (\"How many would you like to create?\")\n      get input {\n        recipe = game.current_alchemy_recipe\n        if (not IsInt (result)) {\n          msg (CapFirst (result) + \" is not a number.\")\n        }\n        else if (IsRegexMatch (\"^\\s*(-|0*\\s*$)\", result)) {\n          msg (\"You didn't enter a number greater than zero.\")\n        }\n        else {\n          number = ToInt (result)\n          // now, we can check again if the player has enough ingredients for the number they entered\n          ingredients_used = NewStringList()\n          failed = false\n          foreach (ingredient_name, recipe.ingredients) {\n            number_needed = DictionaryItem (recipe.ingredients, ingredient_name) * number\n            current_ingredients = FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name))\n            if (ListCount (current_ingredients) &gt;= number_needed) {\n              foreach (i, 0, number_needed - 1) {\n                list add (ingredients_used, GetString (ListItem (current_ingredients, i), \"name\"))\n              }\n            }\n            else {\n              failed = true\n              msg (\"You don't have enough \" + GetDisplayAlias (GetObject (ingredient_name)) + \".\")\n            }\n          }\n          if (not failed) {\n            msg (\"You create \" + number + \"× \" + GetDisplayAlias (recipe))\n            for (i, 0, number - 1) {\n              CloneObjectAndMove (recipe, game.pov)\n            }\n            foreach (ingredient, ingredients_used) {\n              destroy (ingredient)\n            }\n          }\n        }\n      }\n    }\n    // The following line is an ugly hack to change which part of the menu options is the link. Don't be surprised if you can't follow the code:\n    JS.eval(\"$('#\" + game.menuoutputsection + \" a.cmdlink').each(function () {var l=$(this).css({display:'block',marginLeft:'3em'});l.text(l.text().replace(/^.+: /,function (t) {l.parent().prepend(t);return('');});});\")\n    if (ListCount (missing) &gt; 0) {\n      msg (\"To unlock other recipes, try gathering more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\n    }\n  }\n  else if (ListCount (missing) &gt; 0) {\n    msg (\"You can't make anything unless you gather more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\n  }\n  else {\n    msg (CapFirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\n  }\n}\n</code></pre>\n<p>If you're doing this in the web editor, then you might need to add a list of ingredients in your start script. Like this:</p>\n<pre><code>Potion A.ingredients = NewDictionary()\ndictionary add (Potion A.ingredients, \"ingredient1\", 2)\ndictionary add (Potion A.ingredients, \"ingredient2\", 4)\n\nPotion B.ingredients = NewDictionary()\ndictionary add (Potion B.ingredients, \"ingredient1\", 3)\ndictionary add (Potion B.ingredients, \"ingredient4\", 1)\n\nPotion C.ingredients = NewDictionary()\ndictionary add (Potion C.ingredients, \"ingredient2\", 1)\ndictionary add (Potion C.ingredients, \"ingredient3\", 1)\ndictionary add (Potion C.ingredients, \"ingredient4\", 1)\n</code></pre>\n<p>and so on.<br>\nOn the desktop editor, I think you can do this on the potion's \"Attributes\" tab; but I don't use Windows so don't have access to the desktop version of Quest.<br>\nNote that this code uses object <em>names</em> rather than their aliases (just in case they're different)</p>\n<p>Hope the code is all correct and typo-free. I just typed it straight out in the forum, so haven't tested it.</p>\n\n",
      "PostDate": "2020-05-16T11:26:18.0522641Z",
      "LastEditDate": "2020-05-16T12:39:46.7105527Z",
      "link": null
    },
    {
      "PostId": "9c42fca2-2f44-42fc-8233-1ca7aaa434be",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "(that's code for the ShowMenu option in the original question)\r\n\r\nMenus are good to make things easier for the player. But I often find that it's frustrating if I've played a game a lot, and I have to go through multiple menus to choose something when I already know what I want. That's why I like command links: It can look like a menu with options to click, but if I want I can remember the command that each option enters.\r\n\r\nActually, thinking about it now, I'd probably go with 3 separate commands: `alchemy ingredient1`, `alchemy make Potion A`, and `alchemy make 4x Potion A`. That makes it simpler to handle stuff like scope; as well as making the commands more natural.\r\n\r\nIf you're using a stacking system to handle multiple objects in your inventory, the code would probably need modifying to work with that.",
      "EditableFormat": "markdown",
      "HTML": "<p>(that's code for the ShowMenu option in the original question)</p>\n<p>Menus are good to make things easier for the player. But I often find that it's frustrating if I've played a game a lot, and I have to go through multiple menus to choose something when I already know what I want. That's why I like command links: It can look like a menu with options to click, but if I want I can remember the command that each option enters.</p>\n<p>Actually, thinking about it now, I'd probably go with 3 separate commands: <code>alchemy ingredient1</code>, <code>alchemy make Potion A</code>, and <code>alchemy make 4x Potion A</code>. That makes it simpler to handle stuff like scope; as well as making the commands more natural.</p>\n<p>If you're using a stacking system to handle multiple objects in your inventory, the code would probably need modifying to work with that.</p>\n\n",
      "PostDate": "2020-05-16T12:09:30.7033027Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1920870d-4252-446a-8656-58cae5568a37",
      "UserId": 233882,
      "Username": "lucidaxe",
      "AvatarUrl": "https://secure.gravatar.com/avatar/ad8a6ec8e410fc0c58b0efb85e20450e?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Wow! That's a lot of information for me to take in ^ ^; \r\n\r\nI haven't really played around with dictionary attributes, keys and values and how to call them. And my knowledge of the elements and logic of the code is  limited to the point where I'll have to reread everything beside the 'ugly hack' as well :P But that looks pretty comprehensive in terms of functionality. Although a stacking system will probably be needed... It's meant to be a game where you can collect a ton of items, so I'm guessing that will be essential to keep things organized.\r\n\r\nIt would be kinda cool if you could innately tell Quest to treat any clones that will be created from a specific template object as either 'individual' objects or 'stackable' objects (using like a checkbox or dropdown menu on the template object in the editor). Then, when the player carries around multiple copies of an object that were marked as stackable, the _inventory interface_ automatically shows these objects to the player as a stack of one type of object. Even though, you could then still use code like the one you presented, since only the _display_ of the objects to the player is affected, while the actual objects are still sitting individually in the player inventory. But I don't know if this is something that would be easy to do (I imagine it's not) or if that is planned for an update.\r\n\r\nAs a sidenote, I was wondering if it would be possible to go super-multipurpose with the verb and use it in four distinct ways.\r\n\r\n- “alchemy” by itself: Give me general information. Responses: \r\nA) You do not have any ingredients.\r\nB) Displays a list of all possible potions to create from the ingredients the player currently has, noting when they do not have enough of the ingredients for a specific potion. If the player does not have any of the ingredients for a particular potion, that potion is not listed.\r\n\r\n- “alchemy [ingredient]”: Create something from ingredient. Responses: \r\nA) You do not have this ingredient in your inventory. \r\nB) You currently do not have enough of what is required to combine this ingredient with another into a potion. Displays creatable potions and amounts of ingredients missing for each potion. \r\nC) Using [ingredient], you can currently make the following potions: clickable potions with recipes stated, leading to telling the player how many they can make of said potion and asking for an integer input for the amount they want created.\r\n\r\n- “alchemy [potion]”: Create this specific potion if possible, amount yet to be specified. Responses:\r\nA) You do not have enough of the required ingredients to make a [potion]. \r\nB) You can make # [potion] (s), using # [ingredient] + # [ingredient] for each potion. How many would you like to make? Request integer as player input.\r\n\r\n- “alchemy [amount] [potion]”: Create the already specified amount of this specific potion. Responses:\r\nA) You do not have enough of the required ingredients to make any [potion]. (Can’t make even one of said potion.)\r\nB) You do not have enough of the required ingredients to make [amount] [potion] (s). You can, however, make # [potion] (s), using # [ingredient] + # [ingredient] for each potion. How many would you like to make? Request integer as player input.\r\nC) Take away the ingredients and add the amount of potions, display a message as confirmation.\r\n\r\nBut... yeah, I would have to take any stacking system into account first, anyway. I'll need to think about this more.\r\n\r\nI use the desktop version. :)",
      "EditableFormat": "markdown",
      "HTML": "<p>Wow! That's a lot of information for me to take in ^ ^;</p>\n<p>I haven't really played around with dictionary attributes, keys and values and how to call them. And my knowledge of the elements and logic of the code is  limited to the point where I'll have to reread everything beside the 'ugly hack' as well :P But that looks pretty comprehensive in terms of functionality. Although a stacking system will probably be needed... It's meant to be a game where you can collect a ton of items, so I'm guessing that will be essential to keep things organized.</p>\n<p>It would be kinda cool if you could innately tell Quest to treat any clones that will be created from a specific template object as either 'individual' objects or 'stackable' objects (using like a checkbox or dropdown menu on the template object in the editor). Then, when the player carries around multiple copies of an object that were marked as stackable, the <em>inventory interface</em> automatically shows these objects to the player as a stack of one type of object. Even though, you could then still use code like the one you presented, since only the <em>display</em> of the objects to the player is affected, while the actual objects are still sitting individually in the player inventory. But I don't know if this is something that would be easy to do (I imagine it's not) or if that is planned for an update.</p>\n<p>As a sidenote, I was wondering if it would be possible to go super-multipurpose with the verb and use it in four distinct ways.</p>\n<ul>\n<li>\n<p>“alchemy” by itself: Give me general information. Responses:<br>\nA) You do not have any ingredients.<br>\nB) Displays a list of all possible potions to create from the ingredients the player currently has, noting when they do not have enough of the ingredients for a specific potion. If the player does not have any of the ingredients for a particular potion, that potion is not listed.</p>\n</li>\n<li>\n<p>“alchemy [ingredient]”: Create something from ingredient. Responses:<br>\nA) You do not have this ingredient in your inventory.<br>\nB) You currently do not have enough of what is required to combine this ingredient with another into a potion. Displays creatable potions and amounts of ingredients missing for each potion.<br>\nC) Using [ingredient], you can currently make the following potions: clickable potions with recipes stated, leading to telling the player how many they can make of said potion and asking for an integer input for the amount they want created.</p>\n</li>\n<li>\n<p>“alchemy [potion]”: Create this specific potion if possible, amount yet to be specified. Responses:<br>\nA) You do not have enough of the required ingredients to make a [potion].<br>\nB) You can make # [potion] (s), using # [ingredient] + # [ingredient] for each potion. How many would you like to make? Request integer as player input.</p>\n</li>\n<li>\n<p>“alchemy [amount] [potion]”: Create the already specified amount of this specific potion. Responses:<br>\nA) You do not have enough of the required ingredients to make any [potion]. (Can’t make even one of said potion.)<br>\nB) You do not have enough of the required ingredients to make [amount] [potion] (s). You can, however, make # [potion] (s), using # [ingredient] + # [ingredient] for each potion. How many would you like to make? Request integer as player input.<br>\nC) Take away the ingredients and add the amount of potions, display a message as confirmation.</p>\n</li>\n</ul>\n<p>But... yeah, I would have to take any stacking system into account first, anyway. I'll need to think about this more.</p>\n<p>I use the desktop version. :)</p>\n\n",
      "PostDate": "2020-05-16T14:46:25.6731565Z",
      "LastEditDate": "2020-05-16T15:20:28.6391874Z",
      "link": null
    },
    {
      "PostId": "0b396bcd-d347-404d-a3a6-c400adc4efc7",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Here's a first guess at the \"multiple commands\" version.\r\n\r\nFirst command. Its scope should be `inventory`, and its pattern is `alchemy #object#`.\r\n```\r\nif (not ListContains (ScopeReachableInventory(), object)) {\r\n  msg (\"You haven't got \" + object.article + \".\")\r\n}\r\nelse if (not HasObject (object, \"prototype\")) {\r\n  msg (Capfirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\r\n}\r\nelse {\r\n  // first, check how many of the ingredient we have\r\n  ingredient = object.prototype\r\n  number = ListCount (FilterByAttribute (ScopeReachable(), \"prototype\", ingredient))\r\n  // then start making a list of recipes we can make using it\r\n  recipes = NewStringList()\r\n  // I'm also making a list of missing ingredients, for a more informative message if the player can't make anything.\r\n  missing = NewObjectList()\r\n  foreach (recipe, GetDirectChildren(RECIPES)) {\r\n    if (TypeOf (recipe, \"ingredients\") = \"dictionary\") {\r\n      if (DictionaryContains (recipe.ingredients, ingredient.name)) {\r\n        // we've found a recipe that uses this object; do we have enough ingredients?\r\n        can_make = true\r\n        option_text = \"\"\r\n        foreach (other_ingredient, recipe.ingredients) {\r\n          if (DictionaryItem (recipe.ingredients, other_ingredient) > ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (other_ingredient)))) {\r\n            can_make = false\r\n            list add (missing, GetObject (other_ingredient))\r\n          }\r\n          else {\r\n            if (not option_text = \"\") {\r\n              option_text = option_text + \", \"\r\n            }\r\n            option_text = option_text + ToString (DictionaryItem (recipe.ingredients, other_ingredient)) + \"x \" + GetDisplayName (GetObject (other_ingredient))\r\n          }\r\n        }\r\n        if (can_make) {\r\n          list add (recipes, option_text + \": {command:alchemy make \" + GetDisplayAlias(recipe) + \":\" + GetDisplayAlias(recipe) + \"}\")\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (ListCount (recipes) > 0) {\r\n    // We now know which recipes can be made with this ingredient; so show the menu\r\n    msg (\"Using \" + GetDisplayAlias (ingredient) + \", you can currently make the following potions:\")\r\n    msg (\"<ul><li>\" + Join (recipes, \"</li><li>\") + \"</li></ul>\")\r\n    if (ListCount (missing) > 0) {\r\n      msg (\"To unlock other recipes, try gathering more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\r\n    }\r\n  }\r\n  else if (ListCount (missing) > 0) {\r\n    msg (\"You can't make anything unless you gather more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\r\n  }\r\n  else {\r\n    msg (CapFirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\r\n  }\r\n}\r\n```\r\n\r\nSecond command. Its scope should be `RECIPES`, and its pattern is `alchemy make #object#`.\r\n```\r\nif (not object.parent = RECIPES) {\r\n  msg (\"That isn't a potion you can make.\")\r\n}\r\nelse {\r\n  // Make the message to tell them how many they can make:\r\n  max_number = ListCount (ScopeReachableInventory())\r\n  foreach (ingredient_name, object.ingredients) {\r\n    number_needed = DictionaryItem (object.ingredients, ingredient_name)\r\n    number_got = ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name)))\r\n    if (number_needed > number_got) {\r\n      msg (\"You don't have enough {object:\" + ingredient_name + \"} to make this.\")\r\n    }\r\n    if (max_number > number_got / number_needed) {\r\n      max_number = number_got / number_needed\r\n    }\r\n  }\r\n  if (max_number > 0) {\r\n    msg (\"You want to create \" + GetDisplayAlias (object) + \". You can create at maximum \" + max_number + \" of this item.\")\r\n    msg (\"How many would you like to create?\")\r\n    menu = \"<ul>\"\r\n    for (i, 1, max_number) {\r\n      menu = menu + \"<li>{command:alchemy make \"+ToString(i) + \" \" + GetDisplayAlias (object) +\":\" + ToWords (i) + \"} using \"\r\n      foreach (ingredient, object.ingredients) {\r\n        menu = menu + ToString (i * DictionaryItem (object.ingredients, ingredient)) + \"x \" + GetDisplayName (GetObject (ingredient)) + \" + \"\r\n      }\r\n      menu = Left (menu, LengthOf (menu) - 3) + \"</li>\"\r\n    }\r\n    msg (menu + \"</ul>\")\r\n  }\r\n}\r\n```\r\n\r\nAnd the third command. Its scope should be `RECIPES`, and its pattern this time is a regular expression so it's easier to check the number: `^alchemy make (?<text_number>\\d+) ?x? (?<object>.+)$`.\r\n```\r\nif (not object.parent = RECIPES) {\r\n  msg (\"That isn't a potion you can make.\")\r\n}\r\nelse {\r\n  // Check if we have enough ingredients\r\n  ingredients_used = NewStringList()\r\n  failed = false\r\n  foreach (ingredient_name, object.ingredients) {\r\n    number_needed = DictionaryItem (object.ingredients, ingredient_name)\r\n    got = FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name))\r\n    if (ListCount (got) = 0) {\r\n      msg (\"You don't have any {object:\" + ingredient_name + \"}.\")\r\n      failed = true\r\n    }\r\n    else if (number > ListCount (got) / number_needed) {\r\n      msg (\"You only have enough {object:\" + ingredient_name + \"} to make \" + ToString (ListCount (got) / number_needed) + \".\")\r\n      failed = true\r\n    }\r\n    else {\r\n      for (i, 1, number_needed * number) {\r\n        list add (ingredients_used, GetString (ListItem (got, i - 1), \"name\"))\r\n      }\r\n    }\r\n  }\r\n  if (not failed) {\r\n    msg (\"You create \" + number + \"× \" + GetDisplayAlias (object))\r\n    for (i, 0, number - 1) {\r\n      CloneObjectAndMove (object, game.pov)\r\n    }\r\n    foreach (ingredient, ingredients_used) {\r\n      destroy (ingredient)\r\n    }\r\n  }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Here's a first guess at the \"multiple commands\" version.</p>\n<p>First command. Its scope should be <code>inventory</code>, and its pattern is <code>alchemy #object#</code>.</p>\n<pre><code>if (not ListContains (ScopeReachableInventory(), object)) {\n  msg (\"You haven't got \" + object.article + \".\")\n}\nelse if (not HasObject (object, \"prototype\")) {\n  msg (Capfirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\n}\nelse {\n  // first, check how many of the ingredient we have\n  ingredient = object.prototype\n  number = ListCount (FilterByAttribute (ScopeReachable(), \"prototype\", ingredient))\n  // then start making a list of recipes we can make using it\n  recipes = NewStringList()\n  // I'm also making a list of missing ingredients, for a more informative message if the player can't make anything.\n  missing = NewObjectList()\n  foreach (recipe, GetDirectChildren(RECIPES)) {\n    if (TypeOf (recipe, \"ingredients\") = \"dictionary\") {\n      if (DictionaryContains (recipe.ingredients, ingredient.name)) {\n        // we've found a recipe that uses this object; do we have enough ingredients?\n        can_make = true\n        option_text = \"\"\n        foreach (other_ingredient, recipe.ingredients) {\n          if (DictionaryItem (recipe.ingredients, other_ingredient) &gt; ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (other_ingredient)))) {\n            can_make = false\n            list add (missing, GetObject (other_ingredient))\n          }\n          else {\n            if (not option_text = \"\") {\n              option_text = option_text + \", \"\n            }\n            option_text = option_text + ToString (DictionaryItem (recipe.ingredients, other_ingredient)) + \"x \" + GetDisplayName (GetObject (other_ingredient))\n          }\n        }\n        if (can_make) {\n          list add (recipes, option_text + \": {command:alchemy make \" + GetDisplayAlias(recipe) + \":\" + GetDisplayAlias(recipe) + \"}\")\n        }\n      }\n    }\n  }\n  if (ListCount (recipes) &gt; 0) {\n    // We now know which recipes can be made with this ingredient; so show the menu\n    msg (\"Using \" + GetDisplayAlias (ingredient) + \", you can currently make the following potions:\")\n    msg (\"&lt;ul&gt;&lt;li&gt;\" + Join (recipes, \"&lt;/li&gt;&lt;li&gt;\") + \"&lt;/li&gt;&lt;/ul&gt;\")\n    if (ListCount (missing) &gt; 0) {\n      msg (\"To unlock other recipes, try gathering more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\n    }\n  }\n  else if (ListCount (missing) &gt; 0) {\n    msg (\"You can't make anything unless you gather more \" + FormatList (ListCompact (missing), \", \", \", or\", \"\") + \".\")\n  }\n  else {\n    msg (CapFirst (GetDisplayAlias (object)) + \" is not an alchemy ingredient.\")\n  }\n}\n</code></pre>\n<p>Second command. Its scope should be <code>RECIPES</code>, and its pattern is <code>alchemy make #object#</code>.</p>\n<pre><code>if (not object.parent = RECIPES) {\n  msg (\"That isn't a potion you can make.\")\n}\nelse {\n  // Make the message to tell them how many they can make:\n  max_number = ListCount (ScopeReachableInventory())\n  foreach (ingredient_name, object.ingredients) {\n    number_needed = DictionaryItem (object.ingredients, ingredient_name)\n    number_got = ListCount (FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name)))\n    if (number_needed &gt; number_got) {\n      msg (\"You don't have enough {object:\" + ingredient_name + \"} to make this.\")\n    }\n    if (max_number &gt; number_got / number_needed) {\n      max_number = number_got / number_needed\n    }\n  }\n  if (max_number &gt; 0) {\n    msg (\"You want to create \" + GetDisplayAlias (object) + \". You can create at maximum \" + max_number + \" of this item.\")\n    msg (\"How many would you like to create?\")\n    menu = \"&lt;ul&gt;\"\n    for (i, 1, max_number) {\n      menu = menu + \"&lt;li&gt;{command:alchemy make \"+ToString(i) + \" \" + GetDisplayAlias (object) +\":\" + ToWords (i) + \"} using \"\n      foreach (ingredient, object.ingredients) {\n        menu = menu + ToString (i * DictionaryItem (object.ingredients, ingredient)) + \"x \" + GetDisplayName (GetObject (ingredient)) + \" + \"\n      }\n      menu = Left (menu, LengthOf (menu) - 3) + \"&lt;/li&gt;\"\n    }\n    msg (menu + \"&lt;/ul&gt;\")\n  }\n}\n</code></pre>\n<p>And the third command. Its scope should be <code>RECIPES</code>, and its pattern this time is a regular expression so it's easier to check the number: <code>^alchemy make (?&lt;text_number&gt;\\d+) ?x? (?&lt;object&gt;.+)$</code>.</p>\n<pre><code>if (not object.parent = RECIPES) {\n  msg (\"That isn't a potion you can make.\")\n}\nelse {\n  // Check if we have enough ingredients\n  ingredients_used = NewStringList()\n  failed = false\n  foreach (ingredient_name, object.ingredients) {\n    number_needed = DictionaryItem (object.ingredients, ingredient_name)\n    got = FilterByAttribute (ScopeReachableInventory(), \"prototype\", GetObject (ingredient_name))\n    if (ListCount (got) = 0) {\n      msg (\"You don't have any {object:\" + ingredient_name + \"}.\")\n      failed = true\n    }\n    else if (number &gt; ListCount (got) / number_needed) {\n      msg (\"You only have enough {object:\" + ingredient_name + \"} to make \" + ToString (ListCount (got) / number_needed) + \".\")\n      failed = true\n    }\n    else {\n      for (i, 1, number_needed * number) {\n        list add (ingredients_used, GetString (ListItem (got, i - 1), \"name\"))\n      }\n    }\n  }\n  if (not failed) {\n    msg (\"You create \" + number + \"× \" + GetDisplayAlias (object))\n    for (i, 0, number - 1) {\n      CloneObjectAndMove (object, game.pov)\n    }\n    foreach (ingredient, ingredients_used) {\n      destroy (ingredient)\n    }\n  }\n}\n</code></pre>\n\n",
      "PostDate": "2020-05-16T15:27:50.6378599Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "63e5f699-1790-4e26-bc78-2c2500011b7c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Guess we were typing at the same time again :)\r\n\r\n> It would be kinda cool if you could innately tell Quest to treat any clones that will be created from a specific template object as either 'individual' objects or 'stackable' objects (using like a checkbox or dropdown menu on the template object in the editor). Then, when the player carries around multiple copies of an object that were marked as stackable, the inventory interface automatically shows these objects to the player as a stack of one type of object. Even though, you could then still use code like the one you presented, since only the display of the objects to the player is affected, while the actual objects are still sitting individually in the player inventory. But I don't know if this is something that would be easy to do (I imagine it's not) or if that is planned for an update.\r\n\r\nIt would be pretty neat.\r\n\r\nThere are various ways people have approached this with their own scripts. My favourite is a script that automatically renames stackable objects when one of them is moved. so if you have four rocks in a room, they are placed inside each other and their aliases are changed to \"rock\", \"two rocks\", \"three rocks\", and \"four rocks\"; and the first 3 are marked as \"scenery\" so they don't show up in the objects pane. Then the player sees a single item named \"four rocks\", but if they type \"drop two rocks\" it will do the right thing.\r\n\r\nMaking this work with the crafting commands I just posted would be a little more complex; but I don't think it would be too hard.\r\n\r\n> As a sidenote, I was wondering if it would be possible to go super-multipurpose with the verb and use it in four distinct ways.\r\n\r\nThat's pretty much what I thought of to start with. I didn't include \"alchemy\" on its own in the code above, because you didn't originally ask for it; but that's what I would have written.",
      "EditableFormat": "markdown",
      "HTML": "<p>Guess we were typing at the same time again :)</p>\n<blockquote>\n<p>It would be kinda cool if you could innately tell Quest to treat any clones that will be created from a specific template object as either 'individual' objects or 'stackable' objects (using like a checkbox or dropdown menu on the template object in the editor). Then, when the player carries around multiple copies of an object that were marked as stackable, the inventory interface automatically shows these objects to the player as a stack of one type of object. Even though, you could then still use code like the one you presented, since only the display of the objects to the player is affected, while the actual objects are still sitting individually in the player inventory. But I don't know if this is something that would be easy to do (I imagine it's not) or if that is planned for an update.</p>\n</blockquote>\n<p>It would be pretty neat.</p>\n<p>There are various ways people have approached this with their own scripts. My favourite is a script that automatically renames stackable objects when one of them is moved. so if you have four rocks in a room, they are placed inside each other and their aliases are changed to \"rock\", \"two rocks\", \"three rocks\", and \"four rocks\"; and the first 3 are marked as \"scenery\" so they don't show up in the objects pane. Then the player sees a single item named \"four rocks\", but if they type \"drop two rocks\" it will do the right thing.</p>\n<p>Making this work with the crafting commands I just posted would be a little more complex; but I don't think it would be too hard.</p>\n<blockquote>\n<p>As a sidenote, I was wondering if it would be possible to go super-multipurpose with the verb and use it in four distinct ways.</p>\n</blockquote>\n<p>That's pretty much what I thought of to start with. I didn't include \"alchemy\" on its own in the code above, because you didn't originally ask for it; but that's what I would have written.</p>\n\n",
      "PostDate": "2020-05-16T15:39:01.0249067Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "898cacd4-fa37-4931-8188-ff9fdf16e80d",
      "UserId": 233882,
      "Username": "lucidaxe",
      "AvatarUrl": "https://secure.gravatar.com/avatar/ad8a6ec8e410fc0c58b0efb85e20450e?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Wow, that's pretty elaborate! Thank you very much for the examples!\r\n\r\nSorry if it's a dumb question, but what are the essential **differences** between the first iteration of ```alchemy #object#``` you gave as opposed to the second one?\r\n\r\nOne other question...\r\n\r\n> There are various ways people have approached this with their own scripts. My favourite is a script that automatically renames stackable objects when one of them is moved. so if you have four rocks in a room, they are placed inside each other and their aliases are changed to \"rock\", \"two rocks\", \"three rocks\", and \"four rocks\"; and the first 3 are marked as \"scenery\" so they don't show up in the objects pane. Then the player sees a single item named \"four rocks\", but if they type \"drop two rocks\" it will do the right thing.\r\n\r\nDo you have a link to a thread or some other documentation where I can take a look at this stackable objects renaming script?\r\n\r\nI greatly appreciate all of your help!",
      "EditableFormat": "markdown",
      "HTML": "<p>Wow, that's pretty elaborate! Thank you very much for the examples!</p>\n<p>Sorry if it's a dumb question, but what are the essential <strong>differences</strong> between the first iteration of <code>alchemy #object#</code> you gave as opposed to the second one?</p>\n<p>One other question...</p>\n<blockquote>\n<p>There are various ways people have approached this with their own scripts. My favourite is a script that automatically renames stackable objects when one of them is moved. so if you have four rocks in a room, they are placed inside each other and their aliases are changed to \"rock\", \"two rocks\", \"three rocks\", and \"four rocks\"; and the first 3 are marked as \"scenery\" so they don't show up in the objects pane. Then the player sees a single item named \"four rocks\", but if they type \"drop two rocks\" it will do the right thing.</p>\n</blockquote>\n<p>Do you have a link to a thread or some other documentation where I can take a look at this stackable objects renaming script?</p>\n<p>I greatly appreciate all of your help!</p>\n\n",
      "PostDate": "2020-05-16T16:06:02.1892364Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9d3167db-24f3-4fed-affe-839f05db8838",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "The two versions of the script are pretty similar. Main difference is that in the second version, instead of showing a menu and doing something with the response, it generates a \"menu\" which is really just printing out a list of other commands that the player can click on to run them. This means that if 'echo commands' is turned on, the player sees the intermediate commands like \"alchemy make Potion A\", and \"alchemy make 3x Potion A\" - so if they want to, the player can decide to just type that command the next time and skip the menu.\r\n\r\nI'm not so good at explaining this stuff. I'm on my phone right now; but I'll test those scripts out later to make sure I haven't made any mistakes.\r\n\r\n> Do you have a link to a thread or some other documentation where I can take a look at this stackable objects renaming script?\r\n\r\nI can't find the link in a cursory search. Unfortunately, it's not so easy to find older posts here.\r\n\r\nI can probably recreate most of the code off the top of my head.  It's relatively intuitive, even though it needs to deal with quite a few edge cases (handling the naming works out nearly as complex as moving the clones around).",
      "EditableFormat": "markdown",
      "HTML": "<p>The two versions of the script are pretty similar. Main difference is that in the second version, instead of showing a menu and doing something with the response, it generates a \"menu\" which is really just printing out a list of other commands that the player can click on to run them. This means that if 'echo commands' is turned on, the player sees the intermediate commands like \"alchemy make Potion A\", and \"alchemy make 3x Potion A\" - so if they want to, the player can decide to just type that command the next time and skip the menu.</p>\n<p>I'm not so good at explaining this stuff. I'm on my phone right now; but I'll test those scripts out later to make sure I haven't made any mistakes.</p>\n<blockquote>\n<p>Do you have a link to a thread or some other documentation where I can take a look at this stackable objects renaming script?</p>\n</blockquote>\n<p>I can't find the link in a cursory search. Unfortunately, it's not so easy to find older posts here.</p>\n<p>I can probably recreate most of the code off the top of my head.  It's relatively intuitive, even though it needs to deal with quite a few edge cases (handling the naming works out nearly as complex as moving the clones around).</p>\n\n",
      "PostDate": "2020-05-16T17:12:51.0581654Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
