{
  "Topic": {
    "TopicId": "bizjocqayuyyl71vqhphyw",
    "ForumId": "15",
    "Title": "More dev tips: combinable items",
    "LastUpdated": "2021-06-14T06:41:12.409716Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "acae60d8-c7a4-4a64-b71f-49d9001828cd",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I am still on my \"survival horror\" experiment. Today I present to you how to make items that can combine with other items.\r\nCombinable objects are not components, in that they are not parts of a whole, but rather two wholes that can interact with each other\r\n\r\n**Step 1 - Prepare a template**\r\nN.B.: This template uses COUNTABLE as base, but it can work with a simple TAKEABLE as well.\r\n```\r\nconst INVENTORY_ITEM = function(countableLocs) {\r\n  const res = $.extend({}, COUNTABLE(countableLocs))\r\n\r\n  res.combination = false;\r\n\r\n  res.getListAlias = function(loc) {\r\n    let itemAlias = (this.countAtLoc(loc) > 1) ? sentenceCase(this.pluralAlias) : sentenceCase(this.alias)\r\n    return itemAlias + \" (\" + this.countAtLoc(loc) + \")\";\r\n  };\r\n\r\n  return res;\r\n}\r\n```\r\n\r\n**Step 3 - Create a new command**\r\n```\r\ncommands.push(\r\n  new Cmd('CombineWith', {\r\n    //npcCmd:true,\r\n    rules:[cmdRules.canManipulate, cmdRules.isHere],\r\n    regex:/^(?:combine) (.+) (?:with) (.+)$/,\r\n    objects:[\r\n      //{special:'ignore'},\r\n      {scope:parser.isPresent},\r\n      //{special:'ignore'},\r\n      {scope:parser.isPresent},\r\n    ],\r\n    script:function(objects) {\r\n      const obj = objects[0][0]\r\n      const obj2 = objects[1][0]\r\n      \r\n      // We check the entry of the first object, using the name of the second object as key. If the function does not find the entry or does not exist, it will return false. We check the second object just in case.\r\n      let comboResult = false;\r\n      \r\n      if (obj.combination) {\r\n        comboResult = obj.combination(obj2);\r\n      }\r\n      if (comboResult) {\r\n        return world.SUCCESS;\r\n      }\r\n      \r\n      if (obj2.combination) {\r\n        comboResult = obj2.combination(obj);\r\n      }\r\n      if (comboResult) {\r\n        return world.SUCCESS;\r\n      }\r\n\r\n      this.default({char:player, item:obj})\r\n      return world.FAILED; \r\n    },\r\n    defmsg: \"These two items cannot be combined together\",\r\n  })\r\n);\r\n```\r\n\r\n**Step 4 Create your combinable items**\r\nN.B.: here, I go for the classic \"green herb + red herb = powder\" combo, but what happens during a combination can be anything, from modifying the base object to unlock a door or change a story flag.\r\nN.B.2: notice that the combination function of the second object mirrors the one of the first object, in case the player combines the items in the \"reverse\" order.\r\n```\r\ncreateItem(\"greenHerb\", INVENTORY_ITEM({\"cellA\": 1}), {\r\n  loc: \"cellA\",\r\n  alias: \"green herb\",\r\n  examine: \"A green herb with curative properties. It can be combined with other herbs, for a more powerful effect.\",\r\n\r\n  combination: function(otherItem) {\r\n    switch (otherItem.name) {\r\n      case \"redHerb\":\r\n        if (this.countAtLoc(player.name) > 0) {\r\n          this.takeFrom(player.name, 1);\r\n        } else {\r\n          this.takeFrom(player.loc, 1);\r\n        }\r\n        \r\n        if (otherItem.countAtLoc(player.name) > 0) {\r\n          otherItem.takeFrom(player.name, 1);\r\n        } else {\r\n          otherItem.takeFrom(player.loc, 1);\r\n        }\r\n\r\n        w[\"yellowPowder\"].giveTo(player.name, 1);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n})\r\n\r\ncreateItem(\"redHerb\", INVENTORY_ITEM({\"cellA\": 1}), {\r\n  loc: \"cellA\",\r\n  alias: \"red herb\",\r\n  examine: \"This red herb is poisonous if ingested alone. However, when combined to a green herb, it increases tremendously its curative properties.\",\r\n\r\n  combination: function(otherItem) {\r\n    switch (otherItem) {\r\n      case \"greenHerb\":\r\n        if (this.countAtLoc(player.name) > 0) {\r\n          this.takeFrom(player.name, 1);\r\n        } else {\r\n          this.takeFrom(player.loc, 1);\r\n        }\r\n        \r\n        let otherItemObject = w[otherItem]\r\n        if (otherItemObject.countAtLoc(player.name) > 0) {\r\n          otherItemObject.takeFrom(player.name, 1);\r\n        } else {\r\n          otherItemObject.takeFrom(player.loc, 1);\r\n        }\r\n        w[\"yellowPowder\"].giveTo(player.name, 1);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n})\r\n\r\ncreateItem(\"yellowPowder\", INVENTORY_ITEM(), {\r\n  alias: \"yellow powder\",\r\n  examine: \"This powder combines a green herb and a red herb. Ingesting it allows a full recovery.\",\r\n\r\n})\r\n```\r\n\r\n**Step 5 - Test the command**\r\n`combine green herb with red herb`\r\nExpected effect: Green herb and red herb should disappear from their location or be depleted by 1. A single yellow powder item appears in the player's inventory.",
      "EditableFormat": "markdown",
      "HTML": "<p>I am still on my \"survival horror\" experiment. Today I present to you how to make items that can combine with other items.<br>\nCombinable objects are not components, in that they are not parts of a whole, but rather two wholes that can interact with each other</p>\n<p><strong>Step 1 - Prepare a template</strong><br>\nN.B.: This template uses COUNTABLE as base, but it can work with a simple TAKEABLE as well.</p>\n<pre><code>const INVENTORY_ITEM = function(countableLocs) {\n  const res = $.extend({}, COUNTABLE(countableLocs))\n\n  res.combination = false;\n\n  res.getListAlias = function(loc) {\n    let itemAlias = (this.countAtLoc(loc) &gt; 1) ? sentenceCase(this.pluralAlias) : sentenceCase(this.alias)\n    return itemAlias + \" (\" + this.countAtLoc(loc) + \")\";\n  };\n\n  return res;\n}\n</code></pre>\n<p><strong>Step 3 - Create a new command</strong></p>\n<pre><code>commands.push(\n  new Cmd('CombineWith', {\n    //npcCmd:true,\n    rules:[cmdRules.canManipulate, cmdRules.isHere],\n    regex:/^(?:combine) (.+) (?:with) (.+)$/,\n    objects:[\n      //{special:'ignore'},\n      {scope:parser.isPresent},\n      //{special:'ignore'},\n      {scope:parser.isPresent},\n    ],\n    script:function(objects) {\n      const obj = objects[0][0]\n      const obj2 = objects[1][0]\n      \n      // We check the entry of the first object, using the name of the second object as key. If the function does not find the entry or does not exist, it will return false. We check the second object just in case.\n      let comboResult = false;\n      \n      if (obj.combination) {\n        comboResult = obj.combination(obj2);\n      }\n      if (comboResult) {\n        return world.SUCCESS;\n      }\n      \n      if (obj2.combination) {\n        comboResult = obj2.combination(obj);\n      }\n      if (comboResult) {\n        return world.SUCCESS;\n      }\n\n      this.default({char:player, item:obj})\n      return world.FAILED; \n    },\n    defmsg: \"These two items cannot be combined together\",\n  })\n);\n</code></pre>\n<p><strong>Step 4 Create your combinable items</strong><br>\nN.B.: here, I go for the classic \"green herb + red herb = powder\" combo, but what happens during a combination can be anything, from modifying the base object to unlock a door or change a story flag.<br>\nN.B.2: notice that the combination function of the second object mirrors the one of the first object, in case the player combines the items in the \"reverse\" order.</p>\n<pre><code>createItem(\"greenHerb\", INVENTORY_ITEM({\"cellA\": 1}), {\n  loc: \"cellA\",\n  alias: \"green herb\",\n  examine: \"A green herb with curative properties. It can be combined with other herbs, for a more powerful effect.\",\n\n  combination: function(otherItem) {\n    switch (otherItem.name) {\n      case \"redHerb\":\n        if (this.countAtLoc(player.name) &gt; 0) {\n          this.takeFrom(player.name, 1);\n        } else {\n          this.takeFrom(player.loc, 1);\n        }\n        \n        if (otherItem.countAtLoc(player.name) &gt; 0) {\n          otherItem.takeFrom(player.name, 1);\n        } else {\n          otherItem.takeFrom(player.loc, 1);\n        }\n\n        w[\"yellowPowder\"].giveTo(player.name, 1);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n})\n\ncreateItem(\"redHerb\", INVENTORY_ITEM({\"cellA\": 1}), {\n  loc: \"cellA\",\n  alias: \"red herb\",\n  examine: \"This red herb is poisonous if ingested alone. However, when combined to a green herb, it increases tremendously its curative properties.\",\n\n  combination: function(otherItem) {\n    switch (otherItem) {\n      case \"greenHerb\":\n        if (this.countAtLoc(player.name) &gt; 0) {\n          this.takeFrom(player.name, 1);\n        } else {\n          this.takeFrom(player.loc, 1);\n        }\n        \n        let otherItemObject = w[otherItem]\n        if (otherItemObject.countAtLoc(player.name) &gt; 0) {\n          otherItemObject.takeFrom(player.name, 1);\n        } else {\n          otherItemObject.takeFrom(player.loc, 1);\n        }\n        w[\"yellowPowder\"].giveTo(player.name, 1);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n})\n\ncreateItem(\"yellowPowder\", INVENTORY_ITEM(), {\n  alias: \"yellow powder\",\n  examine: \"This powder combines a green herb and a red herb. Ingesting it allows a full recovery.\",\n\n})\n</code></pre>\n<p><strong>Step 5 - Test the command</strong><br>\n<code>combine green herb with red herb</code><br>\nExpected effect: Green herb and red herb should disappear from their location or be depleted by 1. A single yellow powder item appears in the player's inventory.</p>\n\n",
      "PostDate": "2021-06-14T06:41:12.409716Z",
      "LastEditDate": "2021-06-14T07:02:04.4745009Z",
      "link": null
    },
    {
      "PostId": "e89233ba-427a-498a-8c9a-907c0876acde",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Here is an update. We are still combining items, but this time we want to use items that you want to count as individual objects, in case you want to implement an inventory limit of some kind.\r\n\r\nThe new template we will use:\r\n```\r\nconst INVENTORY_ITEM = function() {\r\n  const res = $.extend({}, TAKEABLE_DICTIONARY)\r\n\r\n  res.combination = false;\r\n\r\n  return res;\r\n}\r\n```\r\n\r\nHere is how the combination functions will look like, in the items:\r\n```\r\ncreateItem(\"greenHerb1\", INVENTORY_ITEM(), {\r\n  loc: \"cellA\",\r\n  alias: \"green herb\",\r\n  rootName: \"greenHerb\", //Used for the combination\r\n  examine: \"A green herb with curative properties. It can be combined with other herbs, for a more powerful effect.\",\r\n\r\n  combination: function(otherItem) {\r\n    if (!otherItem.rootName) {\r\n      return false;\r\n    }\r\n\r\n    switch (otherItem.rootName) {\r\n      case \"redHerb\":\r\n        this.loc = false;\r\n        otherItem.loc = false;\r\n        //We clone yellowPowder to give an instance to the player. The name uses a timestamp to avoid duplicates\r\n        cloneObject(w.yellowPowder, player.name, 'yellowPowder' + Date.now())\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n})\r\n\r\ncreateItem(\"redHerb1\", INVENTORY_ITEM(), {\r\n  loc: \"cellA\",\r\n  alias: \"red herb\",\r\n  rootName: \"redHerb\",\r\n  examine: \"This red herb is poisonous if ingested alone. However, when combined to a green herb, it increases tremendously its curative properties.\",\r\n\r\n  combination: function(otherItem) {\r\n    if (!otherItem.rootName) {\r\n      return false;\r\n    }\r\n\r\n    switch (otherItem.rootName) {\r\n      case \"redHerb\":\r\n        this.loc = false;\r\n        otherItem.loc = false;\r\n        //We clone yellowPowder to give an instance to the player. The name uses a timestamp to avoid duplicates\r\n        cloneObject(w.yellowPowder, player.name, 'yellowPowder' + Date.now())\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n})\r\n\r\ncreateItem(\"yellowPowder\", INVENTORY_ITEM(), {\r\n  alias: \"yellow powder\",\r\n  examine: function() {\r\n    msg(\"This powder combines a green herb and a red herb. Ingesting it allows a full recovery. Its real name is: \" + this.name)\r\n  }\r\n\r\n})\r\n```\r\nAs you can notice, we use a \"rootName\" property to identify the possible combination, and we make use of the \"clone\" function to create the yellow powder from ex-nihilo. The herbs are also removed from the game, since they are destroyed during the making of the powder.\r\n\r\nIf you want to optimize further, you can create external functions, if you use a specific combo effect several times accross the game.",
      "EditableFormat": "markdown",
      "HTML": "<p>Here is an update. We are still combining items, but this time we want to use items that you want to count as individual objects, in case you want to implement an inventory limit of some kind.</p>\n<p>The new template we will use:</p>\n<pre><code>const INVENTORY_ITEM = function() {\n  const res = $.extend({}, TAKEABLE_DICTIONARY)\n\n  res.combination = false;\n\n  return res;\n}\n</code></pre>\n<p>Here is how the combination functions will look like, in the items:</p>\n<pre><code>createItem(\"greenHerb1\", INVENTORY_ITEM(), {\n  loc: \"cellA\",\n  alias: \"green herb\",\n  rootName: \"greenHerb\", //Used for the combination\n  examine: \"A green herb with curative properties. It can be combined with other herbs, for a more powerful effect.\",\n\n  combination: function(otherItem) {\n    if (!otherItem.rootName) {\n      return false;\n    }\n\n    switch (otherItem.rootName) {\n      case \"redHerb\":\n        this.loc = false;\n        otherItem.loc = false;\n        //We clone yellowPowder to give an instance to the player. The name uses a timestamp to avoid duplicates\n        cloneObject(w.yellowPowder, player.name, 'yellowPowder' + Date.now())\n        return true;\n      default:\n        return false;\n    }\n  }\n\n})\n\ncreateItem(\"redHerb1\", INVENTORY_ITEM(), {\n  loc: \"cellA\",\n  alias: \"red herb\",\n  rootName: \"redHerb\",\n  examine: \"This red herb is poisonous if ingested alone. However, when combined to a green herb, it increases tremendously its curative properties.\",\n\n  combination: function(otherItem) {\n    if (!otherItem.rootName) {\n      return false;\n    }\n\n    switch (otherItem.rootName) {\n      case \"redHerb\":\n        this.loc = false;\n        otherItem.loc = false;\n        //We clone yellowPowder to give an instance to the player. The name uses a timestamp to avoid duplicates\n        cloneObject(w.yellowPowder, player.name, 'yellowPowder' + Date.now())\n        return true;\n      default:\n        return false;\n    }\n  }\n\n})\n\ncreateItem(\"yellowPowder\", INVENTORY_ITEM(), {\n  alias: \"yellow powder\",\n  examine: function() {\n    msg(\"This powder combines a green herb and a red herb. Ingesting it allows a full recovery. Its real name is: \" + this.name)\n  }\n\n})\n</code></pre>\n<p>As you can notice, we use a \"rootName\" property to identify the possible combination, and we make use of the \"clone\" function to create the yellow powder from ex-nihilo. The herbs are also removed from the game, since they are destroyed during the making of the powder.</p>\n<p>If you want to optimize further, you can create external functions, if you use a specific combo effect several times accross the game.</p>\n\n",
      "PostDate": "2021-06-14T07:08:02.1133399Z",
      "LastEditDate": "2021-06-14T07:13:57.4908277Z",
      "link": null
    },
    {
      "PostId": "be2ec80e-610b-4be2-8813-5767034bec1d",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Will this go into a library or into Quest 6?",
      "EditableFormat": "markdown",
      "HTML": "<p>Will this go into a library or into Quest 6?</p>\n\n",
      "PostDate": "2021-06-17T01:49:57.2898166Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "26d8c241-07a7-42da-925c-441a46681172",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is some custom code that I wrote, and thought I could share with the rest of the community, so it is up for Pix to implement it in the core framework of Quest 6.\r\n\r\nHowever, if you are already coding with Quest 6, you can copy-paste the code into `data.js`, or in a new javascript file that you will add in `settings.files`",
      "EditableFormat": "markdown",
      "HTML": "<p>This is some custom code that I wrote, and thought I could share with the rest of the community, so it is up for Pix to implement it in the core framework of Quest 6.</p>\n<p>However, if you are already coding with Quest 6, you can copy-paste the code into <code>data.js</code>, or in a new javascript file that you will add in <code>settings.files</code></p>\n\n",
      "PostDate": "2021-06-18T05:24:24.7260737Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
