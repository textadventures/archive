{
  "Topic": {
    "TopicId": "czqpdgt2guogrbtfwxgxbg",
    "ForumId": "15",
    "Title": "Quest 6: HACK - Adding the OOPS command to Quest 6 v0.3",
    "LastUpdated": "2020-12-05T19:59:16.4590531Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "6dc9e771-8c5e-4406-b643-bde319b23893",
      "UserId": 301690,
      "Username": "Richard Headkid",
      "AvatarUrl": "http://i.imgur.com/WUGXS8yb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I believe an  OOPS command is essential.\r\n\r\nEven if the player is not using a mobile browser, it's still nice to be able to enter <samp>'OOPS RALPH'</samp> after accidentally entering <samp>'GIVE GREEN LASER SWORD TO ALPH'</samp>.\r\n\r\nEven with a full keyboard and the up arrow, the player would still have to manually edit existing text.\r\n\r\nOOPS is much easier.  It makes typographical errors much less frustrating.\r\n\r\n---\r\nThis *seems* to work without causing any errors with the parser.\r\n\r\nNOTE:  Everything I added has KV on the line (or in a comment just above the new code).\r\n\r\n---\r\n\r\n<details style=\"background-color: #eeeeee;  box-shadow: 1px 1px 2px #bbbbbb;  cursor: pointer;\"><summary style=\"text-align:center;padding:4px;color:white;background-color: black;  box-shadow: 1px 1px 2px #bbbbbb;  cursor: pointer;\">CLICK HERE TO VIEW THE CODE!</summary>\r\n\r\n```js\r\n//===========\r\n// Add OOPS |\r\n//===========\r\n\r\nparser.commandHistory = [] //KV added for modded parser functions\r\nparser.enteredCmdArr = [] //KV added for modded parser functions\r\n\r\n\r\n//  KV MODIFIED this function to allow OOPS (and to generally keep histories of commands)\r\n  parser.parse = function(inputText) {\r\n    parser.msg(\"Input string: \" + inputText);\r\n    parser.enteredCmdArr.push(inputText) //KV added to keep entered command history\r\n    // This allows the command system to be temporarily overriden,\r\n    // say if the game asks a question\r\n    if (parser.override) {\r\n      parser.msg(\"Parser overriden\");\r\n      parser.override(inputText)\r\n      delete parser.override\r\n      return\r\n    }\r\n    \r\n    if (inputText) {\r\n      const res = parser.convertInputTextToCommandCandidate(inputText);\r\n      if (typeof res === \"string\") {\r\n        parsermsg(res);\r\n        world.endTurn(world.PARSER_FAILURE);\r\n        return;\r\n      }\r\n      parser.commandHistory.push(parser.currentCommand) //KV added to keep command history\r\n      parser.currentCommand = res;\r\n    }\r\n    \r\n    // Need to disambiguate, until each of the lowest level lists has exactly one member\r\n    let flag = false;\r\n    for (let i = 0; i < parser.currentCommand.objects.length; i++) {\r\n      for (let j = 0; j < parser.currentCommand.objects[i].length; j++) {\r\n        if (parser.currentCommand.objects[i][j] instanceof Array) {\r\n          if (parser.currentCommand.objects[i][j].length === 1) {\r\n            parser.currentCommand.objects[i][j] = parser.currentCommand.objects[i][j][0];\r\n          }\r\n          else {\r\n            flag = true;\r\n            parser.currentCommand.disambiguate1 = i;\r\n            parser.currentCommand.disambiguate2 = j;\r\n            showMenu(lang.disambig_msg, parser.currentCommand.objects[i][j], function(result) {\r\n              parser.currentCommand.objects[parser.currentCommand.disambiguate1][parser.currentCommand.disambiguate2] = result;\r\n              parser.parse(null);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (!flag) {\r\n\t\t\r\n      parser.execute();\r\n \r\n\t\tparser.lastCmdWasExecuted = true //KV added for OOPS\r\n\t\tparser.Unfound = false //KV added for OOPS\r\n\t\tparser.failedCmd = false //KV added for OOPS\r\n    }\r\n  };\r\n \r\n\r\n\r\n//  KV MODIFIED this function to allow OOPS (and to generally keep histories of commands)\r\n  parser.matchItemsToCmd = function(s, cmd) {\r\n    const res = {cmd:cmd, objectTexts:[], objects:[], matches:[]};\r\n    res.score = cmd.score ? cmd.score : 0;\r\n    \r\n    const arr = cmd.regexes.find(el => el.test(s)).exec(s)\r\n    //for (let regex of el.regexes) {\r\n    //  if (regex.test(cmdString)) arr = regex.exec(s)\r\n    //}\r\n\r\n    \r\n    const fallbackScope = parser.scope(parser.isVisible);\r\n    arr.shift();  // first element is the whole match, so discard\r\n    \r\n    parser.msg(\"..Base score: \" + res.score);\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      if (!cmd.objects[i]) {\r\n        errormsg(\"That command seems to have an error. It has more capture groups than there are elements in the 'objects' attribute.\");\r\n        return false;\r\n      }\r\n      if (cmd.objects[i].ignore) {\r\n        // this capture group has been flagged to be ignored\r\n        continue;\r\n      }\r\n      let objectNames, score = 0;\r\n      res.objectTexts.push(arr[i]);\r\n      if (cmd.objects[i].text) {\r\n        // this capture group has been flagged to be text\r\n        res.objects.push(arr[i]);\r\n        score = 1;\r\n      }\r\n      \r\n      else if (lang.all_regex.test(arr[i]) || lang.all_exclude_regex.test(arr[i])) {\r\n        // Handle ALL and ALL BUT\r\n        if (!cmd.objects[i].scope) console.log(\"WARNING: Command without scope - \" + cmd.name)\r\n        let list = cmd.objects[i].scope ? parser.scope(cmd.objects[i].scope) : fallbackScope;\r\n        let exclude = [game.player];\r\n        \r\n        // anything flagged as scenery should be excluded\r\n        for (let item of list) {\r\n          if (item.scenery || item.excludeFromAll) {\r\n            exclude.push(item);\r\n          }\r\n        }\r\n        \r\n        if (list.length === 0) {\r\n          res.error = cmd.nothingForAll ? cmd.nothingForAll : lang.nothing_msg;\r\n          res.score = -1;\r\n          return res;\r\n        }\r\n        if (lang.all_exclude_regex.test(arr[i])) {\r\n          // if this is ALL BUT we need to remove some things from the list\r\n          // excludes must be in isVisible\r\n          // if it is ambiguous or not recognised it does not get added to the list\r\n          let s = arr[i].replace(all_exclude_regex, \"\").trim();\r\n          objectNames = s.split(joiner_regex).map(function(el){ return el.trim(); });\r\n          for (let s in objectNames) {\r\n            items = parser.findInList(s, fallbackScope);\r\n            if (items.length === 1) {\r\n              exclude.push(items[0]);\r\n            }\r\n          }\r\n        }\r\n        list = list.filter(function(el) { return !exclude.includes(el); });\r\n        if (list.length > 1 && !cmd.objects[i].multiple) {\r\n          res.error = no_multiples_msg;\r\n          res.score = -1;\r\n          return res;\r\n        }\r\n        score = 2;\r\n        res.objects.push(list.map(function(el) { return [el]; }));\r\n        res.matches.push(arr[i]);\r\n        res.all = true;\r\n      }\r\n      \r\n      else {\r\n        objectNames = arr[i].split(lang.joiner_regex).map(function(el){ return el.trim() });\r\n        if (objectNames.length > 1 && !cmd.objects[i].multiple) {\r\n          res.error = no_multiples_msg;\r\n          res.score = -1;\r\n          return res;\r\n        }\r\n        if (!cmd.objects[i].scope) console.log(\"WARNING: No scope (or scope not found) in command \" + cmd.name)\r\n        let scopes = cmd.objects[i].scope ? [parser.scope(cmd.objects[i].scope), fallbackScope] : [fallbackScope];\r\n        //console.log(scopes)\r\n        \r\n        let objs = [], matches = [];\r\n        let objs2, n;\r\n        for (let s of objectNames) {\r\n          const objNameMatch = lang.article_filter_regex.exec(s);\r\n          if (objNameMatch === null) {\r\n            errormsg(\"Failed to match to article_filter_regex with '\" + s + \"', - probably an error in article_filter_regex!\");\r\n            return null;\r\n          }\r\n          [objs2, n] = this.findInScope(objNameMatch[1], scopes, cmd.objects[i]);\r\n          if (n === 0) {\r\n\t\t\t  console.log(\"KV says: unfound object (s) set to parser.unFound!\") //KV added for OOPS\r\n\t\t\t  parser.unFound = s // KV added for OOPS\r\n\t\t\t  parser.lastCmdWasExecuted = false //KV added for OOPS\r\n\t\t\t  parser.failedCmd = cmd  //KV added for OOPS\r\n            res.error = cmd.noobjecterror(s);\r\n            res.score = -1;\r\n            return res;\r\n          }\r\n          else {\r\n            if (n > score) { score = n; }\r\n            objs.push(objs2);\r\n            matches.push(s);\r\n          }\r\n        }\r\n        res.objects.push(objs);\r\n        res.matches.push(matches);\r\n      }\r\n      parser.msg(\"...Adding to the score: \" + score);\r\n      res.score += score;\r\n    }\r\n    return res;\r\n  };\r\n\r\n//=============\r\n// OOPS command \r\n//-------------\r\n//  Added by KV\r\n// \r\n//  I believe an  OOPS command is essential.\r\n//\r\n//  Even if the player is not using a mobile browser,\r\n//  it's still nice to be able to enter OOPS RALPH after\r\n//  accidentally entering GIVE GREEN LASER SWORD TO ALPH.\r\n//\r\n//  Even with a full keyboard and the up arrow, the player\r\n//  would still have to edit existing text.  OOPS is much easier.\r\n//\r\n//  TODO:  Should OOPS handle commands with no objects?\r\n//\r\n//\r\n//  REQUIREMENTS!\r\n//  -------------\r\n//\r\n//  My modded 'parser.matchItemsToCmd' and 'parser.parse' functions.\r\n//\r\n//  A new array: parser.commandHistory\r\n//  Another new array:  parser.enteredCmdArr\r\n//\r\n//==========================================\r\n\r\ncommands.push(new Cmd('Oops', {\r\n  regex:/^(?:oops) (.+)$/,\r\n  objects:[\r\n    {scope:parser.isPresent},\r\n  ],\r\n  default:function(item) {\r\n\tif (parser.lastCmdWasExecuted) {\r\n\t\tmetamsg(\"There is nothing to correct.\");\r\n\t\treturn false;\r\n\t}\r\n\tparser.quickCmd(parser.failedCmd,item)\r\n\treturn true\r\n  },\r\n}));\r\n\r\n//==================\r\n// END OF Add OOPS |\r\n//==================\r\n\r\n//KV added this function to make life simple.\r\nfunction lastCmd(){\r\n\treturn parser.commandHistory[parser.commandHistory.length-1]\r\n}\r\n\r\n//KV added this function to make life simple.\r\n\r\nfunction lastCmdEntered(){\r\n\treturn parser.enteredCmdArr[parser.enteredCmdArr.length-2]\r\n}\r\n\r\n```\r\n\r\nversion 3\r\n\r\n\r\n</details>\r\n\r\n---\r\nEDIT\r\n\r\nFixed a line of code (thanks to mrangel).",
      "EditableFormat": "markdown",
      "HTML": "<p>I believe an  OOPS command is essential.</p>\n<p>Even if the player is not using a mobile browser, it's still nice to be able to enter <samp>'OOPS RALPH'</samp> after accidentally entering <samp>'GIVE GREEN LASER SWORD TO ALPH'</samp>.</p>\n<p>Even with a full keyboard and the up arrow, the player would still have to manually edit existing text.</p>\n<p>OOPS is much easier.  It makes typographical errors much less frustrating.</p>\n<hr>\n<p>This <em>seems</em> to work without causing any errors with the parser.</p>\n<p>NOTE:  Everything I added has KV on the line (or in a comment just above the new code).</p>\n<hr>\n<details style=\"background-color: #eeeeee; cursor: pointer\"><summary style=\"text-align: center; padding: 4px; color: white; background-color: black; cursor: pointer\">CLICK HERE TO VIEW THE CODE!</summary>\n<pre><code>//===========\n// Add OOPS |\n//===========\n\nparser.commandHistory = [] //KV added for modded parser functions\nparser.enteredCmdArr = [] //KV added for modded parser functions\n\n\n//  KV MODIFIED this function to allow OOPS (and to generally keep histories of commands)\n  parser.parse = function(inputText) {\n    parser.msg(\"Input string: \" + inputText);\n    parser.enteredCmdArr.push(inputText) //KV added to keep entered command history\n    // This allows the command system to be temporarily overriden,\n    // say if the game asks a question\n    if (parser.override) {\n      parser.msg(\"Parser overriden\");\n      parser.override(inputText)\n      delete parser.override\n      return\n    }\n    \n    if (inputText) {\n      const res = parser.convertInputTextToCommandCandidate(inputText);\n      if (typeof res === \"string\") {\n        parsermsg(res);\n        world.endTurn(world.PARSER_FAILURE);\n        return;\n      }\n      parser.commandHistory.push(parser.currentCommand) //KV added to keep command history\n      parser.currentCommand = res;\n    }\n    \n    // Need to disambiguate, until each of the lowest level lists has exactly one member\n    let flag = false;\n    for (let i = 0; i &lt; parser.currentCommand.objects.length; i++) {\n      for (let j = 0; j &lt; parser.currentCommand.objects[i].length; j++) {\n        if (parser.currentCommand.objects[i][j] instanceof Array) {\n          if (parser.currentCommand.objects[i][j].length === 1) {\n            parser.currentCommand.objects[i][j] = parser.currentCommand.objects[i][j][0];\n          }\n          else {\n            flag = true;\n            parser.currentCommand.disambiguate1 = i;\n            parser.currentCommand.disambiguate2 = j;\n            showMenu(lang.disambig_msg, parser.currentCommand.objects[i][j], function(result) {\n              parser.currentCommand.objects[parser.currentCommand.disambiguate1][parser.currentCommand.disambiguate2] = result;\n              parser.parse(null);\n            });\n          }\n        }\n      }\n    }\n    if (!flag) {\n\t\t\n      parser.execute();\n \n\t\tparser.lastCmdWasExecuted = true //KV added for OOPS\n\t\tparser.Unfound = false //KV added for OOPS\n\t\tparser.failedCmd = false //KV added for OOPS\n    }\n  };\n \n\n\n//  KV MODIFIED this function to allow OOPS (and to generally keep histories of commands)\n  parser.matchItemsToCmd = function(s, cmd) {\n    const res = {cmd:cmd, objectTexts:[], objects:[], matches:[]};\n    res.score = cmd.score ? cmd.score : 0;\n    \n    const arr = cmd.regexes.find(el =&gt; el.test(s)).exec(s)\n    //for (let regex of el.regexes) {\n    //  if (regex.test(cmdString)) arr = regex.exec(s)\n    //}\n\n    \n    const fallbackScope = parser.scope(parser.isVisible);\n    arr.shift();  // first element is the whole match, so discard\n    \n    parser.msg(\"..Base score: \" + res.score);\n\n    for (let i = 0; i &lt; arr.length; i++) {\n      if (!cmd.objects[i]) {\n        errormsg(\"That command seems to have an error. It has more capture groups than there are elements in the 'objects' attribute.\");\n        return false;\n      }\n      if (cmd.objects[i].ignore) {\n        // this capture group has been flagged to be ignored\n        continue;\n      }\n      let objectNames, score = 0;\n      res.objectTexts.push(arr[i]);\n      if (cmd.objects[i].text) {\n        // this capture group has been flagged to be text\n        res.objects.push(arr[i]);\n        score = 1;\n      }\n      \n      else if (lang.all_regex.test(arr[i]) || lang.all_exclude_regex.test(arr[i])) {\n        // Handle ALL and ALL BUT\n        if (!cmd.objects[i].scope) console.log(\"WARNING: Command without scope - \" + cmd.name)\n        let list = cmd.objects[i].scope ? parser.scope(cmd.objects[i].scope) : fallbackScope;\n        let exclude = [game.player];\n        \n        // anything flagged as scenery should be excluded\n        for (let item of list) {\n          if (item.scenery || item.excludeFromAll) {\n            exclude.push(item);\n          }\n        }\n        \n        if (list.length === 0) {\n          res.error = cmd.nothingForAll ? cmd.nothingForAll : lang.nothing_msg;\n          res.score = -1;\n          return res;\n        }\n        if (lang.all_exclude_regex.test(arr[i])) {\n          // if this is ALL BUT we need to remove some things from the list\n          // excludes must be in isVisible\n          // if it is ambiguous or not recognised it does not get added to the list\n          let s = arr[i].replace(all_exclude_regex, \"\").trim();\n          objectNames = s.split(joiner_regex).map(function(el){ return el.trim(); });\n          for (let s in objectNames) {\n            items = parser.findInList(s, fallbackScope);\n            if (items.length === 1) {\n              exclude.push(items[0]);\n            }\n          }\n        }\n        list = list.filter(function(el) { return !exclude.includes(el); });\n        if (list.length &gt; 1 &amp;&amp; !cmd.objects[i].multiple) {\n          res.error = no_multiples_msg;\n          res.score = -1;\n          return res;\n        }\n        score = 2;\n        res.objects.push(list.map(function(el) { return [el]; }));\n        res.matches.push(arr[i]);\n        res.all = true;\n      }\n      \n      else {\n        objectNames = arr[i].split(lang.joiner_regex).map(function(el){ return el.trim() });\n        if (objectNames.length &gt; 1 &amp;&amp; !cmd.objects[i].multiple) {\n          res.error = no_multiples_msg;\n          res.score = -1;\n          return res;\n        }\n        if (!cmd.objects[i].scope) console.log(\"WARNING: No scope (or scope not found) in command \" + cmd.name)\n        let scopes = cmd.objects[i].scope ? [parser.scope(cmd.objects[i].scope), fallbackScope] : [fallbackScope];\n        //console.log(scopes)\n        \n        let objs = [], matches = [];\n        let objs2, n;\n        for (let s of objectNames) {\n          const objNameMatch = lang.article_filter_regex.exec(s);\n          if (objNameMatch === null) {\n            errormsg(\"Failed to match to article_filter_regex with '\" + s + \"', - probably an error in article_filter_regex!\");\n            return null;\n          }\n          [objs2, n] = this.findInScope(objNameMatch[1], scopes, cmd.objects[i]);\n          if (n === 0) {\n\t\t\t  console.log(\"KV says: unfound object (s) set to parser.unFound!\") //KV added for OOPS\n\t\t\t  parser.unFound = s // KV added for OOPS\n\t\t\t  parser.lastCmdWasExecuted = false //KV added for OOPS\n\t\t\t  parser.failedCmd = cmd  //KV added for OOPS\n            res.error = cmd.noobjecterror(s);\n            res.score = -1;\n            return res;\n          }\n          else {\n            if (n &gt; score) { score = n; }\n            objs.push(objs2);\n            matches.push(s);\n          }\n        }\n        res.objects.push(objs);\n        res.matches.push(matches);\n      }\n      parser.msg(\"...Adding to the score: \" + score);\n      res.score += score;\n    }\n    return res;\n  };\n\n//=============\n// OOPS command \n//-------------\n//  Added by KV\n// \n//  I believe an  OOPS command is essential.\n//\n//  Even if the player is not using a mobile browser,\n//  it's still nice to be able to enter OOPS RALPH after\n//  accidentally entering GIVE GREEN LASER SWORD TO ALPH.\n//\n//  Even with a full keyboard and the up arrow, the player\n//  would still have to edit existing text.  OOPS is much easier.\n//\n//  TODO:  Should OOPS handle commands with no objects?\n//\n//\n//  REQUIREMENTS!\n//  -------------\n//\n//  My modded 'parser.matchItemsToCmd' and 'parser.parse' functions.\n//\n//  A new array: parser.commandHistory\n//  Another new array:  parser.enteredCmdArr\n//\n//==========================================\n\ncommands.push(new Cmd('Oops', {\n  regex:/^(?:oops) (.+)$/,\n  objects:[\n    {scope:parser.isPresent},\n  ],\n  default:function(item) {\n\tif (parser.lastCmdWasExecuted) {\n\t\tmetamsg(\"There is nothing to correct.\");\n\t\treturn false;\n\t}\n\tparser.quickCmd(parser.failedCmd,item)\n\treturn true\n  },\n}));\n\n//==================\n// END OF Add OOPS |\n//==================\n\n//KV added this function to make life simple.\nfunction lastCmd(){\n\treturn parser.commandHistory[parser.commandHistory.length-1]\n}\n\n//KV added this function to make life simple.\n\nfunction lastCmdEntered(){\n\treturn parser.enteredCmdArr[parser.enteredCmdArr.length-2]\n}\n\n</code></pre>\n<p>version 3</p>\n</details>\n<hr>\n<p>EDIT</p>\n<p>Fixed a line of code (thanks to mrangel).</p>\n\n",
      "PostDate": "2020-12-05T19:59:16.4590531Z",
      "LastEditDate": "2020-12-05T21:25:34.0306676Z",
      "link": null
    },
    {
      "PostId": "6b0b25d0-7b21-4434-b5e8-721de5c9e426",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "```\r\nreturn parser.commandHistory[parser.commandHistory.length]\r\n```\r\nThat doesn't look right. Shouldn't that be length-1?\r\n\r\nIf I was doing it I'd probably use `unshift` rather than `push` to add commands to the history, so the list is in reverse order (unshift adds an item to the beginning of an array). It seems more likely they'll be accessed in this order, as most things you might use a command history for will be most interested in the last few commands. So keeping the list in most-recent-first order would mean the most recent command is `parser.commandHistory[0]`",
      "EditableFormat": "markdown",
      "HTML": "<pre><code>return parser.commandHistory[parser.commandHistory.length]\n</code></pre>\n<p>That doesn't look right. Shouldn't that be length-1?</p>\n<p>If I was doing it I'd probably use <code>unshift</code> rather than <code>push</code> to add commands to the history, so the list is in reverse order (unshift adds an item to the beginning of an array). It seems more likely they'll be accessed in this order, as most things you might use a command history for will be most interested in the last few commands. So keeping the list in most-recent-first order would mean the most recent command is <code>parser.commandHistory[0]</code></p>\n\n",
      "PostDate": "2020-12-05T21:20:43.6657014Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ffc3883b-97b9-4f8c-9954-996211fb6b2f",
      "UserId": 301690,
      "Username": "Richard Headkid",
      "AvatarUrl": "http://i.imgur.com/WUGXS8yb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> That doesn't look right. Shouldn't that be length-1?\r\n\r\nYou're right!  I fixed it.\r\n\r\n---\r\n> If I was doing it I'd probably use unshift rather than push to add commands to the history, so the list is in reverse order\r\n\r\nThat is a very good idea.\r\n\r\n---\r\n<s>If I </s>Whenever I get rich, remind me to by _all_ of your Kindle books at one time (excluding the few I already own).",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>That doesn't look right. Shouldn't that be length-1?</p>\n</blockquote>\n<p>You're right!  I fixed it.</p>\n<hr>\n<blockquote>\n<p>If I was doing it I'd probably use unshift rather than push to add commands to the history, so the list is in reverse order</p>\n</blockquote>\n<p>That is a very good idea.</p>\n<hr>\n<p><s>If I </s>Whenever I get rich, remind me to by <em>all</em> of your Kindle books at one time (excluding the few I already own).</p>\n\n",
      "PostDate": "2020-12-05T21:28:50.0115349Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e8262bde-aad2-42ea-bf02-5ec89c778193",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have added an OOPS command, but you will not like it - it only does it for commands typed in.",
      "EditableFormat": "markdown",
      "HTML": "<p>I have added an OOPS command, but you will not like it - it only does it for commands typed in.</p>\n\n",
      "PostDate": "2020-12-05T21:56:58.8917785Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3fc99510-22bd-431f-88ef-21d3d34403a8",
      "UserId": 301690,
      "Username": "Richard Headkid",
      "AvatarUrl": "http://i.imgur.com/WUGXS8yb.png",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  but you will not like it - it only does it for commands typed in\r\n\r\nHa!  I genuinely laughed when I read that.\r\n\r\nI tend to turn off the sidepanes in my games, anyway. \r\n\r\n...and my added code makes it all work the way I like it, too.\r\n\r\nSo, I'm content.\r\n\r\nPlus, I just realized that I don't have a clue how the player could end up in an OOPS scenario via mouse-click.\r\n\r\nNow my logic circuits have overloaded . . .\r\n\r\nSomebody call XanMag! Tell him I need a cold one and some fried chicken, stat!",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>but you will not like it - it only does it for commands typed in</p>\n</blockquote>\n<p>Ha!  I genuinely laughed when I read that.</p>\n<p>I tend to turn off the sidepanes in my games, anyway.</p>\n<p>...and my added code makes it all work the way I like it, too.</p>\n<p>So, I'm content.</p>\n<p>Plus, I just realized that I don't have a clue how the player could end up in an OOPS scenario via mouse-click.</p>\n<p>Now my logic circuits have overloaded . . .</p>\n<p>Somebody call XanMag! Tell him I need a cold one and some fried chicken, stat!</p>\n\n",
      "PostDate": "2020-12-05T22:30:34.1390127Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
