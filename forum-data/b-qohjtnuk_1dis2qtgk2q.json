{
  "Topic": {
    "TopicId": "b-qohjtnuk_1dis2qtgk2q",
    "ForumId": "10",
    "Title": "Are there variable for the players  adverb and noun",
    "LastUpdated": "2020-03-02T04:55:04.292042Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "a630a044-c5f3-47f8-a56e-488c33296b12",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "If the player should enter \"Cook Meat\"\r\nThen the adverb would be Cook and the noun is \"Meat\"\r\n\r\nI thought that maybe the players noun would be something like #noun# then I could test if the player is holding the object that the player typed in \r\nfor example\r\nif (Got(#noun#)) {\r\nAre there variable for the adverb and noun that the player typed in?\r\n\r\nThis would be useful for a 'switch' command. So the read pattern could be 'wash #object#' and then I could have messages for any specific object that the player washes\r\n ",
      "EditableFormat": "markdown",
      "HTML": "<p>If the player should enter \"Cook Meat\"<br>\nThen the adverb would be Cook and the noun is \"Meat\"</p>\n<p>I thought that maybe the players noun would be something like #noun# then I could test if the player is holding the object that the player typed in<br>\nfor example<br>\nif (Got(#noun#)) {<br>\nAre there variable for the adverb and noun that the player typed in?</p>\n<p>This would be useful for a 'switch' command. So the read pattern could be 'wash #object#' and then I could have messages for any specific object that the player washes</p>\n\n",
      "PostDate": "2020-03-02T04:55:04.292042Z",
      "LastEditDate": "2020-03-02T04:55:38.4555585Z",
      "link": null
    },
    {
      "PostId": "1a15dbb5-d0a6-47bd-8677-3db37d69719b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "In a grammatical sense, \"cook\" is a verb.\r\n\r\nIn Quest's code, \"cook\" may be either a verb or a command (Quest's verbs are a special type of command, whose behaviour is defined by the object they're applied to)\r\n\r\nIf you have a \"cook\" *command*, then its pattern will probably be something like `cook #object#`. Within the command's script, you can use the variable `object` to refer to the object that the player typed.\r\nYou can name the variable something else (like `#object1#` or similar), but it has to start with either `object`, `exit`, or `text`. In the case of `text`, the variable will be a string containing what the player typed; for `object` and `exit`, it will be converted to an object (and Quest will ensure that the player can see the object) before running the command.\r\n\r\nIf you have a \"cook\" *verb*, then Quest will check if the object has a script attribute named `cook` and will run that. In this case, the object can be referred to as `this`. If the object doesn't have a `cook` script (like if the player types \"cook table\"), Quest will simply respond \"I can't cook it.\"",
      "EditableFormat": "markdown",
      "HTML": "<p>In a grammatical sense, \"cook\" is a verb.</p>\n<p>In Quest's code, \"cook\" may be either a verb or a command (Quest's verbs are a special type of command, whose behaviour is defined by the object they're applied to)</p>\n<p>If you have a \"cook\" <em>command</em>, then its pattern will probably be something like <code>cook #object#</code>. Within the command's script, you can use the variable <code>object</code> to refer to the object that the player typed.<br>\nYou can name the variable something else (like <code>#object1#</code> or similar), but it has to start with either <code>object</code>, <code>exit</code>, or <code>text</code>. In the case of <code>text</code>, the variable will be a string containing what the player typed; for <code>object</code> and <code>exit</code>, it will be converted to an object (and Quest will ensure that the player can see the object) before running the command.</p>\n<p>If you have a \"cook\" <em>verb</em>, then Quest will check if the object has a script attribute named <code>cook</code> and will run that. In this case, the object can be referred to as <code>this</code>. If the object doesn't have a <code>cook</code> script (like if the player types \"cook table\"), Quest will simply respond \"I can't cook it.\"</p>\n\n",
      "PostDate": "2020-03-02T09:58:27.5005814Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2927a882-6651-4518-b099-1bcaee7fd250",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks mrangel for your reply.\r\n\r\nYes my mistake I got adverbs and verbs mixed up.\r\n\r\nI have not tried it yet but from what you have told me the command 'if #noun# = \"meat\" {' should pass if the player enters 'cook meat'\r\n\r\nLooking at verbs is the command 'if this = \"cook\" {' likely to work?\r\nThere are some cases where the player can do many things with an object so rather than have a lot of script commands I was wondering id there was another way with a word pattern of 'this wood' (where 'this' is the verb that the player has typed.\r\nI could have a word pattern of 'paint wood; cut wood; burn wood' but then I would need to know what verb the player typed so I could deal with for example the painting of the wood.\r\n\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks mrangel for your reply.</p>\n<p>Yes my mistake I got adverbs and verbs mixed up.</p>\n<p>I have not tried it yet but from what you have told me the command 'if #noun# = \"meat\" {' should pass if the player enters 'cook meat'</p>\n<p>Looking at verbs is the command 'if this = \"cook\" {' likely to work?<br>\nThere are some cases where the player can do many things with an object so rather than have a lot of script commands I was wondering id there was another way with a word pattern of 'this wood' (where 'this' is the verb that the player has typed.<br>\nI could have a word pattern of 'paint wood; cut wood; burn wood' but then I would need to know what verb the player typed so I could deal with for example the painting of the wood.</p>\n\n",
      "PostDate": "2020-03-03T00:46:34.2816306Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f70d923c-0784-45a8-b403-fc1ff15780e0",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hi mrangel.\r\n\r\nI was thinking that one possible way of getting the verb that the player typed would be to look at the whole text of the players input #text# and then use the instr string function to either search for a certain word or get the first word the player typed.",
      "EditableFormat": "markdown",
      "HTML": "<p>Hi mrangel.</p>\n<p>I was thinking that one possible way of getting the verb that the player typed would be to look at the whole text of the players input #text# and then use the instr string function to either search for a certain word or get the first word the player typed.</p>\n\n",
      "PostDate": "2020-03-03T01:07:18.3969264Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "4e1ea988-a575-48e9-aa67-3ea8369fb7df",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> I have not tried it yet but from what you have told me the command 'if #noun# = \"meat\" {' should pass if the player enters 'cook meat'\r\n\r\nNo…\r\nIf your script is in a *verb* then you would need:\r\n```\r\nif (this = meat) {\r\n```\r\n(but that's pretty pointless anyway - because the script would be on the meat object's \"verbs\" tab. That script will only be run if the object is the meat, so there's no need to check for it)\r\n\r\nIf your script is a *command* then your command has both a \"pattern\" and a \"script\".\r\nIf the pattern was \"cook #object#\" then you could use `if (object = meat) {` in the script - the `object` parameter is automatically converted to an object the player can see, that matches what they typed.\r\nIf your pattern was \"cook #text#\" they you could use `if (text = \"meat\") {`\r\n\r\n> Looking at verbs is the command 'if this = \"cook\" {' likely to work?\r\n\r\nWhy would you need to?\r\n\r\nEvery verb has its own script. So if your script is a part of the \"cook\" verb, it will only be run if the player's command started with \"cook\".\r\n\r\n> to look at the whole text of the players input #text# and then use the instr string function to either search for a certain word or get the first word the player typed.\r\n\r\nWhy? This seems like an awful lot of effort to go to, in order to do something that Quest already does for you.\r\nI can think of a few situations where this kind of code would be useful; but they're all unnusual edge cases, and they would all have to be handled in completely different ways.\r\n\r\nYou've got these little \"if\" statements; but where are they? Which script are you putting them in?",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>I have not tried it yet but from what you have told me the command 'if #noun# = \"meat\" {' should pass if the player enters 'cook meat'</p>\n</blockquote>\n<p>No…<br>\nIf your script is in a <em>verb</em> then you would need:</p>\n<pre><code>if (this = meat) {\n</code></pre>\n<p>(but that's pretty pointless anyway - because the script would be on the meat object's \"verbs\" tab. That script will only be run if the object is the meat, so there's no need to check for it)</p>\n<p>If your script is a <em>command</em> then your command has both a \"pattern\" and a \"script\".<br>\nIf the pattern was \"cook #object#\" then you could use <code>if (object = meat) {</code> in the script - the <code>object</code> parameter is automatically converted to an object the player can see, that matches what they typed.<br>\nIf your pattern was \"cook #text#\" they you could use <code>if (text = \"meat\") {</code></p>\n<blockquote>\n<p>Looking at verbs is the command 'if this = \"cook\" {' likely to work?</p>\n</blockquote>\n<p>Why would you need to?</p>\n<p>Every verb has its own script. So if your script is a part of the \"cook\" verb, it will only be run if the player's command started with \"cook\".</p>\n<blockquote>\n<p>to look at the whole text of the players input #text# and then use the instr string function to either search for a certain word or get the first word the player typed.</p>\n</blockquote>\n<p>Why? This seems like an awful lot of effort to go to, in order to do something that Quest already does for you.<br>\nI can think of a few situations where this kind of code would be useful; but they're all unnusual edge cases, and they would all have to be handled in completely different ways.</p>\n<p>You've got these little \"if\" statements; but where are they? Which script are you putting them in?</p>\n\n",
      "PostDate": "2020-03-03T08:41:24.3833314Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9623511d-31b2-428e-91d0-5d8bff34d424",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hi mrangel.\r\nLike I said in my first post this would be useful for a \"switch\" command. I used \"if\" to indicate what I'm trying to achieve.\r\nIn this example the word pattern is dig #object#\r\n\r\nswitch (object){\r\ncase (\"carrots\"){\r\n  msg (\"The carrots have not grown big enough\")\r\n{\r\ncase (\"potatoes\"){\r\n  msg(\"You don't have anything to cook the potatoes with\")\r\n{\r\netc\r\nI have not tried this code yet. This would save having a script for each vegetable.\r\n\r\nIf it were possible to work on a verb then I could have a single script for paint wood, burn wood, clean wood and have a message depending on what the player is doing with the wood, using a word pattern such as #verb# wood",
      "EditableFormat": "markdown",
      "HTML": "<p>Hi mrangel.<br>\nLike I said in my first post this would be useful for a \"switch\" command. I used \"if\" to indicate what I'm trying to achieve.<br>\nIn this example the word pattern is dig #object#</p>\n<p>switch (object){<br>\ncase (\"carrots\"){<br>\nmsg (\"The carrots have not grown big enough\")<br>\n{<br>\ncase (\"potatoes\"){<br>\nmsg(\"You don't have anything to cook the potatoes with\")<br>\n{<br>\netc<br>\nI have not tried this code yet. This would save having a script for each vegetable.</p>\n<p>If it were possible to work on a verb then I could have a single script for paint wood, burn wood, clean wood and have a message depending on what the player is doing with the wood, using a word pattern such as #verb# wood</p>\n\n",
      "PostDate": "2020-03-04T02:30:36.8606541Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "f94a73e9-7e90-4d91-bb52-fdaf1223e8e4",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "If you were using 'if' statements, it would have to be `if (object = carrots) {`, for example, because the `object` variable is an object rather than the string typed. (Assuming that there is actually a 'carrots' object which the player can see). But as switch/case converts the variables to strings before comparing them, I think that script should work.\r\n\r\n> If it were possible to work on a verb then I could have a single script for paint wood, burn wood, clean wood and have a message depending on what the player is doing with the wood, using a word pattern such as #verb# wood\r\n\r\nYou could make the pattern `#text# wood`. Then you would have a variable named `text` whose value is either \"paint\", \"burn\", or \"clean\". In this case, it would be up to your script to make sure that the wood is reachable. Note that the variable name in a pattern must start with either `text`, `object`, or `exit` - this tells Quest whether it should compare the player's input against the list of visible objects before running the command.\r\n\r\nYou could also use a 'regular expression' type pattern, which is a more powerful kind of pattern, to do something like: `^(?<text>burn|clean|paint|chop) wood$` (or even `^(?<text>burn|clean|paint|chop) (?<object>wood)$` - which would handle the \"I can't see that\" response automatically if there's no wood around)\r\n\r\nTheoretically, you could even have a pattern `^(?<text>\\S+) *(?<object>\\S.*)?$` which will catch any one-word command followed by an object name, allowing you to neatly handle whatever input the player types (this won't be called for commands which already exist, because if multiple patterns match Quest will pick the one which has the least text captured by variables (seems odd, but there's a reason. I can explain why if you're interested)",
      "EditableFormat": "markdown",
      "HTML": "<p>If you were using 'if' statements, it would have to be <code>if (object = carrots) {</code>, for example, because the <code>object</code> variable is an object rather than the string typed. (Assuming that there is actually a 'carrots' object which the player can see). But as switch/case converts the variables to strings before comparing them, I think that script should work.</p>\n<blockquote>\n<p>If it were possible to work on a verb then I could have a single script for paint wood, burn wood, clean wood and have a message depending on what the player is doing with the wood, using a word pattern such as #verb# wood</p>\n</blockquote>\n<p>You could make the pattern <code>#text# wood</code>. Then you would have a variable named <code>text</code> whose value is either \"paint\", \"burn\", or \"clean\". In this case, it would be up to your script to make sure that the wood is reachable. Note that the variable name in a pattern must start with either <code>text</code>, <code>object</code>, or <code>exit</code> - this tells Quest whether it should compare the player's input against the list of visible objects before running the command.</p>\n<p>You could also use a 'regular expression' type pattern, which is a more powerful kind of pattern, to do something like: <code>^(?&lt;text&gt;burn|clean|paint|chop) wood$</code> (or even <code>^(?&lt;text&gt;burn|clean|paint|chop) (?&lt;object&gt;wood)$</code> - which would handle the \"I can't see that\" response automatically if there's no wood around)</p>\n<p>Theoretically, you could even have a pattern <code>^(?&lt;text&gt;\\S+) *(?&lt;object&gt;\\S.*)?$</code> which will catch any one-word command followed by an object name, allowing you to neatly handle whatever input the player types (this won't be called for commands which already exist, because if multiple patterns match Quest will pick the one which has the least text captured by variables (seems odd, but there's a reason. I can explain why if you're interested)</p>\n\n",
      "PostDate": "2020-03-04T09:00:35.507936Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "7472974c-2e64-4285-9341-ad726e8752b6",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks mrangel.\r\n\r\nI feel that main problem is that you don't know what the player will type so you need to cover yourself. I like the #object# in the word pattern for that reason. I understand that its not possible to fully cover what a player might type.\r\n\r\nIf the player typed \"paint the wood\", \"paint the wood red\" or \"quickly paint the wood\" then I'm not certain if the word patterns you suggested would cover for this.  The word pattern ^(?<text>burn|clean|paint|chop) wood$ seems useful for specific verbs but can it cover the player typing \"destroy wood\" or some other verb and have a default message in the script such as \"You can't do that\"?  So many in the end a pattern on #text# wood would be better.\r\n\r\nIf #text# wood is used then I need a way of separating the adverb from the text or at least get the first wood, would something like    if ^(?<text>paint) {     be suitable for checking if the player typed paint as the verb? \r\n\r\nIf it's not too much work to explain why Quest will pick one that has less text captured by variables for multiple patterns when I'm always interested to learn something new thanks.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks mrangel.</p>\n<p>I feel that main problem is that you don't know what the player will type so you need to cover yourself. I like the #object# in the word pattern for that reason. I understand that its not possible to fully cover what a player might type.</p>\n<p>If the player typed \"paint the wood\", \"paint the wood red\" or \"quickly paint the wood\" then I'm not certain if the word patterns you suggested would cover for this.  The word pattern ^(?</p>\n<p>If #text# wood is used then I need a way of separating the adverb from the text or at least get the first wood, would something like    if ^(?</p>\n<p>If it's not too much work to explain why Quest will pick one that has less text captured by variables for multiple patterns when I'm always interested to learn something new thanks.</p>\n\n",
      "PostDate": "2020-03-05T01:37:06.2711643Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8022716f-afee-40fc-971f-c191fbc110c1",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It's 3am here, so my apologies if I'm not making much sense.\r\n\r\n> If it's not too much work to explain why Quest will pick one that has less text captured by variables for multiple patterns when I'm always interested to learn something new thanks.\r\n\r\nThe case where multiple patterns match is mostly designed for situations where there are one- and two-object versions of a command.\r\n\r\nFor example, the player types \"drop coin in well\".\r\n\r\nThere are two commands this matches, because \"drop\" is both a command on its own, and an alternative for \"put\".\r\n\r\nSo the two patterns that match are (simplified):\r\n* 'drop' command, pattern:`drop #object#`. In this case, the variable `object` captures the input \"coin in well\", 12 characters.\r\n* 'put' command, pattern effectively: `drop #object1# in #object2#`. So the variable `object` captures the input \"coin\" (4 characters) and `object2` captures the input \"well\" (4 characters)\r\n\r\nThe 'drop' command captures 12 characters in its variable. The 'put' command has 4+4=8 characters in variables. In this case, Quest chooses the 'put' command.\r\n\r\nIf the player types \"drop coin in well\", they're more likely to mean the command with the pattern \"drop #object1# in #object2#\" than the command with the pattern \"drop #object#\".\r\n\r\nYou'd think that Quest could guess which command is meant because the player isn't carrying an object named \"coin in well\". But different commands have different scopes, and the disambiguation system means that Quest can't start comparing the `object` variable to an actual list of object until *after* it knows which command it's using. So the developers used the fact that the word \"in\" isn't captured by any variable to draw the distinction. \"drop #object1# in #object2#\" has more \"command\" characters matching the players input, and therefore less characters in its variables.\r\n\r\n(It's worth noting that Quest checks for \"less characters in variables\" rather than \"more characters matching the command words\" - for all the core commands, these two are equivalent; but it's possible to write a regular expression pattern where this isn't necessarily the case. So if you do that, it's useful to know how the system actually works behind the scenes.\r\n\r\nFor example, you could make a pattern: <code style=\"border: 1px dotted red; padding: 4px;\">^(?&lt;text><em style=\"font-family:initial; border: 1px dotted red; padding: 1px; margin: 1px\">put whole pattern here</em>)$</code> - in which case the `text` variable captures the whole command, including any text that's also captured by other variables. So this command would have a silly large number of characters in its variables, and would only ever be triggered if no other command matches the player's input.)\r\n\r\n(PS: The put command's pattern is actually: `^(put|insert|place|drop) (?<object1>.*) (on|in|on to|in to|into) (?<object2>.*)$` - I simplified it for the example above, in the hope it would be easier to understand)\r\n\r\n> If the player typed \"paint the wood\", \"paint the wood red\" or \"quickly paint the wood\" then I'm not certain if the word patterns you suggested would cover for this.\r\n\r\nProperly parsing every option would probably require the system to understand English grammar; which is currently beyond the capability of any AI (though they're coming close).\r\nFor \"paint the wood red\", you could have a pattern like `^paint (?<object>.+?)( (?<text>red|crimson|green|black))?$` or similar, which ignores a colour at the end of the line. If you know what paint they have available, you could come up with a list of colours they're likely to type. Or if the player actually has paint in their inventory, you might be able to match a second object (although that's hard to deal with)\r\n\r\nFor adverbs like \"quickly\", which could be placed just about anywhere in the command, I suspect it might be possible to deal with this by modifying the parser a little. You could just remove these words from the command. However, I think most people playing text adventures wouldn't expect the computer to understand a more complex sentence like that; so are unlikely to try it.\r\n(My thought would be to take out all words ending -ly unless they're found in an object's alias, and put them in a separate variable… shouldn't be hard to do, if you think it would be beneficial)",
      "EditableFormat": "markdown",
      "HTML": "<p>It's 3am here, so my apologies if I'm not making much sense.</p>\n<blockquote>\n<p>If it's not too much work to explain why Quest will pick one that has less text captured by variables for multiple patterns when I'm always interested to learn something new thanks.</p>\n</blockquote>\n<p>The case where multiple patterns match is mostly designed for situations where there are one- and two-object versions of a command.</p>\n<p>For example, the player types \"drop coin in well\".</p>\n<p>There are two commands this matches, because \"drop\" is both a command on its own, and an alternative for \"put\".</p>\n<p>So the two patterns that match are (simplified):</p>\n<ul>\n<li>'drop' command, pattern:<code>drop #object#</code>. In this case, the variable <code>object</code> captures the input \"coin in well\", 12 characters.</li>\n<li>'put' command, pattern effectively: <code>drop #object1# in #object2#</code>. So the variable <code>object</code> captures the input \"coin\" (4 characters) and <code>object2</code> captures the input \"well\" (4 characters)</li>\n</ul>\n<p>The 'drop' command captures 12 characters in its variable. The 'put' command has 4+4=8 characters in variables. In this case, Quest chooses the 'put' command.</p>\n<p>If the player types \"drop coin in well\", they're more likely to mean the command with the pattern \"drop #object1# in #object2#\" than the command with the pattern \"drop #object#\".</p>\n<p>You'd think that Quest could guess which command is meant because the player isn't carrying an object named \"coin in well\". But different commands have different scopes, and the disambiguation system means that Quest can't start comparing the <code>object</code> variable to an actual list of object until <em>after</em> it knows which command it's using. So the developers used the fact that the word \"in\" isn't captured by any variable to draw the distinction. \"drop #object1# in #object2#\" has more \"command\" characters matching the players input, and therefore less characters in its variables.</p>\n<p>(It's worth noting that Quest checks for \"less characters in variables\" rather than \"more characters matching the command words\" - for all the core commands, these two are equivalent; but it's possible to write a regular expression pattern where this isn't necessarily the case. So if you do that, it's useful to know how the system actually works behind the scenes.</p>\n<p>For example, you could make a pattern: <code style=\"border: 1px dotted red; padding: 4px\">^(?&lt;text&gt;<em style=\"font-family: initial; border: 1px dotted red; padding: 1px; margin: 1px\">put whole pattern here</em>)$</code> - in which case the <code>text</code> variable captures the whole command, including any text that's also captured by other variables. So this command would have a silly large number of characters in its variables, and would only ever be triggered if no other command matches the player's input.)</p>\n<p>(PS: The put command's pattern is actually: <code>^(put|insert|place|drop) (?&lt;object1&gt;.*) (on|in|on to|in to|into) (?&lt;object2&gt;.*)$</code> - I simplified it for the example above, in the hope it would be easier to understand)</p>\n<blockquote>\n<p>If the player typed \"paint the wood\", \"paint the wood red\" or \"quickly paint the wood\" then I'm not certain if the word patterns you suggested would cover for this.</p>\n</blockquote>\n<p>Properly parsing every option would probably require the system to understand English grammar; which is currently beyond the capability of any AI (though they're coming close).<br>\nFor \"paint the wood red\", you could have a pattern like <code>^paint (?&lt;object&gt;.+?)( (?&lt;text&gt;red|crimson|green|black))?$</code> or similar, which ignores a colour at the end of the line. If you know what paint they have available, you could come up with a list of colours they're likely to type. Or if the player actually has paint in their inventory, you might be able to match a second object (although that's hard to deal with)</p>\n<p>For adverbs like \"quickly\", which could be placed just about anywhere in the command, I suspect it might be possible to deal with this by modifying the parser a little. You could just remove these words from the command. However, I think most people playing text adventures wouldn't expect the computer to understand a more complex sentence like that; so are unlikely to try it.<br>\n(My thought would be to take out all words ending -ly unless they're found in an object's alias, and put them in a separate variable… shouldn't be hard to do, if you think it would be beneficial)</p>\n\n",
      "PostDate": "2020-03-05T02:51:19.7750206Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "83664b33-5a47-4f66-8991-37b2d8859edd",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks mrangel for the information.\r\n\r\nIs there anywhere in the Quest Help file that I can find how to create my own custom word patterns such as ^(?<text>put whole pattern here)$   I suspect symbols such as ?  and $ have a purpose in the word pattern.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks mrangel for the information.</p>\n<p>Is there anywhere in the Quest Help file that I can find how to create my own custom word patterns such as ^(?</p>\n\n",
      "PostDate": "2020-03-05T23:51:14.3545228Z",
      "LastEditDate": "2020-03-05T23:52:29.9595465Z",
      "link": null
    },
    {
      "PostId": "7494917e-b76b-4e26-a00b-6abb9b69e8e1",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Is there anywhere in the Quest Help file that I can find how to create my own custom word patterns such as ^(?\r\n\r\nRegular Expressions are pretty complex (and the full language is way more complex than you need for Quest), but here's some of the basics:\r\n\r\n* Letters and numbers match themselves. So the pattern `cow` will match any command that includes the word \"cow\"\r\n     * I think letters are case-insensitive in Quest (most languages make this an option)\r\n* The characters `^` and `$` match the beginning and end of the string respectively. So the pattern `^take` would match a command that starts with \"take\", and the pattern `wood$` would match any command that ends with \"wood\".\r\n* Special characters `\\^$[]{}()|.*+?` can be preceded by a backslash to make them match literally. So the pattern `\\^` would match if the player actually typed a \"^\".\r\n* The dot `.` matches any character. So the pattern `b.g` would match the input \"big\", \"bog\", \"bag\", \"b9g\", \"b g\", etc.\r\n* A question mark makes the previous character optional. So the pattern `ropes?$` would match player input ending with either \"rope\" or \"ropes\"\r\n* Parentheses group parts of the pattern together. So the pattern `^look( at)? dragon$` would match the inputs \"look dragon\" or \"look at dragon\".\r\n     * Apparently a common mistake: Watch your spaces. If you put `^look (at)? dragon$`, the player would need to type \"look&nbsp; &nbsp;dragon\" with two spaces, because the spaces aren't part of the optional bit.\r\n* A question mark at the start of parentheses enables a lot of more advanced features. Most of these, you won't need to use. But:\r\n     * <code>(?&lt;<em style=\"font-family: initial; color: blue\">variable name</em>><em style=\"font-family: initial; color: blue\">pattern</em>)</code> matches the pattern inside the brackets, and stores that part of the player's input in a variable for your command to use.\r\n        * In Quest's command patterns, the variable names must start with either \"text\", \"object\", or \"exit\" so that Quest knows whether or not to look up an object before running the command script.\r\n        * When converting \"simple\" command patterns to regular expressions, Quest converts `#object#` to `(?<object>.*)`\r\n* An asterisk `*` makes a character optional or multiple. So the pattern `^pet( cute)* cat$` would match the commands \"pet cat\", \"pet cute cat\", \"pet cute cute cute cute cat\", and so on\r\n* A plus `+` matches multiple in the same way, but requires at least one match. So the pattern `ba+d` would match \"bad\", \"baad\" or \"baaaaaaaaad\", but not \"bd\".\r\n* A number in curly brackets matches that many times. so the pattern `whe{5}` matches the string \"wheeeee\".\r\n     * Two numbers (with a comma) specify a range. So `e{3,5}` will match \"eee\", \"eeee\", or \"eeee\".\r\n     * Either number is optional. So `a{4,}` matches 4 or more \"a\"s in a row, while `x{,4}` matches 4 or less \"x\"s.\r\n* Square brackets match any one of the characters inside them. So `b[ao]d` matches \"bad\" or \"bod\", and `[aeiou]{2,}` matches any set of at least 2 consecutive vowels.\r\n     * If the first character in the brackets is a `^`, it means *not*. So `[^ ,]` matches any character except a space or comma\r\n     * A dash lets you match a range of characters. So `[^3-8]` is the same as `[345678]` and `[^e-i]` is the same as `[^efghi]`.\r\n* A pipe character lets you specify multiple options. `red|blue|green` will match \"red\", \"blue\", or \"green\".\r\n     * Note that `^pose|dance$` will match a command that starts with \"pose\" or ends with \"dance\" - probably not what you want. The coder who does this probably meant `^(pose|dance)$`\r\n* `\\s` matches any whitespace character (space, tab, narrow space, wide space, etc. These will normally only show up in your input if a player is copy-pasting characters from the web or is using a non-English keyboard); `\\d` is any digit; `\\w` is any word character (letters, numbers, or the underscore). `\\S` is a non-space character, `\\D` is a non-digit, and so on. There are also named character classes like `[[:letter:]]` and `[[:emoji:]]`, but I'm not sure if Quest supports them.\r\n* `\\b` matches a position (zero characters; the position between characters) where there's a boundary between a word and non-word. So, for example, `the\\b` would match the word \"the\" in \"over the border\", or in \"the fish\", or just \"the\", but not in \"there\". Conversely, `\\B` matches a position which is not a word boundary, so `the\\B` would match any words that *starts* with \"the\", but not \"the\" on its own.\r\n* A `\\` followed by a digit matches a parenthetical pattern elsewhere in the pattern. So `\\2` matches a repetition of whatever matched the second pair of parentheses in the pattern.\r\n     * Example: the pattern `(bob|steve) and \\1's wife` will match \"bob and bob's wife\" or \"steve and steve's wife\", but not \"bob and steve's wife\".\r\n     * This is often used in things like `(.)(?!\\1)` - which matches a command which does not contain a double letter. (Oh, I didn't mention <code>(?!<em style=\"font-family: initial; color: blue\">pattern</em>)</code>, which matches anything that is not <em>pattern</em>.)\r\n* There are also a couple of weird expressions like `(*FAIL)` and `(*ACCEPT)`, which are normally only useful inside a construct like `(tom|dick|harry)`.\r\n     * `(*FAIL)` causes the entire match to fail as soon as it is reached, even if one of the later alternates would match\r\n     * `(*ACCEPT)` causes pattern matching to end successfully when it is reached, ignoring any other parts of the pattern after it. So the pattern `tell (john|bob(*ACCEPT)|steve) to stop$` would match \"tell john to stop\", \"tell steve to stop\", \"tell bob\", or \"tell bob he's stupid\".\r\n\r\nOne important thing to note is *greediness*. An expression with a `*`, `+`, or `?` in will match as many characters as possible, and then checks to see if the pattern to the right of it will match the remainder of the string. If not, the `*`, `+`, or `?` will try matching less, until the remainder of the pattern matches.\r\nThe corresponding operators `*?`, `+?`, and `??` are *non-greedy*; they will match as few characters as possible in order to let the rest of the string match.\r\n\r\nSo if your pattern is `^(?<text1>.+) (?<text2>.+)$`, the variable text1 will be most of the words in the player's input, and text2 will be the last word (or whatever comes after the last space).\r\nWhereas if your pattern is `^(?<text1>.+?) (?<text2>.+)$`, text1 will be the first word and text2 will be the rest of the string.\r\n\r\nThis becomes relevant if you make a pattern like `give #object1# to #object2#`, which will use the *greedy* operators - and will split the string up incorrectly if object2's alias contains the word \"to\". Making commands like this work correctly is extremely difficult. And note that Quest matches the whole pattern, deciding which command's pattern is the best fit and which parts of the user's input go into object1 and object2, *before* it tries to convert object1 and object2 into actual objects.\r\n\r\nWow… that took longer than I expected. And that's not even all of it.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Is there anywhere in the Quest Help file that I can find how to create my own custom word patterns such as ^(?</p>\n</blockquote>\n<p>Regular Expressions are pretty complex (and the full language is way more complex than you need for Quest), but here's some of the basics:</p>\n<ul>\n<li>Letters and numbers match themselves. So the pattern <code>cow</code> will match any command that includes the word \"cow\"\n<ul>\n<li>I think letters are case-insensitive in Quest (most languages make this an option)</li>\n</ul>\n</li>\n<li>The characters <code>^</code> and <code>$</code> match the beginning and end of the string respectively. So the pattern <code>^take</code> would match a command that starts with \"take\", and the pattern <code>wood$</code> would match any command that ends with \"wood\".</li>\n<li>Special characters <code>\\^$[]{}()|.*+?</code> can be preceded by a backslash to make them match literally. So the pattern <code>\\^</code> would match if the player actually typed a \"^\".</li>\n<li>The dot <code>.</code> matches any character. So the pattern <code>b.g</code> would match the input \"big\", \"bog\", \"bag\", \"b9g\", \"b g\", etc.</li>\n<li>A question mark makes the previous character optional. So the pattern <code>ropes?$</code> would match player input ending with either \"rope\" or \"ropes\"</li>\n<li>Parentheses group parts of the pattern together. So the pattern <code>^look( at)? dragon$</code> would match the inputs \"look dragon\" or \"look at dragon\".\n<ul>\n<li>Apparently a common mistake: Watch your spaces. If you put <code>^look (at)? dragon$</code>, the player would need to type \"look&nbsp; &nbsp;dragon\" with two spaces, because the spaces aren't part of the optional bit.</li>\n</ul>\n</li>\n<li>A question mark at the start of parentheses enables a lot of more advanced features. Most of these, you won't need to use. But:\n<ul>\n<li><code>(?&lt;<em style=\"font-family: initial; color: blue\">variable name</em>&gt;<em style=\"font-family: initial; color: blue\">pattern</em>)</code> matches the pattern inside the brackets, and stores that part of the player's input in a variable for your command to use.\n<ul>\n<li>In Quest's command patterns, the variable names must start with either \"text\", \"object\", or \"exit\" so that Quest knows whether or not to look up an object before running the command script.</li>\n<li>When converting \"simple\" command patterns to regular expressions, Quest converts <code>#object#</code> to <code>(?&lt;object&gt;.*)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>An asterisk <code>*</code> makes a character optional or multiple. So the pattern <code>^pet( cute)* cat$</code> would match the commands \"pet cat\", \"pet cute cat\", \"pet cute cute cute cute cat\", and so on</li>\n<li>A plus <code>+</code> matches multiple in the same way, but requires at least one match. So the pattern <code>ba+d</code> would match \"bad\", \"baad\" or \"baaaaaaaaad\", but not \"bd\".</li>\n<li>A number in curly brackets matches that many times. so the pattern <code>whe{5}</code> matches the string \"wheeeee\".\n<ul>\n<li>Two numbers (with a comma) specify a range. So <code>e{3,5}</code> will match \"eee\", \"eeee\", or \"eeee\".</li>\n<li>Either number is optional. So <code>a{4,}</code> matches 4 or more \"a\"s in a row, while <code>x{,4}</code> matches 4 or less \"x\"s.</li>\n</ul>\n</li>\n<li>Square brackets match any one of the characters inside them. So <code>b[ao]d</code> matches \"bad\" or \"bod\", and <code>[aeiou]{2,}</code> matches any set of at least 2 consecutive vowels.\n<ul>\n<li>If the first character in the brackets is a <code>^</code>, it means <em>not</em>. So <code>[^ ,]</code> matches any character except a space or comma</li>\n<li>A dash lets you match a range of characters. So <code>[^3-8]</code> is the same as <code>[345678]</code> and <code>[^e-i]</code> is the same as <code>[^efghi]</code>.</li>\n</ul>\n</li>\n<li>A pipe character lets you specify multiple options. <code>red|blue|green</code> will match \"red\", \"blue\", or \"green\".\n<ul>\n<li>Note that <code>^pose|dance$</code> will match a command that starts with \"pose\" or ends with \"dance\" - probably not what you want. The coder who does this probably meant <code>^(pose|dance)$</code></li>\n</ul>\n</li>\n<li><code>\\s</code> matches any whitespace character (space, tab, narrow space, wide space, etc. These will normally only show up in your input if a player is copy-pasting characters from the web or is using a non-English keyboard); <code>\\d</code> is any digit; <code>\\w</code> is any word character (letters, numbers, or the underscore). <code>\\S</code> is a non-space character, <code>\\D</code> is a non-digit, and so on. There are also named character classes like <code>[[:letter:]]</code> and <code>[[:emoji:]]</code>, but I'm not sure if Quest supports them.</li>\n<li><code>\\b</code> matches a position (zero characters; the position between characters) where there's a boundary between a word and non-word. So, for example, <code>the\\b</code> would match the word \"the\" in \"over the border\", or in \"the fish\", or just \"the\", but not in \"there\". Conversely, <code>\\B</code> matches a position which is not a word boundary, so <code>the\\B</code> would match any words that <em>starts</em> with \"the\", but not \"the\" on its own.</li>\n<li>A <code>\\</code> followed by a digit matches a parenthetical pattern elsewhere in the pattern. So <code>\\2</code> matches a repetition of whatever matched the second pair of parentheses in the pattern.\n<ul>\n<li>Example: the pattern <code>(bob|steve) and \\1's wife</code> will match \"bob and bob's wife\" or \"steve and steve's wife\", but not \"bob and steve's wife\".</li>\n<li>This is often used in things like <code>(.)(?!\\1)</code> - which matches a command which does not contain a double letter. (Oh, I didn't mention <code>(?!<em style=\"font-family: initial; color: blue\">pattern</em>)</code>, which matches anything that is not <em>pattern</em>.)</li>\n</ul>\n</li>\n<li>There are also a couple of weird expressions like <code>(*FAIL)</code> and <code>(*ACCEPT)</code>, which are normally only useful inside a construct like <code>(tom|dick|harry)</code>.\n<ul>\n<li><code>(*FAIL)</code> causes the entire match to fail as soon as it is reached, even if one of the later alternates would match</li>\n<li><code>(*ACCEPT)</code> causes pattern matching to end successfully when it is reached, ignoring any other parts of the pattern after it. So the pattern <code>tell (john|bob(*ACCEPT)|steve) to stop$</code> would match \"tell john to stop\", \"tell steve to stop\", \"tell bob\", or \"tell bob he's stupid\".</li>\n</ul>\n</li>\n</ul>\n<p>One important thing to note is <em>greediness</em>. An expression with a <code>*</code>, <code>+</code>, or <code>?</code> in will match as many characters as possible, and then checks to see if the pattern to the right of it will match the remainder of the string. If not, the <code>*</code>, <code>+</code>, or <code>?</code> will try matching less, until the remainder of the pattern matches.<br>\nThe corresponding operators <code>*?</code>, <code>+?</code>, and <code>??</code> are <em>non-greedy</em>; they will match as few characters as possible in order to let the rest of the string match.</p>\n<p>So if your pattern is <code>^(?&lt;text1&gt;.+) (?&lt;text2&gt;.+)$</code>, the variable text1 will be most of the words in the player's input, and text2 will be the last word (or whatever comes after the last space).<br>\nWhereas if your pattern is <code>^(?&lt;text1&gt;.+?) (?&lt;text2&gt;.+)$</code>, text1 will be the first word and text2 will be the rest of the string.</p>\n<p>This becomes relevant if you make a pattern like <code>give #object1# to #object2#</code>, which will use the <em>greedy</em> operators - and will split the string up incorrectly if object2's alias contains the word \"to\". Making commands like this work correctly is extremely difficult. And note that Quest matches the whole pattern, deciding which command's pattern is the best fit and which parts of the user's input go into object1 and object2, <em>before</em> it tries to convert object1 and object2 into actual objects.</p>\n<p>Wow… that took longer than I expected. And that's not even all of it.</p>\n\n",
      "PostDate": "2020-03-07T15:55:34.7974231Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "485ac1e4-2bcb-4adf-a3cd-47e5ae25020d",
      "UserId": 454326,
      "Username": "Brian5757",
      "AvatarUrl": "https://secure.gravatar.com/avatar/411c3e8cd4782d4a996f292940a61069?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Good to know thanks mrangel",
      "EditableFormat": "markdown",
      "HTML": "<p>Good to know thanks mrangel</p>\n\n",
      "PostDate": "2020-03-08T01:21:49.2437939Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
