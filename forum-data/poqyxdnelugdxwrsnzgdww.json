{
  "Topic": {
    "TopicId": "poqyxdnelugdxwrsnzgdww",
    "ForumId": "10",
    "Title": "More Trouble with Lists and TurnScripts",
    "LastUpdated": "2023-06-29T14:45:26.0340378Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "8f4ba515-8784-49c6-9d2f-93d86c3c3c34",
      "UserId": 512145,
      "Username": "Ghost of Moria",
      "AvatarUrl": "https://i.imgur.com/MUBkdVDb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "As a fledgling little coder who really only understands it when the syntax makes sense to him, I admit  that it may be what I'm trying to do can be gone about in a better way.\r\n\r\nHere's what I'm trying to do, and I thought a TurnScript might be the way to go: Every turn I want to scan the world (ie. all locations reachable by the player, which I have been exclusive adding to a directory labeled Locations, conveniently enough) for objects with the alias \"doe\" and \"buck.\" I have created two deer objects outside the game world to pull from. I hope to clone from these two deer, labeled deerDoe and deerBuck, and respawn a random one when they die. \r\n\r\nAs far as I can tell, my code should do the following: create a master list of the two deer to pull from, called MasterDeer. Then, it should create the list for AllDeer, which should be checking all the child objects in the Locations directory, adding them to the list if they're alive, and removing them when they're dead. If the list contains less than 2 deer, I want to generate another one randomly, pulling from the two deer on the MasterDeer list. I've tried several versions of syntax to try to get this to work as intended, but since each iteration I try throws errors, so I must be missing something fundamental about the way empty lists work. What if I want to find out if a list is empty, and if so, fill it?\r\n\r\n```\r\nMasterDeer = NewObjectList ()\r\n  list add (MasterDeer, deerBuck)\r\n  list add (MasterDeer, deerDoe)\r\nAllDeer = NewObjectList ()\r\nforeach (object, GetAllChildObjects (Locations)) {\r\n  if (object.alias = \"doe\") {\r\n    if (object.dead = false) {\r\n      list add (AllDeer, object)\r\n    }\r\n    else {\r\n      list remove (AllDeer, object)\r\n    }\r\n  }\r\n  else if (object.alias = \"buck\") {\r\n    if (object.dead = false) {\r\n      list add (AllDeer, object)\r\n    }\r\n    else {\r\n      list remove (AllDeer, object)\r\n    }\r\n  }\r\n}\r\nif (ListCount (AllDeer) < 2) {\r\n  NewDeer = PickOneObject (MasterDeer)\r\n  CloneObjectAndMove (NewDeer, HG11)\r\n  foreach (object, NewDeer) {\r\n    if (object.alias = \"doe\") {\r\n      list remove (NewDeer, object)\r\n    }\r\n    else if (object.alias = \"buck\") {\r\n      list remove (NewDeer, object)\r\n    }\r\n  }\r\n}\r\nelse {\r\n  DisableTurnScript (DeerTurn)\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>As a fledgling little coder who really only understands it when the syntax makes sense to him, I admit  that it may be what I'm trying to do can be gone about in a better way.</p>\n<p>Here's what I'm trying to do, and I thought a TurnScript might be the way to go: Every turn I want to scan the world (ie. all locations reachable by the player, which I have been exclusive adding to a directory labeled Locations, conveniently enough) for objects with the alias \"doe\" and \"buck.\" I have created two deer objects outside the game world to pull from. I hope to clone from these two deer, labeled deerDoe and deerBuck, and respawn a random one when they die.</p>\n<p>As far as I can tell, my code should do the following: create a master list of the two deer to pull from, called MasterDeer. Then, it should create the list for AllDeer, which should be checking all the child objects in the Locations directory, adding them to the list if they're alive, and removing them when they're dead. If the list contains less than 2 deer, I want to generate another one randomly, pulling from the two deer on the MasterDeer list. I've tried several versions of syntax to try to get this to work as intended, but since each iteration I try throws errors, so I must be missing something fundamental about the way empty lists work. What if I want to find out if a list is empty, and if so, fill it?</p>\n<pre><code>MasterDeer = NewObjectList ()\n  list add (MasterDeer, deerBuck)\n  list add (MasterDeer, deerDoe)\nAllDeer = NewObjectList ()\nforeach (object, GetAllChildObjects (Locations)) {\n  if (object.alias = \"doe\") {\n    if (object.dead = false) {\n      list add (AllDeer, object)\n    }\n    else {\n      list remove (AllDeer, object)\n    }\n  }\n  else if (object.alias = \"buck\") {\n    if (object.dead = false) {\n      list add (AllDeer, object)\n    }\n    else {\n      list remove (AllDeer, object)\n    }\n  }\n}\nif (ListCount (AllDeer) &lt; 2) {\n  NewDeer = PickOneObject (MasterDeer)\n  CloneObjectAndMove (NewDeer, HG11)\n  foreach (object, NewDeer) {\n    if (object.alias = \"doe\") {\n      list remove (NewDeer, object)\n    }\n    else if (object.alias = \"buck\") {\n      list remove (NewDeer, object)\n    }\n  }\n}\nelse {\n  DisableTurnScript (DeerTurn)\n}\n</code></pre>\n\n",
      "PostDate": "2023-06-29T14:45:26.0340378Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "475b7b12-b73b-4ef5-bd82-a8facdf866b8",
      "UserId": 512145,
      "Username": "Ghost of Moria",
      "AvatarUrl": "https://i.imgur.com/MUBkdVDb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Or more likely, I'm misunderstanding something about the way I'm trying to call these objects into my lists. Here's my current error.\r\n\r\n```Error evaluating expression 'ListCount(l) = 0' ListCount function expected list parameter was passed null.```",
      "EditableFormat": "markdown",
      "HTML": "<p>Or more likely, I'm misunderstanding something about the way I'm trying to call these objects into my lists. Here's my current error.</p>\n<p><code>Error evaluating expression 'ListCount(l) = 0' ListCount function expected list parameter was passed null.</code></p>\n\n",
      "PostDate": "2023-06-29T15:32:33.7458688Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "e403758b-37b6-4482-b8ab-2a3e3ec37cbc",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hmm… this seems a pretty complex function.\r\n\r\nThe first issue I see is your management of the `AllDeer` list. It goes through each object inside of `Locations`, and finds the deer.\r\nIf they're not dead, it adds them to `AllDeer`.\r\nIf they *are* dead, it removes them from `AllDeer` … which I expect will cause an error, because you're removing something from a list that you haven't added it to.\r\n\r\nAfter making this list, the only thing you seem to do with it is count how many objects are on the list. It might be sensible to make a list if you're doing something else with them in future. But if you're only counting them, it's probably easier just to use a number to keep track of how many you found.\r\n\r\nThen, if the number of the deer is less than two, it gets a bit confusing.\r\nYou pick one of the deer prototypes and store it in a variable `NewDeer`. You then attempt to use `foreach` to loop over `NewDeer`, which fails because it isn't a list. And even if it were a list, the code would fail; because you're not allowed to add/remove from a list during a `foreach` over the same list.\r\n\r\nAt the end, if there are 2 or more deer in Locations, it disables the turnscript… so I guess once you have two deer, you never want to spawn more? Or will something else enable the turnscript again later?\r\n\r\nAlso: you use the aliases \"doe\" and \"buck\" to identify the object. This is generally a bad habit to get into: if you're looking for clones of two particular items, that's what the `prototype` attribute is for: it points to the original that was cloned. And for weird technical reasons, comparing two objects is faster than comparing two strings.\r\n\r\nSo… taking this into account, I think you could use something like:\r\n```\r\nMasterDeer = NewObjectList ()\r\nlist add (MasterDeer, deerBuck)\r\nlist add (MasterDeer, deerDoe)\r\n\r\ndeerCount = 0\r\nforeach (object, GetAllChildObjects (Locations)) {\r\n  if (ListContains (MasterDeer, object.prototype)) {\r\n    if (not GetBoolean (object, \"dead\")) {\r\n      deerCount = deerCount + 1\r\n    }\r\n  }\r\n}\r\n\r\nif (deerCount < 2) {\r\n  NewDeer = PickOneObject (MasterDeer)\r\n  CloneObjectAndMove (NewDeer, HG11)\r\n}\r\nelse {\r\n  DisableTurnScript (DeerTurn)\r\n}\r\n```\r\n\r\n(in this version, rather than comparing `object.prototype` to both \"buck\" and \"doe\", and doing the same thing for each, I checked whether `object.prototype` (the object that an object was cloned from) is in `MasterDeer`; which I think should have the same effect. It just means that if you later add another type of deer, you can just add it to the list instead of needing to modify the code.)\r\n\r\nIf you were to put the code in a function, there would be a more efficient way to do it:\r\n```\r\nMasterDeer = NewObjectList ()\r\nlist add (MasterDeer, deerBuck)\r\nlist add (MasterDeer, deerDoe)\r\n\r\ndeerCount = 0\r\nforeach (object, GetAllChildObjects (Locations)) {\r\n  if (ListContains (MasterDeer, object.prototype)) {\r\n    if (not GetBoolean (object, \"dead\")) {\r\n      deerCount = deerCount + 1\r\n      if (deerCount >= 2) {\r\n        DisableTurnScript (DeerTurn)\r\n        return ()\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nNewDeer = PickOneObject (MasterDeer)\r\nCloneObjectAndMove (NewDeer, HG11)\r\n```\r\n(`return` in this case being used just to stop the running function; if you already found 2 deer, there's no reason to keep on checking the remaining objects)",
      "EditableFormat": "markdown",
      "HTML": "<p>Hmm… this seems a pretty complex function.</p>\n<p>The first issue I see is your management of the <code>AllDeer</code> list. It goes through each object inside of <code>Locations</code>, and finds the deer.<br>\nIf they're not dead, it adds them to <code>AllDeer</code>.<br>\nIf they <em>are</em> dead, it removes them from <code>AllDeer</code> … which I expect will cause an error, because you're removing something from a list that you haven't added it to.</p>\n<p>After making this list, the only thing you seem to do with it is count how many objects are on the list. It might be sensible to make a list if you're doing something else with them in future. But if you're only counting them, it's probably easier just to use a number to keep track of how many you found.</p>\n<p>Then, if the number of the deer is less than two, it gets a bit confusing.<br>\nYou pick one of the deer prototypes and store it in a variable <code>NewDeer</code>. You then attempt to use <code>foreach</code> to loop over <code>NewDeer</code>, which fails because it isn't a list. And even if it were a list, the code would fail; because you're not allowed to add/remove from a list during a <code>foreach</code> over the same list.</p>\n<p>At the end, if there are 2 or more deer in Locations, it disables the turnscript… so I guess once you have two deer, you never want to spawn more? Or will something else enable the turnscript again later?</p>\n<p>Also: you use the aliases \"doe\" and \"buck\" to identify the object. This is generally a bad habit to get into: if you're looking for clones of two particular items, that's what the <code>prototype</code> attribute is for: it points to the original that was cloned. And for weird technical reasons, comparing two objects is faster than comparing two strings.</p>\n<p>So… taking this into account, I think you could use something like:</p>\n<pre><code>MasterDeer = NewObjectList ()\nlist add (MasterDeer, deerBuck)\nlist add (MasterDeer, deerDoe)\n\ndeerCount = 0\nforeach (object, GetAllChildObjects (Locations)) {\n  if (ListContains (MasterDeer, object.prototype)) {\n    if (not GetBoolean (object, \"dead\")) {\n      deerCount = deerCount + 1\n    }\n  }\n}\n\nif (deerCount &lt; 2) {\n  NewDeer = PickOneObject (MasterDeer)\n  CloneObjectAndMove (NewDeer, HG11)\n}\nelse {\n  DisableTurnScript (DeerTurn)\n}\n</code></pre>\n<p>(in this version, rather than comparing <code>object.prototype</code> to both \"buck\" and \"doe\", and doing the same thing for each, I checked whether <code>object.prototype</code> (the object that an object was cloned from) is in <code>MasterDeer</code>; which I think should have the same effect. It just means that if you later add another type of deer, you can just add it to the list instead of needing to modify the code.)</p>\n<p>If you were to put the code in a function, there would be a more efficient way to do it:</p>\n<pre><code>MasterDeer = NewObjectList ()\nlist add (MasterDeer, deerBuck)\nlist add (MasterDeer, deerDoe)\n\ndeerCount = 0\nforeach (object, GetAllChildObjects (Locations)) {\n  if (ListContains (MasterDeer, object.prototype)) {\n    if (not GetBoolean (object, \"dead\")) {\n      deerCount = deerCount + 1\n      if (deerCount &gt;= 2) {\n        DisableTurnScript (DeerTurn)\n        return ()\n      }\n    }\n  }\n}\n\nNewDeer = PickOneObject (MasterDeer)\nCloneObjectAndMove (NewDeer, HG11)\n</code></pre>\n<p>(<code>return</code> in this case being used just to stop the running function; if you already found 2 deer, there's no reason to keep on checking the remaining objects)</p>\n\n",
      "PostDate": "2023-06-29T16:25:37.1286669Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8341ba79-3ee9-4034-9318-bb19c968b3b7",
      "UserId": 260569,
      "Username": "DarkLizerd",
      "AvatarUrl": "https://i.imgur.com/HiZKEtPb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "To me, this sounds like the hard way to do it...\r\nWhy not create a \"map\" that the deer use. \r\nOne that has what rooms connect to what rooms.\r\nwhen a deer is killed, spawn a new deer in a random room, and have it move to any connecting room\r\neither before or after the player moves.\r\nThat way, either the player will move into a room where the player is, OR, the deer will move into the room the player is.\r\nThis sounds like a hunting simulation.\r\nOr... if you don't need moving deer, then do it by random number before the player enters the room. \r\nNo need to track where they are.\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>To me, this sounds like the hard way to do it...<br>\nWhy not create a \"map\" that the deer use.<br>\nOne that has what rooms connect to what rooms.<br>\nwhen a deer is killed, spawn a new deer in a random room, and have it move to any connecting room<br>\neither before or after the player moves.<br>\nThat way, either the player will move into a room where the player is, OR, the deer will move into the room the player is.<br>\nThis sounds like a hunting simulation.<br>\nOr... if you don't need moving deer, then do it by random number before the player enters the room.<br>\nNo need to track where they are.</p>\n\n",
      "PostDate": "2023-07-03T21:19:11.1385999Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "79a18702-8442-4278-9797-e8fdf0256f9c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "@DarkLizerd\r\n\r\n> To me, this sounds like the hard way to do it...\r\nWhy not create a \"map\" that the deer use.\r\nOne that has what rooms connect to what rooms.\r\nwhen a deer is killed, spawn a new deer in a random room, and have it move to any connecting room\r\neither before or after the player moves.\r\n\r\nThat sounds even more complex to me; and doesn't seem to address the same problem.\r\n\r\nThe initial code seems to be intended to create a deer at a fixed location every turn until there are two, and then stop. The given turnscript does seem a little overengineered for the purpose; but I assume this is just the first test for a technique which will later be used with larger numbers of clonable objects.\r\n\r\nIf they just wanted a new deer to be spawned in response to one being killed, then I would agree that rather than counting the number of live deer, it would make more sense to just call `SetTurnTimeout` from the deer's death script, causing another one to be spawned the following turn or after a delay. Unless there's a chance that several will be killed at the same time, and you want to ensure that they are recreated at a rate of one per turn.\r\n\r\n<hr style=\"border-top: 1px dashed navy\"/>\r\n\r\nHmm… that's got me thinking now. If a system like this is being used for multiple types of creatures, I think it would be a lot more efficient to have a single turnscript for all of them. So how would I go about organising something like that?\r\n\r\nI think I'd create a function `SetupRespawningCreature` with 4 parameters: `groupName`, `minimumCount`, `objectToClone`, and `spawnLocation`.  The script would be something like:\r\n```\r\nif (not HasAttribute (game, \"respawnGroups\")) {\r\n  game.respawnGroups = NewDictionary ()\r\n}\r\nif (not DictionaryContains (game.respawnGroups, groupName)) {\r\n  dictionary add (game.respawnGroups, groupName, QuickParams (\"name\", groupName, \"target\", minimumCount, \"objects\", NewObjectList()))\r\n}\r\ndict = DictionaryItem (game.respawnGroups, groupName)\r\nobjList = DictionaryItem (dict, \"objects\")\r\nif (not DictionaryContains (objList, objectToClone)) {\r\n  list add (objList, objectToClone)\r\n}\r\nif (minimumCount > 0 and not Equal (DictionaryItem (dict, \"target\"), minimumCount)) {\r\n  dictionary remove (dict, \"target\")\r\n  dictionary add (dict, \"target\", minimumCount)\r\n}\r\nif (not DictionaryContains (dict, \"locationTable\")) {\r\n  loclist = NewObjectList ()\r\n  dictionary add (dict, \"locationTable\", QuickParams (objectToClone.name, loclist))\r\n}\r\nelse {\r\n  table = DictionaryItem (dict, \"locationTable\")\r\n  if (DictionaryContains (table, objectToClone.name)) {\r\n    loclist = DictionaryItem (table, objectToClone.name)\r\n  }\r\n  else {\r\n    loclist = NewObjectList ()\r\n    dictionary add (table, objectToClone.name, loclist)\r\n  }\r\n}\r\nlist add (loclist, spawnLocation)\r\nEnableTurnScript (CreatureRespawn)\r\n```\r\n\r\nAnd a turnscript called `CreatureRespawn` (initially disabled, so it doesn't run until there are creatures for it to watch for):\r\n```\r\nliveCount = NewDictionary()\r\nforeach (object, FilterByAttribute (GetAllChildObjects (Locations), \"dead\", false)) {\r\n  name = object.prototype.name\r\n  if (DictionaryContains (liveCount, name)) {\r\n    count = DictionaryItem (liveCount, name)\r\n    dictionary remove (liveCount, name)\r\n    dictionary add (liveCount, name, count + 1)\r\n  }\r\n  else {\r\n    dictionary add (liveCount, name, 1)\r\n  }\r\n}\r\nforeach (entry, game.respawnGroups) {\r\n  needed = DictionaryItem (entry, \"target\")\r\n  objects = DictionaryItem (entry, \"objects\")\r\n  foreach (obj, objects) {\r\n    if (DictionaryContains (liveCount, obj.name)) {\r\n      found = DictionaryItem (liveCount, obj.name)\r\n      needed = needed - found\r\n    }\r\n  }\r\n  if (needed < 0) {\r\n    objectToSpawn = PickOneObject (objects)\r\n    table = DictionaryItem (entry, \"locationTable\")\r\n    locations = DictionaryItem (table, objectToSpawn.name)\r\n    loc = PickOneObject (locations)\r\n    CloneObjectAndMove (objectToSpawn, loc)\r\n  }\r\n}\r\n```\r\n\r\nWritten off the top of my head; and a lot more complex than it should be because of the ugliness of Quest's dictionaries. I kind of got carried away there, to be honest. But I think with this script, you could put in your start script:\r\n```\r\nSetupRespawningCreature (\"deer\", 2, deerBuck, HG11)\r\nSetupRespawningCreature (\"deer\", 2, deerDoe, HG11)\r\n```\r\nto create a respawn group called \"deer\" which respawns a deerBuck or a deerDoe at location HG11 each turn until there are two of them. If you add the same creature to a respawn group with multiple locations, it can appear in multiple places; and you can have the same creature in multiple respawn groups. This is a lot more complex to initially set up, but it means that you could make it work with other creatures just by adding new SetupRespawningCreature lines, and the same code will handle all of them.\r\n\r\n(I didn't actually test the code; wrote it straight on the forum… a habit I really need to get out of when I see people talking about an interesting system)",
      "EditableFormat": "markdown",
      "HTML": "<p>@DarkLizerd</p>\n<blockquote>\n<p>To me, this sounds like the hard way to do it...<br>\nWhy not create a \"map\" that the deer use.<br>\nOne that has what rooms connect to what rooms.<br>\nwhen a deer is killed, spawn a new deer in a random room, and have it move to any connecting room<br>\neither before or after the player moves.</p>\n</blockquote>\n<p>That sounds even more complex to me; and doesn't seem to address the same problem.</p>\n<p>The initial code seems to be intended to create a deer at a fixed location every turn until there are two, and then stop. The given turnscript does seem a little overengineered for the purpose; but I assume this is just the first test for a technique which will later be used with larger numbers of clonable objects.</p>\n<p>If they just wanted a new deer to be spawned in response to one being killed, then I would agree that rather than counting the number of live deer, it would make more sense to just call <code>SetTurnTimeout</code> from the deer's death script, causing another one to be spawned the following turn or after a delay. Unless there's a chance that several will be killed at the same time, and you want to ensure that they are recreated at a rate of one per turn.</p>\n<hr style=\"border-top: 1px dashed navy\">\n<p>Hmm… that's got me thinking now. If a system like this is being used for multiple types of creatures, I think it would be a lot more efficient to have a single turnscript for all of them. So how would I go about organising something like that?</p>\n<p>I think I'd create a function <code>SetupRespawningCreature</code> with 4 parameters: <code>groupName</code>, <code>minimumCount</code>, <code>objectToClone</code>, and <code>spawnLocation</code>.  The script would be something like:</p>\n<pre><code>if (not HasAttribute (game, \"respawnGroups\")) {\n  game.respawnGroups = NewDictionary ()\n}\nif (not DictionaryContains (game.respawnGroups, groupName)) {\n  dictionary add (game.respawnGroups, groupName, QuickParams (\"name\", groupName, \"target\", minimumCount, \"objects\", NewObjectList()))\n}\ndict = DictionaryItem (game.respawnGroups, groupName)\nobjList = DictionaryItem (dict, \"objects\")\nif (not DictionaryContains (objList, objectToClone)) {\n  list add (objList, objectToClone)\n}\nif (minimumCount &gt; 0 and not Equal (DictionaryItem (dict, \"target\"), minimumCount)) {\n  dictionary remove (dict, \"target\")\n  dictionary add (dict, \"target\", minimumCount)\n}\nif (not DictionaryContains (dict, \"locationTable\")) {\n  loclist = NewObjectList ()\n  dictionary add (dict, \"locationTable\", QuickParams (objectToClone.name, loclist))\n}\nelse {\n  table = DictionaryItem (dict, \"locationTable\")\n  if (DictionaryContains (table, objectToClone.name)) {\n    loclist = DictionaryItem (table, objectToClone.name)\n  }\n  else {\n    loclist = NewObjectList ()\n    dictionary add (table, objectToClone.name, loclist)\n  }\n}\nlist add (loclist, spawnLocation)\nEnableTurnScript (CreatureRespawn)\n</code></pre>\n<p>And a turnscript called <code>CreatureRespawn</code> (initially disabled, so it doesn't run until there are creatures for it to watch for):</p>\n<pre><code>liveCount = NewDictionary()\nforeach (object, FilterByAttribute (GetAllChildObjects (Locations), \"dead\", false)) {\n  name = object.prototype.name\n  if (DictionaryContains (liveCount, name)) {\n    count = DictionaryItem (liveCount, name)\n    dictionary remove (liveCount, name)\n    dictionary add (liveCount, name, count + 1)\n  }\n  else {\n    dictionary add (liveCount, name, 1)\n  }\n}\nforeach (entry, game.respawnGroups) {\n  needed = DictionaryItem (entry, \"target\")\n  objects = DictionaryItem (entry, \"objects\")\n  foreach (obj, objects) {\n    if (DictionaryContains (liveCount, obj.name)) {\n      found = DictionaryItem (liveCount, obj.name)\n      needed = needed - found\n    }\n  }\n  if (needed &lt; 0) {\n    objectToSpawn = PickOneObject (objects)\n    table = DictionaryItem (entry, \"locationTable\")\n    locations = DictionaryItem (table, objectToSpawn.name)\n    loc = PickOneObject (locations)\n    CloneObjectAndMove (objectToSpawn, loc)\n  }\n}\n</code></pre>\n<p>Written off the top of my head; and a lot more complex than it should be because of the ugliness of Quest's dictionaries. I kind of got carried away there, to be honest. But I think with this script, you could put in your start script:</p>\n<pre><code>SetupRespawningCreature (\"deer\", 2, deerBuck, HG11)\nSetupRespawningCreature (\"deer\", 2, deerDoe, HG11)\n</code></pre>\n<p>to create a respawn group called \"deer\" which respawns a deerBuck or a deerDoe at location HG11 each turn until there are two of them. If you add the same creature to a respawn group with multiple locations, it can appear in multiple places; and you can have the same creature in multiple respawn groups. This is a lot more complex to initially set up, but it means that you could make it work with other creatures just by adding new SetupRespawningCreature lines, and the same code will handle all of them.</p>\n<p>(I didn't actually test the code; wrote it straight on the forum… a habit I really need to get out of when I see people talking about an interesting system)</p>\n\n",
      "PostDate": "2023-07-04T09:37:19.9963363Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d643e063-f559-4f3d-bbf3-3b1900eb13a4",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I couldn't get this out of my head; and realised that it could be easier to use. So, a little modification of the setup function:\r\n\r\n```\r\nif (not HasAttribute (game, \"respawnGroups\")) {\r\n  game.respawnGroups = NewDictionary ()\r\n}\r\nobjectToClone = GetObjectList (objectToClone)\r\nspawnLocation = GetObjectList (spawnLocation)\r\nif (not DictionaryContains (game.respawnGroups, groupName)) {\r\n  dictionary add (game.respawnGroups, groupName, QuickParams (\"name\", groupName, \"target\", minimumCount, \"objects\", NewObjectList()))\r\n}\r\ndict = DictionaryItem (game.respawnGroups, groupName)\r\nobjList = DictionaryItem (dict, \"objects\")\r\ndictionary remove (dict, \"objects\")\r\ndictionary add (dict, \"objects\", ListCompact (ListCombine (objList, objectToClone)))\r\nif (minimumCount > 0 and not Equal (DictionaryItem (dict, \"target\"), minimumCount)) {\r\n  dictionary remove (dict, \"target\")\r\n  dictionary add (dict, \"target\", minimumCount)\r\n}\r\nif (not DictionaryContains (dict, \"locationTable\")) {\r\n  table = NewDictionary ()\r\n  dictionary add (dict, \"locationTable\", table)\r\n}\r\nelse {\r\n  table = DictionaryItem (dict, \"locationTable\")\r\n}\r\nforeach (obj, objectToClone) {\r\n  if (DictionaryContains (table, obj.name)) {\r\n    loclist = DictionaryItem (table, obj.name)\r\n    dictionary remove (table, obj.name)\r\n  }\r\n  else {\r\n    loclist = NewObjectList ()\r\n  }\r\n  dictionary add (table, obj.name, ListCompact (ListCombine (loclist, spawnLocation)))\r\n}\r\nEnableTurnScript (CreatureRespawn)\r\n```\r\n\r\nThis depends on a second function, `GetObjectList` with a single parameter `input` and type \"objectlist\":\r\n(edited: the first two lines were the wrong way around when I originally posted this)\r\n```\r\noutput = NewObjectList ()\r\nswitch (TypeOf (input)) {\r\n  case (\"object\") {\r\n    if (not input = null) {\r\n      list add (output, input)\r\n    }\r\n  }\r\n  case (\"objectlist\") {\r\n    return (input)\r\n  }\r\n  case (\"list\", \"stringlist\") {\r\n    foreach (item, input) {\r\n      output = ListCompact (ListCombine (output, GetObjectList (item)))\r\n    }\r\n  }\r\n  case (\"dictionary\", \"stringdictionary\", \"scriptdictionary\", \"objectdictionary\") {\r\n    foreach (key, input) {\r\n      item = DictionaryItem (input, key)\r\n      output = ListCompact (ListCombine (output, ListCombine (GetObjectList (key), GetObjectList (item))))\r\n    }\r\n  }\r\n  case (\"string\") {\r\n    foreach (element, Split (input)) {\r\n      obj = GetObject (element)\r\n      if (not obj = null) {\r\n        list add (output, obj)\r\n      }\r\n    }\r\n  }\r\n}\r\nreturn (output)\r\n```\r\n\r\nThis means that if you have a bunch of creatures and any of them can appear in several locations, you could do something like:\r\n```\r\nApesList = NewObjectList ()\r\nlist add (ApesList, gibbon)\r\nlist add (ApesList, gorilla)\r\nlist add (ApesList, orangutan)\r\nSetupRespawningCreature (\"ape\", 3, ApesList, \"farmyard;jungle;nest;lab;cage;UFO\")\r\nSetupRespawningCreature (\"ape\", 3, spaceMonkey, UFO)\r\n```\r\nSo you have three apes that can spawn in a list of locations, and one which only spawns at a single location. All of these have the same chance of being created if there are less than 3 apes on the map.\r\nBoth the creature type and location can now be an object, a string containing the object name, a stringlist, an objectlist, or a string containing object names separated by semicolons.",
      "EditableFormat": "markdown",
      "HTML": "<p>I couldn't get this out of my head; and realised that it could be easier to use. So, a little modification of the setup function:</p>\n<pre><code>if (not HasAttribute (game, \"respawnGroups\")) {\n  game.respawnGroups = NewDictionary ()\n}\nobjectToClone = GetObjectList (objectToClone)\nspawnLocation = GetObjectList (spawnLocation)\nif (not DictionaryContains (game.respawnGroups, groupName)) {\n  dictionary add (game.respawnGroups, groupName, QuickParams (\"name\", groupName, \"target\", minimumCount, \"objects\", NewObjectList()))\n}\ndict = DictionaryItem (game.respawnGroups, groupName)\nobjList = DictionaryItem (dict, \"objects\")\ndictionary remove (dict, \"objects\")\ndictionary add (dict, \"objects\", ListCompact (ListCombine (objList, objectToClone)))\nif (minimumCount &gt; 0 and not Equal (DictionaryItem (dict, \"target\"), minimumCount)) {\n  dictionary remove (dict, \"target\")\n  dictionary add (dict, \"target\", minimumCount)\n}\nif (not DictionaryContains (dict, \"locationTable\")) {\n  table = NewDictionary ()\n  dictionary add (dict, \"locationTable\", table)\n}\nelse {\n  table = DictionaryItem (dict, \"locationTable\")\n}\nforeach (obj, objectToClone) {\n  if (DictionaryContains (table, obj.name)) {\n    loclist = DictionaryItem (table, obj.name)\n    dictionary remove (table, obj.name)\n  }\n  else {\n    loclist = NewObjectList ()\n  }\n  dictionary add (table, obj.name, ListCompact (ListCombine (loclist, spawnLocation)))\n}\nEnableTurnScript (CreatureRespawn)\n</code></pre>\n<p>This depends on a second function, <code>GetObjectList</code> with a single parameter <code>input</code> and type \"objectlist\":<br>\n(edited: the first two lines were the wrong way around when I originally posted this)</p>\n<pre><code>output = NewObjectList ()\nswitch (TypeOf (input)) {\n  case (\"object\") {\n    if (not input = null) {\n      list add (output, input)\n    }\n  }\n  case (\"objectlist\") {\n    return (input)\n  }\n  case (\"list\", \"stringlist\") {\n    foreach (item, input) {\n      output = ListCompact (ListCombine (output, GetObjectList (item)))\n    }\n  }\n  case (\"dictionary\", \"stringdictionary\", \"scriptdictionary\", \"objectdictionary\") {\n    foreach (key, input) {\n      item = DictionaryItem (input, key)\n      output = ListCompact (ListCombine (output, ListCombine (GetObjectList (key), GetObjectList (item))))\n    }\n  }\n  case (\"string\") {\n    foreach (element, Split (input)) {\n      obj = GetObject (element)\n      if (not obj = null) {\n        list add (output, obj)\n      }\n    }\n  }\n}\nreturn (output)\n</code></pre>\n<p>This means that if you have a bunch of creatures and any of them can appear in several locations, you could do something like:</p>\n<pre><code>ApesList = NewObjectList ()\nlist add (ApesList, gibbon)\nlist add (ApesList, gorilla)\nlist add (ApesList, orangutan)\nSetupRespawningCreature (\"ape\", 3, ApesList, \"farmyard;jungle;nest;lab;cage;UFO\")\nSetupRespawningCreature (\"ape\", 3, spaceMonkey, UFO)\n</code></pre>\n<p>So you have three apes that can spawn in a list of locations, and one which only spawns at a single location. All of these have the same chance of being created if there are less than 3 apes on the map.<br>\nBoth the creature type and location can now be an object, a string containing the object name, a stringlist, an objectlist, or a string containing object names separated by semicolons.</p>\n\n",
      "PostDate": "2023-07-05T11:33:28.3228783Z",
      "LastEditDate": "2023-07-10T22:38:44.7217671Z",
      "link": null
    },
    {
      "PostId": "77d74696-1676-4e36-badf-7c50428adaee",
      "UserId": 512145,
      "Username": "Ghost of Moria",
      "AvatarUrl": "https://i.imgur.com/MUBkdVDb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "This is actually quite incredible, and I'd love to give this a whirl. All I can say is that this is extremely robust, and that I have several sections of the game I'm building that will benefit hugely from this system. I will say that upon first entering the code, the GetObjectList function did not compile, though I haven't been through it to see where there might be a missed bracket potentially. Some of the syntax in that code is a little beyond my knowledge on how to format, so it's possible I wouldn't catch it no matter how long I looked. Hahaha... But as soon as I have these sections a little more fleshed out, I will attempt to implement this system because it sounds awesome and flexible.",
      "EditableFormat": "markdown",
      "HTML": "<p>This is actually quite incredible, and I'd love to give this a whirl. All I can say is that this is extremely robust, and that I have several sections of the game I'm building that will benefit hugely from this system. I will say that upon first entering the code, the GetObjectList function did not compile, though I haven't been through it to see where there might be a missed bracket potentially. Some of the syntax in that code is a little beyond my knowledge on how to format, so it's possible I wouldn't catch it no matter how long I looked. Hahaha... But as soon as I have these sections a little more fleshed out, I will attempt to implement this system because it sounds awesome and flexible.</p>\n\n",
      "PostDate": "2023-07-10T14:05:50.7043062Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0deb5834-d1ab-4d28-8ebd-d788e6186a9a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Sorry...  I had the first two lines of that function the wrong way around. Editing the post now. Not sure how I managed that.",
      "EditableFormat": "markdown",
      "HTML": "<p>Sorry...  I had the first two lines of that function the wrong way around. Editing the post now. Not sure how I managed that.</p>\n\n",
      "PostDate": "2023-07-10T22:37:43.1126925Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
