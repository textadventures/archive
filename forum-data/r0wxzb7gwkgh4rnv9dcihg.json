{
  "Topic": {
    "TopicId": "r0wxzb7gwkgh4rnv9dcihg",
    "ForumId": "10",
    "Title": "SaveStateLib",
    "LastUpdated": "2019-09-30T09:47:53.7292121Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "48c2af8d-ecc0-4551-b346-33e67f0dca45",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "OK folks; long time in the works, but I've got something that kind of works in some cases now.\r\n\r\nI wanted to set it up so that you can save a game and then resume it on a later version of the game (so can't use Quest's built in save system). I've basically done this by taking a copy of all objects on startup (with attributes to specify that some objects/attributes don't need to be saved), and serialising only the values of attributes which have changed. I've got a couple of other features to reduce the size of the save file, such as dividing a game into 'domains'. If there's a point where the player can't come back to a certain location, there's no need to save any objects there.\r\n\r\nBut anyway… on to the question.\r\nI've got 2 methods of saving. One where the player is presented with a textbox containing a string to copy and paste into a text editor, so they can save it for later, and one which saves the string to LocalStorage.\r\n\r\nHowever, last time I checked LocalStorage is disabled on the desktop version of Quest.\r\nSo, I'm coming up with an alternate solution which feels like a lot of work, but might be simpler. I just want some opinions on whether players would bother using it.\r\n\r\nBasically, when you save you have the option of copying a savestring which you'll need to paste into the 'load' dialog later; or save in your browser; or \"save online\".\r\nThe save online option would prompt the user to pick a username and password, which can then be used to save games to a dedicated space on my webserver. It's a simple database, allowing you to store and retrieve base64 strings.\r\n\r\nBut then I got to thinking. Having to remember a password would be a bit of a pain. Obviously, I could store it in a client cookie, but that doesn't work for the desktop  player.\r\n(I'm assuming that the desktop player even supports loading external sites in iframes; but I see no reason for that to be disabled).\r\n\r\nSo… when you start a game on the desktop player, a little box pops up asking if you want to enable 'quick saving'. Then you can enter your username/pass, the username and a login token are stored in attributes, and a save is fired using Quest's built-in save system. This basically saves the initial state of the game, plus those two values. Then when the player resumes that save, it automatically loads their latest save from the server (possibly with a notice if there is a newer version of the game available).\r\n\r\nThe desktop player would only need to login to the save system when they get a new version of the game; otherwise their save will keep them logged in.\r\n\r\nIt's inelegant, but it's the best I can come up with.\r\nDo you think it's worth the additional complexity?",
      "EditableFormat": "markdown",
      "HTML": "<p>OK folks; long time in the works, but I've got something that kind of works in some cases now.</p>\n<p>I wanted to set it up so that you can save a game and then resume it on a later version of the game (so can't use Quest's built in save system). I've basically done this by taking a copy of all objects on startup (with attributes to specify that some objects/attributes don't need to be saved), and serialising only the values of attributes which have changed. I've got a couple of other features to reduce the size of the save file, such as dividing a game into 'domains'. If there's a point where the player can't come back to a certain location, there's no need to save any objects there.</p>\n<p>But anyway… on to the question.<br>\nI've got 2 methods of saving. One where the player is presented with a textbox containing a string to copy and paste into a text editor, so they can save it for later, and one which saves the string to LocalStorage.</p>\n<p>However, last time I checked LocalStorage is disabled on the desktop version of Quest.<br>\nSo, I'm coming up with an alternate solution which feels like a lot of work, but might be simpler. I just want some opinions on whether players would bother using it.</p>\n<p>Basically, when you save you have the option of copying a savestring which you'll need to paste into the 'load' dialog later; or save in your browser; or \"save online\".<br>\nThe save online option would prompt the user to pick a username and password, which can then be used to save games to a dedicated space on my webserver. It's a simple database, allowing you to store and retrieve base64 strings.</p>\n<p>But then I got to thinking. Having to remember a password would be a bit of a pain. Obviously, I could store it in a client cookie, but that doesn't work for the desktop  player.<br>\n(I'm assuming that the desktop player even supports loading external sites in iframes; but I see no reason for that to be disabled).</p>\n<p>So… when you start a game on the desktop player, a little box pops up asking if you want to enable 'quick saving'. Then you can enter your username/pass, the username and a login token are stored in attributes, and a save is fired using Quest's built-in save system. This basically saves the initial state of the game, plus those two values. Then when the player resumes that save, it automatically loads their latest save from the server (possibly with a notice if there is a newer version of the game available).</p>\n<p>The desktop player would only need to login to the save system when they get a new version of the game; otherwise their save will keep them logged in.</p>\n<p>It's inelegant, but it's the best I can come up with.<br>\nDo you think it's worth the additional complexity?</p>\n\n",
      "PostDate": "2019-09-30T09:47:53.7292121Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9d1ea51c-9d48-4617-8054-c3b232199a56",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "In case anyone has a strong opinion, I've also got 2 different types of save strings. Not sure which would be best if we're asking the player to copy and paste these to store them somewhere.\r\n\r\nFrom my test game:\r\nFormat 1: `Ǡ汁䅜઀✦禤ɹ䂇ƘɐỳΐÒ䒠猢Û倭䟊犂䀽䔒߀ঠ✠徐˻ǣ匮┽ᭃẀ氡滑栣㐢ᠠ棈啌煰ૠ்搠`\r\nFormat 2: `[A4GwhgngpgTg3mEBLMBnAvAIwPaYNwAWUSA5gQC7oBseq5MUAdieQegEwCcAvuALbA4dMOSjpsjPMGwB3WOgDaARgA0VFUs4qArAF1uQA===`\r\n\r\nI think most utilities you might use to save a string for later use wouldn't have a problem with 1; but there's a chance something could get confused. There's less chance of the string getting mangled with type 2, but it's quite a bit longer [these two examples were created using the same save data]",
      "EditableFormat": "markdown",
      "HTML": "<p>In case anyone has a strong opinion, I've also got 2 different types of save strings. Not sure which would be best if we're asking the player to copy and paste these to store them somewhere.</p>\n<p>From my test game:<br>\nFormat 1: <code>Ǡ汁䅜઀✦禤ɹ䂇ƘɐỳΐÒ䒠猢Û倭䟊犂䀽䔒߀ঠ✠徐˻ǣ匮┽ᭃẀ氡滑栣㐢ᠠ棈啌煰ૠ்搠</code><br>\nFormat 2: <code>[A4GwhgngpgTg3mEBLMBnAvAIwPaYNwAWUSA5gQC7oBseq5MUAdieQegEwCcAvuALbA4dMOSjpsjPMGwB3WOgDaARgA0VFUs4qArAF1uQA===</code></p>\n<p>I think most utilities you might use to save a string for later use wouldn't have a problem with 1; but there's a chance something could get confused. There's less chance of the string getting mangled with type 2, but it's quite a bit longer [these two examples were created using the same save data]</p>\n\n",
      "PostDate": "2019-09-30T10:15:19.9327287Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "5d24ec28-4aec-4bf8-9d9b-3e7e22691f99",
      "UserId": 267336,
      "Username": "jmnevil54",
      "AvatarUrl": "https://secure.gravatar.com/avatar/5d73d7ec1dbe20a5cb46f02a6d53f187?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It would be nice to use this save system on the online version.\r\n\r\nFormat 2 is best,  because Chinese characters on most American-English speaking computers is a big NO.",
      "EditableFormat": "markdown",
      "HTML": "<p>It would be nice to use this save system on the online version.</p>\n<p>Format 2 is best,  because Chinese characters on most American-English speaking computers is a big NO.</p>\n\n",
      "PostDate": "2019-09-30T18:47:57.9486862Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "de0750c5-db56-4287-a759-d3835d75749b",
      "UserId": 277074,
      "Username": "Dcoder",
      "AvatarUrl": "https://i.imgur.com/O07mlRtb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Interesting.  If I understand this right, each time you save, all changes from the original game template (not from the last save) are recorded.  Then when you restore a saved game, the original game template is loaded and all cumulative changed values from the saved game are applied (correct me if I'm wrong).\r\n\r\nI would also go with Format 2 as the extra length shouldn't be a big deal, but any confusion with Format 1's characters would be.  How does the save string translate into all of the various changed Quest attribute values, and from all over the game?  I know you can store a lot of data in all those combinations of characters, but I don't get how Quest could reorganize that data back to where it specifically belongs?",
      "EditableFormat": "markdown",
      "HTML": "<p>Interesting.  If I understand this right, each time you save, all changes from the original game template (not from the last save) are recorded.  Then when you restore a saved game, the original game template is loaded and all cumulative changed values from the saved game are applied (correct me if I'm wrong).</p>\n<p>I would also go with Format 2 as the extra length shouldn't be a big deal, but any confusion with Format 1's characters would be.  How does the save string translate into all of the various changed Quest attribute values, and from all over the game?  I know you can store a lot of data in all those combinations of characters, but I don't get how Quest could reorganize that data back to where it specifically belongs?</p>\n\n",
      "PostDate": "2019-10-01T09:48:18.3079286Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "02f33048-60bd-4f20-8116-f3474949be97",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "To make sure that it works when a game is changed and updated (so there might be more variables to save in a later revision), I started with a string that looks like `player{alias=\"Bob\";health=195;maxhealth=300}` - including only the values that have changed since the game started.\r\n\r\nThen I've streamlined it a little using a system that looks a bit like bencode. Instead of an `=` between the attribute name and value, I use a different symbol character for each possible type. So `\"` indicates that the data is a string, `=` a boolean, `#` an int, and so on. In front of strings, I put a number (2 base64 digits) giving the string length. So it would look like `stringattribute\"05hello` … the same length as `stringattribute=\"hello\"`, but faster to process and doesn't need any messing about if there are literal `\"`s, `\\`s, or any other character in the string. Faster to unpack :)\r\n\r\nVirtually all of the data types can be efficiently packed into a string in this way. There's just some really horrible issues if your game deals heavily with creating, destroying, and cloning objects (which I usually do).\r\n\r\nExample of a case that goes pretty troublesome: I have a crafting system in my game. I use it to create 3 hats, so the basic \"hat\" object gets cloned 3 times. I now have hat1, hat2, and hat3. Then I destroy the first two, so my saved game includes attributes for `hat` and `hat3`. On loading, the script sees that there are attributes for `hat3`, which doesn't exist. But it has a `prototype` attribute, so the load script knows that it's a clone. So it creates a new clone , which gets named `hat1`. So now I need to go through all the other objects (ones I've already loaded and ones I haven't) to make sure that any of them which had object attributes pointing to `hat3` now point to the newly created `hat1`. This is very ugly, because it may well fall over on string attributes that hold expressions for use with `eval`, text processor functions which contain the object name, and a couple of other cases.\r\n\r\nBut I think I've got *most* of those to work neatly.\r\n\r\nThe only real problem is script attributes, which I can't create on the fly. But I have to accept that as a limitation of Quest.\r\n\r\n(The strings don't have visible \"name=value\" type text in them for the player to examine because I'm passing them through a javascript implementation of the LZW (zip) algorithm first, and then encoding them as either base64 (6 bits per character) or fullrange UTF16)",
      "EditableFormat": "markdown",
      "HTML": "<p>To make sure that it works when a game is changed and updated (so there might be more variables to save in a later revision), I started with a string that looks like <code>player{alias=\"Bob\";health=195;maxhealth=300}</code> - including only the values that have changed since the game started.</p>\n<p>Then I've streamlined it a little using a system that looks a bit like bencode. Instead of an <code>=</code> between the attribute name and value, I use a different symbol character for each possible type. So <code>\"</code> indicates that the data is a string, <code>=</code> a boolean, <code>#</code> an int, and so on. In front of strings, I put a number (2 base64 digits) giving the string length. So it would look like <code>stringattribute\"05hello</code> … the same length as <code>stringattribute=\"hello\"</code>, but faster to process and doesn't need any messing about if there are literal <code>\"</code>s, <code>\\</code>s, or any other character in the string. Faster to unpack :)</p>\n<p>Virtually all of the data types can be efficiently packed into a string in this way. There's just some really horrible issues if your game deals heavily with creating, destroying, and cloning objects (which I usually do).</p>\n<p>Example of a case that goes pretty troublesome: I have a crafting system in my game. I use it to create 3 hats, so the basic \"hat\" object gets cloned 3 times. I now have hat1, hat2, and hat3. Then I destroy the first two, so my saved game includes attributes for <code>hat</code> and <code>hat3</code>. On loading, the script sees that there are attributes for <code>hat3</code>, which doesn't exist. But it has a <code>prototype</code> attribute, so the load script knows that it's a clone. So it creates a new clone , which gets named <code>hat1</code>. So now I need to go through all the other objects (ones I've already loaded and ones I haven't) to make sure that any of them which had object attributes pointing to <code>hat3</code> now point to the newly created <code>hat1</code>. This is very ugly, because it may well fall over on string attributes that hold expressions for use with <code>eval</code>, text processor functions which contain the object name, and a couple of other cases.</p>\n<p>But I think I've got <em>most</em> of those to work neatly.</p>\n<p>The only real problem is script attributes, which I can't create on the fly. But I have to accept that as a limitation of Quest.</p>\n<p>(The strings don't have visible \"name=value\" type text in them for the player to examine because I'm passing them through a javascript implementation of the LZW (zip) algorithm first, and then encoding them as either base64 (6 bits per character) or fullrange UTF16)</p>\n\n",
      "PostDate": "2019-10-01T12:59:02.4494538Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "21a1d7b6-9c92-49c8-8d15-251463c95cc8",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Heh… I thought updating data blocks would be the hard part. So if you decide to add an extra stat to a game later on, or an extra question at character creation, you can still load an older save and it will do the calculations or ask the extra question before proceeding with the game.\r\n\r\nTurns out it's easy. I even worked in a simplified version of my ShowMenu hacks, so that if you call ShowMenu in the update script to ask the player extra questions, it will wait for an answer before running the next update.\r\n\r\nNearly ready to test now; 704 lines of code, plus 60 in the javascript file.\r\n\r\n*fingers crossed*",
      "EditableFormat": "markdown",
      "HTML": "<p>Heh… I thought updating data blocks would be the hard part. So if you decide to add an extra stat to a game later on, or an extra question at character creation, you can still load an older save and it will do the calculations or ask the extra question before proceeding with the game.</p>\n<p>Turns out it's easy. I even worked in a simplified version of my ShowMenu hacks, so that if you call ShowMenu in the update script to ask the player extra questions, it will wait for an answer before running the next update.</p>\n<p>Nearly ready to test now; 704 lines of code, plus 60 in the javascript file.</p>\n<p><em>fingers crossed</em></p>\n\n",
      "PostDate": "2019-10-04T00:02:52.1744918Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "6e88feea-c7f3-484b-bf63-76ba02d176cf",
      "UserId": 277074,
      "Username": "Dcoder",
      "AvatarUrl": "https://i.imgur.com/O07mlRtb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "A challenge worthy of mrangel!",
      "EditableFormat": "markdown",
      "HTML": "<p>A challenge worthy of mrangel!</p>\n\n",
      "PostDate": "2019-10-04T15:04:31.5071037Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b5a9bbf8-f684-443b-8437-c1a14ad630c7",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Oh! This sounds really amazing. \r\n\r\nHow is it different from Save/Load and could any game use it?\r\n\r\nYou could always go the \"typewriter\" route like in Resident Evil where player's are only allowed to save in certain locations? Just a thought :D\r\n\r\nI super appreciate your hard work Mr.Angel. I wouldn't mind paying you for it either on behalf of everyone who uses Quest.\r\n\r\nAnonynn. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Oh! This sounds really amazing.</p>\n<p>How is it different from Save/Load and could any game use it?</p>\n<p>You could always go the \"typewriter\" route like in Resident Evil where player's are only allowed to save in certain locations? Just a thought :D</p>\n<p>I super appreciate your hard work Mr.Angel. I wouldn't mind paying you for it either on behalf of everyone who uses Quest.</p>\n<p>Anonynn.</p>\n\n",
      "PostDate": "2019-10-10T06:32:15.7102647Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "58e0c667-8fdd-4f75-91b1-f451f18047da",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Also, I would love to test it. If it works on my game it'll likely work on every other one lol xD So let me know when you're ready for some guinea pigs!\r\n\r\nAnonynn",
      "EditableFormat": "markdown",
      "HTML": "<p>Also, I would love to test it. If it works on my game it'll likely work on every other one lol xD So let me know when you're ready for some guinea pigs!</p>\n<p>Anonynn</p>\n\n",
      "PostDate": "2019-10-14T22:43:22.9079868Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "00ff3cfc-da39-475b-a867-b65b217c78b5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks :)\r\n\r\nIt'll likely be a while still; I think I'm nearly there, but there's a lot of unit testing needed; especially when it comes to creating and destroying clones, and object attributes.",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks :)</p>\n<p>It'll likely be a while still; I think I'm nearly there, but there's a lot of unit testing needed; especially when it comes to creating and destroying clones, and object attributes.</p>\n\n",
      "PostDate": "2019-10-15T01:41:26.5582685Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c69eb901-9cb6-4087-b319-c6fbd345415d",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ah okay!\r\n\r\nSo a couple of weeks you think? Or maybe less :D Maybe a month? Sorry, I'm super excited about this and can't wait to test it. \r\n\r\nAnonynn. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Ah okay!</p>\n<p>So a couple of weeks you think? Or maybe less :D Maybe a month? Sorry, I'm super excited about this and can't wait to test it.</p>\n<p>Anonynn.</p>\n\n",
      "PostDate": "2019-10-19T09:17:58.8538527Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "6e229411-f144-477e-ac33-082f9988712b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I don't know how long it might be; depends on my health as well as how much time is taken up by ongoing legal issues. At some point I'll have to get a Windows machine set up for testing; and even though I'm somewhere near the end of the initial coding, I have no idea how many issues might show up when I come to test it in different environments.\r\n\r\nI hope I'll have something  in a couple of weeks, but I can't make any promises. Lately it seems that deadlines or people waiting on me cause too much anxiety and my short-term memory goes to pieces, which isn't so conducive to coding. It shouldn't take too long, so long as it's just me and the code; but whether I'll get that much time is another matter.\r\n\r\nOne possible issues is that because I'm saving the state of the game at startup, the memory footprint will increase. I'm hoping this won't be too large an issue.\r\nInitially, I had the function that does this in an `_initialise_` script, but I realise that in a library that will be a problem (because objects initialised after this one may have a different state). So now I'm setting up a room whose enter script triggers initialisation. This means a game creator can either start the player in that room, or move them there after any kind of intro which you want to show before giving the new/load prompt. Then there will be a couple of game attributes to determine which room the player should be sent to on starting a new game (which could either be the actual first room, or a room containing a proper intro).\r\nI'm hoping that won't cause any problems, but it ended up needing a lot more planning than I expected. Hopefully there's no more of those unexpected issues. (I'm also considering a function `SaveStateSafeInit` which can be put into a game's UI Initialisation script, for anyone who wants to use SaveStateLib without making too many modifications to an existing game. It would run savestate initialisation, and wait for the player to choose \"New game\" before running the start scripts and enter scripts for their current location)\r\n\r\nThere's always new things standing in the way, but I think the goal is in sight now :S",
      "EditableFormat": "markdown",
      "HTML": "<p>I don't know how long it might be; depends on my health as well as how much time is taken up by ongoing legal issues. At some point I'll have to get a Windows machine set up for testing; and even though I'm somewhere near the end of the initial coding, I have no idea how many issues might show up when I come to test it in different environments.</p>\n<p>I hope I'll have something  in a couple of weeks, but I can't make any promises. Lately it seems that deadlines or people waiting on me cause too much anxiety and my short-term memory goes to pieces, which isn't so conducive to coding. It shouldn't take too long, so long as it's just me and the code; but whether I'll get that much time is another matter.</p>\n<p>One possible issues is that because I'm saving the state of the game at startup, the memory footprint will increase. I'm hoping this won't be too large an issue.<br>\nInitially, I had the function that does this in an <code>_initialise_</code> script, but I realise that in a library that will be a problem (because objects initialised after this one may have a different state). So now I'm setting up a room whose enter script triggers initialisation. This means a game creator can either start the player in that room, or move them there after any kind of intro which you want to show before giving the new/load prompt. Then there will be a couple of game attributes to determine which room the player should be sent to on starting a new game (which could either be the actual first room, or a room containing a proper intro).<br>\nI'm hoping that won't cause any problems, but it ended up needing a lot more planning than I expected. Hopefully there's no more of those unexpected issues. (I'm also considering a function <code>SaveStateSafeInit</code> which can be put into a game's UI Initialisation script, for anyone who wants to use SaveStateLib without making too many modifications to an existing game. It would run savestate initialisation, and wait for the player to choose \"New game\" before running the start scripts and enter scripts for their current location)</p>\n<p>There's always new things standing in the way, but I think the goal is in sight now :S</p>\n\n",
      "PostDate": "2019-10-20T09:44:29.7200428Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c548ace0-a85d-4665-b1ec-20c8e27be3fc",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Doing some unit testing now, and going really slow… my setup isn't good for something like this.\r\n\r\nBut getting there slowly :)",
      "EditableFormat": "markdown",
      "HTML": "<p>Doing some unit testing now, and going really slow… my setup isn't good for something like this.</p>\n<p>But getting there slowly :)</p>\n\n",
      "PostDate": "2019-10-30T16:35:14.1601392Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "cc8941d1-e00b-4507-ae8f-5ebcf910a0e9",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Sounds incredibly stressful! I'm sorry you're having so many issues IRL :/ To be honest, I wouldn't worry about deadlines or anything. You should always work at your own pace, especially since you're doing this for free and for other people. The only reason I offered to pay you is because I didn't want you to have to worry about money as well >.< \r\n\r\nAs for the Unit Testing --- HURRAH! Is there anything I can help test and get started? \r\n\r\nAnonynn. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Sounds incredibly stressful! I'm sorry you're having so many issues IRL :/ To be honest, I wouldn't worry about deadlines or anything. You should always work at your own pace, especially since you're doing this for free and for other people. The only reason I offered to pay you is because I didn't want you to have to worry about money as well &gt;.&lt;</p>\n<p>As for the Unit Testing --- HURRAH! Is there anything I can help test and get started?</p>\n<p>Anonynn.</p>\n\n",
      "PostDate": "2019-11-02T22:31:55.1930816Z",
      "LastEditDate": "2019-11-03T09:53:35.7782681Z",
      "link": null
    },
    {
      "PostId": "9301dfb6-e6a6-48df-908a-e15b2815c261",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Any good news :D ?",
      "EditableFormat": "markdown",
      "HTML": "<p>Any good news :D ?</p>\n\n",
      "PostDate": "2019-11-16T11:19:18.0290246Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1250dd02-605e-4e9e-8085-be6a62945dbe",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "One step forward, two steps back.\r\n\r\nI was writing the code in Perl and translating it function-by-function into Quest. Mostly because Perl is very good for dealing with large strings. So, once I had the whole thing built in Perl, I could translate the functions into Quest, and then design my unit tests. Basically, a test harness script which runs every function with every possible type of input (for example testing `EncodeNumber` with positive, negative, zero, small numbers, and large numbers). It would then post the results of this to my Perl script on the server side, and confirm that they generate the same code.\r\n\r\nThen I test it the other way; get the Perl code to generate an object model that includes all the quirks of the format, pass it to Quest, and then a Quest script that goes through the created objects and print all their attributes, including the contents of lists and dictionaries.\r\n\r\nSo far, I'd got to testing numbers, strings, booleans, and null. Done the list testing partly, but still with some bugs to work out.\r\n\r\nThen the server lost a hard drive, and I found out that the automatic backups weren't running (and one of my mailservers had failed, meaning that I hadn't been getting daily emails to tell me the backup had failed).\r\n\r\nSo, I've lost all the server-side code. And probably more importantly for such a complex project, all the *comments* were in the Perl code. Replicating that code in Quest makes it so huge and unwieldy that it's hard to follow, so my method was mostly implementing each function in Perl and then converting it line-by-line to make a Quest function that does the same thing. And often, one line of Perl code is twenty lines in Quest, because of the horribly limited replace functionality.\r\n\r\nSo, ironing out the remaining bugs will be a real pain. I would have said that I was about two thirds of the way through the project before the hardware failure; maybe back to halfway now. But I also have a little less time to spend on this, because there's a lot of other things (like my webmail and tax returns) that I also need to do again.\r\n\r\nSo, I'll do my beast, and hope I should have something usable soon enough.\r\n\r\n_(one of the main issues here is that I'm building a robust data format; any features that need to be added in a future version would have to remain compatible, so that players using a newer version of a game will be able to load their existing saves. So I have to make sure there's places in the structure where additional features could be bolted on, even if I'm not implementing those features yet. Resilient code has to be carefully planned, and it's the loss of the notes that's ended up being the biggest problem)_",
      "EditableFormat": "markdown",
      "HTML": "<p>One step forward, two steps back.</p>\n<p>I was writing the code in Perl and translating it function-by-function into Quest. Mostly because Perl is very good for dealing with large strings. So, once I had the whole thing built in Perl, I could translate the functions into Quest, and then design my unit tests. Basically, a test harness script which runs every function with every possible type of input (for example testing <code>EncodeNumber</code> with positive, negative, zero, small numbers, and large numbers). It would then post the results of this to my Perl script on the server side, and confirm that they generate the same code.</p>\n<p>Then I test it the other way; get the Perl code to generate an object model that includes all the quirks of the format, pass it to Quest, and then a Quest script that goes through the created objects and print all their attributes, including the contents of lists and dictionaries.</p>\n<p>So far, I'd got to testing numbers, strings, booleans, and null. Done the list testing partly, but still with some bugs to work out.</p>\n<p>Then the server lost a hard drive, and I found out that the automatic backups weren't running (and one of my mailservers had failed, meaning that I hadn't been getting daily emails to tell me the backup had failed).</p>\n<p>So, I've lost all the server-side code. And probably more importantly for such a complex project, all the <em>comments</em> were in the Perl code. Replicating that code in Quest makes it so huge and unwieldy that it's hard to follow, so my method was mostly implementing each function in Perl and then converting it line-by-line to make a Quest function that does the same thing. And often, one line of Perl code is twenty lines in Quest, because of the horribly limited replace functionality.</p>\n<p>So, ironing out the remaining bugs will be a real pain. I would have said that I was about two thirds of the way through the project before the hardware failure; maybe back to halfway now. But I also have a little less time to spend on this, because there's a lot of other things (like my webmail and tax returns) that I also need to do again.</p>\n<p>So, I'll do my beast, and hope I should have something usable soon enough.</p>\n<p><em>(one of the main issues here is that I'm building a robust data format; any features that need to be added in a future version would have to remain compatible, so that players using a newer version of a game will be able to load their existing saves. So I have to make sure there's places in the structure where additional features could be bolted on, even if I'm not implementing those features yet. Resilient code has to be carefully planned, and it's the loss of the notes that's ended up being the biggest problem)</em></p>\n\n",
      "PostDate": "2019-11-16T12:38:50.1668931Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "00c13634-fffe-4b0d-aa53-480ef88d6384",
      "UserId": 248029,
      "Username": "Anonynn",
      "AvatarUrl": "https://i.imgur.com/HEtnsWqb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Heyo! \r\n\r\nI was just checking to see if any progress has been made or where the Save System is currently. ^_^ Any good news (please say yes)? \r\n\r\nAnonynn. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Heyo!</p>\n<p>I was just checking to see if any progress has been made or where the Save System is currently. ^_^ Any good news (please say yes)?</p>\n<p>Anonynn.</p>\n\n",
      "PostDate": "2019-12-19T03:32:45.7890917Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "43a3c4f6-dbcf-4cd5-8eae-d17854b7f09b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I need to get this moving again, but I ended up pushing everything else onto the back burner while I was struggling to finish _Hunter's War_, and then have collapsed into irrational panic for most of the last week.\r\n\r\nI'm coming to the conclusion that Quest code isn't very readable. Trying to understand what my code does is proving harder than writing it in the first place, so recreating the documentation from the code might turn out to be harder than starting over.\r\nThis will be ready at some point, but don't get your hopes up too soon.\r\n\r\nI'm not sure whether to prioritise working on the save server or the Quest part first. The server is an optional add on; but because I'm working with Perl, it's a lot quicker to try things out on that side. At least I've got the server up and running properly again. And this time it's RAID1, so less likely to lose everything again.",
      "EditableFormat": "markdown",
      "HTML": "<p>I need to get this moving again, but I ended up pushing everything else onto the back burner while I was struggling to finish <em>Hunter's War</em>, and then have collapsed into irrational panic for most of the last week.</p>\n<p>I'm coming to the conclusion that Quest code isn't very readable. Trying to understand what my code does is proving harder than writing it in the first place, so recreating the documentation from the code might turn out to be harder than starting over.<br>\nThis will be ready at some point, but don't get your hopes up too soon.</p>\n<p>I'm not sure whether to prioritise working on the save server or the Quest part first. The server is an optional add on; but because I'm working with Perl, it's a lot quicker to try things out on that side. At least I've got the server up and running properly again. And this time it's RAID1, so less likely to lose everything again.</p>\n\n",
      "PostDate": "2019-12-19T09:57:11.0792367Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "fc131e1e-d85f-4cf0-a2b6-1d387d0bbf9a",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Have you ever come across the Pareto Principle for software development?\r\n\r\nThe first 80% of the code takes the first 80% of the development time.\r\nThe other 20% takes the remaining 80% of the time.\r\nAnd testing takes the final 80% of the time.\r\n\r\n(that's not the actual Pareto Principle, but it's often stated like that. The principle as used in business for planning development timescales is that when you're 80% through the project in terms of lines of code or number of functions implemented, you should assume that's about 20% in terms of devel",
      "EditableFormat": "markdown",
      "HTML": "<p>Have you ever come across the Pareto Principle for software development?</p>\n<p>The first 80% of the code takes the first 80% of the development time.<br>\nThe other 20% takes the remaining 80% of the time.<br>\nAnd testing takes the final 80% of the time.</p>\n<p>(that's not the actual Pareto Principle, but it's often stated like that. The principle as used in business for planning development timescales is that when you're 80% through the project in terms of lines of code or number of functions implemented, you should assume that's about 20% in terms of devel</p>\n\n",
      "PostDate": "2019-12-20T10:14:24.5984283Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "31a41bf5-0537-4976-9388-08b98e27664f",
      "UserId": 277074,
      "Username": "Dcoder",
      "AvatarUrl": "https://i.imgur.com/O07mlRtb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "No matter how long I work on it, my text adventure game is always 90+% done!",
      "EditableFormat": "markdown",
      "HTML": "<p>No matter how long I work on it, my text adventure game is always 90+% done!</p>\n\n",
      "PostDate": "2019-12-20T10:50:57.1708897Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
