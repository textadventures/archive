{
  "Topic": {
    "TopicId": "jmztmqei20s33uxk80wdra",
    "ForumId": "10",
    "Title": "Way to measure decision time?",
    "LastUpdated": "2020-03-12T15:55:42.3396605Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "b28690db-bdff-4f66-a555-8eb89ebc3a35",
      "UserId": 467573,
      "Username": "Odonhay",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hey everyone!\r\nMy name is Haydn and I'm currently a university student in my final year studying sound for games and apps.\r\n\r\nFor one of my final pieces I'm doing an experiment on how different types of music affect the types of decisions a player might make. More specifically, I'm looking to see whether different levels of intensity in music cause players to take more active actions or more passive actions (i.e. will high-tempo music make someone more likely to \"run\" as opposed to \"hide\").\r\n\r\nI decided to use Quest as my testing ground due to the ability to create choose your own adventure stories and having the ability to embed music into the page, which is what made me notice the scripting side of things.\r\nThis gave me an idea; would I be able to measure how long it takes for a person to make a decision?\r\n\r\nI've had a quick look around but as I am not very familiar with the scripting of Quest I was wondering how I would go about making a timer system that would measure how long a person spends on each decision page, and then be able to post the times for each decision at the end?\r\n\r\nIf anyone can help that would be amazing! Thanks in advance!",
      "EditableFormat": "markdown",
      "HTML": "<p>Hey everyone!<br>\nMy name is Haydn and I'm currently a university student in my final year studying sound for games and apps.</p>\n<p>For one of my final pieces I'm doing an experiment on how different types of music affect the types of decisions a player might make. More specifically, I'm looking to see whether different levels of intensity in music cause players to take more active actions or more passive actions (i.e. will high-tempo music make someone more likely to \"run\" as opposed to \"hide\").</p>\n<p>I decided to use Quest as my testing ground due to the ability to create choose your own adventure stories and having the ability to embed music into the page, which is what made me notice the scripting side of things.<br>\nThis gave me an idea; would I be able to measure how long it takes for a person to make a decision?</p>\n<p>I've had a quick look around but as I am not very familiar with the scripting of Quest I was wondering how I would go about making a timer system that would measure how long a person spends on each decision page, and then be able to post the times for each decision at the end?</p>\n<p>If anyone can help that would be amazing! Thanks in advance!</p>\n\n",
      "PostDate": "2020-03-12T15:55:42.3396605Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1c26d98c-ee0c-4249-b406-be499ffb2230",
      "UserId": 282833,
      "Username": "Io",
      "AvatarUrl": "http://i.imgur.com/XVmdocTb.jpg",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "It would technically be possible. You'd rig a timer to Start whenever a decision is presented, and when a decision is made, part of the 'decision made' code would stop the timer. Said timer would tick up a Variable every so-often, and with some dictionary-shenanigens you could assign it to different Decisions.\r\n\r\nI'm not an expert on Dictionaries, though. The syntax confuses me, but go have a look through!",
      "EditableFormat": "markdown",
      "HTML": "<p>It would technically be possible. You'd rig a timer to Start whenever a decision is presented, and when a decision is made, part of the 'decision made' code would stop the timer. Said timer would tick up a Variable every so-often, and with some dictionary-shenanigens you could assign it to different Decisions.</p>\n<p>I'm not an expert on Dictionaries, though. The syntax confuses me, but go have a look through!</p>\n\n",
      "PostDate": "2020-03-12T16:12:12.5177449Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "2961a298-173a-4384-a111-15062edf9657",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "You didn't say if you're using Quest in gamebook or text adventure mode.\r\n\r\nTimers don't work properly in gamebook mode. But I think you could do this in javascript.\r\n\r\nAssuming you're doing this in gamebook mode, you'd want to modify three of the core functions:\r\nYou'd want to add lines to the beginning of the function `HandleCommand` so that it records or otherwise handles the time taken:\r\n<pre><code><b style=\"display: block; border: 1px solid green\">if (IsRegexMatch (\"^\\d+:\", command)) {\r\n  colon = Instr (command, \":\")\r\n  time = ToInt (Left (command, colon))\r\n  command = Trim (Mid (command, colon + 1))\r\n  <em style=\"color: blue; font-family: initial; font-weight: initial\">// Insert whatever code you want here to process or log the time.</em>\r\n  <em style=\"color: blue; font-family: initial; font-weight: initial\">// The variable `command` will be the name of the page clicked on, and `time` will be the time taken</em>\r\n}</b>if (command = \"undo\") {\r\n  // ignore\r\n}\r\nelse {\r\n  newpage = GetObject(command)\r\n  if (newpage = null) {\r\n    msg (\"Error - no page named '\" + command + \"'\")\r\n  }\r\n  else {\r\n    if (not game.clearlastpage and HasAttribute(player.parent, \"options\")) {\r\n      if (DictionaryContains(player.parent.options, command)) {\r\n        optiontext = StringDictionaryItem(player.parent.options, command)\r\n        msg (\"&lt;b>\" + optiontext + \"&lt;/b>\")\r\n        msg (\"\")\r\n      }\r\n      JS.disableAllCommandLinks()\r\n    }\r\n    player.parent = GetObject(command)\r\n  }\r\n}</code></pre>\r\n\r\nThen you need to modify the javascript, so that the frontend interface will measure and send the time taken. You could do this by adding lines to the function `InitInterface`:\r\n<pre></code>if (game.setcustomwidth) {\r\n  JS.setGameWidth(game.customwidth)\r\n}\r\nif (not game.showborder) {\r\n  JS.hideBorder()\r\n}\r\nif (game.setcustompadding) {\r\n  JS.setGamePadding(game.custompaddingtop, game.custompaddingbottom, game.custompaddingleft, game.custompaddingright)\r\n}\r\nSetBackgroundColour(game.defaultbackground)\r\nSetForegroundColour(game.defaultforeground)\r\nSetLinkForegroundColour(game.defaultlinkforeground)\r\nJS.SetMenuBackground(game.menubackground)\r\nJS.SetMenuForeground(game.menuforeground)\r\nJS.SetMenuHoverBackground(game.menuhoverbackground)\r\nJS.SetMenuHoverForeground(game.menuhoverforeground)\r\nJS.SetMenuFontName(game.menufont)\r\nJS.SetMenuFontSize(game.menufontsize + \"pt\")\r\nJS.panesVisible(false)\r\nJS.uiHide(\"#location\")\r\nJS.uiHide(\"#txtCommandDiv\")\r\n<b style=\"border: 1px solid green\">JS.eval(\"$(function(){var e=new Date;$(document).off('click','.commandlink'),$(document).on('click','.commandlink',function(){var a=$(this);if(!a.hasClass('disabled')&&canSendCommand){a.data('deactivateonclick')&&(a.addClass('disabled'),a.data('deactivated',!0));sendCommand((new Date()-e)+':'+a.data('command'))}}),EndOutputSection=function(a){$('.'+a+' .commandlink').length&&(e=new Date);var n=$.inArray(a,_outputSections);-1!=n&&(_outputSections.splice(n,1),createNewDiv('left'))}});\")</b></code></pre>\r\n\r\n(The javascript there is a little hard to read; uncompressed it would look like this:\r\n```\r\n$(function () {\r\n  var decisiontimer = new Date();\r\n  $(document).off(\"click\", \".commandlink\");\r\n  $(document).on(\"click\", \".commandlink\", function () {\r\n    var $this = $(this);\r\n    if (!$this.hasClass(\"disabled\") && canSendCommand) {\r\n      if ($this.data(\"deactivateonclick\")) {\r\n        $this.addClass(\"disabled\");\r\n        $this.data(\"deactivated\", true);\r\n      }\r\n      var timetaken = new Date();\r\n      timetaken -= decisiontimer;\r\n      var cmd = timetaken.toString() + \":\" + $this.data(\"command\");\r\n      sendCommand(cmd);\r\n    }\r\n  });\r\n\r\n  EndOutputSection = function(name) {\r\n    // if this is an \"options\" output section, we restart the timer.\r\n    if ($(\".\"+name+\" .commandlink\").length) {\r\n      decisiontimer = new Date();\r\n    }\r\n    var index = $.inArray(name, _outputSections);\r\n    if (index != -1) {\r\n      _outputSections.splice(index, 1);\r\n      createNewDiv(\"left\");\r\n    }\r\n  };\r\n});\r\n```\r\nThat modifies the javascript so that the string sent to the Quest backend, instead of the name of the page it should be going to, is a string like \"294:page17\".\r\nThe time in this case is in milliseconds, so if you want it in seconds divide by 1000. The timer is reset every time the browser has finished outputting a section which includes a page link, and is recorded when the player clicks on the link. So in the case of the web player, you're not including any lag while the player waits for their response.\r\n\r\nYou could do something similar with a text adventure (I put green boxes around the code I added to those functions; the existing functions are different for TA, but the bits you add should be the same. Although in that case, it would only work for command links, not for other types of input)",
      "EditableFormat": "markdown",
      "HTML": "<p>You didn't say if you're using Quest in gamebook or text adventure mode.</p>\n<p>Timers don't work properly in gamebook mode. But I think you could do this in javascript.</p>\n<p>Assuming you're doing this in gamebook mode, you'd want to modify three of the core functions:<br>\nYou'd want to add lines to the beginning of the function <code>HandleCommand</code> so that it records or otherwise handles the time taken:</p>\n<pre><code><b style=\"display: block; border: 1px solid green\">if (IsRegexMatch (\"^\\d+:\", command)) {\n  colon = Instr (command, \":\")\n  time = ToInt (Left (command, colon))\n  command = Trim (Mid (command, colon + 1))\n  <em style=\"color: blue; font-family: initial; font-weight: initial\">// Insert whatever code you want here to process or log the time.</em>\n  <em style=\"color: blue; font-family: initial; font-weight: initial\">// The variable `command` will be the name of the page clicked on, and `time` will be the time taken</em>\n}</b>if (command = \"undo\") {\n  // ignore\n}\nelse {\n  newpage = GetObject(command)\n  if (newpage = null) {\n    msg (\"Error - no page named '\" + command + \"'\")\n  }\n  else {\n    if (not game.clearlastpage and HasAttribute(player.parent, \"options\")) {\n      if (DictionaryContains(player.parent.options, command)) {\n        optiontext = StringDictionaryItem(player.parent.options, command)\n        msg (\"&lt;b&gt;\" + optiontext + \"&lt;/b&gt;\")\n        msg (\"\")\n      }\n      JS.disableAllCommandLinks()\n    }\n    player.parent = GetObject(command)\n  }\n}</code></pre>\n<p>Then you need to modify the javascript, so that the frontend interface will measure and send the time taken. You could do this by adding lines to the function <code>InitInterface</code>:</p>\n<pre>if (game.setcustomwidth) {\n  JS.setGameWidth(game.customwidth)\n}\nif (not game.showborder) {\n  JS.hideBorder()\n}\nif (game.setcustompadding) {\n  JS.setGamePadding(game.custompaddingtop, game.custompaddingbottom, game.custompaddingleft, game.custompaddingright)\n}\nSetBackgroundColour(game.defaultbackground)\nSetForegroundColour(game.defaultforeground)\nSetLinkForegroundColour(game.defaultlinkforeground)\nJS.SetMenuBackground(game.menubackground)\nJS.SetMenuForeground(game.menuforeground)\nJS.SetMenuHoverBackground(game.menuhoverbackground)\nJS.SetMenuHoverForeground(game.menuhoverforeground)\nJS.SetMenuFontName(game.menufont)\nJS.SetMenuFontSize(game.menufontsize + \"pt\")\nJS.panesVisible(false)\nJS.uiHide(\"#location\")\nJS.uiHide(\"#txtCommandDiv\")\n<b style=\"border: 1px solid green\">JS.eval(\"$(function(){var e=new Date;$(document).off('click','.commandlink'),$(document).on('click','.commandlink',function(){var a=$(this);if(!a.hasClass('disabled')&amp;&amp;canSendCommand){a.data('deactivateonclick')&amp;&amp;(a.addClass('disabled'),a.data('deactivated',!0));sendCommand((new Date()-e)+':'+a.data('command'))}}),EndOutputSection=function(a){$('.'+a+' .commandlink').length&amp;&amp;(e=new Date);var n=$.inArray(a,_outputSections);-1!=n&amp;&amp;(_outputSections.splice(n,1),createNewDiv('left'))}});\")</b></pre>\n<p>(The javascript there is a little hard to read; uncompressed it would look like this:</p>\n<pre><code>$(function () {\n  var decisiontimer = new Date();\n  $(document).off(\"click\", \".commandlink\");\n  $(document).on(\"click\", \".commandlink\", function () {\n    var $this = $(this);\n    if (!$this.hasClass(\"disabled\") &amp;&amp; canSendCommand) {\n      if ($this.data(\"deactivateonclick\")) {\n        $this.addClass(\"disabled\");\n        $this.data(\"deactivated\", true);\n      }\n      var timetaken = new Date();\n      timetaken -= decisiontimer;\n      var cmd = timetaken.toString() + \":\" + $this.data(\"command\");\n      sendCommand(cmd);\n    }\n  });\n\n  EndOutputSection = function(name) {\n    // if this is an \"options\" output section, we restart the timer.\n    if ($(\".\"+name+\" .commandlink\").length) {\n      decisiontimer = new Date();\n    }\n    var index = $.inArray(name, _outputSections);\n    if (index != -1) {\n      _outputSections.splice(index, 1);\n      createNewDiv(\"left\");\n    }\n  };\n});\n</code></pre>\n<p>That modifies the javascript so that the string sent to the Quest backend, instead of the name of the page it should be going to, is a string like \"294:page17\".<br>\nThe time in this case is in milliseconds, so if you want it in seconds divide by 1000. The timer is reset every time the browser has finished outputting a section which includes a page link, and is recorded when the player clicks on the link. So in the case of the web player, you're not including any lag while the player waits for their response.</p>\n<p>You could do something similar with a text adventure (I put green boxes around the code I added to those functions; the existing functions are different for TA, but the bits you add should be the same. Although in that case, it would only work for command links, not for other types of input)</p>\n\n",
      "PostDate": "2020-03-12T18:04:21.0058406Z",
      "LastEditDate": "2020-03-12T18:10:59.7662908Z",
      "link": null
    }
  ]
}
