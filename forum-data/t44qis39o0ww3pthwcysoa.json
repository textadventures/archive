{
  "Topic": {
    "TopicId": "t44qis39o0ww3pthwcysoa",
    "ForumId": "10",
    "Title": "Thoughts about the grid map",
    "LastUpdated": "2020-10-28T16:00:20.629449Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "6addffe3-0e10-4da7-9602-b8c1bfa911f5",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I've been thinking about the way Quest handles the grid map; and realising that the code is quite inefficient. Now, looping over all the exits in the game every time a player enters a room might not seem like a lot of work, but for the webserver that's running so many games at once, I think this could be putting quite a load on it.\r\n\r\nSo I'm wondering if it might be possible to write a function which calculates the coordinates of all rooms, without so many loops necessary. I'm doing this by introducing the concept of 'worlds'; a group of rooms which are connected to each other by directional exits.\r\n\r\nEach world will be named after the first room in it, and worlds will be merged when a room appears in more than one.\r\nAs there isn't an easy way to distinguish between an object and a room, I'll use the presence of exits to decide what is a room.\r\n\r\nI'll give each room a set of attributes: `grid_x`, `grid_y`, `grid_z`, and `grid_w`, as accessing these is faster than looking stuff up in a tree of dictionaries.\r\n```\r\n// a dictionary of which rooms are in each world; the key is the world name and the value is a list of rooms\r\nrooms_by_world = NewDictionary()\r\n\r\n// now let's make the map\r\nforeach (exit, AllExits()) {\r\n  // We only care about directional exits that connect two rooms\r\n  if (DoesInherit (exit, \"direction\") and HasObject (exit, \"parent\") and HasObject (exit, \"to\")) {\r\n    from = exit.parent\r\n    to = exit.to\r\n\r\n    if (HasString (from, \"grid_w\")) {\r\n      // We have coords for the source room\r\n      //   we only need to do anything if the rooms aren't already connected\r\n      if (not Equals (from.grid_w, to.grid_w)) {\r\n        worldlist = DictionaryItem (rooms_by_world, from.grid_w)\r\n        xpos = from.grid_x + Grid_CalculateCoordinateOffsetX (from, exit, to)\r\n        ypos = from.grid_y + Grid_CalculateCoordinateOffsetY (from, exit, to)\r\n        zpos = from.grid_z + Grid_CalculateCoordinateOffsetZ (from, exit, to)\r\n\r\n        if (HasString (to, \"grid_w\")) {\r\n          // we already have a map for the destination room, so link the whole map together\r\n          //   but move the smaller map, for speed\r\n          otherworldlist = DictionaryItem (rooms_by_world, to.grid_w)\r\n          if (ListCount(worldlist) > ListCount (otherworldlist)) {\r\n            xoffset = xpos - to.grid_x\r\n            yoffset = ypos - to.grid_y\r\n            zoffset = zpos - to.grid_z\r\n            worldname = from.grid_w\r\n            rooms_to_move = otherworldlist\r\n            dictionary remove (rooms_by_world, to.grid_w)\r\n          }\r\n          else {\r\n            xoffset = to.grid_x - xpos\r\n            yoffset = to.grid_y - ypos\r\n            zoffset = to.grid_z - zpos\r\n            worldname = to.grid_w\r\n            rooms_to_move = worldlist\r\n            dictionary remove (rooms_by_world, from.grid_w)\r\n          }\r\n          foreach (room, rooms_to_move) {\r\n            room.grid_w = worldname\r\n            room.grid_x = room.grid_x + xoffset\r\n            room.grid_y = room.grid_y + yoffset\r\n            room.grid_z = room.grid_z + zoffset\r\n            list add (worldlist, room)\r\n          }\r\n        }\r\n        else {\r\n          // destination room is new\r\n          to.grid_w = from.grid_w\r\n          to.grid_x = xpos\r\n          to.grid_y = ypos\r\n          to.grid_z = zpos\r\n          list add (worldlist, to)\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (HasString (to, \"grid_w\")) {\r\n        worldlist = DictionaryItem (rooms_by_world, to.grid_w)\r\n      }\r\n      else {\r\n        // both rooms are new to us, so we add the destination to the map\r\n        to.grid_w = to.name\r\n        to.grid_x = 0\r\n        to.grid_y = 0\r\n        to.grid_z = 0\r\n        worldlist = NewObjectList()\r\n        list add (worldlist, to)\r\n        dictionary add (rooms_by_world, to.name, worldlist)\r\n      }\r\n      // we have the destination room, but not the source\r\n      from.grid_w = to.grid_w\r\n      from.grid_x = to.grid_x - Grid_CalculateCoordinateOffsetX (from, exit, to)\r\n      from.grid_y = to.grid_y - Grid_CalculateCoordinateOffsetY (from, exit, to)\r\n      from.grid_z = to.grid_z - Grid_CalculateCoordinateOffsetZ (from, exit, to)\r\n      list add (worldlist, from)\r\n\r\n      // For convenience, give each room a list of its exits\r\n      from.grid_exits = NewObjectList()\r\n    }\r\n    list add (from.grid_exits, exit)\r\n  }\r\n}\r\n```\r\n\r\nWith a couple of functions to do the actual calculation:\r\n```\r\n<function name=\"Grid_CalculateCoordinateOffsetX\" parameters=\"from, exit, to\" type=\"double\">\r\n  foreach (direction, Split(\"east;west;northeast;northwest;southeast;southwest\")) {\r\n    if (DoesInherit (exit, direction+\"direction\")) {\r\n      if (EndsWith (direction, \"east\")) {\r\n        exit.grid_offset_x = from.grid_width\r\n        exit.grid_end_x = 0\r\n        return (0 - exit.grid_length - to.grid_width)\r\n      }\r\n      else if (EndsWith (direction, \"west\")) {\r\n        exit.grid_offset_x = 0\r\n        exit.grid_end_x = to.grid_width\r\n        return (exit.grid_length + from.grid_width)\r\n      }\r\n    }\r\n  }\r\n  exit.grid_offset_x = from.grid_width / 2.0\r\n  exit.grid_end_x = to.grid_width / 2.0\r\n  return ((from.grid_width - to.grid_width) / 2.0)\r\n</function>\r\n\r\n<function name=\"Grid_CalculateCoordinateOffsetY\" parameters=\"from, exit, to\" type=\"double\">\r\n  foreach (direction, Split(\"north;south;northeast;northwest;southeast;southwest\")) {\r\n    if (DoesInherit (exit, direction+\"direction\")) {\r\n      if (StartsWith (direction, \"north\")) {\r\n        exit.grid_offset_y = from.grid_length\r\n        exit.grid_end_y = 0\r\n        return (0 - exit.grid_length - to.grid_length)\r\n      }\r\n      else if (StartsWith (direction, \"south\")) {\r\n        exit.grid_offset_y = 0\r\n        exit.grid_end_y = to.grid_length\r\n        return (exit.grid_length + from.grid_length)\r\n      }\r\n    }\r\n  }\r\n  exit.grid_offset_y = from.grid_length / 2.0\r\n  exit.grid_end_y = to.grid_length / 2.0\r\n  return ((from.grid_length - to.grid_length) / 2.0)\r\n</function>\r\n\r\n<function name=\"Grid_CalculateCoordinateOffsetZ\" parameters=\"from, exit, to\" type=\"double\">\r\n  if (DoesInherit (exit, \"downdirection\")) {\r\n    return (-exit.grid_length)\r\n  }\r\n  else if (DoesInherit (exit, \"updirection\")) {\r\n    return (exit.grid_length)\r\n  }\r\n  else {\r\n    return (0)\r\n  }\r\n</function>\r\n```\r\n\r\nThen when the coordinates of a room are needed, we can just look them up:\r\n```\r\n<function name=\"Grid_CalculateMapCoordinates\" parameters=\"room, playerobject\">\r\n  if (not HasString (room, \"grid_w\")) {\r\n    // This room isn't on the map, so we add it. Maybe the player got teleported into an unconnected room?\r\n    // or the map has been dynamically modified?\r\n    // First try regeneration the map using the big function above:\r\n    Grid_CalculateAllCoordinates()\r\n\r\n    // And if that didn't work, the room really has no exits, so we make a solitary room and clear the map\r\n    if (not HasString (room, \"grid_w\")) {\r\n      room.grid_w = room.name\r\n      room.grid_x = 0\r\n      room.grid_y = 0\r\n      room.grid_z = 0\r\n    }\r\n  }\r\n\r\n  // Just to make sure, in case the player teleported\r\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"x\", room.grid_x)\r\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"y\", room.grid_y)\r\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"z\", room.grid_z)\r\n  room.grid_render = true\r\n\r\n  foreach (exit, room.grid_exits) {\r\n    // coords for the adjacent room\r\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"x\", exit.to.grid_x)\r\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"y\", exit.to.grid_y)\r\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"z\", exit.to.grid_z)\r\n    exit.to.grid_render = true\r\n    if (DoesInherit (exit, \"compassdirection\") and not GetBoolean (exit, \"grid_render\")) {\r\n      // and for the exit\r\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"x\", room.grid_x + exit.grid_offset_x)\r\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"y\", room.grid_y + exit.grid_offset_y)\r\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_x\", exit.to.grid_x + exit.grid_end_x)\r\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_y\", exit.to.grid_y + exit.grid_end_y)\r\n      exit.grid_render = true\r\n    }\r\n  }\r\n</function>\r\n```\r\n\r\nStill a work in progress… and has the disadvantage that you'll have to regenerate the map if an exit moves. But I think it makes more sense to do it this way.",
      "EditableFormat": "markdown",
      "HTML": "<p>I've been thinking about the way Quest handles the grid map; and realising that the code is quite inefficient. Now, looping over all the exits in the game every time a player enters a room might not seem like a lot of work, but for the webserver that's running so many games at once, I think this could be putting quite a load on it.</p>\n<p>So I'm wondering if it might be possible to write a function which calculates the coordinates of all rooms, without so many loops necessary. I'm doing this by introducing the concept of 'worlds'; a group of rooms which are connected to each other by directional exits.</p>\n<p>Each world will be named after the first room in it, and worlds will be merged when a room appears in more than one.<br>\nAs there isn't an easy way to distinguish between an object and a room, I'll use the presence of exits to decide what is a room.</p>\n<p>I'll give each room a set of attributes: <code>grid_x</code>, <code>grid_y</code>, <code>grid_z</code>, and <code>grid_w</code>, as accessing these is faster than looking stuff up in a tree of dictionaries.</p>\n<pre><code>// a dictionary of which rooms are in each world; the key is the world name and the value is a list of rooms\nrooms_by_world = NewDictionary()\n\n// now let's make the map\nforeach (exit, AllExits()) {\n  // We only care about directional exits that connect two rooms\n  if (DoesInherit (exit, \"direction\") and HasObject (exit, \"parent\") and HasObject (exit, \"to\")) {\n    from = exit.parent\n    to = exit.to\n\n    if (HasString (from, \"grid_w\")) {\n      // We have coords for the source room\n      //   we only need to do anything if the rooms aren't already connected\n      if (not Equals (from.grid_w, to.grid_w)) {\n        worldlist = DictionaryItem (rooms_by_world, from.grid_w)\n        xpos = from.grid_x + Grid_CalculateCoordinateOffsetX (from, exit, to)\n        ypos = from.grid_y + Grid_CalculateCoordinateOffsetY (from, exit, to)\n        zpos = from.grid_z + Grid_CalculateCoordinateOffsetZ (from, exit, to)\n\n        if (HasString (to, \"grid_w\")) {\n          // we already have a map for the destination room, so link the whole map together\n          //   but move the smaller map, for speed\n          otherworldlist = DictionaryItem (rooms_by_world, to.grid_w)\n          if (ListCount(worldlist) &gt; ListCount (otherworldlist)) {\n            xoffset = xpos - to.grid_x\n            yoffset = ypos - to.grid_y\n            zoffset = zpos - to.grid_z\n            worldname = from.grid_w\n            rooms_to_move = otherworldlist\n            dictionary remove (rooms_by_world, to.grid_w)\n          }\n          else {\n            xoffset = to.grid_x - xpos\n            yoffset = to.grid_y - ypos\n            zoffset = to.grid_z - zpos\n            worldname = to.grid_w\n            rooms_to_move = worldlist\n            dictionary remove (rooms_by_world, from.grid_w)\n          }\n          foreach (room, rooms_to_move) {\n            room.grid_w = worldname\n            room.grid_x = room.grid_x + xoffset\n            room.grid_y = room.grid_y + yoffset\n            room.grid_z = room.grid_z + zoffset\n            list add (worldlist, room)\n          }\n        }\n        else {\n          // destination room is new\n          to.grid_w = from.grid_w\n          to.grid_x = xpos\n          to.grid_y = ypos\n          to.grid_z = zpos\n          list add (worldlist, to)\n        }\n      }\n    }\n    else {\n      if (HasString (to, \"grid_w\")) {\n        worldlist = DictionaryItem (rooms_by_world, to.grid_w)\n      }\n      else {\n        // both rooms are new to us, so we add the destination to the map\n        to.grid_w = to.name\n        to.grid_x = 0\n        to.grid_y = 0\n        to.grid_z = 0\n        worldlist = NewObjectList()\n        list add (worldlist, to)\n        dictionary add (rooms_by_world, to.name, worldlist)\n      }\n      // we have the destination room, but not the source\n      from.grid_w = to.grid_w\n      from.grid_x = to.grid_x - Grid_CalculateCoordinateOffsetX (from, exit, to)\n      from.grid_y = to.grid_y - Grid_CalculateCoordinateOffsetY (from, exit, to)\n      from.grid_z = to.grid_z - Grid_CalculateCoordinateOffsetZ (from, exit, to)\n      list add (worldlist, from)\n\n      // For convenience, give each room a list of its exits\n      from.grid_exits = NewObjectList()\n    }\n    list add (from.grid_exits, exit)\n  }\n}\n</code></pre>\n<p>With a couple of functions to do the actual calculation:</p>\n<pre><code>&lt;function name=\"Grid_CalculateCoordinateOffsetX\" parameters=\"from, exit, to\" type=\"double\"&gt;\n  foreach (direction, Split(\"east;west;northeast;northwest;southeast;southwest\")) {\n    if (DoesInherit (exit, direction+\"direction\")) {\n      if (EndsWith (direction, \"east\")) {\n        exit.grid_offset_x = from.grid_width\n        exit.grid_end_x = 0\n        return (0 - exit.grid_length - to.grid_width)\n      }\n      else if (EndsWith (direction, \"west\")) {\n        exit.grid_offset_x = 0\n        exit.grid_end_x = to.grid_width\n        return (exit.grid_length + from.grid_width)\n      }\n    }\n  }\n  exit.grid_offset_x = from.grid_width / 2.0\n  exit.grid_end_x = to.grid_width / 2.0\n  return ((from.grid_width - to.grid_width) / 2.0)\n&lt;/function&gt;\n\n&lt;function name=\"Grid_CalculateCoordinateOffsetY\" parameters=\"from, exit, to\" type=\"double\"&gt;\n  foreach (direction, Split(\"north;south;northeast;northwest;southeast;southwest\")) {\n    if (DoesInherit (exit, direction+\"direction\")) {\n      if (StartsWith (direction, \"north\")) {\n        exit.grid_offset_y = from.grid_length\n        exit.grid_end_y = 0\n        return (0 - exit.grid_length - to.grid_length)\n      }\n      else if (StartsWith (direction, \"south\")) {\n        exit.grid_offset_y = 0\n        exit.grid_end_y = to.grid_length\n        return (exit.grid_length + from.grid_length)\n      }\n    }\n  }\n  exit.grid_offset_y = from.grid_length / 2.0\n  exit.grid_end_y = to.grid_length / 2.0\n  return ((from.grid_length - to.grid_length) / 2.0)\n&lt;/function&gt;\n\n&lt;function name=\"Grid_CalculateCoordinateOffsetZ\" parameters=\"from, exit, to\" type=\"double\"&gt;\n  if (DoesInherit (exit, \"downdirection\")) {\n    return (-exit.grid_length)\n  }\n  else if (DoesInherit (exit, \"updirection\")) {\n    return (exit.grid_length)\n  }\n  else {\n    return (0)\n  }\n&lt;/function&gt;\n</code></pre>\n<p>Then when the coordinates of a room are needed, we can just look them up:</p>\n<pre><code>&lt;function name=\"Grid_CalculateMapCoordinates\" parameters=\"room, playerobject\"&gt;\n  if (not HasString (room, \"grid_w\")) {\n    // This room isn't on the map, so we add it. Maybe the player got teleported into an unconnected room?\n    // or the map has been dynamically modified?\n    // First try regeneration the map using the big function above:\n    Grid_CalculateAllCoordinates()\n\n    // And if that didn't work, the room really has no exits, so we make a solitary room and clear the map\n    if (not HasString (room, \"grid_w\")) {\n      room.grid_w = room.name\n      room.grid_x = 0\n      room.grid_y = 0\n      room.grid_z = 0\n    }\n  }\n\n  // Just to make sure, in case the player teleported\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"x\", room.grid_x)\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"y\", room.grid_y)\n  Grid_SetGridCoordinateForPlayer (playerobject, room, \"z\", room.grid_z)\n  room.grid_render = true\n\n  foreach (exit, room.grid_exits) {\n    // coords for the adjacent room\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"x\", exit.to.grid_x)\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"y\", exit.to.grid_y)\n    Grid_SetGridCoordinateForPlayer (playerobject, exit.to, \"z\", exit.to.grid_z)\n    exit.to.grid_render = true\n    if (DoesInherit (exit, \"compassdirection\") and not GetBoolean (exit, \"grid_render\")) {\n      // and for the exit\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"x\", room.grid_x + exit.grid_offset_x)\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"y\", room.grid_y + exit.grid_offset_y)\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_x\", exit.to.grid_x + exit.grid_end_x)\n      Grid_SetGridCoordinateForPlayer (playerobject, exit, \"end_y\", exit.to.grid_y + exit.grid_end_y)\n      exit.grid_render = true\n    }\n  }\n&lt;/function&gt;\n</code></pre>\n<p>Still a work in progress… and has the disadvantage that you'll have to regenerate the map if an exit moves. But I think it makes more sense to do it this way.</p>\n\n",
      "PostDate": "2020-10-28T16:00:20.629449Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
