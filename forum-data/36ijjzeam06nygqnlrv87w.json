{
  "Topic": {
    "TopicId": "36ijjzeam06nygqnlrv87w",
    "ForumId": "15",
    "Title": "Quest 6 technical suggestion - Make iterations for certain types of object more efficient, with subsets of world/w",
    "LastUpdated": "2021-06-13T13:34:22.7414549Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "a422b6e2-59fc-4304-9dfd-2b94fe75ea1d",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I have always noticed that Quest 6 iterates often in the world dictionary _w_, where all the items are stored. Sometimes several times during a turn.\r\n\r\nI think it would be a good practice to isolate specific types of objects in sub-dictionaries. Looping on specific elements, such as rooms or NPCs, would be much faster and less ressource consuming.\r\n\r\nThe process would basically be:\r\n**createRoom()**\r\nInstead of going into _w_, the function populates a _roomDict_ dictionary instead. Every reference to _w_ in the code would become a reference to _roomDict_, which would skip the iteration over non-room items, for instance when drawing a map.\r\n\r\n**createItem()**\r\nAfter _w_ is built, do a single loop on the dictionary. Using the flag identifying the type of the item (npc=true for instance),  instanciate a new dictionary and populate it. The functions related to this specific type of object can now reference this dictionary instead of _w_\r\n\r\n**Useful standard subsets to have around**\r\n* Rooms\r\n* NPCs\r\n* Wearables\r\n* Keys\r\n\r\n**How to manage loc properties**\r\nLocations can be either a room or a npc. In which case the solution is simple: check both the room and npc subsets, instead of the _w_ subset. Even if it is two subsets instead of a single larger one, their combined sum of elements will be either inferior or equivalent to _w_.\r\nTo make it even more efficient, you could also add a flag indicating whether the item is currently in a room or in a NPC's inventory.\r\n\r\n**Custom subsets**\r\nWhile there would be a limited number of standard dictionaries from the onset, such as _roomDict_ or _npcDict_, the player/developer could create its own custom dictionaries, for its custom rules and scripts.\r\nThe player would call a specific settings function. Each line of the function would look like this, for instance\r\n`monsterDict = populateSubWorld(\"isMonster\", true )`\r\nThe _populateSubWorld_ function would be defined as such:\r\n```\r\npopulateSubWorld(propertyName, propertyCondition) {\r\nlet newDict = {}\r\nfor (let key in w) {\r\n  if (w[key][propertyName] == propertyCondition) {\r\n    newDict[key] = w[key]\r\n]\r\nreturn newDict\r\n}\r\n```\r\nWith a little more brainstorming, there might be a possibility to give more conditions to test.\r\nThese custom subsets are implied to be for the player/dev's use only, and are not supported by the standard functions of the framework.",
      "EditableFormat": "markdown",
      "HTML": "<p>I have always noticed that Quest 6 iterates often in the world dictionary <em>w</em>, where all the items are stored. Sometimes several times during a turn.</p>\n<p>I think it would be a good practice to isolate specific types of objects in sub-dictionaries. Looping on specific elements, such as rooms or NPCs, would be much faster and less ressource consuming.</p>\n<p>The process would basically be:<br>\n<strong>createRoom()</strong><br>\nInstead of going into <em>w</em>, the function populates a <em>roomDict</em> dictionary instead. Every reference to <em>w</em> in the code would become a reference to <em>roomDict</em>, which would skip the iteration over non-room items, for instance when drawing a map.</p>\n<p><strong>createItem()</strong><br>\nAfter <em>w</em> is built, do a single loop on the dictionary. Using the flag identifying the type of the item (npc=true for instance),  instanciate a new dictionary and populate it. The functions related to this specific type of object can now reference this dictionary instead of <em>w</em></p>\n<p><strong>Useful standard subsets to have around</strong></p>\n<ul>\n<li>Rooms</li>\n<li>NPCs</li>\n<li>Wearables</li>\n<li>Keys</li>\n</ul>\n<p><strong>How to manage loc properties</strong><br>\nLocations can be either a room or a npc. In which case the solution is simple: check both the room and npc subsets, instead of the <em>w</em> subset. Even if it is two subsets instead of a single larger one, their combined sum of elements will be either inferior or equivalent to <em>w</em>.<br>\nTo make it even more efficient, you could also add a flag indicating whether the item is currently in a room or in a NPC's inventory.</p>\n<p><strong>Custom subsets</strong><br>\nWhile there would be a limited number of standard dictionaries from the onset, such as <em>roomDict</em> or <em>npcDict</em>, the player/developer could create its own custom dictionaries, for its custom rules and scripts.<br>\nThe player would call a specific settings function. Each line of the function would look like this, for instance<br>\n<code>monsterDict = populateSubWorld(\"isMonster\", true )</code><br>\nThe <em>populateSubWorld</em> function would be defined as such:</p>\n<pre><code>populateSubWorld(propertyName, propertyCondition) {\nlet newDict = {}\nfor (let key in w) {\n  if (w[key][propertyName] == propertyCondition) {\n    newDict[key] = w[key]\n]\nreturn newDict\n}\n</code></pre>\n<p>With a little more brainstorming, there might be a possibility to give more conditions to test.<br>\nThese custom subsets are implied to be for the player/dev's use only, and are not supported by the standard functions of the framework.</p>\n\n",
      "PostDate": "2021-06-13T13:34:22.7414549Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "49911c2d-c763-4b7a-9f72-2b457dd86658",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "If you want to access something by name, there's no benefit to having a separate array. `monsterDict[\"troll4\"]` is no faster than `w[\"troll4\"]`, and having everything in the same dictionary means there's less chance of some library author producing code that doesn't work properly with other object types.\r\n\r\nLooping over a list, however, is a valid use. But for something like that, there's no need to make it a dictionary. It's faster to loop over an array (unless they've optimised it since the last time I checked).\r\n\r\nSo why not make your subworlds simple arrays?\r\n\r\nThen you don't really need to create a new function for something JS already does well. But if you really want a function like the one you suggested (just returning an array rather than a dict, you could do:\r\n```\r\nfunction populateSubWorld(propertyName, propertyCondition) {\r\n  return w.values().filter(a => a[propertyName] == propertyCondition)\r\n}\r\n```\r\nalthough I'd be more likely to write it as:\r\n```\r\nfunction populateSubWorld(propertyName, propertyCondition) {\r\n    return w.values().filter(\r\n      (propertyCondition === undefined) ?\r\n        (a => propertyName in a) :\r\n        (a => a[propertyName] == propertyCondition\r\n      )\r\n    )\r\n}\r\n```\r\nso that `monsterList = populateSubWorld(\"isMonster\")` with a single parameter will get a list of everything that has that property, a little faster than checking for a specific value.",
      "EditableFormat": "markdown",
      "HTML": "<p>If you want to access something by name, there's no benefit to having a separate array. <code>monsterDict[\"troll4\"]</code> is no faster than <code>w[\"troll4\"]</code>, and having everything in the same dictionary means there's less chance of some library author producing code that doesn't work properly with other object types.</p>\n<p>Looping over a list, however, is a valid use. But for something like that, there's no need to make it a dictionary. It's faster to loop over an array (unless they've optimised it since the last time I checked).</p>\n<p>So why not make your subworlds simple arrays?</p>\n<p>Then you don't really need to create a new function for something JS already does well. But if you really want a function like the one you suggested (just returning an array rather than a dict, you could do:</p>\n<pre><code>function populateSubWorld(propertyName, propertyCondition) {\n  return w.values().filter(a =&gt; a[propertyName] == propertyCondition)\n}\n</code></pre>\n<p>although I'd be more likely to write it as:</p>\n<pre><code>function populateSubWorld(propertyName, propertyCondition) {\n    return w.values().filter(\n      (propertyCondition === undefined) ?\n        (a =&gt; propertyName in a) :\n        (a =&gt; a[propertyName] == propertyCondition\n      )\n    )\n}\n</code></pre>\n<p>so that <code>monsterList = populateSubWorld(\"isMonster\")</code> with a single parameter will get a list of everything that has that property, a little faster than checking for a specific value.</p>\n\n",
      "PostDate": "2021-06-13T17:07:34.9987823Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9a056177-6d92-4993-b579-dc173d55ff2a",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "What I want to solve is functions like \"isHereNotHeld\" or \"map.update()\" who iterate over the whole w dictionary, to find the comparatively much smaller list of items fitting the criterium of the function (respectively anything which has `this.loc == player.loc`, and items where `if (room.mapRegion !== region && room.mapRegion !== true)`\r\n\r\nIf you have just four rooms and ten items, this is relatively quick, but imagine if, after two years of development, you have sixty rooms, fifty NPCs, and a hundred fifty items of different types.\r\n\r\nArrays could be another solution, considering that this is an attempt to solve a loop issue.\r\n\r\nBut what I want to push is that I think that there may be optimization issues with turn scripts down the line, with everything being stored in a single dictionary, and thinking with subsets of world would be something to consider.",
      "EditableFormat": "markdown",
      "HTML": "<p>What I want to solve is functions like \"isHereNotHeld\" or \"map.update()\" who iterate over the whole w dictionary, to find the comparatively much smaller list of items fitting the criterium of the function (respectively anything which has <code>this.loc == player.loc</code>, and items where <code>if (room.mapRegion !== region &amp;&amp; room.mapRegion !== true)</code></p>\n<p>If you have just four rooms and ten items, this is relatively quick, but imagine if, after two years of development, you have sixty rooms, fifty NPCs, and a hundred fifty items of different types.</p>\n<p>Arrays could be another solution, considering that this is an attempt to solve a loop issue.</p>\n<p>But what I want to push is that I think that there may be optimization issues with turn scripts down the line, with everything being stored in a single dictionary, and thinking with subsets of world would be something to consider.</p>\n\n",
      "PostDate": "2021-06-13T20:34:10.5720252Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "10dde2a5-bb4b-4f23-9ff0-1b83f06ff69f",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Sorry for the long response… I've been thinking way too hard about program efficiency today, as I've been working on a very slow piece of code today. Waiting for my computer to loop over an array of billions of objects gets tedious very fast; so on a project like that, every tiny change to improve efficiency makes a difference.\r\n\r\nNow I just can't get my mind out of efficiency mode, trying to work out what's the \"best\" way to do something.\r\n\r\n> What I want to solve is functions like \"isHereNotHeld\" or \"map.update()\" who iterate over the whole w dictionary, to find the comparatively much smaller list of items fitting the criterium of the function (respectively anything which has this.loc == player.loc, and items where if (room.mapRegion !== region && room.mapRegion !== true)\r\n\r\nI think that having a separate list for things like that could  make a search faster… but you'd have to remember to update those lists every time an object moves, or every time the player moves. It's easier to make a mistake; as well as being extra operations. Which is more efficient could well vary from one project to another; it's hard to say.\r\n\r\n> If you have just four rooms and ten items, this is relatively quick, but imagine if, after two years of development, you have sixty rooms, fifty NPCs, and a hundred fifty items of different types.\r\n\r\nI like to make my code more efficient if I can (for example, a 20% time saving by using an array rather than a dictionary). But I am well aware that in most situations it really doesn't matter, because a function like that will appear to be instant to a human observer unless the number of objects in your game is very large (For simple filter functions like the ones you reference, it's likely to be \"faster than the eye can see\" until you get to around fifty thousand objects. Or a million on a really fast PC)\r\n\r\nIf you want to optimise the code, it's probably better to look at the functions that are O(N²); they'll slow down at much lower numbers.",
      "EditableFormat": "markdown",
      "HTML": "<p>Sorry for the long response… I've been thinking way too hard about program efficiency today, as I've been working on a very slow piece of code today. Waiting for my computer to loop over an array of billions of objects gets tedious very fast; so on a project like that, every tiny change to improve efficiency makes a difference.</p>\n<p>Now I just can't get my mind out of efficiency mode, trying to work out what's the \"best\" way to do something.</p>\n<blockquote>\n<p>What I want to solve is functions like \"isHereNotHeld\" or \"map.update()\" who iterate over the whole w dictionary, to find the comparatively much smaller list of items fitting the criterium of the function (respectively anything which has this.loc == player.loc, and items where if (room.mapRegion !== region &amp;&amp; room.mapRegion !== true)</p>\n</blockquote>\n<p>I think that having a separate list for things like that could  make a search faster… but you'd have to remember to update those lists every time an object moves, or every time the player moves. It's easier to make a mistake; as well as being extra operations. Which is more efficient could well vary from one project to another; it's hard to say.</p>\n<blockquote>\n<p>If you have just four rooms and ten items, this is relatively quick, but imagine if, after two years of development, you have sixty rooms, fifty NPCs, and a hundred fifty items of different types.</p>\n</blockquote>\n<p>I like to make my code more efficient if I can (for example, a 20% time saving by using an array rather than a dictionary). But I am well aware that in most situations it really doesn't matter, because a function like that will appear to be instant to a human observer unless the number of objects in your game is very large (For simple filter functions like the ones you reference, it's likely to be \"faster than the eye can see\" until you get to around fifty thousand objects. Or a million on a really fast PC)</p>\n<p>If you want to optimise the code, it's probably better to look at the functions that are O(N²); they'll slow down at much lower numbers.</p>\n\n",
      "PostDate": "2021-06-13T22:40:41.1896715Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "ef77be17-6b6c-4b16-b012-07e816dc91cc",
      "UserId": 215742,
      "Username": "Kln",
      "AvatarUrl": "https://secure.gravatar.com/avatar/031273026f596d006f35f260c1e95bbf?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Thanks for your input.\r\nWaiting times around lists and loops is something I encountered in every project I worked on myself, and one of the issues where a single change has the most dramatic effects, as you say. For instance, searching for an element among many in a set rather than a list can make the duration of a program go from hours down to minutes. Same for using a fork/join to traverse your array instead of a single iterator.",
      "EditableFormat": "markdown",
      "HTML": "<p>Thanks for your input.<br>\nWaiting times around lists and loops is something I encountered in every project I worked on myself, and one of the issues where a single change has the most dramatic effects, as you say. For instance, searching for an element among many in a set rather than a list can make the duration of a program go from hours down to minutes. Same for using a fork/join to traverse your array instead of a single iterator.</p>\n\n",
      "PostDate": "2021-06-14T05:40:56.8366212Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
