{
  "Topic": {
    "TopicId": "qc6amqt4xeuotqoj7t46vq",
    "ForumId": "10",
    "Title": "If I only had a brain. . . (I need some Regex help)",
    "LastUpdated": "2021-05-15T22:13:47.2490103Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "cbc69d06-4550-4c43-85cd-f91229762922",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Hello.\r\n\r\nFirst, I know I've been all over the place, asking about all sorts of stuff, and I haven't responded to some of those threads in a day or two, but I will. I'm working on a big port, and all those things must be included. So, I'm not just all over the place for no reason. I have good reason to be all over the place.  :o)\r\n\r\nOkay. . .\r\n\r\nI know there's an easy way to do this with RegEx, but I'm not good at that.\r\n\r\nLet's say I have this \"formula\":\r\n\r\n```\r\n  <PLTABLE\r\n  \"THE GAME\"\r\n  <LTABLE 3\r\n  \"How do I play this game?\"\r\n  \"Try typing things on your keyboard.\"\r\n  \"If that doesn't work, go ask your mom.\">\r\n  <LTABLE 3\r\n  \"How do I stop the bunny people from stealing my carrots?\"\r\n  \"You can't.\">>\r\n  <PLTABLE\r\n  \"THE AUTHOR\"\r\n  <LTABLE 3\r\n  \"Why does K.V. suck at regular expression stuff?\"\r\n  \"Try asking, \\\"K.V., why do you suck?\\\"\"\r\n  \"No one knows.\"\r\n  \"Maybe he was born that way.\">>\r\n\r\n```\r\n\r\n---\r\nThere's no telling how many topics there will be, no telling how many answers there will be, and no telling how many questions there will be, but there will be at least one of each.\r\n\r\nThere's also no telling how much whitespace there will be outside of the ```\"\"```. There's always only one line break, though.\r\n\r\nWhat's the best way to turn this into a dictionary of lists or something?",
      "EditableFormat": "markdown",
      "HTML": "<p>Hello.</p>\n<p>First, I know I've been all over the place, asking about all sorts of stuff, and I haven't responded to some of those threads in a day or two, but I will. I'm working on a big port, and all those things must be included. So, I'm not just all over the place for no reason. I have good reason to be all over the place.  :o)</p>\n<p>Okay. . .</p>\n<p>I know there's an easy way to do this with RegEx, but I'm not good at that.</p>\n<p>Let's say I have this \"formula\":</p>\n<pre><code>  &lt;PLTABLE\n  \"THE GAME\"\n  &lt;LTABLE 3\n  \"How do I play this game?\"\n  \"Try typing things on your keyboard.\"\n  \"If that doesn't work, go ask your mom.\"&gt;\n  &lt;LTABLE 3\n  \"How do I stop the bunny people from stealing my carrots?\"\n  \"You can't.\"&gt;&gt;\n  &lt;PLTABLE\n  \"THE AUTHOR\"\n  &lt;LTABLE 3\n  \"Why does K.V. suck at regular expression stuff?\"\n  \"Try asking, \\\"K.V., why do you suck?\\\"\"\n  \"No one knows.\"\n  \"Maybe he was born that way.\"&gt;&gt;\n\n</code></pre>\n<hr>\n<p>There's no telling how many topics there will be, no telling how many answers there will be, and no telling how many questions there will be, but there will be at least one of each.</p>\n<p>There's also no telling how much whitespace there will be outside of the <code>\"\"</code>. There's always only one line break, though.</p>\n<p>What's the best way to turn this into a dictionary of lists or something?</p>\n\n",
      "PostDate": "2021-05-15T22:13:47.2490103Z",
      "LastEditDate": "2021-05-16T04:09:31.412591Z",
      "link": null
    },
    {
      "PostId": "2fefe976-a211-421f-97a3-b183686a4470",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "PS\r\n\r\nI'm getting close to something, but the code isn't worth posting.\r\n\r\nCan we use a ```global``` flag with regex in Quest?\r\n\r\nLike, if my regex pattern was ```/red/g``` and the string was:\r\n\r\n```\r\nI like red. My favorite color is red. Do you like red?\r\n```\r\n\r\nIf it was JS, it would match all three instances of \"red\".\r\n\r\n...but in Quest, I can only do\r\n\r\n ```\r\nregex = \"red\"\r\ns = \"I like red. My favorite color is red. Do you like red?\"\r\nparams = Populate (regex, s)\r\n```\r\n\r\n...and that would only capture the first instance of red.\r\n\r\nThis one time, in band camp, there was thing, it was called Javascript, and all the people used it, and one of them showed me how to do this:\r\n\r\n```\r\nlet regex = new RegExp('red', 'g');\r\n```\r\n\r\nCan we do something similar in Quest?",
      "EditableFormat": "markdown",
      "HTML": "<p>PS</p>\n<p>I'm getting close to something, but the code isn't worth posting.</p>\n<p>Can we use a <code>global</code> flag with regex in Quest?</p>\n<p>Like, if my regex pattern was <code>/red/g</code> and the string was:</p>\n<pre><code>I like red. My favorite color is red. Do you like red?\n</code></pre>\n<p>If it was JS, it would match all three instances of \"red\".</p>\n<p>...but in Quest, I can only do</p>\n<pre><code>regex = \"red\"\ns = \"I like red. My favorite color is red. Do you like red?\"\nparams = Populate (regex, s)\n</code></pre>\n<p>...and that would only capture the first instance of red.</p>\n<p>This one time, in band camp, there was thing, it was called Javascript, and all the people used it, and one of them showed me how to do this:</p>\n<pre><code>let regex = new RegExp('red', 'g');\n</code></pre>\n<p>Can we do something similar in Quest?</p>\n\n",
      "PostDate": "2021-05-16T04:18:39.1299985Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "8528cd77-51a7-45e5-9416-e790e667e83c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Unfortunately not. To match multiple parts you'd probably need to remove each one as you find it.\r\n\r\nIs this the text storage in ZIL format, and you're storing it in a string so Quest can parse it? Might be easier to build a simple script that will transform it into Quest-readable XML dictionaries.",
      "EditableFormat": "markdown",
      "HTML": "<p>Unfortunately not. To match multiple parts you'd probably need to remove each one as you find it.</p>\n<p>Is this the text storage in ZIL format, and you're storing it in a string so Quest can parse it? Might be easier to build a simple script that will transform it into Quest-readable XML dictionaries.</p>\n\n",
      "PostDate": "2021-05-16T08:37:29.5666321Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "aaa20ee3-597a-4ded-8f22-9cee7e75655b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Or split the text on newlines, and loop over them handling them in a way determined by the start of the line.\r\n\r\nOff the top of my head, typing on my phone, and not 100% sure if this is your intended output format… but this would be my first guess:\r\n```\r\nparents = NewList()\r\ncurrent = NewDictionary()\r\npltable = false\r\nforeach (line, Split (source, chr(13))) {\r\n  if (IsRegexMatch (\"^\\\\s*\\\"(.+)\\\"\\\\s*(<*)\\\\s*$\", line)) {\r\n    parts = Populate  (\"^\\\\s*\\\"(.+)\\\"\\\\s*(<*)\\\\s*$\", line)\r\n    if (TypeOf (current) = \"stringlist\") {\r\n      list add (current, ListItem (parts, 1))\r\n    }\r\n    else {\r\n      key = ListItem (parts, 1)\r\n      if (pltable) {\r\n        value = NewDictionary()\r\n      }\r\n      else {\r\n        value = NewStringList()\r\n      }\r\n      dictionary add (current, key, value)\r\n      list add (parents, current)\r\n      current = value\r\n    }\r\n    for (i, 1, LengthOf(ListItem (parts, 2))) {\r\n      if (ListCount (parents) = 0) {\r\n        return (current)\r\n      }\r\n      else {\r\n        current = ListItem (parents, ListCount (current) - 1)\r\n        list remove (parents, current)\r\n      }\r\n    }\r\n  }\r\n  else if (IsRegexMatch (\"^\\\\s*<PLTABLE\", line)) {\r\n    pltable = true\r\n  }\r\n}\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Or split the text on newlines, and loop over them handling them in a way determined by the start of the line.</p>\n<p>Off the top of my head, typing on my phone, and not 100% sure if this is your intended output format… but this would be my first guess:</p>\n<pre><code>parents = NewList()\ncurrent = NewDictionary()\npltable = false\nforeach (line, Split (source, chr(13))) {\n  if (IsRegexMatch (\"^\\\\s*\\\"(.+)\\\"\\\\s*(&lt;*)\\\\s*$\", line)) {\n    parts = Populate  (\"^\\\\s*\\\"(.+)\\\"\\\\s*(&lt;*)\\\\s*$\", line)\n    if (TypeOf (current) = \"stringlist\") {\n      list add (current, ListItem (parts, 1))\n    }\n    else {\n      key = ListItem (parts, 1)\n      if (pltable) {\n        value = NewDictionary()\n      }\n      else {\n        value = NewStringList()\n      }\n      dictionary add (current, key, value)\n      list add (parents, current)\n      current = value\n    }\n    for (i, 1, LengthOf(ListItem (parts, 2))) {\n      if (ListCount (parents) = 0) {\n        return (current)\n      }\n      else {\n        current = ListItem (parents, ListCount (current) - 1)\n        list remove (parents, current)\n      }\n    }\n  }\n  else if (IsRegexMatch (\"^\\\\s*&lt;PLTABLE\", line)) {\n    pltable = true\n  }\n}\n</code></pre>\n\n",
      "PostDate": "2021-05-16T09:10:57.308451Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "07558769-5da4-45c8-a943-7d34f8a8881c",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Yep. It's ZIL.\r\n\r\nIn ZIL, a table is a list.\r\n\r\nI have already converted one section to Quest in a few ways. I use a dictionary. Dictionar*ies*, actually.\r\n\r\nIn this file, I left out the main table. It actually has:\r\n\r\n```\r\n<PLTABLE\r\n; The hints object\r\n  <PLTABLE\r\n  \"THIS IS A HINTS SECTION\"\r\n    <LTABLE 3\r\n    \"QUESTION\"\r\n    \"HINT 1\"\r\n    \"HINT 2\">\r\n    <LTABLE 3\r\n    \"QUESTION NUMBER TWO\"\r\n    \"HINT 1\">>\r\n  <PLTABLE\r\n  \"THIS IS A SECOND HINTS SECTION.\"\r\n    <LTABLE 3\r\n    \"QUESTION\"\r\n    \"HINT ONE\">\r\n    <LTABLE 3\r\n    \"QUESTION TWO\"\r\n    \"HINT ONE\"\r\n    \"HINT TWO\">>>\r\n```\r\n\r\n---\r\nYeah. They use a list of lists of lists.\r\n\r\nSo, I have a dictionary named \"clues\". Its keys are the text from the sections. The section key \"unlocks\" the string list comprised of the question and the hints.\r\n\r\nI used that to make rooms. and ... I'll just post some code in a little while.\r\n\r\n---\r\nAnyway, I'm going to test your code.  Right now, I'm just making section rooms inside of a room called \"clues\". Each section room's description is just a copy and paste of the LTABLE 3 text. Then, I have a script that converts that text to a string list, and so forth.\r\n\r\nI was just thinking while coding the bit to replace ```\\\"``` with ```@@@``` then remove ```\"``` then replace ```@@@``` with ```\\\"```, that it would be cool if I could just parse the damned ZIL into dictionaries without having to muck about with the section bits.\r\n\r\nAnyway, I've gone completely loopy whilst coding this for . . . however many days it's been, and I must (try to) take a break for the evening.\r\n\r\nTomorrow, after I get my first dose of the vaccine, I shall return and see what all we've got going on here.\r\n\r\nThanks, mrangel!",
      "EditableFormat": "markdown",
      "HTML": "<p>Yep. It's ZIL.</p>\n<p>In ZIL, a table is a list.</p>\n<p>I have already converted one section to Quest in a few ways. I use a dictionary. Dictionar<em>ies</em>, actually.</p>\n<p>In this file, I left out the main table. It actually has:</p>\n<pre><code>&lt;PLTABLE\n; The hints object\n  &lt;PLTABLE\n  \"THIS IS A HINTS SECTION\"\n    &lt;LTABLE 3\n    \"QUESTION\"\n    \"HINT 1\"\n    \"HINT 2\"&gt;\n    &lt;LTABLE 3\n    \"QUESTION NUMBER TWO\"\n    \"HINT 1\"&gt;&gt;\n  &lt;PLTABLE\n  \"THIS IS A SECOND HINTS SECTION.\"\n    &lt;LTABLE 3\n    \"QUESTION\"\n    \"HINT ONE\"&gt;\n    &lt;LTABLE 3\n    \"QUESTION TWO\"\n    \"HINT ONE\"\n    \"HINT TWO\"&gt;&gt;&gt;\n</code></pre>\n<hr>\n<p>Yeah. They use a list of lists of lists.</p>\n<p>So, I have a dictionary named \"clues\". Its keys are the text from the sections. The section key \"unlocks\" the string list comprised of the question and the hints.</p>\n<p>I used that to make rooms. and ... I'll just post some code in a little while.</p>\n<hr>\n<p>Anyway, I'm going to test your code.  Right now, I'm just making section rooms inside of a room called \"clues\". Each section room's description is just a copy and paste of the LTABLE 3 text. Then, I have a script that converts that text to a string list, and so forth.</p>\n<p>I was just thinking while coding the bit to replace <code>\\\"</code> with <code>@@@</code> then remove <code>\"</code> then replace <code>@@@</code> with <code>\\\"</code>, that it would be cool if I could just parse the damned ZIL into dictionaries without having to muck about with the section bits.</p>\n<p>Anyway, I've gone completely loopy whilst coding this for . . . however many days it's been, and I must (try to) take a break for the evening.</p>\n<p>Tomorrow, after I get my first dose of the vaccine, I shall return and see what all we've got going on here.</p>\n<p>Thanks, mrangel!</p>\n\n",
      "PostDate": "2021-05-16T23:55:05.739524Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "fc27309d-8250-4eba-a955-936b2cb97974",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> the bit to replace `\\\"` with `@@@` then remove `\"` then replace `@@@` with `\\\"`, that \r\n\r\nThe usual way to do that would be to use a regexp like `\"(?<somename>(?:\\\\.|[^\\\\\"]+)*)\"` which captures the contents of a quoted string, including any number of quotes escaped by an odd number of backslashes but not a non-escaped quote. Replacing shouldn't be necessary.\r\n\r\nIn your example I thought that would be more than you need, as you never have more than one string on a line so you can just use a single regex to extract the part between the first and last `\"` on the line (assuming only whitespace before it, and whitespace or `>` after)\r\n\r\nI didn't actually think about unescaping the quotes…  presumably you'd do something like `Replace (Replace (ListItem (parts, 1), \"\\\\\\\\\", \"\\\\\"), \"\\\\\\\"\", \"\\\"\")`",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>the bit to replace <code>\\\"</code> with <code>@@@</code> then remove <code>\"</code> then replace <code>@@@</code> with <code>\\\"</code>, that</p>\n</blockquote>\n<p>The usual way to do that would be to use a regexp like <code>\"(?&lt;somename&gt;(?:\\\\.|[^\\\\\"]+)*)\"</code> which captures the contents of a quoted string, including any number of quotes escaped by an odd number of backslashes but not a non-escaped quote. Replacing shouldn't be necessary.</p>\n<p>In your example I thought that would be more than you need, as you never have more than one string on a line so you can just use a single regex to extract the part between the first and last <code>\"</code> on the line (assuming only whitespace before it, and whitespace or <code>&gt;</code> after)</p>\n<p>I didn't actually think about unescaping the quotes…  presumably you'd do something like <code>Replace (Replace (ListItem (parts, 1), \"\\\\\\\\\", \"\\\\\"), \"\\\\\\\"\", \"\\\"\")</code></p>\n\n",
      "PostDate": "2021-05-17T00:26:38.7511895Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "b1de94c2-67b1-490f-922b-0b1d922d906c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Ah, my bad. I forgot that Quest's `Populate` is weird. You'd need to name the groups, I think. I'm used to languages where you can pretend the collection of captured groups is a numbered array.",
      "EditableFormat": "markdown",
      "HTML": "<p>Ah, my bad. I forgot that Quest's <code>Populate</code> is weird. You'd need to name the groups, I think. I'm used to languages where you can pretend the collection of captured groups is a numbered array.</p>\n\n",
      "PostDate": "2021-05-17T00:29:53.8124528Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "72d4f4f0-66ea-40be-96c9-2c2af5482206",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> You'd need to name the groups, I think.\r\n\r\nThe [documentation page](https://docs.textadventures.co.uk/quest/functions/populate.html) concerning ```Populate``` confuses me.\r\n\r\n> Use a cache ID for improved performance if you repeatedly test strings against the same regular expression. The compiled regular expression will be cached and used again for subsequent calls to ```Populate``` (or ```GetMatchStrength``` or ```IsRegexMatch``` ) using the same cache ID.\r\n\r\nOkay. . .\r\n\r\nAlso, [this bit](https://docs.textadventures.co.uk/quest/pattern_matching.html#the-cache-id-parameter):\r\n\r\n> ### The “cache ID” parameter\r\n>\r\n>All the above functions take an optional third parameter, the “cache ID”. If you supply a cache ID, the regex will be saved under that name. The next time you use that cache ID for any of the above functions, Quest will ignore the regex you supply, and use the one it created earlier instead.\r\n>\r\n>Continuing with the example before:\r\n>\r\n> ```\r\n>IsRegexMatch(regex, s1, \"my regex\")\r\n>=> true\r\n>IsRegexMatch(\"nonsense\", s1, \"my regex\")\r\n>=> true\r\n>```\r\n>\r\n>The original regex is given a cache ID here (the string “my regex”). When IsRegexMatch is called a second time, Quest ignores the nonsense regex, because it already has a regex with that cache ID.\r\n>\r\n>Every time the player types some input, Quest has to compare that against the regex for every command, and using cache IDs makes that process considerably faster (and it does that for any custom command you add yourself). It is doubtful if cache IDs are of significant use outside of that, and are more likely to be a source of obscure bugs, so my advice is to not use them.\r\n\r\n\r\n---\r\nIf I am grasping this, this just means that we can use ```#object#```, ```#text#```, etc. (or their ```<?<object>.*)``` counterparts) because the regex Cache IDs are setup?\r\n\r\nLike, if I did:\r\n\r\n```\r\nregex = \"(heck|darn|shoot|dang)\"\r\ns = \"get the darn lamp\"\r\nbsbool = IsRegexMatch(regex, s, \"profanity\")\r\n```\r\n\r\n---\r\nAfter doing that in a game, does that mean I could do this at any point afterwards in a command pattern:\r\n\r\n```examine #profanity# #object#``` or ```^(get|take|grab) (?<profanity>.*) (?<object>.*)$```\r\n\r\n???",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>You'd need to name the groups, I think.</p>\n</blockquote>\n<p>The <a href=\"https://docs.textadventures.co.uk/quest/functions/populate.html\">documentation page</a> concerning <code>Populate</code> confuses me.</p>\n<blockquote>\n<p>Use a cache ID for improved performance if you repeatedly test strings against the same regular expression. The compiled regular expression will be cached and used again for subsequent calls to <code>Populate</code> (or <code>GetMatchStrength</code> or <code>IsRegexMatch</code> ) using the same cache ID.</p>\n</blockquote>\n<p>Okay. . .</p>\n<p>Also, <a href=\"https://docs.textadventures.co.uk/quest/pattern_matching.html#the-cache-id-parameter\">this bit</a>:</p>\n<blockquote>\n<h3>The “cache ID” parameter</h3>\n<p>All the above functions take an optional third parameter, the “cache ID”. If you supply a cache ID, the regex will be saved under that name. The next time you use that cache ID for any of the above functions, Quest will ignore the regex you supply, and use the one it created earlier instead.</p>\n<p>Continuing with the example before:</p>\n<pre><code>IsRegexMatch(regex, s1, \"my regex\")\n=&gt; true\nIsRegexMatch(\"nonsense\", s1, \"my regex\")\n=&gt; true\n</code></pre>\n<p>The original regex is given a cache ID here (the string “my regex”). When IsRegexMatch is called a second time, Quest ignores the nonsense regex, because it already has a regex with that cache ID.</p>\n<p>Every time the player types some input, Quest has to compare that against the regex for every command, and using cache IDs makes that process considerably faster (and it does that for any custom command you add yourself). It is doubtful if cache IDs are of significant use outside of that, and are more likely to be a source of obscure bugs, so my advice is to not use them.</p>\n</blockquote>\n<hr>\n<p>If I am grasping this, this just means that we can use <code>#object#</code>, <code>#text#</code>, etc. (or their <code>&lt;?&lt;object&gt;.*)</code> counterparts) because the regex Cache IDs are setup?</p>\n<p>Like, if I did:</p>\n<pre><code>regex = \"(heck|darn|shoot|dang)\"\ns = \"get the darn lamp\"\nbsbool = IsRegexMatch(regex, s, \"profanity\")\n</code></pre>\n<hr>\n<p>After doing that in a game, does that mean I could do this at any point afterwards in a command pattern:</p>\n<p><code>examine #profanity# #object#</code> or <code>^(get|take|grab) (?&lt;profanity&gt;.*) (?&lt;object&gt;.*)$</code></p>\n<p>???</p>\n\n",
      "PostDate": "2021-05-17T01:58:51.5982316Z",
      "LastEditDate": "2021-05-17T02:26:07.4585887Z",
      "link": null
    },
    {
      "PostId": "8422a990-1ca4-4c44-a2c1-0e7c17ff5a1d",
      "UserId": 1346,
      "Username": "The Pixie",
      "AvatarUrl": "https://secure.gravatar.com/avatar/cfa37e927f96177bcf6053ae8f108f77?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Cache IDs are just for performance. Rather that convert the string to a regex every time, Quest does it once, and can then remember it using its cache ID. It will not help here, I am afraid.",
      "EditableFormat": "markdown",
      "HTML": "<p>Cache IDs are just for performance. Rather that convert the string to a regex every time, Quest does it once, and can then remember it using its cache ID. It will not help here, I am afraid.</p>\n\n",
      "PostDate": "2021-05-17T06:48:31.7864429Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0cf22d42-8f50-451a-a0be-35f4e4fe71fd",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> After doing that in a game, does that mean I could do this at any point afterwards in a command pattern:\r\n\r\nNo; it just means that later after using that test, another piece of code could do:\r\n```\r\nif (IsRegexMatch (\"\", s2, \"profanity\")) {\r\n```\r\nto test using the same regex, or do:\r\n```\r\nif (IsRegexMatch (some_regex, some_string, \"name of regex\")) {\r\n  parts = Populate (\"\", some_string, \"name of regex\")\r\n```\r\n\r\nIt's also why you can't easily use script to change a command's pattern (you'd have to clone the command in order to change its name as well).\r\n\r\n<hr/>\r\n\r\nWhat I meant for the code I posted above was change:\r\n```\r\n  if (IsRegexMatch (\"^\\\\s*\\\"(.+)\\\"\\\\s*(<*)\\\\s*$\", line)) {\r\n    parts = Populate  (\"^\\\\s*\\\"(.+)\\\"\\\\s*(<*)\\\\s*$\", line)\r\n```\r\nto\r\n```\r\n  if (IsRegexMatch (\"^\\\\s*\\\"(?<contents>.+)\\\"\\\\s*(?<closing><*)\\\\s*$\", line)) {\r\n    parts = Populate  (\"^\\\\s*\\\"(?<contents>.+)\\\"\\\\s*(?<closing><*)\\\\s*$\", line)\r\n```\r\nand then\r\n* change `ListItem (parts, 1)` to `DictionaryItem (parts, \"contents\")` to get the contents of the quotes\r\n* change `ListItem (parts, 2)` to `DictionaryItem (parts, \"closing\")` to get the closing `>` at the end of the line\r\n\r\nI'm used to languages where the regex functions deal with numbered groups; but in Quest I can't treat the dictionary `parts` as a list as far as I'm aware.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>After doing that in a game, does that mean I could do this at any point afterwards in a command pattern:</p>\n</blockquote>\n<p>No; it just means that later after using that test, another piece of code could do:</p>\n<pre><code>if (IsRegexMatch (\"\", s2, \"profanity\")) {\n</code></pre>\n<p>to test using the same regex, or do:</p>\n<pre><code>if (IsRegexMatch (some_regex, some_string, \"name of regex\")) {\n  parts = Populate (\"\", some_string, \"name of regex\")\n</code></pre>\n<p>It's also why you can't easily use script to change a command's pattern (you'd have to clone the command in order to change its name as well).</p>\n<hr>\n<p>What I meant for the code I posted above was change:</p>\n<pre><code>  if (IsRegexMatch (\"^\\\\s*\\\"(.+)\\\"\\\\s*(&lt;*)\\\\s*$\", line)) {\n    parts = Populate  (\"^\\\\s*\\\"(.+)\\\"\\\\s*(&lt;*)\\\\s*$\", line)\n</code></pre>\n<p>to</p>\n<pre><code>  if (IsRegexMatch (\"^\\\\s*\\\"(?&lt;contents&gt;.+)\\\"\\\\s*(?&lt;closing&gt;&lt;*)\\\\s*$\", line)) {\n    parts = Populate  (\"^\\\\s*\\\"(?&lt;contents&gt;.+)\\\"\\\\s*(?&lt;closing&gt;&lt;*)\\\\s*$\", line)\n</code></pre>\n<p>and then</p>\n<ul>\n<li>change <code>ListItem (parts, 1)</code> to <code>DictionaryItem (parts, \"contents\")</code> to get the contents of the quotes</li>\n<li>change <code>ListItem (parts, 2)</code> to <code>DictionaryItem (parts, \"closing\")</code> to get the closing <code>&gt;</code> at the end of the line</li>\n</ul>\n<p>I'm used to languages where the regex functions deal with numbered groups; but in Quest I can't treat the dictionary <code>parts</code> as a list as far as I'm aware.</p>\n\n",
      "PostDate": "2021-05-17T08:20:01.5186639Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3d7c66f9-8dc4-4a03-85fb-34cfcd11d5dc",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> So, I have a dictionary named \"clues\". Its keys are the text from the sections. The section key \"unlocks\" the string list comprised of the question and the hints.\r\n\r\nI wasn't so sure about that to start with. It seems a little odd for the first element of a list to be a question, and the rest answers. So I had it making the question a dictionary key pointing to a stringlist of answers.\r\n\r\nIf that's the desired format, it makes the code a little more elegant (and more robust).\r\n\r\n```\r\n<function name=\"ParseDataDictionary\" parameters=\"input\" type=\"dictionary\">\r\n  parents = NewList()\r\n  current = null\r\n  key = null\r\n  open = false\r\n  pattern = \"^\\\\s*(?:<(?<list>LTABLE\\\\s*\\\\d*)|<(?<dictionary>PLTABLE)|\\\"(?<string>([^\\\\\\\\\\\"]+|\\\\\\\\.)*|(?<unknown>.+))\\\")(?<space>[\\\\s>]*)?(?<remainder>.*)$\"\r\n  while (not input = \"\") {\r\n    if (not IsRegexMatch (pattern, input)) {\r\n      error (\"Can't happen: \"+input)\r\n    }\r\n    parse = Populate (pattern, input)\r\n    input = StringDictionaryItem (parse, \"remainder\")\r\n    if (DictionaryContains (parse, \"list\")) {\r\n      value = NewStringList()\r\n      open = true\r\n    }\r\n    else if (DictionaryContains (parse, \"dictionary\")) {\r\n      value = NewDictionary()\r\n      open = true\r\n    }\r\n    else if (DictionaryContains (parse, \"string\")) {\r\n      value = Replace (Replace (StringDictionaryItem (parse, \"string\"), \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\")\r\n      open = false\r\n    }\r\n    else if (DictionaryContains (parse, \"unknown\")) {\r\n      error (\"Unexpected data: \\\"\" + DictionaryItem (parse, \"unknown\") + \"\\\"\")\r\n    }\r\n    if (TypeOf (current) = \"dictionary\") {\r\n      if (not key = null) {\r\n        dictionary add (current, key, value)\r\n        key = null\r\n      }\r\n      else if (open) {\r\n        error (\"Can't use a \" + TypeOf (current) + \" as a dictionary key.\")\r\n      }\r\n      else {\r\n        key = value\r\n      }\r\n    }\r\n    else {\r\n      list add (current, value)\r\n    }\r\n    if (open) {\r\n      if (not current = null) {\r\n        list add (parents, current)\r\n      }\r\n      current = value\r\n    }\r\n    if (DictionaryContains (parse, \"space\")) {\r\n      padding = StringDictionaryItem (parse, \"space\")\r\n      for (i, 1, LengthOf (padding)) {\r\n        if (Mid (padding, i, 1) = \">\") {\r\n          if (key = null) {\r\n            if (ListCount (parents) = 0) {\r\n              if (remainder = \"\") {\r\n                if (TypeOf (\"current\") = \"dictionary\") {\r\n                  return (current)\r\n                }\r\n                else {\r\n                  wrapper = NewDictionary()\r\n                  dictionary add (wrapper, \"result\", current)\r\n                  return (wrapper)\r\n                }\r\n              }\r\n              else {\r\n                error (\"Unexpected data at end of string: \"+remainder)\r\n              }\r\n            }\r\n            else {\r\n              current = ListItem (parents, ListCount (parents) - 1)\r\n              list remove (parents, current)\r\n            }\r\n          }\r\n          else {\r\n            error (\"Odd number of elements in dictionary; spare key \\\"\" + key + \"\\\" has no value.\")\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  error (\"Missing `>`\")\r\n</function>\r\n```\r\n\r\nThis version assumes that a dictionary starts with `<PLTABLE`, a list starts with `<LTABLE`, and allows them to be nested inside each other in any configuration.\r\n\r\nThe pair of `Replace()`s used to turn `\\\"` into `\"` and `\\\\` into `\\` is not robust - but it doesn't need to be, because the big regexp at the top will always catch any unescaped strings; therefore it is safe to assume that a quote remaining in the string is escaped.\r\n\r\nI've called it `ParseDataDictionary` because it assumes the top-level item is a dictionary. Quest doesn't allow functions to return \"list or dictionary\", so if your data structure starts with `<LTABLE` it will get wrapped inside a dictionary with a single element, key \"result\".\r\n\r\nThis code is a bit bigger than the last one; most of that is because of `else` cases or extra checks to ensure it gives a sensible error message if there's a character missing from your data or something. It's simpler really, it just handles errors instead of ignoring them and returning garbage.\r\n\r\nThis version also completely ignores whitespace outside of strings. As you're using a LISP-inspired language, this seems entirely logical. (your sample files have one string per line, but I think that's probably a stylistic choice to make the code more human readable. I think my function would be equally happy to parse your code if you had entered it as:\r\n```\r\n<PLTABLE\"THE GAME\"<LTABLE\r\n3\"How do I play this game?\"\r\n  \"Try typing things on your keyboard.\"\"If that doesn't work, go ask your mom.\"><LTABLE3\"How do I stop the bunny people from stealing my carrots?\"\r\n  \"You can't.\">\r\n><PLTABLE\r\n  \"THE AUTHOR\"<LTABLE3\"Why does K.V. suck at regular expression stuff?\"\r\n  \"Try asking, \\\"K.V., why do you suck?\\\"\"\"No one knows.\"\"Maybe he was born that way.\">>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>So, I have a dictionary named \"clues\". Its keys are the text from the sections. The section key \"unlocks\" the string list comprised of the question and the hints.</p>\n</blockquote>\n<p>I wasn't so sure about that to start with. It seems a little odd for the first element of a list to be a question, and the rest answers. So I had it making the question a dictionary key pointing to a stringlist of answers.</p>\n<p>If that's the desired format, it makes the code a little more elegant (and more robust).</p>\n<pre><code>&lt;function name=\"ParseDataDictionary\" parameters=\"input\" type=\"dictionary\"&gt;\n  parents = NewList()\n  current = null\n  key = null\n  open = false\n  pattern = \"^\\\\s*(?:&lt;(?&lt;list&gt;LTABLE\\\\s*\\\\d*)|&lt;(?&lt;dictionary&gt;PLTABLE)|\\\"(?&lt;string&gt;([^\\\\\\\\\\\"]+|\\\\\\\\.)*|(?&lt;unknown&gt;.+))\\\")(?&lt;space&gt;[\\\\s&gt;]*)?(?&lt;remainder&gt;.*)$\"\n  while (not input = \"\") {\n    if (not IsRegexMatch (pattern, input)) {\n      error (\"Can't happen: \"+input)\n    }\n    parse = Populate (pattern, input)\n    input = StringDictionaryItem (parse, \"remainder\")\n    if (DictionaryContains (parse, \"list\")) {\n      value = NewStringList()\n      open = true\n    }\n    else if (DictionaryContains (parse, \"dictionary\")) {\n      value = NewDictionary()\n      open = true\n    }\n    else if (DictionaryContains (parse, \"string\")) {\n      value = Replace (Replace (StringDictionaryItem (parse, \"string\"), \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\")\n      open = false\n    }\n    else if (DictionaryContains (parse, \"unknown\")) {\n      error (\"Unexpected data: \\\"\" + DictionaryItem (parse, \"unknown\") + \"\\\"\")\n    }\n    if (TypeOf (current) = \"dictionary\") {\n      if (not key = null) {\n        dictionary add (current, key, value)\n        key = null\n      }\n      else if (open) {\n        error (\"Can't use a \" + TypeOf (current) + \" as a dictionary key.\")\n      }\n      else {\n        key = value\n      }\n    }\n    else {\n      list add (current, value)\n    }\n    if (open) {\n      if (not current = null) {\n        list add (parents, current)\n      }\n      current = value\n    }\n    if (DictionaryContains (parse, \"space\")) {\n      padding = StringDictionaryItem (parse, \"space\")\n      for (i, 1, LengthOf (padding)) {\n        if (Mid (padding, i, 1) = \"&gt;\") {\n          if (key = null) {\n            if (ListCount (parents) = 0) {\n              if (remainder = \"\") {\n                if (TypeOf (\"current\") = \"dictionary\") {\n                  return (current)\n                }\n                else {\n                  wrapper = NewDictionary()\n                  dictionary add (wrapper, \"result\", current)\n                  return (wrapper)\n                }\n              }\n              else {\n                error (\"Unexpected data at end of string: \"+remainder)\n              }\n            }\n            else {\n              current = ListItem (parents, ListCount (parents) - 1)\n              list remove (parents, current)\n            }\n          }\n          else {\n            error (\"Odd number of elements in dictionary; spare key \\\"\" + key + \"\\\" has no value.\")\n          }\n        }\n      }\n    }\n  }\n  error (\"Missing `&gt;`\")\n&lt;/function&gt;\n</code></pre>\n<p>This version assumes that a dictionary starts with <code>&lt;PLTABLE</code>, a list starts with <code>&lt;LTABLE</code>, and allows them to be nested inside each other in any configuration.</p>\n<p>The pair of <code>Replace()</code>s used to turn <code>\\\"</code> into <code>\"</code> and <code>\\\\</code> into <code>\\</code> is not robust - but it doesn't need to be, because the big regexp at the top will always catch any unescaped strings; therefore it is safe to assume that a quote remaining in the string is escaped.</p>\n<p>I've called it <code>ParseDataDictionary</code> because it assumes the top-level item is a dictionary. Quest doesn't allow functions to return \"list or dictionary\", so if your data structure starts with <code>&lt;LTABLE</code> it will get wrapped inside a dictionary with a single element, key \"result\".</p>\n<p>This code is a bit bigger than the last one; most of that is because of <code>else</code> cases or extra checks to ensure it gives a sensible error message if there's a character missing from your data or something. It's simpler really, it just handles errors instead of ignoring them and returning garbage.</p>\n<p>This version also completely ignores whitespace outside of strings. As you're using a LISP-inspired language, this seems entirely logical. (your sample files have one string per line, but I think that's probably a stylistic choice to make the code more human readable. I think my function would be equally happy to parse your code if you had entered it as:</p>\n<pre><code>&lt;PLTABLE\"THE GAME\"&lt;LTABLE\n3\"How do I play this game?\"\n  \"Try typing things on your keyboard.\"\"If that doesn't work, go ask your mom.\"&gt;&lt;LTABLE3\"How do I stop the bunny people from stealing my carrots?\"\n  \"You can't.\"&gt;\n&gt;&lt;PLTABLE\n  \"THE AUTHOR\"&lt;LTABLE3\"Why does K.V. suck at regular expression stuff?\"\n  \"Try asking, \\\"K.V., why do you suck?\\\"\"\"No one knows.\"\"Maybe he was born that way.\"&gt;&gt;\n</code></pre>\n\n",
      "PostDate": "2021-05-17T16:39:18.5231138Z",
      "LastEditDate": "2021-05-17T16:48:25.4089446Z",
      "link": null
    },
    {
      "PostId": "38de7163-9a56-46fa-95d7-f3875a9868ae",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": ">  It seems a little odd for the first element of a list to be a question, and the rest answers. So I had it making the question a dictionary key pointing to a stringlist of answers.\r\n\r\nThat's the same thing I did. After I got it working, I did see how it makes sense to have the question as the first in the string list, though. The way things are handled in the screen which actually lists the hints shows only the question first. Each time you press enter, another hint is appended. (I still just like the question as a key, though. At least I'm not alone.)\r\n\r\n---\r\nAlso: Ooh! Ooh!  I'm gonna try that code!\r\n\r\nThanks!!!",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>It seems a little odd for the first element of a list to be a question, and the rest answers. So I had it making the question a dictionary key pointing to a stringlist of answers.</p>\n</blockquote>\n<p>That's the same thing I did. After I got it working, I did see how it makes sense to have the question as the first in the string list, though. The way things are handled in the screen which actually lists the hints shows only the question first. Each time you press enter, another hint is appended. (I still just like the question as a key, though. At least I'm not alone.)</p>\n<hr>\n<p>Also: Ooh! Ooh!  I'm gonna try that code!</p>\n<p>Thanks!!!</p>\n\n",
      "PostDate": "2021-05-17T17:41:23.1831373Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
