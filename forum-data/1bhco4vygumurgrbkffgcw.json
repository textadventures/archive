{
  "Topic": {
    "TopicId": "1bhco4vygumurgrbkffgcw",
    "ForumId": "10",
    "Title": "Chunk-based random map generation",
    "LastUpdated": "2024-05-23T13:41:23.4908014Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "5dfe8434-6fef-4484-9de7-5a7d82ee3249",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I've been thinking about this again. I was originally trying to build something like this for my joke game Tomb of the Dead; but rather than putting it off I might be better typing it on the forum, without disconnections and editor trouble to distract me; so a first top-of-my-head version of the code is there if I decide to use it. And it's here for anyone else to comment on; and to draw inspiration from if it helps you to understand my thought process :)\r\n\r\nThe idea here is that the map is divided into 'chunks'; groups of rooms connected together. The engine can generate a random map layout, but rooms in the same chunk will always be positioned together.\r\n\r\nWe'll do it recursively (yes, I know there's a memory overhead to that) in order to make rollback easier. We could use a modified DLX algorithm; but thanks to Quest's slow dictionaries we would end up creating hundreds of temporary objects to store data; which is not ideal. (Actually… one option would be to hand everything over to Javascript, run map generation on the client side, and then hand control back to Quest when it's finished… this would remove the risk of the script timing out, as well. But… that's a bit silly)\r\n\r\nI'll start by picking some attributes we will need for keeping track of stuff. I'll give the rooms attributes to store their coordinates in the grid temporarily. I'm going to give each room an attribute `map_coordinates` (a string of the form \"x;y;z\" for quicker comparisons). My system will assume that the player starts at 0/0/0 unless otherwise specified, and won't move around rooms that have numbers preassigned.\r\n\r\nNote that at this point I am NOT dealing with some of the funky stuff that gridmap does; like rooms of different sizes, and exit lengths. This means that the coordinates I'm using are not necessarily the same as map coordinates, and are all integers. Maybe I'll change that later; but it seems like it might be a much bigger headache.\r\n\r\nLet's have some attributes that the user can set on rooms to control map generation. These might not be implemented in the first version of the code, but I'll try to keep them in mind so they won't be too hard to add later:\r\n* `map_cloneable` - if true, this room can be cloned to build up the map. This attribute will be checked when it's time to add the room to the map. If only some rooms in a chunk are cloneable, they ones that aren't will appear in the first copy to be placed.\r\n* `map_clone_limit` - maximum number of clones for this room (if given)\r\n* `map_clone_substitutes` - when cloning this room, replace it with an alternative from this list (so if you have a dozen single rooms which could be found along a certain corridor, you could use this so that they're treated identically for the purposes of making the map, and then one is selected when it's time to actually clone them - meaning that each room doesn't get considered separately when working out whether they will fit. Note that using this for chunks which aren't the same size and shape may result in overlapping rooms)\r\n* `map_required` - if true, any layout which can't include this room will result in starting over. When the game starts, it will run room generation until all required rooms are placed; other parts of the map (such as mazes of potentially-infinite clone rooms) can be filled in as the player explores them.\r\n* `map_allow_overlap` - if true, this room can be in the same place as another room. May apply by default for rooms reachable by \"in\" or \"out\" exits; if I remember.\r\n* `map_attempt` - a script to run when the map tries to connect this room. This may be done a dozen times, as the map tries different options, so the script shouldn't be one which takes a long time to run. This script can use the variables `xpos`, `ypos`, `zpos` (integers), `entrancefrom` (room object), `entrancedirection` (\"north\", \"south\", etc), and `entrancereverse` (the reverse exit which will be moved into this room, if applicable) to find out about where the script is trying to place it. The stringlist `maperrors` will initially be empty; but adding any element to it will prevent the room being placed here.\r\n* `map_initialise` - a script to run after giving the room its final coordinates.\r\n\r\nWe can also have rooms with randomisable exits (which connect the chunks together). Exits can be given the attributes:\r\n* `random_to` - a list of rooms, or a string attribute of the form `kitchen;tunnel6;room12;room15`, specifying which rooms which the exit can go to (connecting their chunks)\r\n* `random_to_expression` - an expression which generates a list of possible destinations (overriding the above)\r\n* `map_required_exit` - if true, this exit must go somewhere. If all of the destinations on the list have been placed elsewhere, or there's no space for them, this will cause map generation to back up.\r\n* `map_dummy_exit` - What to do if none of the random options can be placed here. If a string, it will be treated as a locked message for the exit (\"This way is blocked\", for example). If an object (or objectlist to pick one), that object will be cloned here to replace the exit (so you could have an object which is a barred door or a pile of rocks blocking a tunnel, for example). If false, the exit will be removed. If true, the exit will be left as-is (treated as non-random).\r\n* `map_wonky` - If true, this exit doesn't set the coordinates of the room on the other side. For example, if the description says you crawl through a maze of ductwork and don't know which way you're going, the rooms on either side of it could be anywhere.\r\n* `map_create_reverse` - if the attribute refers to an object or exit, it will be moved to the destination room to act as the other side of this door. If false, no reverse exit will be created. If true, create a standard exit in the other direction. (Allows exits to be one-way; or to have other descriptive attributes)\r\n\r\nOther settings:\r\n* `game.map_max_filler` - the maximum number of cloneable, non-required rooms that the system will place in a row before it temporarily excludes them from the next placement. If you've got a bunch of mapped out sections for your castle, and then some cloneable generic corridors and storerooms to fill out the space between them, then you don't want it to waste time filling in the negative space in the map with storerooms before it realises that the throne room complex is too big to fit anywhere.\r\n\r\nNow, I think a sensible algorithm would be:\r\n1. Place the starting room.\r\n\r\nWhen a room is placed (including the starting room) it would:\r\n1. Assign coordinates to all the rooms connected to it\r\n2. If any of the rooms collides with coordinates that have already been used, return failure.\r\n3. If all required rooms and exits have been placed, return success.\r\n4. Loop over the randomisable exits out of the area that's currently connected\r\n    5. Loop over the list of options for where that exit can connect to. For each option (in random order):\r\n        * Try to place that room next to that exit. If it returns success, we return success as well\r\n    6. If the exit isn't required, do whatever its dummy behaviour is before trying the next option\r\n    7. If the exit is required, we can't place this room here. Undo all the coordinate allocations from step 2 above, and return failure.\r\n5. If we get here without returning, then we can't connect any more chunks to the map anywhere, and there are unplaced required rooms. So undo all the coordinate allocations from step 2 above, and return failure.\r\n\r\nWow… I've been typing for ages and I'm still on the pseudocode. Going to leave this here and go for a walk; will turn that into actual code later. **Any ideas/feedback would be appreciated.**\r\n\r\n<hr />\r\n\r\nEDIT:\r\nI think that for something like this, cloneable rooms are a good idea. If you just have map regions, it would be easy to end up in a situation where they collide, but having a small chunk (like one or two corridors) would make it possible to fit in the important rooms. However, if we reach an impossible situation and have to backtrack, creating and destroying objects is rather intensive for Quest. Therefore I think it would make more sense to make a list of rooms to clone, and only actually create stuff when we know the layout works.\r\n\r\nAnd a first piece of actual code: A utility function to convert various data types to an objectlist (which will be useful in a few places).\r\n```\r\n<function name=\"MakeObjectList\" parameters=\"input\" type=\"objectlist\">\r\n  todo = NewList ()\r\n  output = NewObjectList ()\r\n  list add (todo, input)\r\n  while (not ListCount (todo) = 0) {\r\n    item = ListItem (todo, 0)\r\n    list remove (todo, item)\r\n    switch (TypeOf (item)) {\r\n      case (\"string\") {\r\n        foreach (part, Split(item)) {\r\n          if (IsInt (part)) {\r\n            list add (todo, ToInt (part))\r\n          }\r\n          else {\r\n            list add (output, GetObject (part))\r\n          }\r\n        }\r\n      }\r\n      case (\"int\") {\r\n        for (i, 1, item) {\r\n          list add (output, null)\r\n        }\r\n      }\r\n      case (\"list\", \"objectlist\", \"stringlist\") {\r\n        foreach (part, item) {\r\n          list add (todo, part)\r\n        }\r\n      }\r\n      case (\"object\") {\r\n        list add (output, item)\r\n      }\r\n      case (\"script\") {\r\n        invoke (item, QuickParams (\"items\", output, \"parameters\", todo))\r\n      }\r\n      default {\r\n        JS.console.log (\"Warning: Can't convert \" + ToString (item) + \" (\" + TypeOf (item) + \") to object in MakeObjectList\")\r\n      }\r\n    }\r\n  }\r\n  return (output)\r\n</function>\r\n```\r\n\r\nEDIT2:\r\nA second function, this time to add a single room to an existing chunk. This does it recursively, because that seems like the simplest way to do it. The actual chunk-connecting code will be pretty similar to this, but with a lot more complex stuff added.\r\n\r\nThis time, I'm actually passing a bunch of stringlists to the function; it will return the number of rooms added, but will pass back a lot more data by adding items to those lists. This seems to make more sense, as it means we don't need to take a long time massaging the data into a usable format to pass back and forth.\r\n\r\nParameters:\r\n* `room` - rooms to add\r\n* `xpos`, `ypos`, `zpos` - coordinates for the room\r\n* `rooms_by_coords` - dictionary mapping coordinate strings (\"X;Y;Z\") onto the rooms that can be found there. Value will be a room *name*, to account for clones. Clones will show as \"roomname=number\"; for example, the 3rd clone of hallway1 will be named \"hallway1=3\". Because a chunk might already contain multiple rooms at the same coords for some reason (such as in/out exits or nested rooms), this will be a dictionary of stringlists containing the names.\r\n* `rooms_in_chunk` - as above, but for rooms added in this chunk. Tracked separately so that they could easily be removed if it turns out the room isn't allowed here.\r\n* `pending_exits` - an objectlist, containing exits from which new chunks could be reached\r\n* `pending_required` - an objectlist of required rooms which haven't yet been reached\r\n* `mapwarnings` - a stringlist of warnings, which may be displayed on the console so that users can figure out why their map has problems\r\n* `maperrors` - a stringlist of errors found while trying to lay out the map. If this has any elements in it, the chunk will probably fail to be generated; but we don't abort right away in case another script wants to overrule it\r\n```\r\n<function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors\" type=\"int\">\r\n  // TODO\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>I've been thinking about this again. I was originally trying to build something like this for my joke game Tomb of the Dead; but rather than putting it off I might be better typing it on the forum, without disconnections and editor trouble to distract me; so a first top-of-my-head version of the code is there if I decide to use it. And it's here for anyone else to comment on; and to draw inspiration from if it helps you to understand my thought process :)</p>\n<p>The idea here is that the map is divided into 'chunks'; groups of rooms connected together. The engine can generate a random map layout, but rooms in the same chunk will always be positioned together.</p>\n<p>We'll do it recursively (yes, I know there's a memory overhead to that) in order to make rollback easier. We could use a modified DLX algorithm; but thanks to Quest's slow dictionaries we would end up creating hundreds of temporary objects to store data; which is not ideal. (Actually… one option would be to hand everything over to Javascript, run map generation on the client side, and then hand control back to Quest when it's finished… this would remove the risk of the script timing out, as well. But… that's a bit silly)</p>\n<p>I'll start by picking some attributes we will need for keeping track of stuff. I'll give the rooms attributes to store their coordinates in the grid temporarily. I'm going to give each room an attribute <code>map_coordinates</code> (a string of the form \"x;y;z\" for quicker comparisons). My system will assume that the player starts at 0/0/0 unless otherwise specified, and won't move around rooms that have numbers preassigned.</p>\n<p>Note that at this point I am NOT dealing with some of the funky stuff that gridmap does; like rooms of different sizes, and exit lengths. This means that the coordinates I'm using are not necessarily the same as map coordinates, and are all integers. Maybe I'll change that later; but it seems like it might be a much bigger headache.</p>\n<p>Let's have some attributes that the user can set on rooms to control map generation. These might not be implemented in the first version of the code, but I'll try to keep them in mind so they won't be too hard to add later:</p>\n<ul>\n<li><code>map_cloneable</code> - if true, this room can be cloned to build up the map. This attribute will be checked when it's time to add the room to the map. If only some rooms in a chunk are cloneable, they ones that aren't will appear in the first copy to be placed.</li>\n<li><code>map_clone_limit</code> - maximum number of clones for this room (if given)</li>\n<li><code>map_clone_substitutes</code> - when cloning this room, replace it with an alternative from this list (so if you have a dozen single rooms which could be found along a certain corridor, you could use this so that they're treated identically for the purposes of making the map, and then one is selected when it's time to actually clone them - meaning that each room doesn't get considered separately when working out whether they will fit. Note that using this for chunks which aren't the same size and shape may result in overlapping rooms)</li>\n<li><code>map_required</code> - if true, any layout which can't include this room will result in starting over. When the game starts, it will run room generation until all required rooms are placed; other parts of the map (such as mazes of potentially-infinite clone rooms) can be filled in as the player explores them.</li>\n<li><code>map_allow_overlap</code> - if true, this room can be in the same place as another room. May apply by default for rooms reachable by \"in\" or \"out\" exits; if I remember.</li>\n<li><code>map_attempt</code> - a script to run when the map tries to connect this room. This may be done a dozen times, as the map tries different options, so the script shouldn't be one which takes a long time to run. This script can use the variables <code>xpos</code>, <code>ypos</code>, <code>zpos</code> (integers), <code>entrancefrom</code> (room object), <code>entrancedirection</code> (\"north\", \"south\", etc), and <code>entrancereverse</code> (the reverse exit which will be moved into this room, if applicable) to find out about where the script is trying to place it. The stringlist <code>maperrors</code> will initially be empty; but adding any element to it will prevent the room being placed here.</li>\n<li><code>map_initialise</code> - a script to run after giving the room its final coordinates.</li>\n</ul>\n<p>We can also have rooms with randomisable exits (which connect the chunks together). Exits can be given the attributes:</p>\n<ul>\n<li><code>random_to</code> - a list of rooms, or a string attribute of the form <code>kitchen;tunnel6;room12;room15</code>, specifying which rooms which the exit can go to (connecting their chunks)</li>\n<li><code>random_to_expression</code> - an expression which generates a list of possible destinations (overriding the above)</li>\n<li><code>map_required_exit</code> - if true, this exit must go somewhere. If all of the destinations on the list have been placed elsewhere, or there's no space for them, this will cause map generation to back up.</li>\n<li><code>map_dummy_exit</code> - What to do if none of the random options can be placed here. If a string, it will be treated as a locked message for the exit (\"This way is blocked\", for example). If an object (or objectlist to pick one), that object will be cloned here to replace the exit (so you could have an object which is a barred door or a pile of rocks blocking a tunnel, for example). If false, the exit will be removed. If true, the exit will be left as-is (treated as non-random).</li>\n<li><code>map_wonky</code> - If true, this exit doesn't set the coordinates of the room on the other side. For example, if the description says you crawl through a maze of ductwork and don't know which way you're going, the rooms on either side of it could be anywhere.</li>\n<li><code>map_create_reverse</code> - if the attribute refers to an object or exit, it will be moved to the destination room to act as the other side of this door. If false, no reverse exit will be created. If true, create a standard exit in the other direction. (Allows exits to be one-way; or to have other descriptive attributes)</li>\n</ul>\n<p>Other settings:</p>\n<ul>\n<li><code>game.map_max_filler</code> - the maximum number of cloneable, non-required rooms that the system will place in a row before it temporarily excludes them from the next placement. If you've got a bunch of mapped out sections for your castle, and then some cloneable generic corridors and storerooms to fill out the space between them, then you don't want it to waste time filling in the negative space in the map with storerooms before it realises that the throne room complex is too big to fit anywhere.</li>\n</ul>\n<p>Now, I think a sensible algorithm would be:</p>\n<ol>\n<li>Place the starting room.</li>\n</ol>\n<p>When a room is placed (including the starting room) it would:</p>\n<ol>\n<li>Assign coordinates to all the rooms connected to it</li>\n<li>If any of the rooms collides with coordinates that have already been used, return failure.</li>\n<li>If all required rooms and exits have been placed, return success.</li>\n<li>Loop over the randomisable exits out of the area that's currently connected\n<ol start=\"5\">\n<li>Loop over the list of options for where that exit can connect to. For each option (in random order):\n<ul>\n<li>Try to place that room next to that exit. If it returns success, we return success as well</li>\n</ul>\n</li>\n<li>If the exit isn't required, do whatever its dummy behaviour is before trying the next option</li>\n<li>If the exit is required, we can't place this room here. Undo all the coordinate allocations from step 2 above, and return failure.</li>\n</ol>\n</li>\n<li>If we get here without returning, then we can't connect any more chunks to the map anywhere, and there are unplaced required rooms. So undo all the coordinate allocations from step 2 above, and return failure.</li>\n</ol>\n<p>Wow… I've been typing for ages and I'm still on the pseudocode. Going to leave this here and go for a walk; will turn that into actual code later. <strong>Any ideas/feedback would be appreciated.</strong></p>\n<hr>\n<p>EDIT:<br>\nI think that for something like this, cloneable rooms are a good idea. If you just have map regions, it would be easy to end up in a situation where they collide, but having a small chunk (like one or two corridors) would make it possible to fit in the important rooms. However, if we reach an impossible situation and have to backtrack, creating and destroying objects is rather intensive for Quest. Therefore I think it would make more sense to make a list of rooms to clone, and only actually create stuff when we know the layout works.</p>\n<p>And a first piece of actual code: A utility function to convert various data types to an objectlist (which will be useful in a few places).</p>\n<pre><code>&lt;function name=\"MakeObjectList\" parameters=\"input\" type=\"objectlist\"&gt;\n  todo = NewList ()\n  output = NewObjectList ()\n  list add (todo, input)\n  while (not ListCount (todo) = 0) {\n    item = ListItem (todo, 0)\n    list remove (todo, item)\n    switch (TypeOf (item)) {\n      case (\"string\") {\n        foreach (part, Split(item)) {\n          if (IsInt (part)) {\n            list add (todo, ToInt (part))\n          }\n          else {\n            list add (output, GetObject (part))\n          }\n        }\n      }\n      case (\"int\") {\n        for (i, 1, item) {\n          list add (output, null)\n        }\n      }\n      case (\"list\", \"objectlist\", \"stringlist\") {\n        foreach (part, item) {\n          list add (todo, part)\n        }\n      }\n      case (\"object\") {\n        list add (output, item)\n      }\n      case (\"script\") {\n        invoke (item, QuickParams (\"items\", output, \"parameters\", todo))\n      }\n      default {\n        JS.console.log (\"Warning: Can't convert \" + ToString (item) + \" (\" + TypeOf (item) + \") to object in MakeObjectList\")\n      }\n    }\n  }\n  return (output)\n&lt;/function&gt;\n</code></pre>\n<p>EDIT2:<br>\nA second function, this time to add a single room to an existing chunk. This does it recursively, because that seems like the simplest way to do it. The actual chunk-connecting code will be pretty similar to this, but with a lot more complex stuff added.</p>\n<p>This time, I'm actually passing a bunch of stringlists to the function; it will return the number of rooms added, but will pass back a lot more data by adding items to those lists. This seems to make more sense, as it means we don't need to take a long time massaging the data into a usable format to pass back and forth.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>room</code> - rooms to add</li>\n<li><code>xpos</code>, <code>ypos</code>, <code>zpos</code> - coordinates for the room</li>\n<li><code>rooms_by_coords</code> - dictionary mapping coordinate strings (\"X;Y;Z\") onto the rooms that can be found there. Value will be a room <em>name</em>, to account for clones. Clones will show as \"roomname=number\"; for example, the 3rd clone of hallway1 will be named \"hallway1=3\". Because a chunk might already contain multiple rooms at the same coords for some reason (such as in/out exits or nested rooms), this will be a dictionary of stringlists containing the names.</li>\n<li><code>rooms_in_chunk</code> - as above, but for rooms added in this chunk. Tracked separately so that they could easily be removed if it turns out the room isn't allowed here.</li>\n<li><code>pending_exits</code> - an objectlist, containing exits from which new chunks could be reached</li>\n<li><code>pending_required</code> - an objectlist of required rooms which haven't yet been reached</li>\n<li><code>mapwarnings</code> - a stringlist of warnings, which may be displayed on the console so that users can figure out why their map has problems</li>\n<li><code>maperrors</code> - a stringlist of errors found while trying to lay out the map. If this has any elements in it, the chunk will probably fail to be generated; but we don't abort right away in case another script wants to overrule it</li>\n</ul>\n<pre><code>&lt;function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors\" type=\"int\"&gt;\n  // TODO\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2024-05-23T13:41:23.4908014Z",
      "LastEditDate": "2024-05-26T08:52:52.8542227Z",
      "link": null
    },
    {
      "PostId": "6ea36d99-fcea-41b6-9de9-7dd155ae5753",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Just realised I never finished this. That's what happens when I try to make something in my own project; I just get too many other things demanding my attention. Thought that doing it on a forum post might be easier, but…\r\n\r\nWell, here's a little bit more, anyway. Utility functions first\r\n```\r\n<function name=\"AddRoomCoordsToDictionary\" parameters=\"dict, coords, roomname, mapwarnings\">\r\n  if (DictionaryContains (dict, coords)) {\r\n    list = DictionaryItem (dict, coords)\r\n  }\r\n  else {\r\n    list = NewStringList ()\r\n    dictionary add (dict, coords, list)\r\n  }\r\n  if (ListContains (list, roomname)) {\r\n    list add (mapwarnings, \"Adding room '\" + roomname + \"' to list at coords \" + coords + \". Room already present.\")\r\n  }\r\n  else {\r\n    list add (list, roomname)\r\n  }\r\n</function>\r\n\r\n<function name=\"RemoveRoomCoordsFromDictionary\" parameters=\"dict, coords, roomname, mapwarnings\">\r\n  if (DictionaryContains (dict, coords)) {\r\n    list = DictionaryItem (dict, coords)\r\n    if (ListContains (list, roomname)) {\r\n      list remove (list, roomname)\r\n    }\r\n    else {\r\n      list add (mapwarnings, \"Removing room '\" + roomname + \"' from dictionary at coords \" + coords + \". Room doesn't exist here.\")\r\n    }\r\n  }\r\n  else {\r\n    list add (mapwarnings, \"Removing room '\" + roomname + \"' from dictionary at coords \" + coords + \". No rooms at these coordinates.\")\r\n  }\r\n</function>\r\n\r\n<function name=\"RollbackCoordsDictionaries\" parameters=\"masterdict, rollbackdict, mapwarnings\">\r\n  foreach (coords, rollbackdict) {\r\n    roomlist = DictionaryItem (rollbackdict, coords)\r\n    while (not ListCount (roomlist) = 0) {\r\n      roomname = ListItem (roomlist, 0)\r\n      RemoveRoomCoordsFromDictionary (masterdict, coords, roomname, mapwarnings)\r\n      RemoveRoomCoordsFromDictionary (rollbackdict, coords, roomname, mapwarnings)\r\n      room = GetMapBaseRoom (roomname, mapwarnings, maperrors)\r\n      if (not room=null) {\r\n        switch (TypeOf (room, \"map_coordinates\")) {\r\n          case (\"string\") {\r\n            if (room.map_coordinates = coords) {\r\n              room.map_coordinates = null\r\n            }\r\n            else {\r\n              list add (maperrors, \"Removing room '\" + roomname + \"' from \" + coords + \", but it's at \" + room.map_coordinates)\r\n            }\r\n          }\r\n          case (\"list\", \"stringlist\") {\r\n            if (ListContains (room.map_coordinates, coords)) {\r\n              list remove (room.map_coordinates, coords)\r\n            }\r\n            else {\r\n              list add (maperrors, \"Removing room '\" + roomname + \"' from \" + coords + \", but it's at \" + room.map_coordinates)\r\n            }\r\n          }\r\n          default {\r\n            list add (maperrors, \"Removing '\" + roomname + \"' from \" + coords + \" but its map_coordinates is \r\n \"+room.map_coordinates + \"' (\"+TypeOf (room, \"map_coordinates\") + \")\")\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n</function>\r\n\r\n<!-- This function may have more sanity checks added later - like checking for clones of a non-cloneable room -->\r\n<!-- For now it will just let errors slip through, so isn't very robust -->\r\n<function name=\"GetMapBaseRoom\" parameters=\"roomname, mapwarnings, maperrors\" type=\"object\">\r\n  split = Instr (roomname, \"=\")\r\n  if (split = 0) {\r\n    room = GetObject (roomname)\r\n  }\r\n  else {\r\n    room = GetObject (Left (roomname, split - 1))\r\n  }\r\n  if (room = null) {\r\n    list add (maperrors, \"Failed to get base room for '\" + roomname + \"'\")\r\n  }\r\n  return (room)\r\n</function>\r\n```\r\nAnd then we move on to actual logic:\r\n```\r\n<function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, exits_to_create, pending_required, mapwarnings, maperrors\" type=\"int\">\r\n  coords = \"\" + x + \"/\" + y + \"/\" + z\r\n  roomname = room.name\r\n  if (IsRoomAtCoordinates (room, coords)) {\r\n    return (0)\r\n  }\r\n  else if (HasAttribute (room, \"map_coordinates\")) {\r\n    switch (TypeOf ((room, \"map_coordinates\")) {\r\n      case (\"string\") {\r\n        if (room.map_coordinates = \"\") {\r\n          room.map_coordinates = coords\r\n          list add (mapwarnings, \"Room \" + room.name + \" had empty string in coords\")\r\n        }\r\n        else {\r\n          if (not GetBoolean (map, \"cloneable\")) {\r\n            list add (mapwarnings, \"Cloning non-cloneable room \" + room.name)\r\n          }\r\n          // TODO - change the attribute to a list\r\n        }\r\n      }\r\n      case (\"stringlist\", \"list\") {\r\n        // TODO\r\n      }\r\n      default {\r\n        list add (maperrors, \"Couldn't add '\" + room.name + \"' at coords \" + coords + \" - map_coordinates is \" + room.map_coordinates + \" (\" + TypeOf (room, \"map_coordinates\") + \")\")\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    // room hasn't been placed yet\r\n    if (GetBoolean (room, \"cloneable\")) {\r\n      roomname = roomname + \"=1\"\r\n      room.map_coordinates = NewStringList ()\r\n      list add (room.map_coordinates, coords)\r\n    }\r\n    else {\r\n      room.map_coordinates = coords\r\n    }\r\n  }\r\n  AddRoomCoordsToDictionary (rooms_by_cords, coords, roomname, mapwarnings)\r\n  AddRoomCoordsToDictionary (rooms_in_chunk, coords, roomname, mapwarnings)\r\n  roomsadded = 1\r\n  // TODO - loop over exits and call this function again for adjacent rooms\r\n  return (roomsadded)\r\n</function>\r\n```\r\n\r\n**EDIT**: I've made a couple of attempts to fill in the incomplete bits of this function, and I keep finding unexpected complexity as a result of the clones. It might be better to disregard clones for now, and then add them in once the rest of the code is done.",
      "EditableFormat": "markdown",
      "HTML": "<p>Just realised I never finished this. That's what happens when I try to make something in my own project; I just get too many other things demanding my attention. Thought that doing it on a forum post might be easier, but…</p>\n<p>Well, here's a little bit more, anyway. Utility functions first</p>\n<pre><code>&lt;function name=\"AddRoomCoordsToDictionary\" parameters=\"dict, coords, roomname, mapwarnings\"&gt;\n  if (DictionaryContains (dict, coords)) {\n    list = DictionaryItem (dict, coords)\n  }\n  else {\n    list = NewStringList ()\n    dictionary add (dict, coords, list)\n  }\n  if (ListContains (list, roomname)) {\n    list add (mapwarnings, \"Adding room '\" + roomname + \"' to list at coords \" + coords + \". Room already present.\")\n  }\n  else {\n    list add (list, roomname)\n  }\n&lt;/function&gt;\n\n&lt;function name=\"RemoveRoomCoordsFromDictionary\" parameters=\"dict, coords, roomname, mapwarnings\"&gt;\n  if (DictionaryContains (dict, coords)) {\n    list = DictionaryItem (dict, coords)\n    if (ListContains (list, roomname)) {\n      list remove (list, roomname)\n    }\n    else {\n      list add (mapwarnings, \"Removing room '\" + roomname + \"' from dictionary at coords \" + coords + \". Room doesn't exist here.\")\n    }\n  }\n  else {\n    list add (mapwarnings, \"Removing room '\" + roomname + \"' from dictionary at coords \" + coords + \". No rooms at these coordinates.\")\n  }\n&lt;/function&gt;\n\n&lt;function name=\"RollbackCoordsDictionaries\" parameters=\"masterdict, rollbackdict, mapwarnings\"&gt;\n  foreach (coords, rollbackdict) {\n    roomlist = DictionaryItem (rollbackdict, coords)\n    while (not ListCount (roomlist) = 0) {\n      roomname = ListItem (roomlist, 0)\n      RemoveRoomCoordsFromDictionary (masterdict, coords, roomname, mapwarnings)\n      RemoveRoomCoordsFromDictionary (rollbackdict, coords, roomname, mapwarnings)\n      room = GetMapBaseRoom (roomname, mapwarnings, maperrors)\n      if (not room=null) {\n        switch (TypeOf (room, \"map_coordinates\")) {\n          case (\"string\") {\n            if (room.map_coordinates = coords) {\n              room.map_coordinates = null\n            }\n            else {\n              list add (maperrors, \"Removing room '\" + roomname + \"' from \" + coords + \", but it's at \" + room.map_coordinates)\n            }\n          }\n          case (\"list\", \"stringlist\") {\n            if (ListContains (room.map_coordinates, coords)) {\n              list remove (room.map_coordinates, coords)\n            }\n            else {\n              list add (maperrors, \"Removing room '\" + roomname + \"' from \" + coords + \", but it's at \" + room.map_coordinates)\n            }\n          }\n          default {\n            list add (maperrors, \"Removing '\" + roomname + \"' from \" + coords + \" but its map_coordinates is \n \"+room.map_coordinates + \"' (\"+TypeOf (room, \"map_coordinates\") + \")\")\n          }\n        }\n      }\n    }\n  }\n&lt;/function&gt;\n\n&lt;!-- This function may have more sanity checks added later - like checking for clones of a non-cloneable room --&gt;\n&lt;!-- For now it will just let errors slip through, so isn't very robust --&gt;\n&lt;function name=\"GetMapBaseRoom\" parameters=\"roomname, mapwarnings, maperrors\" type=\"object\"&gt;\n  split = Instr (roomname, \"=\")\n  if (split = 0) {\n    room = GetObject (roomname)\n  }\n  else {\n    room = GetObject (Left (roomname, split - 1))\n  }\n  if (room = null) {\n    list add (maperrors, \"Failed to get base room for '\" + roomname + \"'\")\n  }\n  return (room)\n&lt;/function&gt;\n</code></pre>\n<p>And then we move on to actual logic:</p>\n<pre><code>&lt;function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, exits_to_create, pending_required, mapwarnings, maperrors\" type=\"int\"&gt;\n  coords = \"\" + x + \"/\" + y + \"/\" + z\n  roomname = room.name\n  if (IsRoomAtCoordinates (room, coords)) {\n    return (0)\n  }\n  else if (HasAttribute (room, \"map_coordinates\")) {\n    switch (TypeOf ((room, \"map_coordinates\")) {\n      case (\"string\") {\n        if (room.map_coordinates = \"\") {\n          room.map_coordinates = coords\n          list add (mapwarnings, \"Room \" + room.name + \" had empty string in coords\")\n        }\n        else {\n          if (not GetBoolean (map, \"cloneable\")) {\n            list add (mapwarnings, \"Cloning non-cloneable room \" + room.name)\n          }\n          // TODO - change the attribute to a list\n        }\n      }\n      case (\"stringlist\", \"list\") {\n        // TODO\n      }\n      default {\n        list add (maperrors, \"Couldn't add '\" + room.name + \"' at coords \" + coords + \" - map_coordinates is \" + room.map_coordinates + \" (\" + TypeOf (room, \"map_coordinates\") + \")\")\n      }\n    }\n  }\n  else {\n    // room hasn't been placed yet\n    if (GetBoolean (room, \"cloneable\")) {\n      roomname = roomname + \"=1\"\n      room.map_coordinates = NewStringList ()\n      list add (room.map_coordinates, coords)\n    }\n    else {\n      room.map_coordinates = coords\n    }\n  }\n  AddRoomCoordsToDictionary (rooms_by_cords, coords, roomname, mapwarnings)\n  AddRoomCoordsToDictionary (rooms_in_chunk, coords, roomname, mapwarnings)\n  roomsadded = 1\n  // TODO - loop over exits and call this function again for adjacent rooms\n  return (roomsadded)\n&lt;/function&gt;\n</code></pre>\n<p><strong>EDIT</strong>: I've made a couple of attempts to fill in the incomplete bits of this function, and I keep finding unexpected complexity as a result of the clones. It might be better to disregard clones for now, and then add them in once the rest of the code is done.</p>\n\n",
      "PostDate": "2024-06-03T16:57:03.8224542Z",
      "LastEditDate": "2024-06-04T19:52:40.3086696Z",
      "link": null
    },
    {
      "PostId": "e0874321-f3dc-4ca7-8984-1b242b64ac40",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Okay… here's a simplified version without support for cloneable rooms\r\n```\r\n<function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors\" type=\"int\">\r\n  coords = \"\" + x + \"/\" + y + \"/\" + z\r\n  roomname = room.name\r\n  if (HasString (room, \"map_coordinates\")) {\r\n    if (not Equals (coords, room.map_coordinates)) {\r\n      list add (maperrors, \"Room \" + room.name + \" has already been placed at \" + room.map_coordinates + \". Can't place it at \" + coords + \".\")\r\n    }\r\n    return (0)\r\n  }\r\n  else {\r\n    // room hasn't been placed yet\r\n    room.map_coordinates = coords\r\n  }\r\n  AddRoomCoordsToDictionary (rooms_by_cords, coords, roomname, mapwarnings)\r\n  AddRoomCoordsToDictionary (rooms_in_chunk, coords, roomname, mapwarnings)\r\n  if (ListContains (pending_required, room)) {\r\n    list remove (pending_required, room)\r\n  }\r\n  roomsadded = 1\r\n\r\n  // TODO - loop over exits and call this function again for adjacent rooms\r\n  foreach (door, AllExits()) {\r\n    if (door.parent = room) {\r\n      if (HasAttribute (door, \"random_to\") or HasAttribute (door, \"random_to_expression\") and not GetBoolean (door, \"random_done\")) {\r\n        list add (pending_exits, door)\r\n      }\r\n      else if (not GetBoolean (door, \"map_wonky\")) {\r\n        xdest = xpos\r\n        ydest = ypos\r\n        zdest = zpos\r\n        foreach (dir, Split(\"north;south;east;west;northeast;northwest;southeast;southwest;up;down\")) {\r\n          if (DoesInherit (door, dir + \"direction\")) {\r\n            if (not Instr(dir, \"north\") = 0) {\r\n              ydest = ydest - 1\r\n            }\r\n            else if (not Instr(dir, \"south\") = 0) {\r\n              ydest = ydest + 1\r\n            }\r\n            if (not Instr(dir, \"west\") = 0) {\r\n              xdest = xdest - 1\r\n            }\r\n            else if (not Instr(dir, \"east\") = 0) {\r\n              xdest = xdest + 1\r\n            }\r\n            if (not Instr(dir, \"down\") = 0) {\r\n              zdest = zdest - 1\r\n            }\r\n            else if (not Instr(dir, \"up\") = 0) {\r\n              zdest = zdest + 1\r\n            }\r\n          }\r\n        }\r\n        roomsadded = roomsadded + AddRoomToChunk (door.to, xdest, ydest, zdest, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors)\r\n      }\r\n    }\r\n  }\r\n  return (roomsadded)\r\n</function>\r\n```",
      "EditableFormat": "markdown",
      "HTML": "<p>Okay… here's a simplified version without support for cloneable rooms</p>\n<pre><code>&lt;function name=\"AddRoomToChunk\" parameters=\"room, xpos, ypos, zpos, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors\" type=\"int\"&gt;\n  coords = \"\" + x + \"/\" + y + \"/\" + z\n  roomname = room.name\n  if (HasString (room, \"map_coordinates\")) {\n    if (not Equals (coords, room.map_coordinates)) {\n      list add (maperrors, \"Room \" + room.name + \" has already been placed at \" + room.map_coordinates + \". Can't place it at \" + coords + \".\")\n    }\n    return (0)\n  }\n  else {\n    // room hasn't been placed yet\n    room.map_coordinates = coords\n  }\n  AddRoomCoordsToDictionary (rooms_by_cords, coords, roomname, mapwarnings)\n  AddRoomCoordsToDictionary (rooms_in_chunk, coords, roomname, mapwarnings)\n  if (ListContains (pending_required, room)) {\n    list remove (pending_required, room)\n  }\n  roomsadded = 1\n\n  // TODO - loop over exits and call this function again for adjacent rooms\n  foreach (door, AllExits()) {\n    if (door.parent = room) {\n      if (HasAttribute (door, \"random_to\") or HasAttribute (door, \"random_to_expression\") and not GetBoolean (door, \"random_done\")) {\n        list add (pending_exits, door)\n      }\n      else if (not GetBoolean (door, \"map_wonky\")) {\n        xdest = xpos\n        ydest = ypos\n        zdest = zpos\n        foreach (dir, Split(\"north;south;east;west;northeast;northwest;southeast;southwest;up;down\")) {\n          if (DoesInherit (door, dir + \"direction\")) {\n            if (not Instr(dir, \"north\") = 0) {\n              ydest = ydest - 1\n            }\n            else if (not Instr(dir, \"south\") = 0) {\n              ydest = ydest + 1\n            }\n            if (not Instr(dir, \"west\") = 0) {\n              xdest = xdest - 1\n            }\n            else if (not Instr(dir, \"east\") = 0) {\n              xdest = xdest + 1\n            }\n            if (not Instr(dir, \"down\") = 0) {\n              zdest = zdest - 1\n            }\n            else if (not Instr(dir, \"up\") = 0) {\n              zdest = zdest + 1\n            }\n          }\n        }\n        roomsadded = roomsadded + AddRoomToChunk (door.to, xdest, ydest, zdest, rooms_by_coords, rooms_in_chunk, pending_exits, pending_required, mapwarnings, maperrors)\n      }\n    }\n  }\n  return (roomsadded)\n&lt;/function&gt;\n</code></pre>\n\n",
      "PostDate": "2024-06-07T13:32:07.9798029Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
