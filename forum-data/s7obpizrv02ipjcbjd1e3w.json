{
  "Topic": {
    "TopicId": "s7obpizrv02ipjcbjd1e3w",
    "ForumId": "24",
    "Title": "JS arrays in squiffy",
    "LastUpdated": "2021-01-03T03:06:17.4067765Z",
    "ReplyCount": 0
  },
  "Posts": [
    {
      "PostId": "a49f088a-f1a5-4d8f-b887-6ce36a92d798",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "According to what I'm reading, variables (and arrays) in JS are all global in nature. However, I'm not having a lot of luck seeing arrays in functions. An example:\r\n```\r\n[[Start]]:\r\n\r\n    var Arr1 = [];\r\n    Arr1[0]=50;\r\n\r\n    set(\"test1\",Arr1[0]); //works\r\ntest1={test1}\r\n\r\n[[Next]]\r\n\r\n[[Next]]:\r\n    set(\"test2\",Arr1[0]); //fails\r\ntest2={test2}\r\n```\r\nAny ideas on how to use an array in other places (either JS functions or other squiffy sections)?",
      "EditableFormat": "markdown",
      "HTML": "<p>According to what I'm reading, variables (and arrays) in JS are all global in nature. However, I'm not having a lot of luck seeing arrays in functions. An example:</p>\n<pre><code>[[Start]]:\n\n    var Arr1 = [];\n    Arr1[0]=50;\n\n    set(\"test1\",Arr1[0]); //works\ntest1={test1}\n\n[[Next]]\n\n[[Next]]:\n    set(\"test2\",Arr1[0]); //fails\ntest2={test2}\n</code></pre>\n<p>Any ideas on how to use an array in other places (either JS functions or other squiffy sections)?</p>\n\n",
      "PostDate": "2021-01-03T03:06:17.4067765Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "9ffd7d92-ba29-49b3-a498-4de2e9e87c15",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Declaring a variable with `var` is optional, and makes it local to the current function. ",
      "EditableFormat": "markdown",
      "HTML": "<p>Declaring a variable with <code>var</code> is optional, and makes it local to the current function.</p>\n\n",
      "PostDate": "2021-01-03T06:34:39.1803984Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "1aaff333-06a9-4172-87d9-0c951953547b",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Taking Var out of this code causes it to crash in Squiffy.\r\n\r\nActually, last night I poked around some more and found a conversation where someone talked about the same thing - JS variables and arrays do not cross into new sections - they are local to that section.\r\n\r\nIf you want to jump a variable to another section, you have to carry it across in a squiffy variable, using Set and Get commands. Which means arrays are out.\r\n\r\nWhich is okay. Last night in bed, I thought about it and figured a way to do it with just squiffy variables. I'm not sure how keen I am with this -an array would have been perfect. But you do what you can do with this application, I guess.",
      "EditableFormat": "markdown",
      "HTML": "<p>Taking Var out of this code causes it to crash in Squiffy.</p>\n<p>Actually, last night I poked around some more and found a conversation where someone talked about the same thing - JS variables and arrays do not cross into new sections - they are local to that section.</p>\n<p>If you want to jump a variable to another section, you have to carry it across in a squiffy variable, using Set and Get commands. Which means arrays are out.</p>\n<p>Which is okay. Last night in bed, I thought about it and figured a way to do it with just squiffy variables. I'm not sure how keen I am with this -an array would have been perfect. But you do what you can do with this application, I guess.</p>\n\n",
      "PostDate": "2021-01-03T15:47:35.3992057Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "097db7cb-fd3d-474e-a1de-f0c30e700821",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Actually, last night I poked around some more and found a conversation where someone talked about the same thing - JS variables and arrays do not cross into new sections - they are local to that section.\r\n\r\nTechnically, undeclared variables aren't even variables; they're properties.\r\n\r\nIf you just do `Arr1 = []` without the `var`, it doesn't declare a local variable. It assumes `Arr1` is shorthand for `this.Arr1`. But Squiffy does something a little odd (which I'd forgotten about), so even though `this` refers to something like `squiffy.story.sections['Start']`, setting an attribute on it doesn't work as expected.\r\n\r\nThe usual way of handling global variables in cases like this is to use an object you know to be global. For example, you can refer to `window.Arr1`, and know that it's the same variable everywhere. That's the easy way to use global JS variables in Squiffy.\r\n\r\n**But** there's a downside. Squiffy attributes are stored in LocalStorage, so they're still there when the player closes the browser and opens it again. The same isn't true for JS variables, which only last as long as the window exists. So in this case, it still might be helpful to use a Squiffy attribute.\r\n\r\n> Which means arrays are out.\r\n\r\nI don't see why it should be.\r\n\r\nHow about:\r\n```\r\n[[Start]]:\r\n    var Arr1 = [0, 1, \"foo\"];\r\n    set (\"Arr1\", JSON.stringify(Arr1));\r\n\r\nThe attribute Arr1 has been set to the string: '{Arr1}'.\r\n\r\nOK, now try [[Next]].\r\n\r\n[[Next]]:\r\n    var Arr1 = JSON.parse(get(\"Arr1\"))\r\n    set(\"test2\", Arr1[1])\r\n\r\nThe middle element of that array is {test2}.\r\n```\r\nJSON lets you turn a javascript data type into a string and back again. It's normally used when stuff like arrays and objects needs to be sent between a client and server; but it works just fine for storing arrays or other data in a Squiffy attribute. This method works fine whether it's arrays or plain objects you're dealing with. Or even arrays of objects.\r\n\r\n<hr/>\r\n\r\nAn alternative I've used, to avoid having to explicitly use JSON everywhere, is to store them in a javascript variable, and put that into an attribute when saving. Something like (off the top of my head):\r\n\r\n```\r\n[[Start]]:\r\n    // Redefining the save function, so that it will save our custom variable\r\n    squiffy.story.save = function () {\r\n        // This is what 'save' does by default:\r\n        squiffy.set('_output', squiffy.ui.output.html());\r\n\r\n        // Save our custom variable\r\n        squiffy.set('myvariable', JSON.stringify(window.myvariable))\r\n\r\n        // And abuse the 'transition' mechanism to make sure it's loaded again\r\n        // by causing the javascript in a particular section to to be run as soon as this saved game is loaded\r\n        squiffy.set('_transition', \"squiffy.story.sections['load variables'].js\")\r\n    }\r\n    window.myvariable = [];\r\n    // Now we've guaranteed that window.myvariable exists, it will be accessible because it's in the context chain\r\n    // so we don't need to look at it again\r\n\r\nNow, take a look at the [[first section]].\r\n\r\n[[load variables]]:\r\n    window.myvariable = JSON.parse(get(\"myvariable\"))\r\n\r\nThis section should never actually be visited, so it doesn't need text. It just makes sure that the variable is saved correctly.\r\n\r\n[[first section]]:\r\n    myvariable = [\"apple\", \"banana\"];\r\n\r\nSo what next?\r\nDo you  like [more bananas], [cherries], or [peaches]?\r\nOr would you like to see [[what the variable contains]]?\r\n\r\n[more bananas]:\r\n    myvariable.push(\"all the bananas\")\r\n\r\nOkay! Now what?\r\n\r\n[cherries]:\r\n    myvariable.push(\"cherry\")\r\n\r\nOkay! Now what?\r\n\r\n[peaches]:\r\n    myvariable.push(\"peaches\")\r\n\r\nOkay! Now what?\r\n\r\n[[what the variable contains]]:\r\n    set ('testvariable', myvariable.join(', '))\r\n\r\nThat variable contains: {testvariable}.\r\n```\r\n\r\nThis means you have all the flexibility of a JS variable, which is accessible anywhere as long as you explicitly refer to it as `window.myvariable` the first time. And it persists into a saved game as well.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Actually, last night I poked around some more and found a conversation where someone talked about the same thing - JS variables and arrays do not cross into new sections - they are local to that section.</p>\n</blockquote>\n<p>Technically, undeclared variables aren't even variables; they're properties.</p>\n<p>If you just do <code>Arr1 = []</code> without the <code>var</code>, it doesn't declare a local variable. It assumes <code>Arr1</code> is shorthand for <code>this.Arr1</code>. But Squiffy does something a little odd (which I'd forgotten about), so even though <code>this</code> refers to something like <code>squiffy.story.sections['Start']</code>, setting an attribute on it doesn't work as expected.</p>\n<p>The usual way of handling global variables in cases like this is to use an object you know to be global. For example, you can refer to <code>window.Arr1</code>, and know that it's the same variable everywhere. That's the easy way to use global JS variables in Squiffy.</p>\n<p><strong>But</strong> there's a downside. Squiffy attributes are stored in LocalStorage, so they're still there when the player closes the browser and opens it again. The same isn't true for JS variables, which only last as long as the window exists. So in this case, it still might be helpful to use a Squiffy attribute.</p>\n<blockquote>\n<p>Which means arrays are out.</p>\n</blockquote>\n<p>I don't see why it should be.</p>\n<p>How about:</p>\n<pre><code>[[Start]]:\n    var Arr1 = [0, 1, \"foo\"];\n    set (\"Arr1\", JSON.stringify(Arr1));\n\nThe attribute Arr1 has been set to the string: '{Arr1}'.\n\nOK, now try [[Next]].\n\n[[Next]]:\n    var Arr1 = JSON.parse(get(\"Arr1\"))\n    set(\"test2\", Arr1[1])\n\nThe middle element of that array is {test2}.\n</code></pre>\n<p>JSON lets you turn a javascript data type into a string and back again. It's normally used when stuff like arrays and objects needs to be sent between a client and server; but it works just fine for storing arrays or other data in a Squiffy attribute. This method works fine whether it's arrays or plain objects you're dealing with. Or even arrays of objects.</p>\n<hr>\n<p>An alternative I've used, to avoid having to explicitly use JSON everywhere, is to store them in a javascript variable, and put that into an attribute when saving. Something like (off the top of my head):</p>\n<pre><code>[[Start]]:\n    // Redefining the save function, so that it will save our custom variable\n    squiffy.story.save = function () {\n        // This is what 'save' does by default:\n        squiffy.set('_output', squiffy.ui.output.html());\n\n        // Save our custom variable\n        squiffy.set('myvariable', JSON.stringify(window.myvariable))\n\n        // And abuse the 'transition' mechanism to make sure it's loaded again\n        // by causing the javascript in a particular section to to be run as soon as this saved game is loaded\n        squiffy.set('_transition', \"squiffy.story.sections['load variables'].js\")\n    }\n    window.myvariable = [];\n    // Now we've guaranteed that window.myvariable exists, it will be accessible because it's in the context chain\n    // so we don't need to look at it again\n\nNow, take a look at the [[first section]].\n\n[[load variables]]:\n    window.myvariable = JSON.parse(get(\"myvariable\"))\n\nThis section should never actually be visited, so it doesn't need text. It just makes sure that the variable is saved correctly.\n\n[[first section]]:\n    myvariable = [\"apple\", \"banana\"];\n\nSo what next?\nDo you  like [more bananas], [cherries], or [peaches]?\nOr would you like to see [[what the variable contains]]?\n\n[more bananas]:\n    myvariable.push(\"all the bananas\")\n\nOkay! Now what?\n\n[cherries]:\n    myvariable.push(\"cherry\")\n\nOkay! Now what?\n\n[peaches]:\n    myvariable.push(\"peaches\")\n\nOkay! Now what?\n\n[[what the variable contains]]:\n    set ('testvariable', myvariable.join(', '))\n\nThat variable contains: {testvariable}.\n</code></pre>\n<p>This means you have all the flexibility of a JS variable, which is accessible anywhere as long as you explicitly refer to it as <code>window.myvariable</code> the first time. And it persists into a saved game as well.</p>\n\n",
      "PostDate": "2021-01-03T19:34:17.2496534Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0f02f7f9-7212-4f52-b4df-5d4d29e003d6",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "I think that might do it. I'm going to have to play with it a bit. One thing I did see - I'm expecting it to be pretty large (800+). It (your first example) doesn't seem to like leaving the array open - does it need to be allocated?\r\n\r\n```\r\n[[Start]]:\r\n    var Arr1 = [];\r\n    set (\"Arr1\", JSON.stringify(Arr1));\r\n\r\n    Arr1[1]=5;\r\n    \r\nThe attribute Arr1 has been set to the string: '{Arr1}'.\r\n\r\nOK, now try [[Next]].\r\n\r\n[[Next]]:\r\n    var Arr1 = JSON.parse(get(\"Arr1\"))\r\n    set(\"test2\", Arr1[1])\r\n\r\nThe middle element of that array is {test2}.\r\n```\r\nIn this case, I get back true, not 5.",
      "EditableFormat": "markdown",
      "HTML": "<p>I think that might do it. I'm going to have to play with it a bit. One thing I did see - I'm expecting it to be pretty large (800+). It (your first example) doesn't seem to like leaving the array open - does it need to be allocated?</p>\n<pre><code>[[Start]]:\n    var Arr1 = [];\n    set (\"Arr1\", JSON.stringify(Arr1));\n\n    Arr1[1]=5;\n    \nThe attribute Arr1 has been set to the string: '{Arr1}'.\n\nOK, now try [[Next]].\n\n[[Next]]:\n    var Arr1 = JSON.parse(get(\"Arr1\"))\n    set(\"test2\", Arr1[1])\n\nThe middle element of that array is {test2}.\n</code></pre>\n<p>In this case, I get back true, not 5.</p>\n\n",
      "PostDate": "2021-01-03T20:54:21.8682671Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0ed9b8ff-0e1e-4d77-a539-333e14885b3b",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> doesn't seem to like leaving the array open\r\n\r\nNot sure what you mean there.\r\n\r\n> does it need to be allocated\r\n\r\nNo; javascript is a high level language. An array is created by using `[]`, whether or not you put values in them.\r\n\r\n> In this case, I get back true, not 5.\r\n\r\nWhen you do `set (\"Arr1\", JSON.stringify(Arr1));`, you're setting the squiffy attribute to the string `\"[]\"` - the current values in that array. You can then add an element to the array, but the array is just a local variable.\r\n\r\nThe line in the second function, `Arr1 = JSON.parse(get(\"Arr1\"))`, restores that variable to the exact values it had when `set (\"Arr1\", JSON.stringify(Arr1))` was called. In this example, an empty array.\r\n\r\nSo your second section, you look at `Arr1[1]` and get back `undefined` because the array is empty. I'm not sure what weirdness of Squiffy's text processor causes this to render as \"true\", but I think I've come across that quirk before.\r\n\r\nIf you want to add values to the array, you need to do that *before* the call to `JSON.stringify`.\r\n\r\nThat's one of the reasons I prefer the second option. 8 lines of script at the start of your game, and then you can trust Squiffy to save the values after each section.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>doesn't seem to like leaving the array open</p>\n</blockquote>\n<p>Not sure what you mean there.</p>\n<blockquote>\n<p>does it need to be allocated</p>\n</blockquote>\n<p>No; javascript is a high level language. An array is created by using <code>[]</code>, whether or not you put values in them.</p>\n<blockquote>\n<p>In this case, I get back true, not 5.</p>\n</blockquote>\n<p>When you do <code>set (\"Arr1\", JSON.stringify(Arr1));</code>, you're setting the squiffy attribute to the string <code>\"[]\"</code> - the current values in that array. You can then add an element to the array, but the array is just a local variable.</p>\n<p>The line in the second function, <code>Arr1 = JSON.parse(get(\"Arr1\"))</code>, restores that variable to the exact values it had when <code>set (\"Arr1\", JSON.stringify(Arr1))</code> was called. In this example, an empty array.</p>\n<p>So your second section, you look at <code>Arr1[1]</code> and get back <code>undefined</code> because the array is empty. I'm not sure what weirdness of Squiffy's text processor causes this to render as \"true\", but I think I've come across that quirk before.</p>\n<p>If you want to add values to the array, you need to do that <em>before</em> the call to <code>JSON.stringify</code>.</p>\n<p>That's one of the reasons I prefer the second option. 8 lines of script at the start of your game, and then you can trust Squiffy to save the values after each section.</p>\n\n",
      "PostDate": "2021-01-04T01:40:40.6740509Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "64fe1d29-226d-46d1-9711-15d69250fbb3",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "```\r\n[[Start]]:\r\n    var Arr1 = [];\r\n    set (\"Arr1\", JSON.stringify(Arr1));\r\n    var Arr2 = [];\r\n    set (\"Arr2\", JSON.stringify(Arr2));\r\n    Arr1[1]=5;\r\n    Arr2[1]=42;\r\n    set(\"Arr2_1\",JSON.stringify(Arr2));\r\n    \r\nThe attribute Arr1 has been set to the string: '{Arr1}'.\r\n\r\nThe attribute Arr2 has been set to the string: '{Arr2}'.\r\n\r\nThe attribute Arr2_1 has been set to the string: '{Arr2_1}'.\r\n\r\nOK, now try [[Next]].\r\n\r\n[[Next]]:\r\n    var Arr1 = JSON.parse(get(\"Arr1\"))\r\n    set(\"test2\", Arr1[1])\r\n    var Arr2 = JSON.parse(get(\"Arr2\"))\r\n    set(\"test3\", Arr2[1])\r\n    var Arr2_1 = JSON.parse(get(\"Arr2_1\"))\r\n    set(\"test3\", Arr2[1])\r\n    set(\"test4\", Arr2_1[1])\r\n\r\nThe middle element of that array is {test2}.\r\n\r\nThe middle element of that array is {test3}.\r\n\r\nThe middle element of that array is {test4}.\r\n```\r\n\r\n---\r\n<details><summary>Animated GIF</summary>\r\n\r\n[![Peek 2021-01-03 20-53](https://user-images.githubusercontent.com/30656341/103496997-ca411d00-4e05-11eb-9c5b-f20840159191.gif)](https://user-images.githubusercontent.com/30656341/103496997-ca411d00-4e05-11eb-9c5b-f20840159191.gif)\r\n\r\n</details>\r\n",
      "EditableFormat": "markdown",
      "HTML": "<pre><code>[[Start]]:\n    var Arr1 = [];\n    set (\"Arr1\", JSON.stringify(Arr1));\n    var Arr2 = [];\n    set (\"Arr2\", JSON.stringify(Arr2));\n    Arr1[1]=5;\n    Arr2[1]=42;\n    set(\"Arr2_1\",JSON.stringify(Arr2));\n    \nThe attribute Arr1 has been set to the string: '{Arr1}'.\n\nThe attribute Arr2 has been set to the string: '{Arr2}'.\n\nThe attribute Arr2_1 has been set to the string: '{Arr2_1}'.\n\nOK, now try [[Next]].\n\n[[Next]]:\n    var Arr1 = JSON.parse(get(\"Arr1\"))\n    set(\"test2\", Arr1[1])\n    var Arr2 = JSON.parse(get(\"Arr2\"))\n    set(\"test3\", Arr2[1])\n    var Arr2_1 = JSON.parse(get(\"Arr2_1\"))\n    set(\"test3\", Arr2[1])\n    set(\"test4\", Arr2_1[1])\n\nThe middle element of that array is {test2}.\n\nThe middle element of that array is {test3}.\n\nThe middle element of that array is {test4}.\n</code></pre>\n<hr>\n<details><summary>Animated GIF</summary>\n<p><a href=\"https://user-images.githubusercontent.com/30656341/103496997-ca411d00-4e05-11eb-9c5b-f20840159191.gif\"><img src=\"https://user-images.githubusercontent.com/30656341/103496997-ca411d00-4e05-11eb-9c5b-f20840159191.gif\" alt=\"Peek 2021-01-03 20-53\"></a></p>\n</details>\n\n",
      "PostDate": "2021-01-04T02:27:22.4894523Z",
      "LastEditDate": "2021-01-07T14:18:39.9954416Z",
      "link": null
    },
    {
      "PostId": "898431f8-4c61-4a89-8ef6-e524ece257ef",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "So what am I doing wrong here? I thought (kinda) that I understand what you are doing (saving the location of the array, rather than the array). But I only get trues for values on the second section.\r\n```\r\n[[Start]]:\r\n    var Arr1 = [];\r\n    set (\"Arr1\", JSON.stringify(Arr1));\r\n\r\n    Arr1[1]=5;\r\n    \r\n    Arr1[10]=50;\r\n\r\nOK, now try [[Next]].\r\n\r\n[[Next]]:\r\n    var Arr1 = JSON.parse(get(\"Arr1\"))\r\n    set(\"test1\", Arr1[1]);\r\n    set(\"test2\", Arr1[10]);\r\n\r\ntest1 {test1}\r\n\r\ntest2 {test2}\r\n```\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>So what am I doing wrong here? I thought (kinda) that I understand what you are doing (saving the location of the array, rather than the array). But I only get trues for values on the second section.</p>\n<pre><code>[[Start]]:\n    var Arr1 = [];\n    set (\"Arr1\", JSON.stringify(Arr1));\n\n    Arr1[1]=5;\n    \n    Arr1[10]=50;\n\nOK, now try [[Next]].\n\n[[Next]]:\n    var Arr1 = JSON.parse(get(\"Arr1\"))\n    set(\"test1\", Arr1[1]);\n    set(\"test2\", Arr1[10]);\n\ntest1 {test1}\n\ntest2 {test2}\n</code></pre>\n\n",
      "PostDate": "2021-01-05T17:20:51.3068414Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "08488060-ea3f-47ee-b108-ef25d7e23485",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "You can't modify the array after you've \"stringified\" it into JSON.  Well, you can, but it has no affect on the \"stringified\" array.  You have to \"stringify\" into JSON *after* the array is the way you want it.\r\n\r\n<details>\r\n\r\n[![squiffy-bluevoss-2021-01-05](https://user-images.githubusercontent.com/30656341/103683324-abe73880-4f4f-11eb-8a64-4ec608580b04.gif)](https://user-images.githubusercontent.com/30656341/103683324-abe73880-4f4f-11eb-8a64-4ec608580b04.gif)\r\n\r\n</details>",
      "EditableFormat": "markdown",
      "HTML": "<p>You can't modify the array after you've \"stringified\" it into JSON.  Well, you can, but it has no affect on the \"stringified\" array.  You have to \"stringify\" into JSON <em>after</em> the array is the way you want it.</p>\n<details>\n<p><a href=\"https://user-images.githubusercontent.com/30656341/103683324-abe73880-4f4f-11eb-8a64-4ec608580b04.gif\"><img src=\"https://user-images.githubusercontent.com/30656341/103683324-abe73880-4f4f-11eb-8a64-4ec608580b04.gif\" alt=\"squiffy-bluevoss-2021-01-05\"></a></p>\n</details>\n\n",
      "PostDate": "2021-01-05T18:17:08.4477346Z",
      "LastEditDate": "2021-01-07T14:19:17.4090876Z",
      "link": null
    },
    {
      "PostId": "99b9400d-8e0f-4fea-a0b4-6c2a52acc837",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "Okay, I understand. I needed a way to keep track of things beyond the player's knowledge, but that involves them changing. Looks like I'll have to go with \"plan B\"\r\n",
      "EditableFormat": "markdown",
      "HTML": "<p>Okay, I understand. I needed a way to keep track of things beyond the player's knowledge, but that involves them changing. Looks like I'll have to go with \"plan B\"</p>\n\n",
      "PostDate": "2021-01-05T19:08:01.601906Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "3685c0d8-600c-4ae7-8830-1bd480fe026e",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> saving the location of the array, rather than the array\r\n\r\nNo, that's only in the version with the more complex function at the beginning.\r\n\r\nIn this version, `stringify` saves a snapshot of what the array's values currently are, and `parse` restores the array from the snapshot. You need to put the `stringify` line **after** the code that changes the array.\r\n\r\nIf you don't want to save and load the variables in every JS section that uses them, you should use the version with the function. Here's a more compressed version without the comments; which should be easier to adapt if there's more than one array you want to save:\r\n<pre><code>@start Start\r\n\r\n[[initialise variables]]:\r\n    Object.defineProperties (window, Object.fromEntries([<b style=\"color: blue; font-family: initial\">\"variable1\", \"Array2\", \"carbuncle\"</b>].map(attr => [attr,{get: () => JSON.parse(squiffy.get(attr) || \"\"),set: (v) => squiffy.set(attr, JSON.stringify(v))}])))\r\n\r\n[[Start]]:\r\n    squiffy.story.save = eval(\"(\"+squiffy.story.save.toString().replace('}', \";squiffy.set('_transition', \\\"squiffy.story.sections['initialise variables'].js\\\")}\")+\")\")\r\n    squiffy.story.sections['initialise variables'].js()\r\n\r\nYou can start your game as normal here, and trust in the Javascript Magic above to automatically save and restore your variables. All you need to do is change the list of variables.</code></pre>\r\n\r\nNote: You can't do this with javascript objects that contain functions, objects referring to a network or stream handle, prototypes, or any variable which is already a property of the window object. Apart from that, you can paste in a couple of lines and not have to worry about it any more. Just change the list of variable names which I've highlighted in blue in the code.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>saving the location of the array, rather than the array</p>\n</blockquote>\n<p>No, that's only in the version with the more complex function at the beginning.</p>\n<p>In this version, <code>stringify</code> saves a snapshot of what the array's values currently are, and <code>parse</code> restores the array from the snapshot. You need to put the <code>stringify</code> line <strong>after</strong> the code that changes the array.</p>\n<p>If you don't want to save and load the variables in every JS section that uses them, you should use the version with the function. Here's a more compressed version without the comments; which should be easier to adapt if there's more than one array you want to save:</p>\n<pre><code>@start Start\n\n[[initialise variables]]:\n    Object.defineProperties (window, Object.fromEntries([<b style=\"color: blue; font-family: initial\">\"variable1\", \"Array2\", \"carbuncle\"</b>].map(attr =&gt; [attr,{get: () =&gt; JSON.parse(squiffy.get(attr) || \"\"),set: (v) =&gt; squiffy.set(attr, JSON.stringify(v))}])))\n\n[[Start]]:\n    squiffy.story.save = eval(\"(\"+squiffy.story.save.toString().replace('}', \";squiffy.set('_transition', \\\"squiffy.story.sections['initialise variables'].js\\\")}\")+\")\")\n    squiffy.story.sections['initialise variables'].js()\n\nYou can start your game as normal here, and trust in the Javascript Magic above to automatically save and restore your variables. All you need to do is change the list of variables.</code></pre>\n<p>Note: You can't do this with javascript objects that contain functions, objects referring to a network or stream handle, prototypes, or any variable which is already a property of the window object. Apart from that, you can paste in a couple of lines and not have to worry about it any more. Just change the list of variable names which I've highlighted in blue in the code.</p>\n\n",
      "PostDate": "2021-01-05T20:41:44.8919755Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "c0314600-62f7-405a-8029-dbd786cd2b0c",
      "UserId": 518866,
      "Username": "K.V.",
      "AvatarUrl": "https://secure.gravatar.com/avatar/a97688aadc8152436180b511021e94a7?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> In this version, stringify saves a snapshot of what the array's values currently are, and parse restores the array from the snapshot. You need to put the stringify line after the code that changes the array.\r\n\r\nThis is how I wanted to explain it, but I had to use the example to show it instead.  (Hehehe.)\r\n\r\n> If you don't want to save and load the variables in every JS section that uses them, you should use the version with the function. \r\n\r\nHere's what I was wondering:  Which approach would slow the game down worse: going back and forth from JSON to an array, or having a huge array?  It seems like that array would be getting created (in some form or fashion) each time that JSON string is parsed; no? (Seriously asking -- not rhetorical at all.)",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>In this version, stringify saves a snapshot of what the array's values currently are, and parse restores the array from the snapshot. You need to put the stringify line after the code that changes the array.</p>\n</blockquote>\n<p>This is how I wanted to explain it, but I had to use the example to show it instead.  (Hehehe.)</p>\n<blockquote>\n<p>If you don't want to save and load the variables in every JS section that uses them, you should use the version with the function.</p>\n</blockquote>\n<p>Here's what I was wondering:  Which approach would slow the game down worse: going back and forth from JSON to an array, or having a huge array?  It seems like that array would be getting created (in some form or fashion) each time that JSON string is parsed; no? (Seriously asking -- not rhetorical at all.)</p>\n\n",
      "PostDate": "2021-01-05T23:45:58.0752727Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "d638985b-78f9-4154-a9c1-21819718a98c",
      "UserId": 319917,
      "Username": "mrangel",
      "AvatarUrl": "https://secure.gravatar.com/avatar/?d=retro",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "> Here's what I was wondering: Which approach would slow the game down worse: going back and forth from JSON to an array, or having a huge array? It seems like that array would be getting created (in some form or fashion) each time that JSON string is parsed; no? (Seriously asking -- not rhetorical at all.)\r\n\r\nIn theory you want to minimise the number of times data is serialised or deserialised.\r\n\r\nIn ranked order of efficiency:\r\n* Saving data\r\n   1. in a `beforeunload` event handler (when the page is closed; best)\r\n   2. when the data has been changed (`set` binding)\r\n   3. manually at the end of each section that changes the variable\r\n   4. in `squiffy.story.save` (after every section; worst)\r\n* Loading data\r\n   1. the first time data is accessed in a diven session (`get` binding)\r\n   2. when the game is loaded\r\n   3. manually at the start of each section that uses the variable (may be better than 2 if the variable isn't always needed)\r\n\r\nBut the time taken to evaluate a string like `[undefined,1,2,5]` is very small. Unless you're talking about hundreds of variables, or an array with thousands of elements, I don't think the player is ever going to notice.\r\n\r\nStill, here's a more efficient version of that code:\r\n\r\n```\r\n[[initialise variables]]:\r\n    var jsvars = {};\r\n    [\"variable1\", \"vaariable2\", \"myvariable3\"].forEach(attr => {\r\n        Object.defineProperty(window, attr, {\r\n            get: () => {\r\n                if (jsvars[attr]) {\r\n                    return jsvars[attr];\r\n                } else {\r\n                    let stored = squiffy.get(attr);\r\n                    return jsvars[attr] = stored ? JSON.parse(stored) : undefined;\r\n                }\r\n            },\r\n            set: (val) => {\r\n                if (val !== jsvars[attr]) {\r\n                    jsvars[attr] = val;\r\n                }\r\n            }\r\n        });\r\n    });\r\n    window.addEventListener('beforeunload', (event) => {\r\n        $.each(jsvars, (key, value) => squiffy.set(key, JSON.stringify (value)));\r\n        squiffy.set('_transition', \"squiffy.story.sections['initialise variables'].js\");\r\n    })\r\n\r\n[[Start]]:\r\n    squiffy.story.sections['initialise variables'].js();\r\n\r\nStart your game as normal…\r\n```\r\n\r\nThis is only saving the variables when the browser window is closed; which means that some data might be lost if the browser crashes or if the unload event is prevented (some popup blockers prevent this event from firing normally). Note that we can't use `set` to check when a variable is changed, because this only happens when a new value is assigned to it. You can add values to an existing array or object without calling its property set method.\r\n\r\nIt also defines the properties, but only calls `JSON.parse` the first time each property is accessed. This could be more efficient, but the difference is likely too small to notice in most cases.",
      "EditableFormat": "markdown",
      "HTML": "<blockquote>\n<p>Here's what I was wondering: Which approach would slow the game down worse: going back and forth from JSON to an array, or having a huge array? It seems like that array would be getting created (in some form or fashion) each time that JSON string is parsed; no? (Seriously asking -- not rhetorical at all.)</p>\n</blockquote>\n<p>In theory you want to minimise the number of times data is serialised or deserialised.</p>\n<p>In ranked order of efficiency:</p>\n<ul>\n<li>Saving data\n<ol>\n<li>in a <code>beforeunload</code> event handler (when the page is closed; best)</li>\n<li>when the data has been changed (<code>set</code> binding)</li>\n<li>manually at the end of each section that changes the variable</li>\n<li>in <code>squiffy.story.save</code> (after every section; worst)</li>\n</ol>\n</li>\n<li>Loading data\n<ol>\n<li>the first time data is accessed in a diven session (<code>get</code> binding)</li>\n<li>when the game is loaded</li>\n<li>manually at the start of each section that uses the variable (may be better than 2 if the variable isn't always needed)</li>\n</ol>\n</li>\n</ul>\n<p>But the time taken to evaluate a string like <code>[undefined,1,2,5]</code> is very small. Unless you're talking about hundreds of variables, or an array with thousands of elements, I don't think the player is ever going to notice.</p>\n<p>Still, here's a more efficient version of that code:</p>\n<pre><code>[[initialise variables]]:\n    var jsvars = {};\n    [\"variable1\", \"vaariable2\", \"myvariable3\"].forEach(attr =&gt; {\n        Object.defineProperty(window, attr, {\n            get: () =&gt; {\n                if (jsvars[attr]) {\n                    return jsvars[attr];\n                } else {\n                    let stored = squiffy.get(attr);\n                    return jsvars[attr] = stored ? JSON.parse(stored) : undefined;\n                }\n            },\n            set: (val) =&gt; {\n                if (val !== jsvars[attr]) {\n                    jsvars[attr] = val;\n                }\n            }\n        });\n    });\n    window.addEventListener('beforeunload', (event) =&gt; {\n        $.each(jsvars, (key, value) =&gt; squiffy.set(key, JSON.stringify (value)));\n        squiffy.set('_transition', \"squiffy.story.sections['initialise variables'].js\");\n    })\n\n[[Start]]:\n    squiffy.story.sections['initialise variables'].js();\n\nStart your game as normal…\n</code></pre>\n<p>This is only saving the variables when the browser window is closed; which means that some data might be lost if the browser crashes or if the unload event is prevented (some popup blockers prevent this event from firing normally). Note that we can't use <code>set</code> to check when a variable is changed, because this only happens when a new value is assigned to it. You can add values to an existing array or object without calling its property set method.</p>\n<p>It also defines the properties, but only calls <code>JSON.parse</code> the first time each property is accessed. This could be more efficient, but the difference is likely too small to notice in most cases.</p>\n\n",
      "PostDate": "2021-01-06T17:07:39.6412378Z",
      "LastEditDate": null,
      "link": null
    },
    {
      "PostId": "0179ce52-09a7-4314-8f57-0ba72ea1da31",
      "UserId": 251768,
      "Username": "Bluevoss",
      "AvatarUrl": "https://i.imgur.com/6mfIIbhb.gif",
      "UserAvatar": null,
      "UserGravatar": null,
      "EditableText": "After a lot of thought about this, I think I'll just handle it through function calls that select the correct variable. As for the moving items (spaceships) I'll just have to come up with a set of variables that combine location and velocity in one number.\r\n\r\nThanks for your help!",
      "EditableFormat": "markdown",
      "HTML": "<p>After a lot of thought about this, I think I'll just handle it through function calls that select the correct variable. As for the moving items (spaceships) I'll just have to come up with a set of variables that combine location and velocity in one number.</p>\n<p>Thanks for your help!</p>\n\n",
      "PostDate": "2021-01-11T19:33:06.8623719Z",
      "LastEditDate": null,
      "link": null
    }
  ]
}
