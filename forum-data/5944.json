{
  "Topic": {
    "TopicId": "5944",
    "ForumId": "3",
    "Title": "Help: Assembly Language (MASM .386)",
    "LastUpdated": "2016-04-07T10:59:57+01:00",
    "ReplyCount": 143
  },
  "Posts": [
    {
      "PostId": "41143",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm currently taking a beginning Assembly Language class, and am struggling with it.\n\nif any of you know MASM 30386 (.386, or .386+, but we're only tested on .386), and wouldn't mind and/or have the time, I could use all the help I can get on it!\n\nIf you're interested/available/willing/able to help, leave a post here letting me know.\n\nI struggled with our first program: palindrome (reversing a string), and bloody trying to figure out the IO winAPIs (ReadConsole, WriteConsole) ... grrr !!\n\n(I'll post the code/program that I came up with in a few days to a week later, when I'm not as busy with my school work/tests)",
      "EditableFormat": "bbcode",
      "HTML": "I'm currently taking a beginning Assembly Language class, and am struggling with it.<br/><br/>if any of you know MASM 30386 (.386, or .386+, but we're only tested on .386), and wouldn't mind and/or have the time, I could use all the help I can get on it!<br/><br/>If you're interested/available/willing/able to help, leave a post here letting me know.<br/><br/>I struggled with our first program: palindrome (reversing a string), and bloody trying to figure out the IO winAPIs (ReadConsole, WriteConsole) ... grrr !!<br/><br/>(I'll post the code/program that I came up with in a few days to a week later, when I'm not as busy with my school work/tests)",
      "PostDate": "2016-02-09T11:14:24+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41152",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I'm willing to give it a shot! I used to program the 80x86, decades ago. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "I'm willing to give it a shot! I used to program the 80x86, decades ago. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-02-09T21:24:19+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41155",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Awesome! Right now, the big jump for me is just learning all of the assembly commands and their syntax/format and etc, getting them to work, lol. And the same with learning all the winAPIs that we'll use more of too. After doing this first actual code-work, I think, I'm understanding much better, the basics of 'mov' (I'm learning the 'mov' mindset, vs the 'if and assignment' mindset of high level languages, I think pretty well now, which is used for doing assembly coding), addresses, registers, and the logic/pattern/sequence/methodology involved. Still a bit shaky with the stack, pushing, and popping function calls and their args/params, and etc. The other jump is assembly/low level coding vs high-level coding, as stuff isn't the same at assembly vs high level, as there's actual (&quot;very useful&quot;) run-time operations vs &quot;not as useful&quot; compile-time operations (the high-level like operator symbols: =, EQU, +, -, etc don't work the same as they do in high level languages, lol). Oh, and I really need to learn how to use the debugger and debug... though I do like learning on my own what is wrong or going on with my own program on my own, feels like I'm learning assembly better by doing so, then &quot;cheating&quot; with the Visual basic express/free IDE's debugger.\n\nThe MASM we're learning still uses a lot of the 80x86 architecture (processor's have kinda been stuck with intel's original 80x86 architecture, lol), but as far as I learned, the big change is just that (most of) the registers are expanded from 16 bit to 32 bit:\n\n<!-- m --><a class=\"postlink\" href=\"http://www.programming.msjc.edu/asm/Unit2/32-Bitx86Architecture.aspx\">http://www.programming.msjc.edu/asm/Uni ... cture.aspx</a><!-- m -->\n\nbut, I still got a lot more to learn...\n\n----------\n\nI won't try to bug you guys~gals too much, but if I can get any support for possibly when I need it, would be great of course. And, I know how busy, (especially) you are Jay, so you, and anyone/everyone else, don't feel any pressure. This thread is just for any possible support, emergencies, or just stuff I'm struggling with, so it's at your convenience or mood, if you want to help me with whatever I may post about, or not.",
      "EditableFormat": "bbcode",
      "HTML": "Awesome! Right now, the big jump for me is just learning all of the assembly commands and their syntax/format and etc, getting them to work, lol. And the same with learning all the winAPIs that we'll use more of too. After doing this first actual code-work, I think, I'm understanding much better, the basics of 'mov' (I'm learning the 'mov' mindset, vs the 'if and assignment' mindset of high level languages, I think pretty well now, which is used for doing assembly coding), addresses, registers, and the logic/pattern/sequence/methodology involved. Still a bit shaky with the stack, pushing, and popping function calls and their args/params, and etc. The other jump is assembly/low level coding vs high-level coding, as stuff isn't the same at assembly vs high level, as there's actual (&quot;very useful&quot;) run-time operations vs &quot;not as useful&quot; compile-time operations (the high-level like operator symbols: =, EQU, +, -, etc don't work the same as they do in high level languages, lol). Oh, and I really need to learn how to use the debugger and debug... though I do like learning on my own what is wrong or going on with my own program on my own, feels like I'm learning assembly better by doing so, then &quot;cheating&quot; with the Visual basic express/free IDE's debugger.<br/><br/>The MASM we're learning still uses a lot of the 80x86 architecture (processor's have kinda been stuck with intel's original 80x86 architecture, lol), but as far as I learned, the big change is just that (most of) the registers are expanded from 16 bit to 32 bit:<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.programming.msjc.edu/asm/Unit2/32-Bitx86Architecture.aspx\">http://www.programming.msjc.edu/asm/Uni ... cture.aspx</a><!-- m --><br/><br/>but, I still got a lot more to learn...<br/><br/>----------<br/><br/>I won't try to bug you guys~gals too much, but if I can get any support for possibly when I need it, would be great of course. And, I know how busy, (especially) you are Jay, so you, and anyone/everyone else, don't feel any pressure. This thread is just for any possible support, emergencies, or just stuff I'm struggling with, so it's at your convenience or mood, if you want to help me with whatever I may post about, or not.",
      "PostDate": "2016-02-10T02:50:28+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41156",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "When I was writing in assembly, there were no &quot;E*&quot; registers - only ones like AX, BX, SI, etc. And we were in real mode, so we had to address everything relative to the segment registers (and indices were 16-bit, so you had to do some interesting things to address more than 64K at a time - but then machines only had 1MB if you were lucky lol). Of course, it's all extensible, and I can read the disassembly nowadays when I'm debugging higher-level code. So we should be able to get there (or somewhere).",
      "EditableFormat": "bbcode",
      "HTML": "When I was writing in assembly, there were no &quot;E*&quot; registers - only ones like AX, BX, SI, etc. And we were in real mode, so we had to address everything relative to the segment registers (and indices were 16-bit, so you had to do some interesting things to address more than 64K at a time - but then machines only had 1MB if you were lucky lol). Of course, it's all extensible, and I can read the disassembly nowadays when I'm debugging higher-level code. So we should be able to get there (or somewhere).",
      "PostDate": "2016-02-10T08:31:02+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41374",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "My next assignment (time frame/due: Mar. 2) is to write a program that emulates a 16 bit/8086 cpu\n\nI've started and am currently confused on how to set/assign the address size vs the size of the value it holds.\n\n--------\nsome of the assignment instructions:\n\n6 registers each 8 bits (R0-R5, valued 0-5)\n16-bit (1 word) address space\n1k of RAM\non reset, cpu begins execution at 0\nregister operands are 1 byte\nall memory addresses are 2 bytes long (words)\n------\n\nthis is what I've brainstormed so far (not sure if this is how it can be done or not):\n\n(I've done this for the values as can be seen below, but am confused on how to set/assign the address size to be 16 bits/words)\n\n.data:\n\n; (Variables):\n\n; RA: an array/segment that holds the 6 registers (sub segments: R0-R5)\n\nRA byte 6 dup (0)\n\nR0 offset RA\nR1 offset RA + 1\nR2 offset RA + 2\nR3 offset RA + 3\nR4 offset RA + 4\nR5 offset RA + 5\n\nR0 sizeof type byte\nR1 sizeof type byte\nR2 sizeof type byte\nR3 sizeof type byte\nR4 sizeof type byte\nR5 sizeof type byte\n\nor, is this completely off, in what I need to do ???\n\n-----\n\nhow do I do 16 bit (2 bytes = 1 word) address space and have the values be 1 byte ???\n\ndo I set/assign the size of the array for the address size instead of what I did above? Is the address the MSB (most significant byte: bits 8-15) and the value the LSB (least significant byte: 0-7), or is the entire 16 bits used for the address, and then I just assign the size for its values... somehow? I'm confused, grr.",
      "EditableFormat": "bbcode",
      "HTML": "My next assignment (time frame/due: Mar. 2) is to write a program that emulates a 16 bit/8086 cpu<br/><br/>I've started and am currently confused on how to set/assign the address size vs the size of the value it holds.<br/><br/>--------<br/>some of the assignment instructions:<br/><br/>6 registers each 8 bits (R0-R5, valued 0-5)<br/>16-bit (1 word) address space<br/>1k of RAM<br/>on reset, cpu begins execution at 0<br/>register operands are 1 byte<br/>all memory addresses are 2 bytes long (words)<br/>------<br/><br/>this is what I've brainstormed so far (not sure if this is how it can be done or not):<br/><br/>(I've done this for the values as can be seen below, but am confused on how to set/assign the address size to be 16 bits/words)<br/><br/>.data:<br/><br/>; (Variables):<br/><br/>; RA: an array/segment that holds the 6 registers (sub segments: R0-R5)<br/><br/>RA byte 6 dup (0)<br/><br/>R0 offset RA<br/>R1 offset RA + 1<br/>R2 offset RA + 2<br/>R3 offset RA + 3<br/>R4 offset RA + 4<br/>R5 offset RA + 5<br/><br/>R0 sizeof type byte<br/>R1 sizeof type byte<br/>R2 sizeof type byte<br/>R3 sizeof type byte<br/>R4 sizeof type byte<br/>R5 sizeof type byte<br/><br/>or, is this completely off, in what I need to do ???<br/><br/>-----<br/><br/>how do I do 16 bit (2 bytes = 1 word) address space and have the values be 1 byte ???<br/><br/>do I set/assign the size of the array for the address size instead of what I did above? Is the address the MSB (most significant byte: bits 8-15) and the value the LSB (least significant byte: 0-7), or is the entire 16 bits used for the address, and then I just assign the size for its values... somehow? I'm confused, grr.",
      "PostDate": "2016-02-22T22:19:45+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41375",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I'm slightly confused, as you say you want to emulate a 16-bit 8086 cpu, but an 8086 doesn't have Rx registers. So I'll assume that you're just trying to emulate *a* 16-bit cpu of some kind. If I've gotten that wrong, let me know... It's also quite strange to have an 8-bit register size for a 16-bit processor.  <!-- s:? --><img src=\"{SMILIES_PATH}/icon_confused.gif\" alt=\":?\" title=\"Confused\" /><!-- s:? --> \n\nKeep in mind through all this that I'm not actually trying this out, so I could get things wrong...\n\n(It's been a while since I dealt with MASM directives, so I found this page: <!-- m --><a class=\"postlink\" href=\"http://www.oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_8/CH08-5.html\">http://www.oopweb.com/Assembly/Document ... H08-5.html</a><!-- m -->)\n\nGiven the basic things you said above, you're going to have 6 general purpose registers (R0-R5). What you might be able to do is:\n\n[code:xpf7lqqa]RA equ this byte\nR0 byte 0\nR1 byte 0\nR2 byte 0\nR3 byte 0\nR4 byte 0\nR5 byte 0[/code:xpf7lqqa]\n\nThat would give RA an address of the start of your registers but still have them individually accessible. (That's assuming you need to be able to do array indexing, which you might depending on how your instructions refer to registers.)\n\n(You could probably also go the way you were going with defining the array and then 'equ'ing offsets into it, but I'm not sure of the syntax for that.)\n\nYour simulated memory will be a byte array of size 1K:\n\n[code:xpf7lqqa]memory byte 1024 dup(0)[/code:xpf7lqqa]\n\nYou're also going to need an instruction pointer. This is where the 16-bit address space first comes in, as your IP will be a 16-bit register which holds the next instruction address.\n\n[code:xpf7lqqa]rip word 0[/code:xpf7lqqa]\n\nThe rip will be an offset into your memory array. So it will begin reading from the start of your memory array on reset, assuming you have some &quot;reset&quot; code that sets rip to 0. (An alternative: dedicate a register like ESI or EDI to be your instruction pointer. It's handy to use one of those since you're going to need to use it to reference things indirectly.)\n\nI don't know if you also need some sort of stack pointer, to handle . If so, it will be 16 bits as well. (You can't address more than 256 bytes with an 8-bit value.)\n\nSo, on reset, you'll set the rip register to 0, and then you're going to enter a loop where you process instructions. This is the part that I'm still unclear on - you need to have your instruction set defined. Since it's an 16-bit processor, your opcodes will probably be 16-bit? Immediate values shoved into registers will be 8 bits only. (You can't put a 16-bit value into an 8-bit register.) So an instruction might be something like:\n\nmov r0, 0\n\nDepending on how the instruction set is defined, that might be a single byte for the &quot;mov&quot; and then bytes following for the register and then the value:\n\n&lt;some 16-bit opcode for mov + the register&gt; &lt;an 8-bit immediate value to assign&gt;\n\nThat would be three bytes long.\n\n[quote:xpf7lqqa]Is the address the MSB (most significant byte: bits 8-15) and the value the LSB (least significant byte: 0-7), or is the entire 16 bits used for the address, and then I just assign the size for its values... somehow? I'm confused, grr.[/quote:xpf7lqqa]\nTo be honest, I'm not sure what you're asking here. You seem to be getting down to how to encode things, but that's where your instruction set comes in. Don't get confused by the fact that you have 16- or 32-bit registers. Just use the parts that you need. If you had your IP in esi, you could load the current value from there (I think!) by using something like:\n\n[code:xpf7lqqa]mov al, byte ptr memory&#91;esi&#93;[/code:xpf7lqqa]\n\n(It's possible you might have to use ebx for that.)\n\nI'll stop at this point and see if I've gone off in the weed as far as your questions go. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "I'm slightly confused, as you say you want to emulate a 16-bit 8086 cpu, but an 8086 doesn't have Rx registers. So I'll assume that you're just trying to emulate *a* 16-bit cpu of some kind. If I've gotten that wrong, let me know... It's also quite strange to have an 8-bit register size for a 16-bit processor.  <!-- s:? --><img src=\"{SMILIES_PATH}/icon_confused.gif\" alt=\":?\" title=\"Confused\" /><!-- s:? --> <br/><br/>Keep in mind through all this that I'm not actually trying this out, so I could get things wrong...<br/><br/>(It's been a while since I dealt with MASM directives, so I found this page: <!-- m --><a class=\"postlink\" href=\"http://www.oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_8/CH08-5.html\">http://www.oopweb.com/Assembly/Document ... H08-5.html</a><!-- m -->)<br/><br/>Given the basic things you said above, you're going to have 6 general purpose registers (R0-R5). What you might be able to do is:<br/><br/><pre><code>RA equ this byte<br/>R0 byte 0<br/>R1 byte 0<br/>R2 byte 0<br/>R3 byte 0<br/>R4 byte 0<br/>R5 byte 0</code></pre><br/><br/>That would give RA an address of the start of your registers but still have them individually accessible. (That's assuming you need to be able to do array indexing, which you might depending on how your instructions refer to registers.)<br/><br/>(You could probably also go the way you were going with defining the array and then 'equ'ing offsets into it, but I'm not sure of the syntax for that.)<br/><br/>Your simulated memory will be a byte array of size 1K:<br/><br/><pre><code>memory byte 1024 dup(0)</code></pre><br/><br/>You're also going to need an instruction pointer. This is where the 16-bit address space first comes in, as your IP will be a 16-bit register which holds the next instruction address.<br/><br/><pre><code>rip word 0</code></pre><br/><br/>The rip will be an offset into your memory array. So it will begin reading from the start of your memory array on reset, assuming you have some &quot;reset&quot; code that sets rip to 0. (An alternative: dedicate a register like ESI or EDI to be your instruction pointer. It's handy to use one of those since you're going to need to use it to reference things indirectly.)<br/><br/>I don't know if you also need some sort of stack pointer, to handle . If so, it will be 16 bits as well. (You can't address more than 256 bytes with an 8-bit value.)<br/><br/>So, on reset, you'll set the rip register to 0, and then you're going to enter a loop where you process instructions. This is the part that I'm still unclear on - you need to have your instruction set defined. Since it's an 16-bit processor, your opcodes will probably be 16-bit? Immediate values shoved into registers will be 8 bits only. (You can't put a 16-bit value into an 8-bit register.) So an instruction might be something like:<br/><br/>mov r0, 0<br/><br/>Depending on how the instruction set is defined, that might be a single byte for the &quot;mov&quot; and then bytes following for the register and then the value:<br/><br/>&lt;some 16-bit opcode for mov + the register&gt; &lt;an 8-bit immediate value to assign&gt;<br/><br/>That would be three bytes long.<br/><br/><blockquote><p>Is the address the MSB (most significant byte: bits 8-15) and the value the LSB (least significant byte: 0-7), or is the entire 16 bits used for the address, and then I just assign the size for its values... somehow? I'm confused, grr.</p></blockquote><br/>To be honest, I'm not sure what you're asking here. You seem to be getting down to how to encode things, but that's where your instruction set comes in. Don't get confused by the fact that you have 16- or 32-bit registers. Just use the parts that you need. If you had your IP in esi, you could load the current value from there (I think!) by using something like:<br/><br/><pre><code>mov al, byte ptr memory&#91;esi&#93;</code></pre><br/><br/>(It's possible you might have to use ebx for that.)<br/><br/>I'll stop at this point and see if I've gone off in the weed as far as your questions go. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-02-22T23:14:51+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41376",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "[code:3dr4g8al]bit&#58; smallest unit on binary computer, each digit in binary is a bit\n\nnibble&#58; 4 bits (same as a hexidecimal digit), (2 nibbles = 1 byte)\nbyte&#58; 8 bits (2 nibbles/hexidecimal digits), smallest addressable unit on most computers\n\nword&#58; 16 bits (2 bytes)\ndword (double word)&#58; 32 bits (4 bytes)\nqword (quad word)&#58; 64 bits (8 bytes)\n\n---------------------------\n\nfor the most part (at least what we're learning), there's really no difference between the 32 bit that we're learning and the old 8086 (80x86) that you are used to Jay, we're mostly learning how to do the same stuff you'd do on/with the 8086, with the only difference is in that we use 32 bit registers (except the segment registers, they stay 16 bit)&#58;\n\n80386 (&#46;386)&#58;\n\neax = (16 bit extended ax) = 32 bits (31 bit to 0 bit)\n\neax&#58;\n\nax = lower/lsb of eax, 16 bits (15 bit to 0 bit)\nN/A = we can't refer/index into the higher/msb of eax, 16 bits (bit 31 to bit 16)\n\nax&#58;\n\nah = higher/msb of ax, 8 bits (bit 15 to bit 8)\nal = lower/lsb of ax, 8 bits (bit 7 to bit 0)\n\nVS\n\n8086 (80x86)&#58;\n\nax = 16 bits (15 bit to 0 bit)\n\nax&#58;\n\nah = higher/msb of ax, 8 bits (bit 15 to bit 8)\nal = lower/lsb of ax, 8 bits (bit 7 to bit 0)\n\n-----------------\n\nso you can just explain to me or help me in term of the 8086, as I don't think there'll be much difference or confusion on my part, due to not really doing anything different in the 32 bit cpu system of registers of 80386&#46; You don't need to try to learn the 80386 as it really seems to behave and/or be designed in the same way as the 8086 design/build[/code:3dr4g8al]\n\n---------------------------------------\n\nAs best as I understand, we're suppose to mimic the 8086 cpu's registers, through using variables instead of the actual registers: make variables that act like the registers. I'm not sure if we can use the actual registers (ax, bx, cx, dx, ip, sp, etc) at all or not. I presume we'd be using the stack (pushing and popping) in-place of using the registers, to deal with the transitional step for doing 'mov', as we can't do mov mem (register variable) to mem (register variable) directly (mov R1, R0 --- ERROR, mem to mem isn't allowed).\n\n-----------\n\nThe 'R0-R5' are just names of the variables (that are to act like the actual registers), for an example:\n\n(I presume the 'R' was merely chosen to stand for 'register', lol)\n\nax -&gt; is replaced by -&gt; variable: R0\nbx -&gt; is replaced by -&gt; variable: R1\ncx -&gt; is replaced by -&gt; variable: R2\ndx -&gt; is replaced by -&gt; variable: R3\nsp/bp/di/si/ip/st~flag -&gt; is replaced by -&gt; variable: R4\nsp/bp/di/si/ip/st~flag -&gt; is replaced by -&gt; variable: R5\n\n(I haven't learned what the 'status' register is in 8086... I presume this 'status' register is generally the same as the 'eflags' register of 32 bit CPUs/80360+)\n\n(eflags register, 15 bit to 0 bit: undefined/reserved, undefined/reserved, undefined/reserved, undefined/reserved, overflow, direction, interrupt, trap, sign, zero, undefined/reserved, auxilary, undefined/reserved, zero, undefined/reserved, carry)\n\n--------------\n\nI came up with creating the 'RA (Register Array: an array variable whose subsections are the 6 register variables)', can this do done? (see below too)\n\nI assume that the 1k (2^10 = 1024) is the size of the entire mimic memory segment you got to work with, named as 'program buffer' (this is what we're using for the data file read into our program), and since the addresses are 16 bit, it's: 2^16 = 65536 sub-segments, but I'm confused by this...\n\nso, if I were/able to use my 'RA', it would just be a sub-segment within the 1k mimic memory segment? I presume for the instruction operations, I'd be using the initial offset address of my 'RA' (which I presume i placed somewhere within the 1k mimic memory segment), and then indexing/scaling over to the specific register segment of it?\n\n---------\n\nI'm still trying to digest/understand your post's contents with trying to match up and just understand my assignment... laughs.\n\nwe're given very limited instructions for our assignment/program, just that it has to emulate a cpu, using the given information about the fake cpu (see my previous post), and a given instruction set, an example of one of them:\n\nmnemonic ~ opcode (hexidecmal) ~ operand 1 ~ operand 2\n\nADD ~ 11h ~ reg1 ~ reg2\n\nI presume the 'regX' are our register-mimic variables: R0-R5\n\nI think from your post, I understand a little bit into how to code in the instructions using the mimic-registers (variables: R0-R5)\n\nlet me see if I can figure out how to do this stuff on my own... I think I can... if not I'll post here letting you know I need help, lol.\n\n------\n\nTHANK YOU VERY MUCH FOR YOUR HELP, JAY!\n\nyour post has been very helpfully, I'm working working on trying to understand it and in-relation-to my (attempt in undertanding the) assignment, lol.\n\nI just need (at least for now) some understanding/guidance on where/how to begin, as I'm a bit lost just being thrown this assignment so quickly while still new to assembly, with so little instructional help.\n\nDon't try to help me in too much detail or beyond what I ask, if you can, as I need to do this myself, my questions are just to hopefully steer me in the right direction or approach in trying to do this assignment. I just want that little nudge/push/hint, so I can hopefully figure out how to do it on my own (besides the needed little push/nudge/hint). This is why my posts might be a bit vague and/or intentionally leaving out some content. I just want nudges, not help with doing the entire assignment. It's my assignment to finish, but I do need a little hintful helping as I'm a bit lost at how to get started and go about the various aspects of it.",
      "EditableFormat": "bbcode",
      "HTML": "<pre><code>bit&#58; smallest unit on binary computer, each digit in binary is a bit<br/><br/>nibble&#58; 4 bits (same as a hexidecimal digit), (2 nibbles = 1 byte)<br/>byte&#58; 8 bits (2 nibbles/hexidecimal digits), smallest addressable unit on most computers<br/><br/>word&#58; 16 bits (2 bytes)<br/>dword (double word)&#58; 32 bits (4 bytes)<br/>qword (quad word)&#58; 64 bits (8 bytes)<br/><br/>---------------------------<br/><br/>for the most part (at least what we're learning), there's really no difference between the 32 bit that we're learning and the old 8086 (80x86) that you are used to Jay, we're mostly learning how to do the same stuff you'd do on/with the 8086, with the only difference is in that we use 32 bit registers (except the segment registers, they stay 16 bit)&#58;<br/><br/>80386 (&#46;386)&#58;<br/><br/>eax = (16 bit extended ax) = 32 bits (31 bit to 0 bit)<br/><br/>eax&#58;<br/><br/>ax = lower/lsb of eax, 16 bits (15 bit to 0 bit)<br/>N/A = we can't refer/index into the higher/msb of eax, 16 bits (bit 31 to bit 16)<br/><br/>ax&#58;<br/><br/>ah = higher/msb of ax, 8 bits (bit 15 to bit 8)<br/>al = lower/lsb of ax, 8 bits (bit 7 to bit 0)<br/><br/>VS<br/><br/>8086 (80x86)&#58;<br/><br/>ax = 16 bits (15 bit to 0 bit)<br/><br/>ax&#58;<br/><br/>ah = higher/msb of ax, 8 bits (bit 15 to bit 8)<br/>al = lower/lsb of ax, 8 bits (bit 7 to bit 0)<br/><br/>-----------------<br/><br/>so you can just explain to me or help me in term of the 8086, as I don't think there'll be much difference or confusion on my part, due to not really doing anything different in the 32 bit cpu system of registers of 80386&#46; You don't need to try to learn the 80386 as it really seems to behave and/or be designed in the same way as the 8086 design/build</code></pre><br/><br/>---------------------------------------<br/><br/>As best as I understand, we're suppose to mimic the 8086 cpu's registers, through using variables instead of the actual registers: make variables that act like the registers. I'm not sure if we can use the actual registers (ax, bx, cx, dx, ip, sp, etc) at all or not. I presume we'd be using the stack (pushing and popping) in-place of using the registers, to deal with the transitional step for doing 'mov', as we can't do mov mem (register variable) to mem (register variable) directly (mov R1, R0 --- ERROR, mem to mem isn't allowed).<br/><br/>-----------<br/><br/>The 'R0-R5' are just names of the variables (that are to act like the actual registers), for an example:<br/><br/>(I presume the 'R' was merely chosen to stand for 'register', lol)<br/><br/>ax -&gt; is replaced by -&gt; variable: R0<br/>bx -&gt; is replaced by -&gt; variable: R1<br/>cx -&gt; is replaced by -&gt; variable: R2<br/>dx -&gt; is replaced by -&gt; variable: R3<br/>sp/bp/di/si/ip/st~flag -&gt; is replaced by -&gt; variable: R4<br/>sp/bp/di/si/ip/st~flag -&gt; is replaced by -&gt; variable: R5<br/><br/>(I haven't learned what the 'status' register is in 8086... I presume this 'status' register is generally the same as the 'eflags' register of 32 bit CPUs/80360+)<br/><br/>(eflags register, 15 bit to 0 bit: undefined/reserved, undefined/reserved, undefined/reserved, undefined/reserved, overflow, direction, interrupt, trap, sign, zero, undefined/reserved, auxilary, undefined/reserved, zero, undefined/reserved, carry)<br/><br/>--------------<br/><br/>I came up with creating the 'RA (Register Array: an array variable whose subsections are the 6 register variables)', can this do done? (see below too)<br/><br/>I assume that the 1k (2^10 = 1024) is the size of the entire mimic memory segment you got to work with, named as 'program buffer' (this is what we're using for the data file read into our program), and since the addresses are 16 bit, it's: 2^16 = 65536 sub-segments, but I'm confused by this...<br/><br/>so, if I were/able to use my 'RA', it would just be a sub-segment within the 1k mimic memory segment? I presume for the instruction operations, I'd be using the initial offset address of my 'RA' (which I presume i placed somewhere within the 1k mimic memory segment), and then indexing/scaling over to the specific register segment of it?<br/><br/>---------<br/><br/>I'm still trying to digest/understand your post's contents with trying to match up and just understand my assignment... laughs.<br/><br/>we're given very limited instructions for our assignment/program, just that it has to emulate a cpu, using the given information about the fake cpu (see my previous post), and a given instruction set, an example of one of them:<br/><br/>mnemonic ~ opcode (hexidecmal) ~ operand 1 ~ operand 2<br/><br/>ADD ~ 11h ~ reg1 ~ reg2<br/><br/>I presume the 'regX' are our register-mimic variables: R0-R5<br/><br/>I think from your post, I understand a little bit into how to code in the instructions using the mimic-registers (variables: R0-R5)<br/><br/>let me see if I can figure out how to do this stuff on my own... I think I can... if not I'll post here letting you know I need help, lol.<br/><br/>------<br/><br/>THANK YOU VERY MUCH FOR YOUR HELP, JAY!<br/><br/>your post has been very helpfully, I'm working working on trying to understand it and in-relation-to my (attempt in undertanding the) assignment, lol.<br/><br/>I just need (at least for now) some understanding/guidance on where/how to begin, as I'm a bit lost just being thrown this assignment so quickly while still new to assembly, with so little instructional help.<br/><br/>Don't try to help me in too much detail or beyond what I ask, if you can, as I need to do this myself, my questions are just to hopefully steer me in the right direction or approach in trying to do this assignment. I just want that little nudge/push/hint, so I can hopefully figure out how to do it on my own (besides the needed little push/nudge/hint). This is why my posts might be a bit vague and/or intentionally leaving out some content. I just want nudges, not help with doing the entire assignment. It's my assignment to finish, but I do need a little hintful helping as I'm a bit lost at how to get started and go about the various aspects of it.",
      "PostDate": "2016-02-23T00:46:34+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41378",
      "UserId": 0,
      "Username": "XanMag",
      "UserAvatar": "7161_1436827710.jpg",
      "UserGravatar": "4b45a3afd18077f76f6569225c422bdb",
      "EditableText": "Just google it.  All the kids are doing it nowadays... <!-- s:| --><img src=\"{SMILIES_PATH}/icon_neutral.gif\" alt=\":|\" title=\"Neutral\" /><!-- s:| -->",
      "EditableFormat": "bbcode",
      "HTML": "Just google it.  All the kids are doing it nowadays... <!-- s:| --><img src=\"{SMILIES_PATH}/icon_neutral.gif\" alt=\":|\" title=\"Neutral\" /><!-- s:| -->",
      "PostDate": "2016-02-23T01:23:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41379",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I really suck at searching the net, sighs. I can't find anything on this at all from googling. Also, there's so much assembly online... it's hard to know what is authentic/official and/or matching to the assembly you're using.",
      "EditableFormat": "bbcode",
      "HTML": "I really suck at searching the net, sighs. I can't find anything on this at all from googling. Also, there's so much assembly online... it's hard to know what is authentic/official and/or matching to the assembly you're using.",
      "PostDate": "2016-02-23T02:35:11+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41386",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "It must have been late last night when I wrote that, but when I got up this morning, it seemed clearer to me. And what you said in your post makes me think that you're slightly confused the way I was as well. Maybe we can gain clarity together. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\n[Also, I understand completely what you mean about not going beyond what you ask (and I admire that). I'll try to restrain myself... ]\n\nYou had said you need to emulate an 8086 CPU, but what it looks like you're actually doing for your assignment is emulating an arbitrary 8-bit processor *using* an 8086 emulator to write your code. Does that make sense? In other words, you're writing the code in 8086 assembler (and probably running it on an 8086 emulator). but what you're trying to emulate *through your code* is this imaginary 8-bit processor. So the register set and all that will have nothing to do with the 8086.\n\nIt's as if you're an engineer and your company wants to make a new 8-bit processor. But you want to be sure it will work reasonably, so your boss says &quot;Go write some software that emulates this.&quot; It could be written in C. It could be written in Java or Javascript or Pascal or anything. For this assignment, you happen to have to write it in 8086 assembly. It might help, actually, if we discuss things as if you it were in a language besides 8086 assembly. That might help to make clear where the dividing line is.\n\nImagine you were going to write this in Quest. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You would have an object called &quot;Processor&quot;, with attributes for each of the registers. Then you'd have some sort of array or list that corresponds to the memory the processor acts on. Quest would make it difficult, since you can't modify arrays very easily. But maybe that image helps?\n\nTo some of your points above.\n\nEven though you're going to be storing R0-R5 (and all your other registers perhaps) in your *emulator's* memory (they have to live somewhere), in the virtual space of your 8-bit processor, they won't be in *its* memory, just as the 8086's AX, BX, etc registers aren't in actual memory - they're in the processor. You are basically building *in code* what would normally be done in hardware within the processor chip. There's storage internal to a processor for registers and things. Since you're doing it all yourself, you need to allocate a place for those in your program, but they won't be in the 1K memory space for your virtual processor. They will live outside that, in the &quot;processor object&quot; if you will. (That is, they won't be addressable.)\n\nSo you will have the *registers*, which are your R0-R5, the IP, SP, status flags, etc - all &quot;internal&quot; to your simulated  processor. And then you'll have the 1K &quot;memory&quot; the processor operates on. Memory and registers are completely separate things. You said you can't do memory-to-memory moves, which seems reasonable. (You couldn't do that, for example, on a 6502. You always had to load from memory into a register and then store from the register to another memory address.) But that's *not* \n\nMOV R0, R1\n\nThat's moving between two of your virtual registers! In your virtual processor, that's an internal operation, not involving your virtual processor's &quot;memory&quot; at all.\n\nI know it will be a bit confusing at first, but you need to keep straight what's virtual from what is not, keep straight what things look like from the virtual processor's point of view vs what it looks like in the code that's *emulating* it all. The registers R0-R5 are just variables in your emulator, and as such, they will be in your program's data segment, but from the point of view of the instructions running in your virtual processor, they will be in the virtual processor as registers.\n\nThe thing to keep in mind is that you're going to be implementing all the instructions for this processor using 8086 instructions. And the instructions will be opcodes that you'll read as numbers. You won't see &quot;MOV&quot;. You'll see an 8-bit number like 0x63. You'll need to read that byte at the IP, go &quot;this is a MOV instruction&quot; and then read whatever additional bytes you need to make up the operands, by incrementing your IP and reading subsequent bytes from your memory array. (It's all clear to me because I used to read and write the actual bytes by hand, and I even wrote a 6502 emulator on the 6502-based Apple computer I had, just for fun. Yes, heady days. lol The thing is, you need to allocate a place for each virtual register in your emulator's memory, just as you're doing.)\n\nThink of the instruction as being arbitrary &quot;tokens&quot;.\n\nHopefully that makes things clearer. If not, then let's discuss some more, at this level. Because I feel like there's a conceptual disconnect that's going to make it hard for you to do what you need to do until the light bulb goes off. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Perhaps a picture would help...",
      "EditableFormat": "bbcode",
      "HTML": "It must have been late last night when I wrote that, but when I got up this morning, it seemed clearer to me. And what you said in your post makes me think that you're slightly confused the way I was as well. Maybe we can gain clarity together. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>[Also, I understand completely what you mean about not going beyond what you ask (and I admire that). I'll try to restrain myself... ]<br/><br/>You had said you need to emulate an 8086 CPU, but what it looks like you're actually doing for your assignment is emulating an arbitrary 8-bit processor *using* an 8086 emulator to write your code. Does that make sense? In other words, you're writing the code in 8086 assembler (and probably running it on an 8086 emulator). but what you're trying to emulate *through your code* is this imaginary 8-bit processor. So the register set and all that will have nothing to do with the 8086.<br/><br/>It's as if you're an engineer and your company wants to make a new 8-bit processor. But you want to be sure it will work reasonably, so your boss says &quot;Go write some software that emulates this.&quot; It could be written in C. It could be written in Java or Javascript or Pascal or anything. For this assignment, you happen to have to write it in 8086 assembly. It might help, actually, if we discuss things as if you it were in a language besides 8086 assembly. That might help to make clear where the dividing line is.<br/><br/>Imagine you were going to write this in Quest. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You would have an object called &quot;Processor&quot;, with attributes for each of the registers. Then you'd have some sort of array or list that corresponds to the memory the processor acts on. Quest would make it difficult, since you can't modify arrays very easily. But maybe that image helps?<br/><br/>To some of your points above.<br/><br/>Even though you're going to be storing R0-R5 (and all your other registers perhaps) in your *emulator's* memory (they have to live somewhere), in the virtual space of your 8-bit processor, they won't be in *its* memory, just as the 8086's AX, BX, etc registers aren't in actual memory - they're in the processor. You are basically building *in code* what would normally be done in hardware within the processor chip. There's storage internal to a processor for registers and things. Since you're doing it all yourself, you need to allocate a place for those in your program, but they won't be in the 1K memory space for your virtual processor. They will live outside that, in the &quot;processor object&quot; if you will. (That is, they won't be addressable.)<br/><br/>So you will have the *registers*, which are your R0-R5, the IP, SP, status flags, etc - all &quot;internal&quot; to your simulated  processor. And then you'll have the 1K &quot;memory&quot; the processor operates on. Memory and registers are completely separate things. You said you can't do memory-to-memory moves, which seems reasonable. (You couldn't do that, for example, on a 6502. You always had to load from memory into a register and then store from the register to another memory address.) But that's *not* <br/><br/>MOV R0, R1<br/><br/>That's moving between two of your virtual registers! In your virtual processor, that's an internal operation, not involving your virtual processor's &quot;memory&quot; at all.<br/><br/>I know it will be a bit confusing at first, but you need to keep straight what's virtual from what is not, keep straight what things look like from the virtual processor's point of view vs what it looks like in the code that's *emulating* it all. The registers R0-R5 are just variables in your emulator, and as such, they will be in your program's data segment, but from the point of view of the instructions running in your virtual processor, they will be in the virtual processor as registers.<br/><br/>The thing to keep in mind is that you're going to be implementing all the instructions for this processor using 8086 instructions. And the instructions will be opcodes that you'll read as numbers. You won't see &quot;MOV&quot;. You'll see an 8-bit number like 0x63. You'll need to read that byte at the IP, go &quot;this is a MOV instruction&quot; and then read whatever additional bytes you need to make up the operands, by incrementing your IP and reading subsequent bytes from your memory array. (It's all clear to me because I used to read and write the actual bytes by hand, and I even wrote a 6502 emulator on the 6502-based Apple computer I had, just for fun. Yes, heady days. lol The thing is, you need to allocate a place for each virtual register in your emulator's memory, just as you're doing.)<br/><br/>Think of the instruction as being arbitrary &quot;tokens&quot;.<br/><br/>Hopefully that makes things clearer. If not, then let's discuss some more, at this level. Because I feel like there's a conceptual disconnect that's going to make it hard for you to do what you need to do until the light bulb goes off. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Perhaps a picture would help...",
      "PostDate": "2016-02-23T07:48:13+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41388",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "We're using the .586 MASM build (newer than the .386), using express VirtualStudio as the IDE, I don't think we're using or making any actual cpu emulation program, only using variables (which are in the DS, which makes them mem, so mov R0, R1 would be a mem to mem move still, I think, unless I'm completely not understanding this emulation/virtualization concept in your post) and etc to try to emulate/mimic/substitute the actual 16 bit registers (though we're working with the 32 bit registers but that doesn't really matter much as we can refer to the 16 bits, and the 8 bits, divisions of them) of the MASM (that I've seen in trying to research online of/using the various different languages: that seems a bit too advanced for us), though we are going to run a 'machine.bin' file (which may be in binary) given to us and a starting program to work with/add to (with code on how to do the winAPI stuff of reading a file, as only learned how to IO to console so far), to see if our emulated cpu program works. Though maybe I'm completely wrong, and you're understanding the assignment better than I am, which is very likely. \n\nI'll email or talk to my professor (wed-tomorrow) and hopefully be able to get my confusion straightened out on exactly what/how we're suppose to be doing this assignment. Not, &quot;how-how&quot; to do the coding, just what exactly we're suppose to be trying to do with the assignment. At least I'm too dumb/stupid to be figuring this out, hence my confusion, and asking here in hopes of getting some guidance/hints/understanding of what I need to do, sighs. I'm not sure even how to do the instruction set creation, as I don't know what/how they'll be used... argh. So many questions/confusions, sighs. I really want to learn assembly, and I kind of am getting it slowly, but this stuff is tough (at least in trying to figure out what we're to do with this intentionally vague-info'ed assignment), I'm struggling with it, whereas, thanks to quest, I haven't hardly struggled with the higher language classes (C++ and Java).\n\nUnfortunately, that post confused me a bit more, let me see if I can get some clarity/guidance from my prof directly, and then we can go from there, if I still need help, laughs. I will be trying to understand/digest your post too, but I'm going to get my other school work done and out of the way today, so I got the rest of the ~week to try to get this assembly lab figured out and done and working, laughs.",
      "EditableFormat": "bbcode",
      "HTML": "We're using the .586 MASM build (newer than the .386), using express VirtualStudio as the IDE, I don't think we're using or making any actual cpu emulation program, only using variables (which are in the DS, which makes them mem, so mov R0, R1 would be a mem to mem move still, I think, unless I'm completely not understanding this emulation/virtualization concept in your post) and etc to try to emulate/mimic/substitute the actual 16 bit registers (though we're working with the 32 bit registers but that doesn't really matter much as we can refer to the 16 bits, and the 8 bits, divisions of them) of the MASM (that I've seen in trying to research online of/using the various different languages: that seems a bit too advanced for us), though we are going to run a 'machine.bin' file (which may be in binary) given to us and a starting program to work with/add to (with code on how to do the winAPI stuff of reading a file, as only learned how to IO to console so far), to see if our emulated cpu program works. Though maybe I'm completely wrong, and you're understanding the assignment better than I am, which is very likely. <br/><br/>I'll email or talk to my professor (wed-tomorrow) and hopefully be able to get my confusion straightened out on exactly what/how we're suppose to be doing this assignment. Not, &quot;how-how&quot; to do the coding, just what exactly we're suppose to be trying to do with the assignment. At least I'm too dumb/stupid to be figuring this out, hence my confusion, and asking here in hopes of getting some guidance/hints/understanding of what I need to do, sighs. I'm not sure even how to do the instruction set creation, as I don't know what/how they'll be used... argh. So many questions/confusions, sighs. I really want to learn assembly, and I kind of am getting it slowly, but this stuff is tough (at least in trying to figure out what we're to do with this intentionally vague-info'ed assignment), I'm struggling with it, whereas, thanks to quest, I haven't hardly struggled with the higher language classes (C++ and Java).<br/><br/>Unfortunately, that post confused me a bit more, let me see if I can get some clarity/guidance from my prof directly, and then we can go from there, if I still need help, laughs. I will be trying to understand/digest your post too, but I'm going to get my other school work done and out of the way today, so I got the rest of the ~week to try to get this assembly lab figured out and done and working, laughs.",
      "PostDate": "2016-02-23T17:19:12+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41389",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "okay... in trying to make some sense of all of this...\n\nI'm guessing that the '1024' byte array variable 'program_buffer byte 1024 dup (?/0)', since it *IS* being used to hold the read data from the 'machine.bin' file that we're using to test our program, would be used for the 'reseting to location 0', and not my own written MASM program's DS and/or CS, does this sound right, or completely wrong?\n\nThen, using the address location of my '6' byte array variable 'RA byte 6 dup (?/0)', I can index/scale/direct-offset (via as adjusting &quot;ip&quot;) to the specific sub-segment (R0-R5: virtual/emulation/substitute registers) of it. And, if I understand correctly, I can make the address size of it be 16 bits by another means (such as maybe the 'word ptr' or something to that effect, which I would need to be 16 bits in order to do the indexing/scaling/etc to the subsegment R0-R5 &quot;registers&quot;, anyways, right?)\n\nAre then the given instruction set's opcodes, refering to the memory addresses in the 1024 byte array variable (via adjusting &quot;ip&quot;) ?? Or, am I to create the instruction sets in my own program, refering to them via the DS (if they're to be variables) and/or the CS as (if they're to be) Labels/Procedures/Macros?\n\nIs this the correct setup/design I created (I know I'm asking about what I've done already, as it seems to make sense to me...), or do I have it completely wrong?",
      "EditableFormat": "bbcode",
      "HTML": "okay... in trying to make some sense of all of this...<br/><br/>I'm guessing that the '1024' byte array variable 'program_buffer byte 1024 dup (?/0)', since it *IS* being used to hold the read data from the 'machine.bin' file that we're using to test our program, would be used for the 'reseting to location 0', and not my own written MASM program's DS and/or CS, does this sound right, or completely wrong?<br/><br/>Then, using the address location of my '6' byte array variable 'RA byte 6 dup (?/0)', I can index/scale/direct-offset (via as adjusting &quot;ip&quot;) to the specific sub-segment (R0-R5: virtual/emulation/substitute registers) of it. And, if I understand correctly, I can make the address size of it be 16 bits by another means (such as maybe the 'word ptr' or something to that effect, which I would need to be 16 bits in order to do the indexing/scaling/etc to the subsegment R0-R5 &quot;registers&quot;, anyways, right?)<br/><br/>Are then the given instruction set's opcodes, refering to the memory addresses in the 1024 byte array variable (via adjusting &quot;ip&quot;) ?? Or, am I to create the instruction sets in my own program, refering to them via the DS (if they're to be variables) and/or the CS as (if they're to be) Labels/Procedures/Macros?<br/><br/>Is this the correct setup/design I created (I know I'm asking about what I've done already, as it seems to make sense to me...), or do I have it completely wrong?",
      "PostDate": "2016-02-23T17:45:47+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41390",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "First, if your instructor is giving you a machine.bin file, then part of the assignment must be the definitions for the various opcodes/instructions you need to implement. Is that the case? Because the structure of the instruction set can help guide how you implement the various (virtual) registers. I think if you could look at those instructions, you'd see what they look like, what kind of operations can be performed, etc. Without being given how the actual instructions look byte-wise, you'd have no chance of running the .bin file.\n\n[quote:2pe1y7bl]I'm guessing that the '1024' byte array variable 'program_buffer byte 1024 dup (?/0)', since it *IS* being used to hold the read data from the 'machine.bin' file that we're using to test our program, would be used for the 'reseting to location 0', and not my own written MASM program's DS and/or CS, does this sound right, or completely wrong?[/quote:2pe1y7bl]\n\nYes and no. The 1024 byte array is your simulated memory. Your virtual instruction pointer will be an index into that memory. (Your simulated processor's memory space will range from 0 to 1023). You're going to have a virtual IP (which will probably just be a variable you define). That's the thing: you can't emulate or simulate a processor using your own processor's resources (instruction pointer, stack pointer, status flags, etc). You'll need all those resources to write the code that does the actual simulation. So you're going to need something else to hold those values. The simplest approach is to have memory variables that represent those virtual internal registers. (Again, think of how you'd do this in Quest. The values have to go somewhere.) So to reset your virtual processor, it would be as simple as \n\nmov virtual_ip, 0\n\nwhere virtual_ip is your variable that holds the current instruction pointer. But the missing part is that you will then *use* that virtual instruction pointer to index into your 1K virtual memory and read values (the .bin file, in this case) a byte at a time and execute them based on what the opcode is that you've fetched.\n\n[quote:2pe1y7bl]Then, using the address location of my '6' byte array variable 'RA byte 6 dup (?/0)', I can index/scale/direct-offset (via as adjusting &quot;ip&quot;) to the specific sub-segment (R0-R5: virtual/emulation/substitute registers) of it. And, if I understand correctly, I can make the address size of it be 16 bits by another means (such as maybe the 'word ptr' or something to that effect, which I would need to be 16 bits in order to do the indexing/scaling/etc to the subsegment R0-R5 &quot;registers&quot;, anyways, right?)[/quote:2pe1y7bl]\n\nThe 16-bit accesses into your simulated memory block actually have nothing to do with the R0-R5 registers. Those registers are 8-bit *data* registers. To fetch instructions, you'll use your instruction pointer. The instruction pointer needs to be 16 bits, since it's effectively a 16-bit address (even though, really, for you it's just an offset into your 1K block). To read data, that will come from the operand part of the instruction. \n\nLet me give an example, using the simplest processor I know well, the 6502. The 6502 has three 8-bit data registers, A, X, and Y. It also has an 8-bit stack pointer, an 8-bit set of processor flags, and a 16-bit instruction pointer. The instruction to load a value into the A register (accumulator) is - not surprisingly - &quot;LDA&quot;. But if you look at the docs, you'll see there are 8 variants of LDA depending on what your addressing mode is. \n\nTo load an immediate 8-bit value, it's simple. The opcode is $A9 (the $ means hex in this case), and the value to load into A immediately follows it;\n\nLDA #$64    -&gt;     $A9  $64\n\nSo when the processor is reading instructions, if it sees $A9, it goes &quot;That's loading the accumulator with an immediate value&quot;. So it reads the next byte value and then puts that in the A register. If you were emulating that, you'd do the same thing: you'd read the $A9 by indexing into memory; then you'd increment your IP. Then you'd see it was a LDA immediate, read the next byte and then increment IP again. Then you'd store the value in the A register.\n\nAnother addressing mode is &quot;absolute&quot;. In that case, the load is coming from a memory address, which is specified in the instruction. Having a 16-bit address size, that takes two bytes, which are read in succession and then assembled into a single value to put on the address bus. If you, say, wanted to load the value at memory location $4010 (and given that the opcode for LDA absolute is $AD), you'd have:\n\nLDA $4010    -&gt;  $AD $10 $40      (low order part of the address is first on a 6502. On a 68000, it's reversed. You need to know your endian-ness.)\n\nSo when you encounter a $AD, you know you need to read *two* following bytes to get an address which you then read from.\n\nThat gives you two places you will use 16-bit addresses in an 8-bit world: to fetch instructions and operand data via the IP, and to read absolute (or indexed or whatever) data specified in instructions. But I doubt you will ever use the 8-bit registers as an address to fetch data, unless there is some special mode where you can combine them to generate an address.\n\n[quote:2pe1y7bl]Are then the given instruction set's opcodes, refering to the memory addresses in the 1024 byte array variable (via adjusting &quot;ip&quot;) ?? Or, am I to create the instruction sets in my own program, refering to them via the DS (if they're to be variables) and/or the CS as (if they're to be) Labels/Procedures/Macros?[/quote:2pe1y7bl]\nI may have answered some of that above. The opcodes are data values living *in* the memory. You will fetch them one at a time, see what they are, and execute them. (A crude implementation of this would a large if/then or switch statement, but you would most likely use a jump table of addresses, with a function per supported opcode.) They may refer to data in-stream as well (as shown above). But you will have to write code to actually implement each instruction. For example, to implement the LDA immediate above, you might have (pseudocode) like:\n\n[code:2pe1y7bl]get next byte pointed to by IP\nincrement IP\nstore that value in the A register\n[/code:2pe1y7bl]\nFor the absolute case, it would be something like:\n\n[code:2pe1y7bl]get next byte pointed to by IP and hold it somewhere\nincrement IP\nget next byte pointed to by IP \nincrement IP\ncombine the two bytes into an address\nget the byte pointed to by that address\nstore that value in the A register&#46;[/code:2pe1y7bl]\nYou're going to have code like that (but real code) for each and every instruction. You're implementing the logic for this virtual processor, including all the functionality for all the opcodes. (In actual processors, this is termed &quot;microcode&quot;. Since you're not inside a processor, it's just &quot;code acting like microcode&quot;.)\n\nTo sum up, what you have so far is a rough beginning. You'll need:\n\n- R0-R5 as byte values (memory locations to hold the simulated registers)\n- IP as a word/16-bit value which points into your memory to fetch the next instruction.\n- SP (stack pointer): I assume, since almost all processors do, but it depends on what your instructions are.\n- Flags: these hold the status result for the most recent operation. (For example, decrementing a register will set the Z flag if the value goes to zero.) \n\nAll this stuff that's been done for you when you use your own assembly instructions (updating registers, moving data around, etc), you now need to implement yourself for this virtual processor.\n\nI don't know if that's making any sense or helping. I'm actually surprised they're having you do this, if it's a beginning assembly class. Though it will give you good insight into what your own processor is doing by having you effectively write your own. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "First, if your instructor is giving you a machine.bin file, then part of the assignment must be the definitions for the various opcodes/instructions you need to implement. Is that the case? Because the structure of the instruction set can help guide how you implement the various (virtual) registers. I think if you could look at those instructions, you'd see what they look like, what kind of operations can be performed, etc. Without being given how the actual instructions look byte-wise, you'd have no chance of running the .bin file.<br/><br/><blockquote><p>I'm guessing that the '1024' byte array variable 'program_buffer byte 1024 dup (?/0)', since it *IS* being used to hold the read data from the 'machine.bin' file that we're using to test our program, would be used for the 'reseting to location 0', and not my own written MASM program's DS and/or CS, does this sound right, or completely wrong?</p></blockquote><br/><br/>Yes and no. The 1024 byte array is your simulated memory. Your virtual instruction pointer will be an index into that memory. (Your simulated processor's memory space will range from 0 to 1023). You're going to have a virtual IP (which will probably just be a variable you define). That's the thing: you can't emulate or simulate a processor using your own processor's resources (instruction pointer, stack pointer, status flags, etc). You'll need all those resources to write the code that does the actual simulation. So you're going to need something else to hold those values. The simplest approach is to have memory variables that represent those virtual internal registers. (Again, think of how you'd do this in Quest. The values have to go somewhere.) So to reset your virtual processor, it would be as simple as <br/><br/>mov virtual_ip, 0<br/><br/>where virtual_ip is your variable that holds the current instruction pointer. But the missing part is that you will then *use* that virtual instruction pointer to index into your 1K virtual memory and read values (the .bin file, in this case) a byte at a time and execute them based on what the opcode is that you've fetched.<br/><br/><blockquote><p>Then, using the address location of my '6' byte array variable 'RA byte 6 dup (?/0)', I can index/scale/direct-offset (via as adjusting &quot;ip&quot;) to the specific sub-segment (R0-R5: virtual/emulation/substitute registers) of it. And, if I understand correctly, I can make the address size of it be 16 bits by another means (such as maybe the 'word ptr' or something to that effect, which I would need to be 16 bits in order to do the indexing/scaling/etc to the subsegment R0-R5 &quot;registers&quot;, anyways, right?)</p></blockquote><br/><br/>The 16-bit accesses into your simulated memory block actually have nothing to do with the R0-R5 registers. Those registers are 8-bit *data* registers. To fetch instructions, you'll use your instruction pointer. The instruction pointer needs to be 16 bits, since it's effectively a 16-bit address (even though, really, for you it's just an offset into your 1K block). To read data, that will come from the operand part of the instruction. <br/><br/>Let me give an example, using the simplest processor I know well, the 6502. The 6502 has three 8-bit data registers, A, X, and Y. It also has an 8-bit stack pointer, an 8-bit set of processor flags, and a 16-bit instruction pointer. The instruction to load a value into the A register (accumulator) is - not surprisingly - &quot;LDA&quot;. But if you look at the docs, you'll see there are 8 variants of LDA depending on what your addressing mode is. <br/><br/>To load an immediate 8-bit value, it's simple. The opcode is $A9 (the $ means hex in this case), and the value to load into A immediately follows it;<br/><br/>LDA #$64    -&gt;     $A9  $64<br/><br/>So when the processor is reading instructions, if it sees $A9, it goes &quot;That's loading the accumulator with an immediate value&quot;. So it reads the next byte value and then puts that in the A register. If you were emulating that, you'd do the same thing: you'd read the $A9 by indexing into memory; then you'd increment your IP. Then you'd see it was a LDA immediate, read the next byte and then increment IP again. Then you'd store the value in the A register.<br/><br/>Another addressing mode is &quot;absolute&quot;. In that case, the load is coming from a memory address, which is specified in the instruction. Having a 16-bit address size, that takes two bytes, which are read in succession and then assembled into a single value to put on the address bus. If you, say, wanted to load the value at memory location $4010 (and given that the opcode for LDA absolute is $AD), you'd have:<br/><br/>LDA $4010    -&gt;  $AD $10 $40      (low order part of the address is first on a 6502. On a 68000, it's reversed. You need to know your endian-ness.)<br/><br/>So when you encounter a $AD, you know you need to read *two* following bytes to get an address which you then read from.<br/><br/>That gives you two places you will use 16-bit addresses in an 8-bit world: to fetch instructions and operand data via the IP, and to read absolute (or indexed or whatever) data specified in instructions. But I doubt you will ever use the 8-bit registers as an address to fetch data, unless there is some special mode where you can combine them to generate an address.<br/><br/><blockquote><p>Are then the given instruction set's opcodes, refering to the memory addresses in the 1024 byte array variable (via adjusting &quot;ip&quot;) ?? Or, am I to create the instruction sets in my own program, refering to them via the DS (if they're to be variables) and/or the CS as (if they're to be) Labels/Procedures/Macros?</p></blockquote><br/>I may have answered some of that above. The opcodes are data values living *in* the memory. You will fetch them one at a time, see what they are, and execute them. (A crude implementation of this would a large if/then or switch statement, but you would most likely use a jump table of addresses, with a function per supported opcode.) They may refer to data in-stream as well (as shown above). But you will have to write code to actually implement each instruction. For example, to implement the LDA immediate above, you might have (pseudocode) like:<br/><br/><pre><code>get next byte pointed to by IP<br/>increment IP<br/>store that value in the A register<br/></code></pre><br/>For the absolute case, it would be something like:<br/><br/><pre><code>get next byte pointed to by IP and hold it somewhere<br/>increment IP<br/>get next byte pointed to by IP <br/>increment IP<br/>combine the two bytes into an address<br/>get the byte pointed to by that address<br/>store that value in the A register&#46;</code></pre><br/>You're going to have code like that (but real code) for each and every instruction. You're implementing the logic for this virtual processor, including all the functionality for all the opcodes. (In actual processors, this is termed &quot;microcode&quot;. Since you're not inside a processor, it's just &quot;code acting like microcode&quot;.)<br/><br/>To sum up, what you have so far is a rough beginning. You'll need:<br/><br/>- R0-R5 as byte values (memory locations to hold the simulated registers)<br/>- IP as a word/16-bit value which points into your memory to fetch the next instruction.<br/>- SP (stack pointer): I assume, since almost all processors do, but it depends on what your instructions are.<br/>- Flags: these hold the status result for the most recent operation. (For example, decrementing a register will set the Z flag if the value goes to zero.) <br/><br/>All this stuff that's been done for you when you use your own assembly instructions (updating registers, moving data around, etc), you now need to implement yourself for this virtual processor.<br/><br/>I don't know if that's making any sense or helping. I'm actually surprised they're having you do this, if it's a beginning assembly class. Though it will give you good insight into what your own processor is doing by having you effectively write your own. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-02-23T19:01:59+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41394",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ah, that post makes much more sense to me (I understand it pretty well), just have to study some parts of it specifically.\n\nI still have one remaining question (for now), which I couldn't quite discern from your post:\n\nare the virtual registers (R0-R5) suppose to be located within the '1024 array variable memory segment' or outside of it ?\n\nalso, about the opcodes... (okay that's actually one more question, lol)... (I have to get to class now, so I haven't been able to read your post more closely/deductively, so that's why I'm asking this question, even though I could maybe have discerned it on my own... when I get back from class to read your post more closely)...\n\nso they're the values stored in an address in the '1024 array variable memory segment', or are the opcodes the addresses and we get their values, to 'if check' what operation/instruction-set we do? or, are the opcodes stored outside of the '1024 array variable memory segment' ???",
      "EditableFormat": "bbcode",
      "HTML": "ah, that post makes much more sense to me (I understand it pretty well), just have to study some parts of it specifically.<br/><br/>I still have one remaining question (for now), which I couldn't quite discern from your post:<br/><br/>are the virtual registers (R0-R5) suppose to be located within the '1024 array variable memory segment' or outside of it ?<br/><br/>also, about the opcodes... (okay that's actually one more question, lol)... (I have to get to class now, so I haven't been able to read your post more closely/deductively, so that's why I'm asking this question, even though I could maybe have discerned it on my own... when I get back from class to read your post more closely)...<br/><br/>so they're the values stored in an address in the '1024 array variable memory segment', or are the opcodes the addresses and we get their values, to 'if check' what operation/instruction-set we do? or, are the opcodes stored outside of the '1024 array variable memory segment' ???",
      "PostDate": "2016-02-23T22:07:32+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41399",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The virtual registers are outside the memory segment, just as in the x86 processor, where you have the AX, BX, CX, etc registers which are on the processor chip but aren't part of the main memory (that is, they don't have a physical address in main memory).\n\nAnd the opcodes (operational codes, or instructions) are just numbers stored in memory. They have meaning to the processor when being interpreted as instructions (e.g. 1 = load memory, 2 = store memory, 3 = move register to register, 4 = add a value to a register, 5 = increment a register, etc - all things I just made up, by the way), but at the end of the day, they're just numbers. That's one of the magical things about computers - code is just data. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nImagine I tell you the following: I'm going to give you a string. As you go along the string, the following rules apply.\n\n- When you hit an 'A', that means load the value of the number that follows. So &quot;A0&quot; means &quot;load the value 0&quot;.\n- When you hit a 'B', that means add the value of the number that follows to what you have so far. So &quot;B5&quot; means add 5.\n- When you hit a 'C', that means subtract the value of the number that follows from what you have so far. So &quot;C4&quot; means subtract 4.\n- When you hit a 'D', that means to increment the value you have,\n- When you hit a 'E', that means to decrement the value you have,\n- When you hit a 'F', that means to print the value you have.\n\nWhat would be printed by the following &quot;program&quot;? \n\n&quot;A3B8DDC5EF&quot;\n\nTo figure it out, you'd step through the string, character by character. First, you load the character at index 0, and you get an 'A'. So you execute the code for 'A', which is to load the value of the next number. You look at index 1, and you see 3, so you load 3 into your accumulator. Then you increment your offset (instruction pointer or program counter) to 2. (Your accumulator is now 3.)\n\nYou then load the value at offset 2, and you find a &quot;B&quot;. So you execute the code for &quot;B&quot; - grab the number at the offset past the &quot;B&quot;. add it to your accumulator, and then increment past that number. (Your accumulator is now 11.)\n\nThe next &quot;opcode&quot; at 4 is &quot;D&quot;, which is to increment your accumulator. You do that (getting 12). It has no arguments, so your offset of 5 is the next instruction.\n\nYou keep going. You increment the accumulator (D at offset 5), subtract 5 from it (C5 at offsets 6 and 7), decrement it (E at offset <!-- s8) --><img src=\"{SMILIES_PATH}/icon_cool.gif\" alt=\"8)\" title=\"Cool\" /><!-- s8) --> and finally print it (F at offset 9) -&gt; resulting in 7 (if I did my math right).\n\nThat's how a processor works, The &quot;offset&quot; pointing into the string is your 16-bit instruction pointer pointing into memory. The values you read (the A,B,C, etc) are your opcodes, In your virtual processor, they'll just be 8-bit values, ranging from 0-255. That gives you 256 possible opcodes, which you need to know the definitions for and write code for.\n\nHope that helps, and good luck! (And let me know if you have more questions.)",
      "EditableFormat": "bbcode",
      "HTML": "The virtual registers are outside the memory segment, just as in the x86 processor, where you have the AX, BX, CX, etc registers which are on the processor chip but aren't part of the main memory (that is, they don't have a physical address in main memory).<br/><br/>And the opcodes (operational codes, or instructions) are just numbers stored in memory. They have meaning to the processor when being interpreted as instructions (e.g. 1 = load memory, 2 = store memory, 3 = move register to register, 4 = add a value to a register, 5 = increment a register, etc - all things I just made up, by the way), but at the end of the day, they're just numbers. That's one of the magical things about computers - code is just data. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>Imagine I tell you the following: I'm going to give you a string. As you go along the string, the following rules apply.<br/><br/>- When you hit an 'A', that means load the value of the number that follows. So &quot;A0&quot; means &quot;load the value 0&quot;.<br/>- When you hit a 'B', that means add the value of the number that follows to what you have so far. So &quot;B5&quot; means add 5.<br/>- When you hit a 'C', that means subtract the value of the number that follows from what you have so far. So &quot;C4&quot; means subtract 4.<br/>- When you hit a 'D', that means to increment the value you have,<br/>- When you hit a 'E', that means to decrement the value you have,<br/>- When you hit a 'F', that means to print the value you have.<br/><br/>What would be printed by the following &quot;program&quot;? <br/><br/>&quot;A3B8DDC5EF&quot;<br/><br/>To figure it out, you'd step through the string, character by character. First, you load the character at index 0, and you get an 'A'. So you execute the code for 'A', which is to load the value of the next number. You look at index 1, and you see 3, so you load 3 into your accumulator. Then you increment your offset (instruction pointer or program counter) to 2. (Your accumulator is now 3.)<br/><br/>You then load the value at offset 2, and you find a &quot;B&quot;. So you execute the code for &quot;B&quot; - grab the number at the offset past the &quot;B&quot;. add it to your accumulator, and then increment past that number. (Your accumulator is now 11.)<br/><br/>The next &quot;opcode&quot; at 4 is &quot;D&quot;, which is to increment your accumulator. You do that (getting 12). It has no arguments, so your offset of 5 is the next instruction.<br/><br/>You keep going. You increment the accumulator (D at offset 5), subtract 5 from it (C5 at offsets 6 and 7), decrement it (E at offset <!-- s8) --><img src=\"{SMILIES_PATH}/icon_cool.gif\" alt=\"8)\" title=\"Cool\" /><!-- s8) --> and finally print it (F at offset 9) -&gt; resulting in 7 (if I did my math right).<br/><br/>That's how a processor works, The &quot;offset&quot; pointing into the string is your 16-bit instruction pointer pointing into memory. The values you read (the A,B,C, etc) are your opcodes, In your virtual processor, they'll just be 8-bit values, ranging from 0-255. That gives you 256 possible opcodes, which you need to know the definitions for and write code for.<br/><br/>Hope that helps, and good luck! (And let me know if you have more questions.)",
      "PostDate": "2016-02-23T22:43:01+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41401",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Thank you for that explanation (sorry about the question about where the registers are stored, after I posted I'm like that was a dumb question, as the registers are separate from memory, the CPU has its own limited memory array/space/segment, which is, *LOGICALLY* - somehow that I think is still a bit of a mystery to even computer theory/theorists on how it is able to work, lol - as I've come across in my research, divided up into sub-segments, some of which those sub-segments, are better known as the registers, 32:eax/16:ax/8:a, ebx/bx/b, ecx/cx/c, edx/dx/d, etc. These are the fastest memory sources, as they're apart of the CPU, whereas RAM is separate, bussed off on the mother board, as the &quot;mem sticks/bus&quot;, so it's slower than the register memory, but they're less volative than the registers, which require variables or the stack-pushing-popping to preserve their data, but RAM is still volatile too obviously, especially compared to secondary memory, storage disk space, such as a HDD or ODD, extHDD, flash, etc. And even these are still volatile due to entropy and and etc wear of the materials and etc physics/chemistry stuff, so after say maybe 10 years, contrary to the layman's belief that the data lasts forever, your data on your burned cd, is gone/corrupted/damaged permanently ---except maybe not in zero, well near zero, Kelvin, lol), but I wasn't sure about how the instruction set/opcodes worked and where they're located, so that was really helpful.\n\nAs I already mentioned/explained above, I finally am understanding well about how memory itself works (already: prior to your posts, thanks to some of my C++ and Java classes and a lot to my current Assembly class), so I do/did already understand about base addresses, offsets, indirect, and etc. I just didn't know how the opcodes/instruction set worked at all.\n\n--------\n\nYour posts have been of such great great tremendous help, THANK YOU VERY MUCH, Jay! I think I can hopefully figure out how to do the lab now on my own (and maybe a little more help from the prof), but I was asking a classmate today, and he said that I was on the right track, thanks to what you explained and helped me with, with these posts of yours. So, hopefully, I won't be needing to ask you any more, and can figure the rest out on my own, HK crosses his fingers, but maybe I'll still be stumped on some things... HK is hoping he can do it now!\n\nProbably a little too helpful (and not that I'd: &quot;not looking a gift horse in the mouth&quot;, lol, but I do like trying to do as much as I can on my own and hate asking for help, but sometimes I do need help, no matter how hard I try on my own)... though I do have a much better understanding now, which I didn't priorly. Also, I already knew about some of the &quot;too helpful&quot; content, whereas I was more stuck on just the exactly what the assignment wanted me to do in general terms / design, as I couldn't induce it on my own, due to being new to Assembly. It's like expecting someone to know (or to figure out that) something when they don't know that something (or nor the parts needed to figure out that something. Imagine Sherlock Holmes trying to solve a case without knowing what pieces to even be looking for, lol). If I already knew assembly well, then I'm sure, I'd know exactly what was expected from the vague instructions, but I was quite lost until I got help from you Jay, as I don't already know Assembly, and thus couldn't figure out what I didn't know already. It's a bit of a cunundrum (can't spell), ya you obviously don't want to tell them how to do the program, but they need to have an idea how to do the program, to do the program. It's a near impossible balancing act.. Provide enough instruction to steer/guide them in the right direction or understanding, without giving instruction on &quot;how-how to do the actual lab directly&quot;. How to give a hint without it being (or ending up as) an answer, is probably a better analogy that I just thought of.\n\n------\n\nAnyways, I'll try to get the same level of help from the teacher as I got from you and my classmate, so I appreciate all the help: you, classmate, and hopefully the teacher too, crediting all of your help of course. I needed it, as I was really lost/confused on my own.",
      "EditableFormat": "bbcode",
      "HTML": "Thank you for that explanation (sorry about the question about where the registers are stored, after I posted I'm like that was a dumb question, as the registers are separate from memory, the CPU has its own limited memory array/space/segment, which is, *LOGICALLY* - somehow that I think is still a bit of a mystery to even computer theory/theorists on how it is able to work, lol - as I've come across in my research, divided up into sub-segments, some of which those sub-segments, are better known as the registers, 32:eax/16:ax/8:a, ebx/bx/b, ecx/cx/c, edx/dx/d, etc. These are the fastest memory sources, as they're apart of the CPU, whereas RAM is separate, bussed off on the mother board, as the &quot;mem sticks/bus&quot;, so it's slower than the register memory, but they're less volative than the registers, which require variables or the stack-pushing-popping to preserve their data, but RAM is still volatile too obviously, especially compared to secondary memory, storage disk space, such as a HDD or ODD, extHDD, flash, etc. And even these are still volatile due to entropy and and etc wear of the materials and etc physics/chemistry stuff, so after say maybe 10 years, contrary to the layman's belief that the data lasts forever, your data on your burned cd, is gone/corrupted/damaged permanently ---except maybe not in zero, well near zero, Kelvin, lol), but I wasn't sure about how the instruction set/opcodes worked and where they're located, so that was really helpful.<br/><br/>As I already mentioned/explained above, I finally am understanding well about how memory itself works (already: prior to your posts, thanks to some of my C++ and Java classes and a lot to my current Assembly class), so I do/did already understand about base addresses, offsets, indirect, and etc. I just didn't know how the opcodes/instruction set worked at all.<br/><br/>--------<br/><br/>Your posts have been of such great great tremendous help, THANK YOU VERY MUCH, Jay! I think I can hopefully figure out how to do the lab now on my own (and maybe a little more help from the prof), but I was asking a classmate today, and he said that I was on the right track, thanks to what you explained and helped me with, with these posts of yours. So, hopefully, I won't be needing to ask you any more, and can figure the rest out on my own, HK crosses his fingers, but maybe I'll still be stumped on some things... HK is hoping he can do it now!<br/><br/>Probably a little too helpful (and not that I'd: &quot;not looking a gift horse in the mouth&quot;, lol, but I do like trying to do as much as I can on my own and hate asking for help, but sometimes I do need help, no matter how hard I try on my own)... though I do have a much better understanding now, which I didn't priorly. Also, I already knew about some of the &quot;too helpful&quot; content, whereas I was more stuck on just the exactly what the assignment wanted me to do in general terms / design, as I couldn't induce it on my own, due to being new to Assembly. It's like expecting someone to know (or to figure out that) something when they don't know that something (or nor the parts needed to figure out that something. Imagine Sherlock Holmes trying to solve a case without knowing what pieces to even be looking for, lol). If I already knew assembly well, then I'm sure, I'd know exactly what was expected from the vague instructions, but I was quite lost until I got help from you Jay, as I don't already know Assembly, and thus couldn't figure out what I didn't know already. It's a bit of a cunundrum (can't spell), ya you obviously don't want to tell them how to do the program, but they need to have an idea how to do the program, to do the program. It's a near impossible balancing act.. Provide enough instruction to steer/guide them in the right direction or understanding, without giving instruction on &quot;how-how to do the actual lab directly&quot;. How to give a hint without it being (or ending up as) an answer, is probably a better analogy that I just thought of.<br/><br/>------<br/><br/>Anyways, I'll try to get the same level of help from the teacher as I got from you and my classmate, so I appreciate all the help: you, classmate, and hopefully the teacher too, crediting all of your help of course. I needed it, as I was really lost/confused on my own.",
      "PostDate": "2016-02-24T03:05:49+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41405",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Glad I could help, and good luck! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\n(And I hope I didn't cross too many lines. Sometimes the hardest part in answering a question is working out what's being asked.)",
      "EditableFormat": "bbcode",
      "HTML": "Glad I could help, and good luck! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>(And I hope I didn't cross too many lines. Sometimes the hardest part in answering a question is working out what's being asked.)",
      "PostDate": "2016-02-24T10:04:07+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41415",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "laughs, that too... on your side, sorry for the confusion on what I was asking about or for, it's not easy when you don't know yourself what to ask about or how to word your question correctly, sighs. So, rest easy, as indeed I'm to blame, for any possible &quot;too helpfulness&quot;, due to my unclear posts and questions",
      "EditableFormat": "bbcode",
      "HTML": "laughs, that too... on your side, sorry for the confusion on what I was asking about or for, it's not easy when you don't know yourself what to ask about or how to word your question correctly, sighs. So, rest easy, as indeed I'm to blame, for any possible &quot;too helpfulness&quot;, due to my unclear posts and questions",
      "PostDate": "2016-02-24T16:53:03+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41437",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "So, I talked to the prof on some things that I was still confused about and wanting to make sure that what I gleamed from the help from you Jay and others, is what was wanted from the lab/project/program/assignment...\n\nWOW... just WOW... all this lab is... is a Script Dictionary !!! HK bangs his head on the desk, just a bloody... script dictionary... design! HK laughs madly, lol.\n\nI was confused on the instruction set/opcodes, I thought I had to construct them like functions or &quot;like add the opcode address and the reg1 adress and the reg2 address togehter, or somehow put those 3 address values together to get the adress of the instruction set/opteration or whatever lol, and then magically know what kind of function/action to use it for... which was really purplexing me&quot;\n\nOnly difference of course is that this is assembly, using addressing, as the 'opcode values' are just the 'keys' of a Script Dictionary, and the scripts are just achieved also via (a simple method of many methods) assembly's old school usage of &quot;goto&quot; jumping. Intead of 'if', as this is assembly (though I think assembly does have 'if' instruction sets added to it now too) we just use 'cmp (compare)', for pseudocode example:\n\nfile: 1 2 3 4 5 6 99 87 55 30 70 20 10 0 78 -&gt; put (read) into -&gt; mem_array\n\nopcode1 = 5\nopcode2 = 30\n\n:start:\ncmp mem_array_offset[index] == opcode1, if true, goto 'add' code line/block, and do the given operations of 'add'.\ncmp mem_array_offset[index] == opcode2, if true, goto 'mov' codeline/block, and do the given operations of 'mov'\netc etc etc\nincrease index\ngoto start\n\n:add:\nadd reg1, reg2\n\n:mov:\nmov reg1, reg2\n\netc etc etc\n\n-----------------------\n\nthis lab is so easy... now... (aside from not screwing up my addressing or whatever mistake, and having to trouble shoot it/them, lol)\n\n--------------------\n\nAGAIN, THANK YOU JAY, your posts really helped a lot in getting the initial basic understanding of how this is done in assembly, I would never had figured any of this out on my own... sighs. I'm stupid/dumb...\n\nbut I'm also...\n\nHK, THE SMARTEST DUMBEST PERSON! <!-- s:D --><img src=\"{SMILIES_PATH}/icon_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D -->\n\n(I really like this title I came up with myself for myself, hehe, from struggling so much with understanding programming, but then having moments of, for me genius, in suddenly understanding the programming when just a few moments ago I was totally clueless, this has happened so much to me as I'm trying to learn more and more programming, doing more and more coding labs/projects and etc)\n\n(I'm really happy that I now finally understand this assembly lab, maybe I do have a chance in this class, ... if I can start doing better on tests... grr. HK still though dances around in joy... knocking over everything... as he can't dance on top of being super clumsy... lol)",
      "EditableFormat": "bbcode",
      "HTML": "So, I talked to the prof on some things that I was still confused about and wanting to make sure that what I gleamed from the help from you Jay and others, is what was wanted from the lab/project/program/assignment...<br/><br/>WOW... just WOW... all this lab is... is a Script Dictionary !!! HK bangs his head on the desk, just a bloody... script dictionary... design! HK laughs madly, lol.<br/><br/>I was confused on the instruction set/opcodes, I thought I had to construct them like functions or &quot;like add the opcode address and the reg1 adress and the reg2 address togehter, or somehow put those 3 address values together to get the adress of the instruction set/opteration or whatever lol, and then magically know what kind of function/action to use it for... which was really purplexing me&quot;<br/><br/>Only difference of course is that this is assembly, using addressing, as the 'opcode values' are just the 'keys' of a Script Dictionary, and the scripts are just achieved also via (a simple method of many methods) assembly's old school usage of &quot;goto&quot; jumping. Intead of 'if', as this is assembly (though I think assembly does have 'if' instruction sets added to it now too) we just use 'cmp (compare)', for pseudocode example:<br/><br/>file: 1 2 3 4 5 6 99 87 55 30 70 20 10 0 78 -&gt; put (read) into -&gt; mem_array<br/><br/>opcode1 = 5<br/>opcode2 = 30<br/><br/>:start:<br/>cmp mem_array_offset[index] == opcode1, if true, goto 'add' code line/block, and do the given operations of 'add'.<br/>cmp mem_array_offset[index] == opcode2, if true, goto 'mov' codeline/block, and do the given operations of 'mov'<br/>etc etc etc<br/>increase index<br/>goto start<br/><br/>:add:<br/>add reg1, reg2<br/><br/>:mov:<br/>mov reg1, reg2<br/><br/>etc etc etc<br/><br/>-----------------------<br/><br/>this lab is so easy... now... (aside from not screwing up my addressing or whatever mistake, and having to trouble shoot it/them, lol)<br/><br/>--------------------<br/><br/>AGAIN, THANK YOU JAY, your posts really helped a lot in getting the initial basic understanding of how this is done in assembly, I would never had figured any of this out on my own... sighs. I'm stupid/dumb...<br/><br/>but I'm also...<br/><br/>HK, THE SMARTEST DUMBEST PERSON! <!-- s:D --><img src=\"{SMILIES_PATH}/icon_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D --><br/><br/>(I really like this title I came up with myself for myself, hehe, from struggling so much with understanding programming, but then having moments of, for me genius, in suddenly understanding the programming when just a few moments ago I was totally clueless, this has happened so much to me as I'm trying to learn more and more programming, doing more and more coding labs/projects and etc)<br/><br/>(I'm really happy that I now finally understand this assembly lab, maybe I do have a chance in this class, ... if I can start doing better on tests... grr. HK still though dances around in joy... knocking over everything... as he can't dance on top of being super clumsy... lol)",
      "PostDate": "2016-02-25T08:33:10+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41440",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The light bulb has gone off.  <!-- s:idea: --><img src=\"{SMILIES_PATH}/icon_idea.gif\" alt=\":idea:\" title=\"Idea\" /><!-- s:idea: -->  I'm glad it makes sense now. I tried to hint at that a bit (or more) above, and I even had &quot;script dictionary&quot; in my head at one point as a Quest analogue, but it never made it into my response. I think you're going to enjoy this one, once you get into it. It's magical to watch your code executing other code. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "The light bulb has gone off.  <!-- s:idea: --><img src=\"{SMILIES_PATH}/icon_idea.gif\" alt=\":idea:\" title=\"Idea\" /><!-- s:idea: -->  I'm glad it makes sense now. I tried to hint at that a bit (or more) above, and I even had &quot;script dictionary&quot; in my head at one point as a Quest analogue, but it never made it into my response. I think you're going to enjoy this one, once you get into it. It's magical to watch your code executing other code. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-02-25T09:58:21+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41463",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "(bloody need to install VS community for the binary editor, so I can see the machine.bin, for testing/debugging/checking my program, last time I tried to install VS community it's trial subscription ran out, but isn't there suppose a free version of it? As the free 'express' version I've been using doesn't have the binary editor, which I need, grr. I better not have any isssues... I need to work on my program... as the technical details of it are still a bit murky for me... despite understanding that I'm doing a script dictionary now)\n\n-------------------------\n\nquick question:\n\nso I got my 'machine.bin' file with a bunch of hexidecimals in it, (some of those represent the opcodes), which we place that data into an array variable, and iterate through it seeing if those values are the opcode values and performing the opcode instruction/operations.\n\nsome of the given instructions say to use &quot;address&quot;, are they refering to the array containing the machine.bin data, meaning that we're to change those values based on our instructions, which will be re-read over and over again, with those new values (instead of the original values), possibly being an opcode, and this continues until we hit the terminate program opcode?\n\nfor example, say the mem array (which initially contains the original hexidecimal values/opcodes):\n\n00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09\n\nand lets say the given instruction sets are:\n\n00: add\n01: sub\n02: mov\n03: store address ; store value in reg1 (R0) into &quot;address&quot;\n04: load\n\nlet's pretend that 'store' changes the (addresses/offsets that have the) '09' values to say '02', as seen below:\n\n00 01 02 03 04 05 06 07 08 02 00 01 02 03 04 05 06 07 08 02\n\nand thus when it iterates through again, it now does 'mov' operations when it gets to those addresses (and thus in this example, there's no 'store' operations now occuring), is this what is suppose to happen?\n\n-------------\n\nor, am I getting confused, and I just iterate through the mem array (which holds the machine.bin file; the hecidecimal/opcodes) only once, (the iteration is through the loop/goto checking of the opcode values to jump to what operation to perform), and the manipulation is based on whatever the given instructions are, whether they manipulate the values in the mem array or not?\n\n----------\n\nalso... from this given assignment statement:\n\nCPU contains 6 registers each 8 bits  (R0 – R5 valued 0 – 5)\n\ndoes this mean that the registers are initially set to having those values?:\n\nmov R0, 00h\nmov R1, 01h\nmov R2, 02h\nmov R3, 03h\nmov R4, 04h\nmov R5, 05h\n\nas I'm wondering this, due to having 'add and sub' dealing with reg operands",
      "EditableFormat": "bbcode",
      "HTML": "(bloody need to install VS community for the binary editor, so I can see the machine.bin, for testing/debugging/checking my program, last time I tried to install VS community it's trial subscription ran out, but isn't there suppose a free version of it? As the free 'express' version I've been using doesn't have the binary editor, which I need, grr. I better not have any isssues... I need to work on my program... as the technical details of it are still a bit murky for me... despite understanding that I'm doing a script dictionary now)<br/><br/>-------------------------<br/><br/>quick question:<br/><br/>so I got my 'machine.bin' file with a bunch of hexidecimals in it, (some of those represent the opcodes), which we place that data into an array variable, and iterate through it seeing if those values are the opcode values and performing the opcode instruction/operations.<br/><br/>some of the given instructions say to use &quot;address&quot;, are they refering to the array containing the machine.bin data, meaning that we're to change those values based on our instructions, which will be re-read over and over again, with those new values (instead of the original values), possibly being an opcode, and this continues until we hit the terminate program opcode?<br/><br/>for example, say the mem array (which initially contains the original hexidecimal values/opcodes):<br/><br/>00 01 02 03 04 05 06 07 08 09 00 01 02 03 04 05 06 07 08 09<br/><br/>and lets say the given instruction sets are:<br/><br/>00: add<br/>01: sub<br/>02: mov<br/>03: store address ; store value in reg1 (R0) into &quot;address&quot;<br/>04: load<br/><br/>let's pretend that 'store' changes the (addresses/offsets that have the) '09' values to say '02', as seen below:<br/><br/>00 01 02 03 04 05 06 07 08 02 00 01 02 03 04 05 06 07 08 02<br/><br/>and thus when it iterates through again, it now does 'mov' operations when it gets to those addresses (and thus in this example, there's no 'store' operations now occuring), is this what is suppose to happen?<br/><br/>-------------<br/><br/>or, am I getting confused, and I just iterate through the mem array (which holds the machine.bin file; the hecidecimal/opcodes) only once, (the iteration is through the loop/goto checking of the opcode values to jump to what operation to perform), and the manipulation is based on whatever the given instructions are, whether they manipulate the values in the mem array or not?<br/><br/>----------<br/><br/>also... from this given assignment statement:<br/><br/>CPU contains 6 registers each 8 bits  (R0 – R5 valued 0 – 5)<br/><br/>does this mean that the registers are initially set to having those values?:<br/><br/>mov R0, 00h<br/>mov R1, 01h<br/>mov R2, 02h<br/>mov R3, 03h<br/>mov R4, 04h<br/>mov R5, 05h<br/><br/>as I'm wondering this, due to having 'add and sub' dealing with reg operands",
      "PostDate": "2016-02-27T00:39:10+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41466",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm still struggling a bit with how to use the given instruction sets with the 'machine.bin' (opcodes) file, sighs. If I could just get some help with walking through one of them, would be immensely helpful. There's so much information overload for me, that I'm overwhelmed, confused, and lost, sighs.\n\nour given CPU information:\n\ncpu contains 6 registers, each 8 bits (R0-R5 valued 0-5)\n16-bit address space\n1k of RAM\non reset the cpu begins execution at location 0\ncisc style instruction set, instruction length varies with instruction\nregister operands are 1 byte\nall memory addresses are 2 bytes long and are stored in big endian format\n\nour given instruction set:\n\nmenumonic, opcode (hexidecimal), operand 1, operand 2, notes\n\nADD, 11h, reg1, reg2, reg1=reg1+reg2\nSUB, 22h, reg1, reg2, reg1=reg1-reg2\nXOR, 44h, reg1, reg2, reg1=reg1 XOR reg2\nLOAD, 05h, reg1, address, load reg1 with value at address\nLOADR, 55h, reg1, adress, load reg1 with value at (address+reg1)\nSTORE, 06h, address, ---, write value in R0 to address\nSTORR, 66h, reg1, address, write value in R0 to (address+reg1)\nOUT, 0CCh, reg1, ---, send value in reg1 to output (screen)\nJNZ, 0AAh, reg1, address, if value in reg1 isn't zero then next instruction is at address\nHALT, 0FFh, ---, ---, CPU halts - terminate program\n\nour given 'machine.bin' file (only first 32 byte address slots):\n\n...............................................................................................................A......B......C......D......E......F\n..........................0......1......2......3......4......5......6......7..........8......9.....10.....11....12....13....14....15\n0000 0000 ~~~ 05 ~ 04 ~ 01 ~ A3 ~ 44 ~ 02 ~ 02 ~ 05 ~~~ 00 ~ 01 ~ A0 ~ 05 ~ 04 ~ 01 ~ A3 ~ 11 ~~~ .... D... .... ....\n0000 0010 ~~~ 00 ~ 04 ~ 06 ~ 01 ~ A0 ~ 05 ~ 03 ~ 01 ~~~ A1 ~ 44 ~ 01 ~ 01 ~ 11 ~ 01 ~ 00 ~ 55 ~~~ .... .... .D.. ...U\n0000 0020 ~~~ 01 ~ 00 ~ A0 ~ 11 ~ 03 ~ 01 ~ 44 ~ 05 ~~~ 05 ~ 11 ~ 05 ~ 00 ~ 44 ~ 00 ~ 00 ~ 11 ~~~ .... ..D. .... D...\n\n-------------\n\nmy understanding so far:\n\n(I've been using these vids, <!-- m --><a class=\"postlink\" href=\"https://www.youtube.com/watch?v=tjZ2Mh_MV6g\">https://www.youtube.com/watch?v=tjZ2Mh_MV6g</a><!-- m -->, <!-- m --><a class=\"postlink\" href=\"https://www.youtube.com/watch?v=Xj5BqNHi1X8\">https://www.youtube.com/watch?v=Xj5BqNHi1X8</a><!-- m -->, and etc following vids, best vids I found so far on explaining this stuff. I know he's working with 8085, but he's explaining how the instructions and opcodes work...)\n\n05 -&gt; mov R0, 05\n\nor... am I suppose to also use: 04, 01, A3 ???, as the vids talk about, something like:\n\nmov 04's address (dest), 01's address (source), A3's address (next instruction) ???\n\nwhat also is confusing me is the '44' instruction, as it's an XOR of reg1 and reg2, but I've not put anyhting into (haven't used) reg2... so I'm confused...",
      "EditableFormat": "bbcode",
      "HTML": "I'm still struggling a bit with how to use the given instruction sets with the 'machine.bin' (opcodes) file, sighs. If I could just get some help with walking through one of them, would be immensely helpful. There's so much information overload for me, that I'm overwhelmed, confused, and lost, sighs.<br/><br/>our given CPU information:<br/><br/>cpu contains 6 registers, each 8 bits (R0-R5 valued 0-5)<br/>16-bit address space<br/>1k of RAM<br/>on reset the cpu begins execution at location 0<br/>cisc style instruction set, instruction length varies with instruction<br/>register operands are 1 byte<br/>all memory addresses are 2 bytes long and are stored in big endian format<br/><br/>our given instruction set:<br/><br/>menumonic, opcode (hexidecimal), operand 1, operand 2, notes<br/><br/>ADD, 11h, reg1, reg2, reg1=reg1+reg2<br/>SUB, 22h, reg1, reg2, reg1=reg1-reg2<br/>XOR, 44h, reg1, reg2, reg1=reg1 XOR reg2<br/>LOAD, 05h, reg1, address, load reg1 with value at address<br/>LOADR, 55h, reg1, adress, load reg1 with value at (address+reg1)<br/>STORE, 06h, address, ---, write value in R0 to address<br/>STORR, 66h, reg1, address, write value in R0 to (address+reg1)<br/>OUT, 0CCh, reg1, ---, send value in reg1 to output (screen)<br/>JNZ, 0AAh, reg1, address, if value in reg1 isn't zero then next instruction is at address<br/>HALT, 0FFh, ---, ---, CPU halts - terminate program<br/><br/>our given 'machine.bin' file (only first 32 byte address slots):<br/><br/>...............................................................................................................A......B......C......D......E......F<br/>..........................0......1......2......3......4......5......6......7..........8......9.....10.....11....12....13....14....15<br/>0000 0000 ~~~ 05 ~ 04 ~ 01 ~ A3 ~ 44 ~ 02 ~ 02 ~ 05 ~~~ 00 ~ 01 ~ A0 ~ 05 ~ 04 ~ 01 ~ A3 ~ 11 ~~~ .... D... .... ....<br/>0000 0010 ~~~ 00 ~ 04 ~ 06 ~ 01 ~ A0 ~ 05 ~ 03 ~ 01 ~~~ A1 ~ 44 ~ 01 ~ 01 ~ 11 ~ 01 ~ 00 ~ 55 ~~~ .... .... .D.. ...U<br/>0000 0020 ~~~ 01 ~ 00 ~ A0 ~ 11 ~ 03 ~ 01 ~ 44 ~ 05 ~~~ 05 ~ 11 ~ 05 ~ 00 ~ 44 ~ 00 ~ 00 ~ 11 ~~~ .... ..D. .... D...<br/><br/>-------------<br/><br/>my understanding so far:<br/><br/>(I've been using these vids, <!-- m --><a class=\"postlink\" href=\"https://www.youtube.com/watch?v=tjZ2Mh_MV6g\">https://www.youtube.com/watch?v=tjZ2Mh_MV6g</a><!-- m -->, <!-- m --><a class=\"postlink\" href=\"https://www.youtube.com/watch?v=Xj5BqNHi1X8\">https://www.youtube.com/watch?v=Xj5BqNHi1X8</a><!-- m -->, and etc following vids, best vids I found so far on explaining this stuff. I know he's working with 8085, but he's explaining how the instructions and opcodes work...)<br/><br/>05 -&gt; mov R0, 05<br/><br/>or... am I suppose to also use: 04, 01, A3 ???, as the vids talk about, something like:<br/><br/>mov 04's address (dest), 01's address (source), A3's address (next instruction) ???<br/><br/>what also is confusing me is the '44' instruction, as it's an XOR of reg1 and reg2, but I've not put anyhting into (haven't used) reg2... so I'm confused...",
      "PostDate": "2016-02-27T08:51:54+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41467",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:2a1yjyl7]CPU contains 6 registers each 8 bits (R0 – R5 valued 0 – 5)\n\ndoes this mean that the registers are initially set to having those values?:[/quote:2a1yjyl7]\n\nTo answer in easy order... \n\nTo be honest, I don't know why the registers would start with those particular values, but I can't work out a different interpretation of that statement that isn't redundant. I think in normal processors, the registers either start out 0 or have random values, depending on how the bits come up (apart from the status register, which needs to be reasonably defined). You wouldn't want to rely on a register having a particular value anyway. (I'm ignoring processors that dedicate specific registers to particular values.)\n\n[quote:2a1yjyl7]Or, am I getting confused, and I just iterate through the mem array[/quote:2a1yjyl7]\nYou just iterate through the mem array. You mentioned there's a terminate opcode, so you would stop there. And if you have jumps or branches or &quot;go to subroutine&quot; type instructions, then those would alter the instruction pointer, allowing you to jump around in the memory array. But beyond that, you just keep plodding forward.\n\nAnd now about the address and other operands.\n\n(Actually,  I see you just asked another question, so I'll pick it up there.)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>CPU contains 6 registers each 8 bits (R0 – R5 valued 0 – 5)<br/><br/>does this mean that the registers are initially set to having those values?:</p></blockquote><br/><br/>To answer in easy order... <br/><br/>To be honest, I don't know why the registers would start with those particular values, but I can't work out a different interpretation of that statement that isn't redundant. I think in normal processors, the registers either start out 0 or have random values, depending on how the bits come up (apart from the status register, which needs to be reasonably defined). You wouldn't want to rely on a register having a particular value anyway. (I'm ignoring processors that dedicate specific registers to particular values.)<br/><br/><blockquote><p>Or, am I getting confused, and I just iterate through the mem array</p></blockquote><br/>You just iterate through the mem array. You mentioned there's a terminate opcode, so you would stop there. And if you have jumps or branches or &quot;go to subroutine&quot; type instructions, then those would alter the instruction pointer, allowing you to jump around in the memory array. But beyond that, you just keep plodding forward.<br/><br/>And now about the address and other operands.<br/><br/>(Actually,  I see you just asked another question, so I'll pick it up there.)",
      "PostDate": "2016-02-27T08:57:27+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41468",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The key is to know that the memory you're stepping through is not just the instructions but the data as well, and the amount of data bytes depends on the instruction. Let's do some. I assume that where it specifies a register in an instruction, that's a single byte index for the register, and an address is two bytes. Looking at the data, it looks like addresses are big endian (high byte first), since they need to be within your 1K block.\n\nThe first byte is 5. That's a load. The next byte is the register to load into, followed by the address (as two bytes) to load from. So you'd have:\n\n05 (LOAD) 04 (register 4) 01 A3 (from address 0x01a3)      =&gt; LOAD R4, $01a3\n\nNext you have:\n\n44 (XOR) 02 (R2) 02 (R2)                                                  =&gt; XOR R2, R2    (which zeros it)\n\n05 (LOAD) 00 (R0) 01 A0 (from address 0x01a0)                  =&gt; LOAD R0, $01a0\n \nAnd so forth. I can do more if you want, but maybe that helps?",
      "EditableFormat": "bbcode",
      "HTML": "The key is to know that the memory you're stepping through is not just the instructions but the data as well, and the amount of data bytes depends on the instruction. Let's do some. I assume that where it specifies a register in an instruction, that's a single byte index for the register, and an address is two bytes. Looking at the data, it looks like addresses are big endian (high byte first), since they need to be within your 1K block.<br/><br/>The first byte is 5. That's a load. The next byte is the register to load into, followed by the address (as two bytes) to load from. So you'd have:<br/><br/>05 (LOAD) 04 (register 4) 01 A3 (from address 0x01a3)      =&gt; LOAD R4, $01a3<br/><br/>Next you have:<br/><br/>44 (XOR) 02 (R2) 02 (R2)                                                  =&gt; XOR R2, R2    (which zeros it)<br/><br/>05 (LOAD) 00 (R0) 01 A0 (from address 0x01a0)                  =&gt; LOAD R0, $01a0<br/> <br/>And so forth. I can do more if you want, but maybe that helps?",
      "PostDate": "2016-02-27T09:06:16+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41469",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I just editted my previous post (the one with the assignment requirements and info)... if you wouldn't mind looking over it again... to see what I understand/don't understand, and am confused with.",
      "EditableFormat": "bbcode",
      "HTML": "I just editted my previous post (the one with the assignment requirements and info)... if you wouldn't mind looking over it again... to see what I understand/don't understand, and am confused with.",
      "PostDate": "2016-02-27T09:07:22+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41470",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "It looks like you have the right idea. But addresses are 16 bits - two bytes. (See my post.) The XOR is actually the same register, which makes it 0.",
      "EditableFormat": "bbcode",
      "HTML": "It looks like you have the right idea. But addresses are 16 bits - two bytes. (See my post.) The XOR is actually the same register, which makes it 0.",
      "PostDate": "2016-02-27T09:10:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41471",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ya, I just started reading your post with this in it:\n\n&quot;The first byte is 5. That's a load. The next byte is the register to load into, followed by the address (as two bytes) to load from. So you'd have:\n\n05 (LOAD) 04 (register 4) 01 A3 (from address 0x01a3) =&gt; LOAD R4, $01a3&quot;\n\nI think I get it now!\n\nso the &quot;6 registers of a byte: R0-R5 with values 0-5&quot;, the values '0-5' is just to correlate to the data in the mem array:\n\ndata in mem array -&gt; virtual register (variable)\n\n00 -&gt; R0\n01 -&gt; R1\n02 -&gt; R2\n03 -&gt; R3\n04 -&gt; R4\n05 -&gt; R5 // well, this actually can't be done, lol, as 05 is already an opcode... lol",
      "EditableFormat": "bbcode",
      "HTML": "ya, I just started reading your post with this in it:<br/><br/>&quot;The first byte is 5. That's a load. The next byte is the register to load into, followed by the address (as two bytes) to load from. So you'd have:<br/><br/>05 (LOAD) 04 (register 4) 01 A3 (from address 0x01a3) =&gt; LOAD R4, $01a3&quot;<br/><br/>I think I get it now!<br/><br/>so the &quot;6 registers of a byte: R0-R5 with values 0-5&quot;, the values '0-5' is just to correlate to the data in the mem array:<br/><br/>data in mem array -&gt; virtual register (variable)<br/><br/>00 -&gt; R0<br/>01 -&gt; R1<br/>02 -&gt; R2<br/>03 -&gt; R3<br/>04 -&gt; R4<br/>05 -&gt; R5 // well, this actually can't be done, lol, as 05 is already an opcode... lol",
      "PostDate": "2016-02-27T09:14:52+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41472",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Great! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "Great! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-02-27T09:15:20+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41473",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:1cllf8fb]05 -&gt; R5 // well, this actually can't be done, lol, as 05 is already an opcode... lol[/quote:1cllf8fb]\n\nIt depends! It depends on whether you encounter it at the time you expect an instruction or not. You have to keep in mind that you're marching through the array one byte at a time. You read the opcode and then increment the instruction pointer. If the opcode needs a register, then you read that byte, but at that point, you're not processing it as an instruction but as data for the instruction. Then increment the IP and read the high byte for the address and you increment again and read the low byte for the address and then you increment again to prep you for reading the next instruction. \n\nData values have meaning in context only. If you're at the point of reading an opcode, it's treated as an opcode. If it's at the point of reading a register, it's treated as a register. You must parse it sequentially, in context. You can't just say every 5 is an opcode. It might be a register value or part of an address even.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>05 -&gt; R5 // well, this actually can't be done, lol, as 05 is already an opcode... lol</p></blockquote><br/><br/>It depends! It depends on whether you encounter it at the time you expect an instruction or not. You have to keep in mind that you're marching through the array one byte at a time. You read the opcode and then increment the instruction pointer. If the opcode needs a register, then you read that byte, but at that point, you're not processing it as an instruction but as data for the instruction. Then increment the IP and read the high byte for the address and you increment again and read the low byte for the address and then you increment again to prep you for reading the next instruction. <br/><br/>Data values have meaning in context only. If you're at the point of reading an opcode, it's treated as an opcode. If it's at the point of reading a register, it's treated as a register. You must parse it sequentially, in context. You can't just say every 5 is an opcode. It might be a register value or part of an address even.",
      "PostDate": "2016-02-27T09:26:58+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41474",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ah, thanks for clearing that up as well!\n\n-------------\n\nthank you so much... hopefully now I can get this entire assignment done without any more difficulties, ... but probably something else still will come up... sighs.\n\nI've never done assembly before (unlike learning the high level languages thanks to/from 3 years of learning quest), so unfortunately, I wasn't able to connect/infer/understand these questions on my own and hours of research (I tried... sighs), so I needed these &quot;example walkthrough helps and explanations&quot; you've been giving me in your posts. I think a lot of the class is struggling too, except the ones who probably already know assembly a bit (or they're just geniuses... or better at researching/online searching than I am). For someone totally new to assembly, these constructs of how to match the data with the instructions and my initial difficulty with understanding that (some of) the data is the opcodes and you're basically doing a Script dictionary, using the opcodes as the 'keys' and the goto looping/jumping based on checking if the data is an op code and what opcode. I just think we needed more of a walk-through like you've been doing for me, to get this stuff realized, as I wouldn't have ever been able to infer these constructs on my own.\n\n---------\n\nI really appreciate the help you've given me! I unfortunately don't have any network for getting help (aside from the prof). I haven't been able to get any of the other students to be study-buddies for/with me yet. I'm still trying to work on it, but they're not that interested, sighs.\n\nYou've been such a life saver (hopefully, I won't be needing to bug you too much more with this or future assignments), THANK YOU VERY MUCH!",
      "EditableFormat": "bbcode",
      "HTML": "ah, thanks for clearing that up as well!<br/><br/>-------------<br/><br/>thank you so much... hopefully now I can get this entire assignment done without any more difficulties, ... but probably something else still will come up... sighs.<br/><br/>I've never done assembly before (unlike learning the high level languages thanks to/from 3 years of learning quest), so unfortunately, I wasn't able to connect/infer/understand these questions on my own and hours of research (I tried... sighs), so I needed these &quot;example walkthrough helps and explanations&quot; you've been giving me in your posts. I think a lot of the class is struggling too, except the ones who probably already know assembly a bit (or they're just geniuses... or better at researching/online searching than I am). For someone totally new to assembly, these constructs of how to match the data with the instructions and my initial difficulty with understanding that (some of) the data is the opcodes and you're basically doing a Script dictionary, using the opcodes as the 'keys' and the goto looping/jumping based on checking if the data is an op code and what opcode. I just think we needed more of a walk-through like you've been doing for me, to get this stuff realized, as I wouldn't have ever been able to infer these constructs on my own.<br/><br/>---------<br/><br/>I really appreciate the help you've given me! I unfortunately don't have any network for getting help (aside from the prof). I haven't been able to get any of the other students to be study-buddies for/with me yet. I'm still trying to work on it, but they're not that interested, sighs.<br/><br/>You've been such a life saver (hopefully, I won't be needing to bug you too much more with this or future assignments), THANK YOU VERY MUCH!",
      "PostDate": "2016-02-27T09:29:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41475",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "If you get a chance, look at what the assembly code *you* write generates in machine code, either via a disassembler or a debugger. That will help you to see, from a real processor, how things are structured as well.",
      "EditableFormat": "bbcode",
      "HTML": "If you get a chance, look at what the assembly code *you* write generates in machine code, either via a disassembler or a debugger. That will help you to see, from a real processor, how things are structured as well.",
      "PostDate": "2016-02-27T09:31:51+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41477",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "extremely quick question, for the:\n\n'LOADR' and 'STORR' instructions:\n\nLOADR, 55h, reg1, address, load reg1 with value at (address+reg1)\nSTORR, 66h, reg1, address, write value in R0 to (address+reg1)\n\nfor the '+reg1' in '(address+reg1)' do I use the offset of the specified register (aka: 0-5), or do I use the value held in/at that specified register (whatever) ??? As in either case, I could be jumping forward to another segment of 1 (value data) or 2 bytes (address data), though so far in the 'machine.bin' the register offset has been 0 or 1 (meaning we're just using storing/loading the value from/into the msb/lsb of the address), I think.\n\nthat was probably confusing...\n\nfor pretend example, if I had:\n\nRA = register array: R0, R1, R2, R3, R4, R5\nRA[0] = 100h\nmem_array[index_offset_var] = 00h ; 00h -&gt; RA[00h-&gt;0]\n\nwould I do conceptually:\n\nmov mem_array[index_offset_var + 0], RA[0]\n\nor this conceptually:\n\nmov mem_array[index_offset_var + 100], RA[0]\n\n???",
      "EditableFormat": "bbcode",
      "HTML": "extremely quick question, for the:<br/><br/>'LOADR' and 'STORR' instructions:<br/><br/>LOADR, 55h, reg1, address, load reg1 with value at (address+reg1)<br/>STORR, 66h, reg1, address, write value in R0 to (address+reg1)<br/><br/>for the '+reg1' in '(address+reg1)' do I use the offset of the specified register (aka: 0-5), or do I use the value held in/at that specified register (whatever) ??? As in either case, I could be jumping forward to another segment of 1 (value data) or 2 bytes (address data), though so far in the 'machine.bin' the register offset has been 0 or 1 (meaning we're just using storing/loading the value from/into the msb/lsb of the address), I think.<br/><br/>that was probably confusing...<br/><br/>for pretend example, if I had:<br/><br/>RA = register array: R0, R1, R2, R3, R4, R5<br/>RA[0] = 100h<br/>mem_array[index_offset_var] = 00h ; 00h -&gt; RA[00h-&gt;0]<br/><br/>would I do conceptually:<br/><br/>mov mem_array[index_offset_var + 0], RA[0]<br/><br/>or this conceptually:<br/><br/>mov mem_array[index_offset_var + 100], RA[0]<br/><br/>???",
      "PostDate": "2016-02-28T04:08:23+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41478",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The general answer is that you use the value. The offset is not really very useful.\n\n--- Longer: examples ---\n\nLet's try this example (which doesn't use R0 for everything, since it makes a difference):\n\n55 01 23 45\n\nThis is a LOADR using R1 and address 0x2345. And let's say R1 has value 0x20. Then in this case, you'd have:\n\nR1 &lt;- [address + R1]\n    &lt;- [0x2345 + 0x20]\n\nSo R1 would be loaded with whatever value is at memory location 0x2365.\n\nSimilarly:\n\n66 01 23 45\n\nis a STORR with the same arguments, and R0 is implicitly used as the source. Assuming R0 has value 0x42, then:\n\n[address + R1] &lt;- R0, or\n\n[0x2345+0x20] &lt;- 0x42\n\nSo you'd store the value of R0 (0x42) into the memory address 0x2365.",
      "EditableFormat": "bbcode",
      "HTML": "The general answer is that you use the value. The offset is not really very useful.<br/><br/>--- Longer: examples ---<br/><br/>Let's try this example (which doesn't use R0 for everything, since it makes a difference):<br/><br/>55 01 23 45<br/><br/>This is a LOADR using R1 and address 0x2345. And let's say R1 has value 0x20. Then in this case, you'd have:<br/><br/>R1 &lt;- [address + R1]<br/>    &lt;- [0x2345 + 0x20]<br/><br/>So R1 would be loaded with whatever value is at memory location 0x2365.<br/><br/>Similarly:<br/><br/>66 01 23 45<br/><br/>is a STORR with the same arguments, and R0 is implicitly used as the source. Assuming R0 has value 0x42, then:<br/><br/>[address + R1] &lt;- R0, or<br/><br/>[0x2345+0x20] &lt;- 0x42<br/><br/>So you'd store the value of R0 (0x42) into the memory address 0x2365.",
      "PostDate": "2016-02-28T08:07:28+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41479",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:2lox212e]so far in the 'machine.bin' the register offset has been 0 or 1 (meaning we're just using storing/loading the value from/into the msb/lsb of the address)[/quote:2lox212e]\nAnd I have no idea what this means, which scares me a bit. The register &quot;offset&quot;, if you will, has nothing to with the bits of any address. It just specifies which register to use, which is outside of any address calculations as far as the processor is concerned. (Your implementation might use it to index, but that's not a concern in the higher level, virtual processor model.)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>so far in the 'machine.bin' the register offset has been 0 or 1 (meaning we're just using storing/loading the value from/into the msb/lsb of the address)</p></blockquote><br/>And I have no idea what this means, which scares me a bit. The register &quot;offset&quot;, if you will, has nothing to with the bits of any address. It just specifies which register to use, which is outside of any address calculations as far as the processor is concerned. (Your implementation might use it to index, but that's not a concern in the higher level, virtual processor model.)",
      "PostDate": "2016-02-28T08:10:48+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41480",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "err, I meant the data values (that are for being the instruction sets' regX operands) in the machine.bin file\n\nso, just ignore this bit, lol.\n\n--------\n\nThanks for answering about my index mode question.\n\n(I was tired when I asked that question, I knew that answer... but my mind was tired and pre-occupied with everything else of the lab, lol. So, my mind wasn't focused on how the indirect address mode works. Getting sleep and not being tired, helps a lot)",
      "EditableFormat": "bbcode",
      "HTML": "err, I meant the data values (that are for being the instruction sets' regX operands) in the machine.bin file<br/><br/>so, just ignore this bit, lol.<br/><br/>--------<br/><br/>Thanks for answering about my index mode question.<br/><br/>(I was tired when I asked that question, I knew that answer... but my mind was tired and pre-occupied with everything else of the lab, lol. So, my mind wasn't focused on how the indirect address mode works. Getting sleep and not being tired, helps a lot)",
      "PostDate": "2016-02-28T12:29:45+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41481",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I know the feeling! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I've made some really stupid mistakes when tired that I looked at the next day and thought, &quot;What were you thinking?&quot;",
      "EditableFormat": "bbcode",
      "HTML": "I know the feeling! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I've made some really stupid mistakes when tired that I looked at the next day and thought, &quot;What were you thinking?&quot;",
      "PostDate": "2016-02-28T12:37:27+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41500",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "sighs, I'm just stupid, sighs. I just can't figure this stuff out on my own, sorry for asking for help again, but I need another walkthrough help with this stuff (I'm pretty much asking you do to do the entire assignment, as we're just given this for us to figure out, which I just can't do my first time without having a demonstration, sighs. I'm just stupid, sighs. I can't learn this stuff on my own for my first time, I need to see how it works and is done, for me to start to understand this stuff, sighs). HK, is not the &quot;smartest stupidest/dumbest person&quot;, HK is just the stupidest/dumbest person, sighs.\n\nI'm really sorry for needing you for such a &quot;crutch&quot;, but our prof just gave this assignment, and as can be seen, it's really difficult for me to figure and do all of this stuff, for my very first time, on my own without much help nor practice on how to do this assignment, and me being stupid, I can't figure it out like other (smart, unlike me) people can, sighs. All we do in class is a lecture on the instruction points (just more overwhelming information), wish we could be given practice labs and helped/guided through them (and more slowly too, as I'm new to the different numbering systems, it takes me a bit longer with hexidecimal and binary, compared obviously to decimal, lol)... so we can learn how to actually do assembly labs, sighs.\n\nThere's no tutoring that I'm aware of for assembly at the school/college I go to, none of my colleagues are interested in helping, I can't find any videos online and I really have a hard time learning from online videos anyways, and our prof works, so we really only get him for the single day of the week that is our class (I really hate programming classes which meet only once a week). I never asked a teacher for help tutoring before (assuming we could even be able to schedule for a tutoring session), so it would be really socially awkward for me, ...&quot;hey prof can you tutor me, so I don't flunk your class?&quot; I don't care about grades at this point, but I'd like to learn assembly (It'd be nice if I could get that costly education from the school that I paid for... my money your service of education, a very simple contract/agreement, gotta love the U.S. school system, no wonder we're like 38 or wrose in world)... can't become a programmer if I can even program in assembly, sighs. I got no network of friends or other people I know to get help/tutoring from, except you Jay.\n\nlong sob story short, I can't thank you enough Jay! Is there any way I could pay you for your help? Some kind of paypal or something maybe? I don't know how online transactions work very well, as I believe you're still lving in europe, and I in CA, U.S.\n\n------------\n\nour given CPU information:\n\ncpu contains 6 registers, each 8 bits (R0-R5 valued 0-5)\n16-bit address space\n1k of RAM\non reset the cpu begins execution at location 0\ncisc style instruction set, instruction length varies with instruction\nregister operands are 1 byte\nall memory addresses are 2 bytes long and are stored in big endian format\n\nour given instruction set:\n\nmenumonic, opcode (hexidecimal), operand 1, operand 2, notes\n\nADD, 11h, reg1, reg2, reg1=reg1+reg2\nSUB, 22h, reg1, reg2, reg1=reg1-reg2\nXOR, 44h, reg1, reg2, reg1=reg1 XOR reg2\nLOAD, 05h, reg1, address, load reg1 with value at address\nLOADR, 55h, reg1, adress, load reg1 with value at (address+reg1)\nSTORE, 06h, address, ---, write value in R0 to address\nSTORR, 66h, reg1, address, write value in R0 to (address+reg1)\nOUT, 0CCh, reg1, ---, send value in reg1 to output (screen)\nJNZ, 0AAh, reg1, address, if value in reg1 isn't zero then next instruction is at address\nHALT, 0FFh, ---, ---, CPU halts - terminate program\n\nour given 'machine.bin' file (only first 32 byte address slots):\n\n...............................................................................................................A......B......C......D......E......F\n..........................0......1......2......3......4......5......6......7..........8......9.....10.....11....12....13....14....15\n0000 0000 ~~~ 05 ~ 04 ~ 01 ~ A3 ~ 44 ~ 02 ~ 02 ~ 05 ~~~ 00 ~ 01 ~ A0 ~ 05 ~ 04 ~ 01 ~ A3 ~ 11 ~~~ .... D... .... ....\n0000 0010 ~~~ 00 ~ 04 ~ 06 ~ 01 ~ A0 ~ 05 ~ 03 ~ 01 ~~~ A1 ~ 44 ~ 01 ~ 01 ~ 11 ~ 01 ~ 00 ~ 55 ~~~ .... .... .D.. ...U\n0000 0020 ~~~ 01 ~ 00 ~ A0 ~ 11 ~ 03 ~ 01 ~ 44 ~ 05 ~~~ 05 ~ 11 ~ 05 ~ 00 ~ 44 ~ 00 ~ 00 ~ 11 ~~~ .... ..D. .... D...\n\n------------------------------------\n\nendian-ness:\n\nthe 'machine.bin' is in big-endian, I think...\n\nthe 'machine.bin' is stored in a 'virtual mem' array variable (named: program_buffer) on the intel masm32's DS (data segment) ;does it keep the same endian-ness as the 'machine.bin' or does it convert it's endian-ness?\n\nthe 'virtual registers' are stored in an array variable (named: RA) on the intel masm32's DS (data segment)\n\nintel masm32 uses little-endian\n\nall memory addresses are 2 bytes long and are stored in big endian format\n\nregister operands are 1 byte\n\n16-bit address space\n\ncould you explain what I need to do with the endian-ness?\n\n(I have some guesses, but it'd be a waste of time and space for me to try to explain/write out my guesses and thoughts here)\n\n(I'm aware/believe that I can use 'bswap' for dwords:32bits to convert between endian-ness)\n\n(I'm aware/believe that I can use 'xchg' for the high:8bits and low:8bits of words:16bits:example ax: xchg ah,al)\n\n(let me know if I'm incorrect about 'xchg' and/or 'bswap', or if you know of any other instructions that would work, or if I have to manually 'function' it in)\n\n-----------------------------------------------\n\n(I'm not sure about the 8085 you worked with, but the general purpose registers in 80386+ aren't as role-restricted as they originally were in the first cpus)\n\nso, our first instruction:\n\n05 04 01 A3\nLOAD R4, value at address*\n\n*does this mean just '01 h' (1 d) or '01A3 h' (419 d/t) or '0xA301 h' (41729 d/t) ???\n\n*also, I believe that a byte (8 bits) can hold '0-256' unsigned (2^8) and '-128+128' signed (2^7), whereas a word (16 bits) can hold '0-65536' unsigned (2^16) and '-32768+32768' signed (2^15).\n\nthis is the initial algorithm I came up with (only the parts for the very first operation):\n\nPre_Start:\n\nmov ebx, 01h ; starting at 'index 1' was wrong (I noticed the machine.bin seemed to start at index 1), so I changed to correct index of 0: xor ebx, ebx\n\nStart:\n\ncmp program_buffer, LOAD ; LOAD EQU 05h\nje Load\n\nLoad:\nadd ebx, 01h ;this moves from '05' to '04'\nmov eax, program_buffer[ebx] ;moves the value (0-5) into eax, which will be used as RA's index: RA[eax]\nadd ebx, 01h ;this moves from '04' to '01'\n\nmov edx, word ptr program_buffer[ebx]\n;Is this correct to be using a word value (01A3 or A301), as (I think I'm) suppose to put this into a byte... ???\n;if I'm only working with a byte (01 h or 0xA3 h), than it'd be easy to use: mov (dl or dh), xxx\n;if I'm working with a word (01A3 h or 0xA301 h),  than I can either use: (movzx edx or mov dx), xxx\n\nmov RA[eax], edx ; this is where my main troubles are ...\n\nadd ebx, 02h ; this is for jumping past the word address (01 h, 0xA3 h) to the next opcode: '44 h' (an XOR operation)\n\n; I'm having enough trouble already, I haven't even started to learning of being aware of the flags' settings/clearings yet..., so I'm cheating below lol\nxor eax, eax\ncmp eax, 00h\nje Start\n\n-----------------------\n\nP.S.\n\nI can't even get the VS' linking to work with the 'win32api.asm' (prototype/header) file we're to use for the 'invoke' commands (it does all the pushes/pops for us), so after wasting huge hours to no avail of trying to do this, I luckily had the thought to just copy and paste its contents directly into my program, as It seemed just like a header/prototype file as with C++, and thankfully it worked... now I can finally debug... but I've got no experience with assembly and degugging, hence why I'm stuck and am asking if you can walk me through getting the algorithm/logic/syntax right for a instruction (the first instruction), as hopefully upon seeing how one is done, I can do/figure out the rest.",
      "EditableFormat": "bbcode",
      "HTML": "sighs, I'm just stupid, sighs. I just can't figure this stuff out on my own, sorry for asking for help again, but I need another walkthrough help with this stuff (I'm pretty much asking you do to do the entire assignment, as we're just given this for us to figure out, which I just can't do my first time without having a demonstration, sighs. I'm just stupid, sighs. I can't learn this stuff on my own for my first time, I need to see how it works and is done, for me to start to understand this stuff, sighs). HK, is not the &quot;smartest stupidest/dumbest person&quot;, HK is just the stupidest/dumbest person, sighs.<br/><br/>I'm really sorry for needing you for such a &quot;crutch&quot;, but our prof just gave this assignment, and as can be seen, it's really difficult for me to figure and do all of this stuff, for my very first time, on my own without much help nor practice on how to do this assignment, and me being stupid, I can't figure it out like other (smart, unlike me) people can, sighs. All we do in class is a lecture on the instruction points (just more overwhelming information), wish we could be given practice labs and helped/guided through them (and more slowly too, as I'm new to the different numbering systems, it takes me a bit longer with hexidecimal and binary, compared obviously to decimal, lol)... so we can learn how to actually do assembly labs, sighs.<br/><br/>There's no tutoring that I'm aware of for assembly at the school/college I go to, none of my colleagues are interested in helping, I can't find any videos online and I really have a hard time learning from online videos anyways, and our prof works, so we really only get him for the single day of the week that is our class (I really hate programming classes which meet only once a week). I never asked a teacher for help tutoring before (assuming we could even be able to schedule for a tutoring session), so it would be really socially awkward for me, ...&quot;hey prof can you tutor me, so I don't flunk your class?&quot; I don't care about grades at this point, but I'd like to learn assembly (It'd be nice if I could get that costly education from the school that I paid for... my money your service of education, a very simple contract/agreement, gotta love the U.S. school system, no wonder we're like 38 or wrose in world)... can't become a programmer if I can even program in assembly, sighs. I got no network of friends or other people I know to get help/tutoring from, except you Jay.<br/><br/>long sob story short, I can't thank you enough Jay! Is there any way I could pay you for your help? Some kind of paypal or something maybe? I don't know how online transactions work very well, as I believe you're still lving in europe, and I in CA, U.S.<br/><br/>------------<br/><br/>our given CPU information:<br/><br/>cpu contains 6 registers, each 8 bits (R0-R5 valued 0-5)<br/>16-bit address space<br/>1k of RAM<br/>on reset the cpu begins execution at location 0<br/>cisc style instruction set, instruction length varies with instruction<br/>register operands are 1 byte<br/>all memory addresses are 2 bytes long and are stored in big endian format<br/><br/>our given instruction set:<br/><br/>menumonic, opcode (hexidecimal), operand 1, operand 2, notes<br/><br/>ADD, 11h, reg1, reg2, reg1=reg1+reg2<br/>SUB, 22h, reg1, reg2, reg1=reg1-reg2<br/>XOR, 44h, reg1, reg2, reg1=reg1 XOR reg2<br/>LOAD, 05h, reg1, address, load reg1 with value at address<br/>LOADR, 55h, reg1, adress, load reg1 with value at (address+reg1)<br/>STORE, 06h, address, ---, write value in R0 to address<br/>STORR, 66h, reg1, address, write value in R0 to (address+reg1)<br/>OUT, 0CCh, reg1, ---, send value in reg1 to output (screen)<br/>JNZ, 0AAh, reg1, address, if value in reg1 isn't zero then next instruction is at address<br/>HALT, 0FFh, ---, ---, CPU halts - terminate program<br/><br/>our given 'machine.bin' file (only first 32 byte address slots):<br/><br/>...............................................................................................................A......B......C......D......E......F<br/>..........................0......1......2......3......4......5......6......7..........8......9.....10.....11....12....13....14....15<br/>0000 0000 ~~~ 05 ~ 04 ~ 01 ~ A3 ~ 44 ~ 02 ~ 02 ~ 05 ~~~ 00 ~ 01 ~ A0 ~ 05 ~ 04 ~ 01 ~ A3 ~ 11 ~~~ .... D... .... ....<br/>0000 0010 ~~~ 00 ~ 04 ~ 06 ~ 01 ~ A0 ~ 05 ~ 03 ~ 01 ~~~ A1 ~ 44 ~ 01 ~ 01 ~ 11 ~ 01 ~ 00 ~ 55 ~~~ .... .... .D.. ...U<br/>0000 0020 ~~~ 01 ~ 00 ~ A0 ~ 11 ~ 03 ~ 01 ~ 44 ~ 05 ~~~ 05 ~ 11 ~ 05 ~ 00 ~ 44 ~ 00 ~ 00 ~ 11 ~~~ .... ..D. .... D...<br/><br/>------------------------------------<br/><br/>endian-ness:<br/><br/>the 'machine.bin' is in big-endian, I think...<br/><br/>the 'machine.bin' is stored in a 'virtual mem' array variable (named: program_buffer) on the intel masm32's DS (data segment) ;does it keep the same endian-ness as the 'machine.bin' or does it convert it's endian-ness?<br/><br/>the 'virtual registers' are stored in an array variable (named: RA) on the intel masm32's DS (data segment)<br/><br/>intel masm32 uses little-endian<br/><br/>all memory addresses are 2 bytes long and are stored in big endian format<br/><br/>register operands are 1 byte<br/><br/>16-bit address space<br/><br/>could you explain what I need to do with the endian-ness?<br/><br/>(I have some guesses, but it'd be a waste of time and space for me to try to explain/write out my guesses and thoughts here)<br/><br/>(I'm aware/believe that I can use 'bswap' for dwords:32bits to convert between endian-ness)<br/><br/>(I'm aware/believe that I can use 'xchg' for the high:8bits and low:8bits of words:16bits:example ax: xchg ah,al)<br/><br/>(let me know if I'm incorrect about 'xchg' and/or 'bswap', or if you know of any other instructions that would work, or if I have to manually 'function' it in)<br/><br/>-----------------------------------------------<br/><br/>(I'm not sure about the 8085 you worked with, but the general purpose registers in 80386+ aren't as role-restricted as they originally were in the first cpus)<br/><br/>so, our first instruction:<br/><br/>05 04 01 A3<br/>LOAD R4, value at address*<br/><br/>*does this mean just '01 h' (1 d) or '01A3 h' (419 d/t) or '0xA301 h' (41729 d/t) ???<br/><br/>*also, I believe that a byte (8 bits) can hold '0-256' unsigned (2^8) and '-128+128' signed (2^7), whereas a word (16 bits) can hold '0-65536' unsigned (2^16) and '-32768+32768' signed (2^15).<br/><br/>this is the initial algorithm I came up with (only the parts for the very first operation):<br/><br/>Pre_Start:<br/><br/>mov ebx, 01h ; starting at 'index 1' was wrong (I noticed the machine.bin seemed to start at index 1), so I changed to correct index of 0: xor ebx, ebx<br/><br/>Start:<br/><br/>cmp program_buffer, LOAD ; LOAD EQU 05h<br/>je Load<br/><br/>Load:<br/>add ebx, 01h ;this moves from '05' to '04'<br/>mov eax, program_buffer[ebx] ;moves the value (0-5) into eax, which will be used as RA's index: RA[eax]<br/>add ebx, 01h ;this moves from '04' to '01'<br/><br/>mov edx, word ptr program_buffer[ebx]<br/>;Is this correct to be using a word value (01A3 or A301), as (I think I'm) suppose to put this into a byte... ???<br/>;if I'm only working with a byte (01 h or 0xA3 h), than it'd be easy to use: mov (dl or dh), xxx<br/>;if I'm working with a word (01A3 h or 0xA301 h),  than I can either use: (movzx edx or mov dx), xxx<br/><br/>mov RA[eax], edx ; this is where my main troubles are ...<br/><br/>add ebx, 02h ; this is for jumping past the word address (01 h, 0xA3 h) to the next opcode: '44 h' (an XOR operation)<br/><br/>; I'm having enough trouble already, I haven't even started to learning of being aware of the flags' settings/clearings yet..., so I'm cheating below lol<br/>xor eax, eax<br/>cmp eax, 00h<br/>je Start<br/><br/>-----------------------<br/><br/>P.S.<br/><br/>I can't even get the VS' linking to work with the 'win32api.asm' (prototype/header) file we're to use for the 'invoke' commands (it does all the pushes/pops for us), so after wasting huge hours to no avail of trying to do this, I luckily had the thought to just copy and paste its contents directly into my program, as It seemed just like a header/prototype file as with C++, and thankfully it worked... now I can finally debug... but I've got no experience with assembly and degugging, hence why I'm stuck and am asking if you can walk me through getting the algorithm/logic/syntax right for a instruction (the first instruction), as hopefully upon seeing how one is done, I can do/figure out the rest.",
      "PostDate": "2016-03-01T00:57:20+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41505",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "First of all, you're not stupid! You actually have a good start here. If anything, I think it's not being explained properly. (And no, forget compensation. I'm happy to see you get to end of this. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> )\n\nso, our first instruction:\n\n[quote:1miahtk6]05 04 01 A3\nLOAD R4, value at address*\n\n*does this mean just '01 h' (1 d) or '01A3 h' (419 d/t) or '0xA301 h' (41729 d/t) ???[/quote:1miahtk6]\nAs addresses are 16 bits, it would not be just 01 (that's only 8 bits). So it would definitely be the next two bytes to make an address. I had assumed initially that it was big-endian (as the address 0xa301 would be beyond your 1K &quot;memory&quot;), and you've just said it is, so that's confirmation.\n\nSo first, yes, the starting index is 0. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nOne thing that might help is to always increment bx after reading a value. That way, you'll always be prepped to read the next value in the stream.\n\nmov al, program_buffer[bx]\ninc bx\ncmp al, LOAD\nje load\n\n\nload:\nmov cl,  program_buffer[bx]     ; grab register value\ninc bx\nxor ch,ch         ; clear high byte, so you have a 16-bit offset to use : (0:cl)\n\nNow, as the x86 is little endian (low byte stored first) and this is big endian (high byte stored first), you can't just read the 16-bit value as is (it will be swapped). You can either:\n1) read it as a word and then swap it. You can't use bswap, as that appears to only work for 32-bit registers. So I think your xchg method would work. Just be sure to read the value into a register with high and low parts. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nmov ax, program_buffer[bx]\nadd bx, 2\nxchg ah, al\n\n2) read each byte separately:\nmov ah, program_buffer[bx]  ; high byte\ninc bx\nmov al, program_buffer[bx]  ; low byte\ninc bx\n\nWhen you go to load, it will be a byte value. So you'd load it into a byte regsister (e.g. dh or dl, not dx)\nmov dl, program_buffer[ax]  ; ax here,as that's the address from the instruction, not the next address in the program\n\nAnd then you should be able to store:\n\nmov RA[cx], dl\n\nThere may be syntax problems with this, and when I programmed the x86, you couldn't do arbitrary things with registers. So if there are problems with those, then you might have to get things into appropriate registers. (e.g. si and di are good for indexing, so you  might have to move cx into one of them, for example. Or maybe not. See how it goes.)\n\nI think you have the right idea. Just go step by step and keep the right sizes for your registers. (And if you don't like all the cmp's for the various instructions, we can discuss a &quot;jump table&quot;, where you put the addresses of all the functions in to a memory array and then just jump into it based on the index - but that's a bit more advanced. Think of it as a script dictionary. EDIT: Actually, ignore this. I keep forgetting that you don't have that many opcodes. With the amount you have, the if/then cmp sort of thing should be fine. Otherwise, you'd have a largely empty table.)\n\nI'm at work now, so I might not be able to respond very quickly. (I'm being a bit bad at the moment, to tell you the truth, doing this, but what the hell...) So if you respond and I take a while, keep that in mind.",
      "EditableFormat": "bbcode",
      "HTML": "First of all, you're not stupid! You actually have a good start here. If anything, I think it's not being explained properly. (And no, forget compensation. I'm happy to see you get to end of this. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> )<br/><br/>so, our first instruction:<br/><br/><blockquote><p>05 04 01 A3<br/>LOAD R4, value at address*<br/><br/>*does this mean just '01 h' (1 d) or '01A3 h' (419 d/t) or '0xA301 h' (41729 d/t) ???</p></blockquote><br/>As addresses are 16 bits, it would not be just 01 (that's only 8 bits). So it would definitely be the next two bytes to make an address. I had assumed initially that it was big-endian (as the address 0xa301 would be beyond your 1K &quot;memory&quot;), and you've just said it is, so that's confirmation.<br/><br/>So first, yes, the starting index is 0. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>One thing that might help is to always increment bx after reading a value. That way, you'll always be prepped to read the next value in the stream.<br/><br/>mov al, program_buffer[bx]<br/>inc bx<br/>cmp al, LOAD<br/>je load<br/><br/><br/>load:<br/>mov cl,  program_buffer[bx]     ; grab register value<br/>inc bx<br/>xor ch,ch         ; clear high byte, so you have a 16-bit offset to use : (0:cl)<br/><br/>Now, as the x86 is little endian (low byte stored first) and this is big endian (high byte stored first), you can't just read the 16-bit value as is (it will be swapped). You can either:<br/>1) read it as a word and then swap it. You can't use bswap, as that appears to only work for 32-bit registers. So I think your xchg method would work. Just be sure to read the value into a register with high and low parts. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>mov ax, program_buffer[bx]<br/>add bx, 2<br/>xchg ah, al<br/><br/>2) read each byte separately:<br/>mov ah, program_buffer[bx]  ; high byte<br/>inc bx<br/>mov al, program_buffer[bx]  ; low byte<br/>inc bx<br/><br/>When you go to load, it will be a byte value. So you'd load it into a byte regsister (e.g. dh or dl, not dx)<br/>mov dl, program_buffer[ax]  ; ax here,as that's the address from the instruction, not the next address in the program<br/><br/>And then you should be able to store:<br/><br/>mov RA[cx], dl<br/><br/>There may be syntax problems with this, and when I programmed the x86, you couldn't do arbitrary things with registers. So if there are problems with those, then you might have to get things into appropriate registers. (e.g. si and di are good for indexing, so you  might have to move cx into one of them, for example. Or maybe not. See how it goes.)<br/><br/>I think you have the right idea. Just go step by step and keep the right sizes for your registers. (And if you don't like all the cmp's for the various instructions, we can discuss a &quot;jump table&quot;, where you put the addresses of all the functions in to a memory array and then just jump into it based on the index - but that's a bit more advanced. Think of it as a script dictionary. EDIT: Actually, ignore this. I keep forgetting that you don't have that many opcodes. With the amount you have, the if/then cmp sort of thing should be fine. Otherwise, you'd have a largely empty table.)<br/><br/>I'm at work now, so I might not be able to respond very quickly. (I'm being a bit bad at the moment, to tell you the truth, doing this, but what the hell...) So if you respond and I take a while, keep that in mind.",
      "PostDate": "2016-03-01T09:22:46+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41506",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ya, I saw the table in my own endeavors in trying to learn more of assembly, but I'll learn it at a later time, as indeed our conditions (instructions in instruction set) are so few, so the multiple cmps suffice for now. I just need to get down these basics/fundamentals of how programming is done in assembly, then I can learn all of the different and/or exotic features/instructions/etc that exist for use later on. I'm already too overwhelmed with stuff, which makes it hard for me. I can't focus on or figure out what's important when there's too much information given to me (just like when I first started with learning quest, I was so confused by all of the terms, data types, element/object types, and etc).\n\n----------------\n\nthanks for pointing out my redundency of the index increaser (I had it in every instruction label-jump, lol, wasn't paying attention to that), which I can just put it once into the start loop.\n\nEdit: actually, this doesn't work easily for my design... meh\n\n------------------\n\nah, so the issue preventing me from putting the address' word value into the byte RA (register array) wasn't the two byte values of the address, but just their endian-ness (causing their value to be beyond a bit's max value range). I was confused how I was to put what I thought was the address' word value (01A3/A301) into my byte register... (or if I was just to place the high/low into the byte register, ignoring the other high/low bit).\n\nis this correct?\n\nI can do this? for example:\n\nmov RA[0], dl/dh\n\nbut.. which do I use? the low or high? don't I need both low and high, as isn't that the value I want to store? I'm still a bit confused with this...\n\nthe dl/dh isn't seen as a word into the RA[0] byte, due to merely using the correct (doing the conversion) endian-ness ???\n\n----------\n\nit's just really awful/depressing/unmotivating/downer/despairing when you've tried so hard (getting huge headaches from all the thinking) and over long hours to try to figure out (in this case, programming) and you just utterly fail. I am stupid, I shouldn't be utterly failing with working so hard. The worse thing in the world: &quot;working like a madman and not getting anything done&quot;; that's the definition of failure/loser, of being totally stupid/pathetic, sighs. Ignore my sobbing/self-pity, as I'm just really hard on myself, I expect/demand high quality of myself, so it's very disappointing when I fail so badly at things, sighs. I just take failure really hard, especially when I try so hard too.\n\n--------\n\nAnyways, you're the greatest, Jay!, thank you soooooooooooo much for your help! A total life saver with this assembly learning! I'm really learning and understanding it so well now, thanks to you!",
      "EditableFormat": "bbcode",
      "HTML": "ya, I saw the table in my own endeavors in trying to learn more of assembly, but I'll learn it at a later time, as indeed our conditions (instructions in instruction set) are so few, so the multiple cmps suffice for now. I just need to get down these basics/fundamentals of how programming is done in assembly, then I can learn all of the different and/or exotic features/instructions/etc that exist for use later on. I'm already too overwhelmed with stuff, which makes it hard for me. I can't focus on or figure out what's important when there's too much information given to me (just like when I first started with learning quest, I was so confused by all of the terms, data types, element/object types, and etc).<br/><br/>----------------<br/><br/>thanks for pointing out my redundency of the index increaser (I had it in every instruction label-jump, lol, wasn't paying attention to that), which I can just put it once into the start loop.<br/><br/>Edit: actually, this doesn't work easily for my design... meh<br/><br/>------------------<br/><br/>ah, so the issue preventing me from putting the address' word value into the byte RA (register array) wasn't the two byte values of the address, but just their endian-ness (causing their value to be beyond a bit's max value range). I was confused how I was to put what I thought was the address' word value (01A3/A301) into my byte register... (or if I was just to place the high/low into the byte register, ignoring the other high/low bit).<br/><br/>is this correct?<br/><br/>I can do this? for example:<br/><br/>mov RA[0], dl/dh<br/><br/>but.. which do I use? the low or high? don't I need both low and high, as isn't that the value I want to store? I'm still a bit confused with this...<br/><br/>the dl/dh isn't seen as a word into the RA[0] byte, due to merely using the correct (doing the conversion) endian-ness ???<br/><br/>----------<br/><br/>it's just really awful/depressing/unmotivating/downer/despairing when you've tried so hard (getting huge headaches from all the thinking) and over long hours to try to figure out (in this case, programming) and you just utterly fail. I am stupid, I shouldn't be utterly failing with working so hard. The worse thing in the world: &quot;working like a madman and not getting anything done&quot;; that's the definition of failure/loser, of being totally stupid/pathetic, sighs. Ignore my sobbing/self-pity, as I'm just really hard on myself, I expect/demand high quality of myself, so it's very disappointing when I fail so badly at things, sighs. I just take failure really hard, especially when I try so hard too.<br/><br/>--------<br/><br/>Anyways, you're the greatest, Jay!, thank you soooooooooooo much for your help! A total life saver with this assembly learning! I'm really learning and understanding it so well now, thanks to you!",
      "PostDate": "2016-03-01T11:25:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41507",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The endian-ness only comes into play for values with multiple bytes (so 16-bit, 32-bit, 64-bit values, etc). It has to do with the order of the bytes within the larger element. So a 16-bit (2 byte) value can either be stored either [low 8 bits, high 8 bits] or [high 8 bits, low 8 bits]. A single byte is just stored, so there is no issue there.\n\nYou'll see endian-ness as an issue with addresses, since they're stored high-byte first in your virtual processor but low-byte first in the native x86 code.  If you read it as a 16-bit value, the two bytes will be swapped. You either need to swap them or read them a byte at a time into the right spot. (That may be a bit redundant with my previous answer, but just in case that wasn't clear.)\n\nEndian-ness should not have an effect when working with the registers, as the register index (the value in the instruction) is only a byte, and the registers themselves are only a byte. You do need to extend the 8-bit register index into a 16-bit value to use it as an index. I don't think you can use an 8-bit register as an index.\n\n[quote:3iszseqd]I can do this? for example:\n\nmov RA[0], dl/dh\n\nbut.. which do I use? the low or high? don't I need both low and high, as isn't that the value I want to store? I'm still a bit confused with this...[/quote:3iszseqd]\ndl and dh are two 8-bit halves of the 16-bit dx. You can treat them as two individual 8-bit registers or together as a single 16-bit register. In this case, you're only working with an 8-bit data value (the single byte you load from memory and want to put in the &quot;register&quot;). So the answer to your question of which of dl/dh to use is &quot;whichever one you loaded the value into to begin with&quot;. Just pick one and use it. Either is fine. You don't need both high and low, as that would imply a 16-bit value; but you only have an 8-bit one. You can use any 8-bit register for your transfer.",
      "EditableFormat": "bbcode",
      "HTML": "The endian-ness only comes into play for values with multiple bytes (so 16-bit, 32-bit, 64-bit values, etc). It has to do with the order of the bytes within the larger element. So a 16-bit (2 byte) value can either be stored either [low 8 bits, high 8 bits] or [high 8 bits, low 8 bits]. A single byte is just stored, so there is no issue there.<br/><br/>You'll see endian-ness as an issue with addresses, since they're stored high-byte first in your virtual processor but low-byte first in the native x86 code.  If you read it as a 16-bit value, the two bytes will be swapped. You either need to swap them or read them a byte at a time into the right spot. (That may be a bit redundant with my previous answer, but just in case that wasn't clear.)<br/><br/>Endian-ness should not have an effect when working with the registers, as the register index (the value in the instruction) is only a byte, and the registers themselves are only a byte. You do need to extend the 8-bit register index into a 16-bit value to use it as an index. I don't think you can use an 8-bit register as an index.<br/><br/><blockquote><p>I can do this? for example:<br/><br/>mov RA[0], dl/dh<br/><br/>but.. which do I use? the low or high? don't I need both low and high, as isn't that the value I want to store? I'm still a bit confused with this...</p></blockquote><br/>dl and dh are two 8-bit halves of the 16-bit dx. You can treat them as two individual 8-bit registers or together as a single 16-bit register. In this case, you're only working with an 8-bit data value (the single byte you load from memory and want to put in the &quot;register&quot;). So the answer to your question of which of dl/dh to use is &quot;whichever one you loaded the value into to begin with&quot;. Just pick one and use it. Either is fine. You don't need both high and low, as that would imply a 16-bit value; but you only have an 8-bit one. You can use any 8-bit register for your transfer.",
      "PostDate": "2016-03-01T12:19:32+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41509",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "this is what I have so far:\n\n[code:371ienea]Pre_start&#58;\n\nxor ebx, ebx ;this is what I use for the incrementing index\n\nmov ecx, LENGTHOF program_buffer\n;I just read that the 'loop' has a limited range, so to be safe, am using manual decrement ecx checking-jump, though hopefully I don't have the same issue ;with the jumping (near vs far), as I've not tried to understand them, lol&#46;\n\nStart&#58;\n\nsub ecx, 01h\n;used for the looping, do I need to use 'sbb' (subtract with barrow/carry?), as I don't understand carry arithmetic or nor bit carrying in general\n\ncmp program_buffer&#91;ebx&#93;, LOAD ;LOAD EQU 05h\nje Load\n\ncmp program_buffer&#91;ebx&#93;, Store ;STORE EQU 06h\nje Store\n\ncmp program_buffer&#91;ebx&#93;, ADD_ENUM ;ADD_ENUM EQU 11h\n;ADD (and others) got color coded&#46;&#46;&#46; so I'm using 'ADD_ENUM' just to be safe, as I don't want to over-write an instruction set operation, lol\nje Add_Enum\n\ncmp program_buffer&#91;ebx&#93;, SUB_ENUM ;SUB_ENUM EQU 22h\nje Sub_Enum\n\ncmp program_buffer&#91;ebx&#93;, XOR_ENUM ;XOR_ENUM EQU 44h\nje Xor_Enum\n\ncmp program_buffer&#91;ebx&#93;, LOAD_R ;LOAD_R EQU 55h\nje Load_R\n\ncmp program_buffer&#91;ebx&#93;, STORE_R ;STORE_R EQU 66h\nje Store_R\n\ncmp program_buffer&#91;ebx&#93;, JNZ_ENUM ;JNZ_ENUM EQU 0AAh\nje Jnz_Enum\n\ncmp program_buffer&#91;ebx&#93;, OUT_ENUM ;OUT_ENUM EQU 0CCh\nje Out_Enum\n\ncmp program_buffer&#91;ebx&#93;, HALT ;HALT EQU 0FFh\nje Halt\n\ncmp ecx, 00h ;or it's&#58; 01h\n;need to figure it out (confused where/when ecx is needed to be checked at&#58; 0 or 1), easy to test it, when I get to it&#46;&#46;&#46;\nje Finish\nadd ebx, 01h ;just in case a value doesn't match up with any of the compares, to advance it to the next value (next address)\njne Start\n\nLoad&#58;\n\nadd ebx, 01h ;moves index from opcode address/value (05) to register address/value (04)\nmovzx eax, program_buffer&#91;ebx&#93; ;the 'movzx' fills in zeroes for the rest (unused) of the bit slots ;storing the register index into eax\nadd ebx, 01h ;moves index from register address/value (04) to the left byte of the address' address/value (01 of 01,A3)\n\nmovzx edx word ptr program_buffer&#91;ebx&#93;\n;the 'type&#58;word ptr' gets (in this case) 01A3 for us and puts it into edx (and movzx zeroes the remaining unused bits), which I think you do differently in your 8085/8086 code\n\nxchg dh, dl ;this should switch the high and low bits (big endian to little endian), so now dx should be in little endian\n\nmov RA&#91;eax&#93;, ??? ;this is where I don't understand, as which am I to use, dl or dh, but don't we need to use both bytes (dx&#58; 01A3/A301 whatever it is), which would be the value (419) ???\n\nadd ebx, 02h ; to skip past the the word address indexes to the next opcode value (44&#58;XOR)\n\n;to cheat/ensure that I jump back to Start, lol&#58;\nxor eax,eax\ncmp eax, 00h\nje start\n\nStore&#58;\n\n(etc etc etc operations/labels, once I get few parts of the load algorithm understood, I should be able to get all of the other operations correct)[/code:371ienea]\n\n-------------------\n\nEdit:\n\nah, so because its '419' it doesn't use the high byte... do I need to zero out that high byte? as I couldn't quite follow some of your code... (edit2: I understand that for the mov/transfer I can use either dl or dh, now, but am unsure if I need to zero out the high byte?)\n\nand ya, I still have trouble separating/understanding/confused by address length/size and/vs their value length/size, as can be seen by my questions",
      "EditableFormat": "bbcode",
      "HTML": "this is what I have so far:<br/><br/><pre><code>Pre_start&#58;<br/><br/>xor ebx, ebx ;this is what I use for the incrementing index<br/><br/>mov ecx, LENGTHOF program_buffer<br/>;I just read that the 'loop' has a limited range, so to be safe, am using manual decrement ecx checking-jump, though hopefully I don't have the same issue ;with the jumping (near vs far), as I've not tried to understand them, lol&#46;<br/><br/>Start&#58;<br/><br/>sub ecx, 01h<br/>;used for the looping, do I need to use 'sbb' (subtract with barrow/carry?), as I don't understand carry arithmetic or nor bit carrying in general<br/><br/>cmp program_buffer&#91;ebx&#93;, LOAD ;LOAD EQU 05h<br/>je Load<br/><br/>cmp program_buffer&#91;ebx&#93;, Store ;STORE EQU 06h<br/>je Store<br/><br/>cmp program_buffer&#91;ebx&#93;, ADD_ENUM ;ADD_ENUM EQU 11h<br/>;ADD (and others) got color coded&#46;&#46;&#46; so I'm using 'ADD_ENUM' just to be safe, as I don't want to over-write an instruction set operation, lol<br/>je Add_Enum<br/><br/>cmp program_buffer&#91;ebx&#93;, SUB_ENUM ;SUB_ENUM EQU 22h<br/>je Sub_Enum<br/><br/>cmp program_buffer&#91;ebx&#93;, XOR_ENUM ;XOR_ENUM EQU 44h<br/>je Xor_Enum<br/><br/>cmp program_buffer&#91;ebx&#93;, LOAD_R ;LOAD_R EQU 55h<br/>je Load_R<br/><br/>cmp program_buffer&#91;ebx&#93;, STORE_R ;STORE_R EQU 66h<br/>je Store_R<br/><br/>cmp program_buffer&#91;ebx&#93;, JNZ_ENUM ;JNZ_ENUM EQU 0AAh<br/>je Jnz_Enum<br/><br/>cmp program_buffer&#91;ebx&#93;, OUT_ENUM ;OUT_ENUM EQU 0CCh<br/>je Out_Enum<br/><br/>cmp program_buffer&#91;ebx&#93;, HALT ;HALT EQU 0FFh<br/>je Halt<br/><br/>cmp ecx, 00h ;or it's&#58; 01h<br/>;need to figure it out (confused where/when ecx is needed to be checked at&#58; 0 or 1), easy to test it, when I get to it&#46;&#46;&#46;<br/>je Finish<br/>add ebx, 01h ;just in case a value doesn't match up with any of the compares, to advance it to the next value (next address)<br/>jne Start<br/><br/>Load&#58;<br/><br/>add ebx, 01h ;moves index from opcode address/value (05) to register address/value (04)<br/>movzx eax, program_buffer&#91;ebx&#93; ;the 'movzx' fills in zeroes for the rest (unused) of the bit slots ;storing the register index into eax<br/>add ebx, 01h ;moves index from register address/value (04) to the left byte of the address' address/value (01 of 01,A3)<br/><br/>movzx edx word ptr program_buffer&#91;ebx&#93;<br/>;the 'type&#58;word ptr' gets (in this case) 01A3 for us and puts it into edx (and movzx zeroes the remaining unused bits), which I think you do differently in your 8085/8086 code<br/><br/>xchg dh, dl ;this should switch the high and low bits (big endian to little endian), so now dx should be in little endian<br/><br/>mov RA&#91;eax&#93;, ??? ;this is where I don't understand, as which am I to use, dl or dh, but don't we need to use both bytes (dx&#58; 01A3/A301 whatever it is), which would be the value (419) ???<br/><br/>add ebx, 02h ; to skip past the the word address indexes to the next opcode value (44&#58;XOR)<br/><br/>;to cheat/ensure that I jump back to Start, lol&#58;<br/>xor eax,eax<br/>cmp eax, 00h<br/>je start<br/><br/>Store&#58;<br/><br/>(etc etc etc operations/labels, once I get few parts of the load algorithm understood, I should be able to get all of the other operations correct)</code></pre><br/><br/>-------------------<br/><br/>Edit:<br/><br/>ah, so because its '419' it doesn't use the high byte... do I need to zero out that high byte? as I couldn't quite follow some of your code... (edit2: I understand that for the mov/transfer I can use either dl or dh, now, but am unsure if I need to zero out the high byte?)<br/><br/>and ya, I still have trouble separating/understanding/confused by address length/size and/vs their value length/size, as can be seen by my questions",
      "PostDate": "2016-03-01T13:01:21+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41511",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:265g13ul]ah, so because its '419' it doesn't use the high byte[/quote:265g13ul]\n\nThe key to your misunderstanding is in your question: is 419 actually an 8-bit value? (Hint: A single byte is in the range 0-255 (0-0xFF)).\n\nMore importantly though, regardless of the value, it's stored in the stream as two bytes in the instruction (as it has to be an address). In this case, it's stored as 01 A3. That's two bytes. Even if it was 00 00, it would still be two bytes. You get the high and low for the address.\n\nWhen you read the value at that 16-bit location, what it *points* to is a byte.\n\nData values are 8 bits.\nAddresses are 16 bits.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>ah, so because its '419' it doesn't use the high byte</p></blockquote><br/><br/>The key to your misunderstanding is in your question: is 419 actually an 8-bit value? (Hint: A single byte is in the range 0-255 (0-0xFF)).<br/><br/>More importantly though, regardless of the value, it's stored in the stream as two bytes in the instruction (as it has to be an address). In this case, it's stored as 01 A3. That's two bytes. Even if it was 00 00, it would still be two bytes. You get the high and low for the address.<br/><br/>When you read the value at that 16-bit location, what it *points* to is a byte.<br/><br/>Data values are 8 bits.<br/>Addresses are 16 bits.",
      "PostDate": "2016-03-01T13:20:30+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41512",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Well, the program &quot;runs...&quot; somewhat... I tried to debug through it (took a long long time, lots of steps, lol)... I ended up with '5' being the value used for the WriteConsoleA (display/output in/for the cmd prompt box), except it outputs a spade (like in playing cards)... also... it seemed to have failed when it got to, as it went past the FF... seemingly stuck forever/infinite loop (not sure why/how my program was able to output and seemingly not crash... or maybe it did use up all of the resources and just didn't give a crashing error message, meh):\n\nwhat I'm guessing is suppose the last sequence of the program:\n\nAA 05 00 07 FF\n\n(machine.bin's indexes of: 0000 0090: 05 01 A2 11 02 04 22 05 02 AA 05 00 07 FF 00 00)\n\nfor reference of why I think the program ends above, aside from the FF (terminate), there's also the below:\n\n(machine.bin's indexes of: 0000 00A0: 63 06 37 A6 16 84 CC 71 E5 5A CD 0B 0C 0D 0E oF)\n\n-----------\n\nI've no idea how to debug/troubleshoot whatever my issues are... it'd take too long for me to try to map it out by hand... and I wouldn't even know if I could even do it accurately... I never done debugging before, so I don't have any idea on how to use it purposefully... I watched the intel registers change, but couldn't figure out how to show each of the values in the virtual register array, and etc stuff that I'm clueless about doing/using.\n\nI guess I could post all of my operations and/or full code, and maybe you could spot some mistakes that way... at this point I don't care too much, I've already come so vastly far from where I started at, &quot;huuugggeee&quot; (if I can use this saying by Presidential Candidate Donald Trump, it's becoming really populous now, lol, like how that stupid bud-weis-er frog advertising from long ago or the stupid 'wazzup' whatever beer advertising long ago) thanks to you Jay!",
      "EditableFormat": "bbcode",
      "HTML": "Well, the program &quot;runs...&quot; somewhat... I tried to debug through it (took a long long time, lots of steps, lol)... I ended up with '5' being the value used for the WriteConsoleA (display/output in/for the cmd prompt box), except it outputs a spade (like in playing cards)... also... it seemed to have failed when it got to, as it went past the FF... seemingly stuck forever/infinite loop (not sure why/how my program was able to output and seemingly not crash... or maybe it did use up all of the resources and just didn't give a crashing error message, meh):<br/><br/>what I'm guessing is suppose the last sequence of the program:<br/><br/>AA 05 00 07 FF<br/><br/>(machine.bin's indexes of: 0000 0090: 05 01 A2 11 02 04 22 05 02 AA 05 00 07 FF 00 00)<br/><br/>for reference of why I think the program ends above, aside from the FF (terminate), there's also the below:<br/><br/>(machine.bin's indexes of: 0000 00A0: 63 06 37 A6 16 84 CC 71 E5 5A CD 0B 0C 0D 0E oF)<br/><br/>-----------<br/><br/>I've no idea how to debug/troubleshoot whatever my issues are... it'd take too long for me to try to map it out by hand... and I wouldn't even know if I could even do it accurately... I never done debugging before, so I don't have any idea on how to use it purposefully... I watched the intel registers change, but couldn't figure out how to show each of the values in the virtual register array, and etc stuff that I'm clueless about doing/using.<br/><br/>I guess I could post all of my operations and/or full code, and maybe you could spot some mistakes that way... at this point I don't care too much, I've already come so vastly far from where I started at, &quot;huuugggeee&quot; (if I can use this saying by Presidential Candidate Donald Trump, it's becoming really populous now, lol, like how that stupid bud-weis-er frog advertising from long ago or the stupid 'wazzup' whatever beer advertising long ago) thanks to you Jay!",
      "PostDate": "2016-03-01T14:50:00+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41513",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "That last sequence is\n\njnz R5, 0007 (jmp back to offset 7 if r5 is not zero)\nhalt\n\nWhat do you do for a halt? I assume you have to break out of your loop somehow (the one I imagine you have).\n\nAlso, feel free to post, either here or to my email, if you wish.",
      "EditableFormat": "bbcode",
      "HTML": "That last sequence is<br/><br/>jnz R5, 0007 (jmp back to offset 7 if r5 is not zero)<br/>halt<br/><br/>What do you do for a halt? I assume you have to break out of your loop somehow (the one I imagine you have).<br/><br/>Also, feel free to post, either here or to my email, if you wish.",
      "PostDate": "2016-03-01T15:31:54+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41516",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "well, I'm sure there's a ton of errors , not just at the end, as probably I got some bad algorithms for my instructions/operations and/or elsewhere code blunders. I still a little confused with the endian-ness for the other operations, especially if the converting is needed to be done or not, and/or how to do it in reverse (little endian to big endian). I tried based off of you helping me with the 'load' operation, though obviously got stuff wrong.\n\nanyways, here's my program... hopefully the format will be preserved...\n\n(sorry, I haven't got around yet to doing the commenting, lol)\n\n(also, I had to paste the header/prototype file into my program, so it takes up a lot of my program, scroll down past it to the rest of my program's code)\n\n(I'm sure I needed to use the arithmetic carry/borrow commands, add:adc/sub:sbb, but I don't understand how to work with carrying/borrowing digits yet)\n\n(also, maybe I needed to use 'lea' too for some address-getting... hmm)\n\n[code:xu79a91i];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n;redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; This program's purpose is to emulate a CPU\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\t\t\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\n\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\t\t\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nMAX_RAM\t\t\t\t\tEQU\t\t1024\nINVALID_HANDLE_VALUE\t\tEQU\t\t  -1\nERROR_ENUM\t\t\t\tEQU\t\t   1\nREAD_FILE_ERROR\t\t\tEQU\t\t   0\nNULL_PTR\t\t\t\t\tEQU\t\t   0\n\nCARRIAGE_RETURN\t\t\tEQU\t\t 0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t 0Ah\n\nADD_ENUM\t\t\t\tEQU\t\t 11h\nSUB_ENUM\t\t\t\t\tEQU\t\t 22h\nXOR_ENUM\t\t\t\tEQU\t\t 44h\nLOAD\t\t\t\t\tEQU\t\t 05h\nLOAD_R\t\t\t\t\tEQU\t\t 55h\nSTORE\t\t\t\t\tEQU\t\t 06h\nSTORE_R\t\t\t\t\tEQU\t\t 66h\nOUT_ENUM\t\t\t\tEQU\t\t0CCh\nJNZ_ENUM\t\t\t\t\tEQU\t\t0AAh\nHALT\t\t\t\t\tEQU\t\t0FFh\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to emulate a CPU&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nerror_file_open\t\t\tbyte\t&quot;ERROR&#58; Unable to open input file&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nfile_name\t\t\t\tbyte\t&quot;c&#58;\\redacted\\machine&#46;bin&quot;, 0\n\nprogram_buffer\t\t\tbyte\tMAX_RAM dup (0)\n\nreturn_code\t\t\t\tdword\t0\n\nbytes_written\t\t\t\tdword\t0\nbytes_read\t\t\t\tdword\t0\nfile_handle\t\t\t\tdword\t0\nfile_size\t\t\t\t\tdword\t0\nhandle_std_out\t\t\t\tdword\t0\nhandle_std_in\t\t\t\tdword\t0\n\nRA\t\t\t\t\t\tbyte\t6 dup (0) ; RA = register array (R0-R5)\n\noutput_value\t\t\t\tdword\t?\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_std_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_std_in, eax\n\n\t;********************************\n\t; Open existing file for reading\n\t;********************************\n\n\tinvoke\tCreateFileA, offset file_name, GENERIC_READ, FILE_SHARE_NONE, \\\n\t\t\tNULL_PTR, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL_PTR\n\t\t\t\t\n\tcmp\t\teax, INVALID_HANDLE_VALUE\n\tje\t\tOpen_Error\n\tmov\t\tfile_handle, eax\n\t\n\t;*******************************************\n\t; Determine the size of the file (in bytes)\n\t;*******************************************\n\t\n\tinvoke\tGetFileSize, file_handle, NULL_PTR\n\tmov\t\tfile_size, eax\n\t\n\t;****************************************\n\t; Read the entire file into emulator RAM\n\t;****************************************\n\n\tinvoke\tReadFile, file_handle, offset program_buffer, file_size, \\\n\t\t\toffset bytes_read, NULL_PTR\n\t\t\t\n\tcmp\t\teax, READ_FILE_ERROR\n\tje\t\tFinish\n\t\n\t;****************\n\t; Close the file\n\t;****************\n\t\n\tinvoke\tCloseHandle, file_handle\n\nPre_Start&#58;\n\n\tinvoke WriteConsoleA, handle_std_out, OFFSET heading, SIZEOF heading, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\t\t\t\n\tinvoke WriteConsoleA, handle_std_out, OFFSET history, SIZEOF history, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\t\t\t\n\tinvoke WriteConsoleA, handle_std_out, OFFSET purpose, SIZEOF purpose, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\n\txor ebx, ebx\n\t\n\tmov ecx, LENGTHOF program_buffer\n\t\nStart&#58;\n\t\n\tsub ecx, 01h\n\n\tcmp program_buffer&#91;ebx&#93;, LOAD\n\tje Load\n\t\n\tcmp program_buffer&#91;ebx&#93;, STORE\n\tje Store\n\t\n\tcmp program_buffer&#91;ebx&#93;, ADD_ENUM\n\tje Add_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, SUB_ENUM\n\tje Sub_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, XOR_ENUM\n\tje Xor_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, LOAD_R\n\tje Load_R\n\t\n\tcmp program_buffer&#91;ebx&#93;, STORE_R\n\tje Store_R\n\t\n\tcmp program_buffer&#91;ebx&#93;, JNZ_ENUM\n\tje Jnz_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, OUT_ENUM\n\tje Out_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, HALT\n\tje Finish\n\n\tcmp ecx, 00h ; or its 01h\n\tje Finish\n\tadd ebx, 01h\n\tjne Start\n\t\nLoad&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tadd ebx, 01h\n\tmovzx edx, word ptr program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\tmov RA&#91;eax&#93;, dl\n\tadd ebx, 02h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nStore&#58;\n\n\tadd ebx, 01h\n\tmovzx ax, RA&#91;0&#93;\n\txchg ah, al\n\tmov word ptr program_buffer&#91;ebx&#93;, ax\n\tadd ebx, 02h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nAdd_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx edi, program_buffer&#91;ebx&#93;\n\tmovzx eax, RA&#91;edi&#93;\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;esi&#93;\n\tadd eax, edx\n\tmov RA&#91;edi&#93;, al\n\tadd ebx, 01h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nSub_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx edi, program_buffer&#91;ebx&#93;\n\tmovzx eax, RA&#91;edi&#93;\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;esi&#93;\n\tsub eax, edx\n\tmov RA&#91;edi&#93;, al\n\tadd ebx, 01h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nXor_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmov edi, eax\n\tadd ebx, 01h\n\tmovzx edx, program_buffer&#91;ebx&#93;\n\txor eax, edx\n\tmov RA&#91;edi&#93;, al\n\tadd ebx, 01h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nLoad_R&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmovzx edi, RA&#91;eax&#93;\n\tadd ebx, 01h\n\tmovzx edx, program_buffer&#91;ebx+edi&#93;\n\txchg dh, dl\n\tmov RA&#91;eax&#93;, dl\n\tadd ebx, 02h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nStore_R&#58;\n\n\tadd ebx, 01h\n\tmovzx edx, RA&#91;0&#93;\n\txchg dh, dl\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmovzx edi, RA&#91;eax&#93;\n\tadd ebx, 01h\n\tmov word ptr program_buffer&#91;ebx+edi&#93;, dx\n\tadd ebx, 02h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nJnz_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tcmp eax, 00h\n\tadd ebx, 01h\n\tjne Start\n\tadd ebx, 02h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\nOut_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;eax&#93;\n\n\tmov output_value, edx\n\n\tinvoke WriteConsoleA, handle_std_out, OFFSET output_value, \\\n\t\t\tSIZEOF output_value, OFFSET bytes_written, NULL_PTR\n\n\tadd ebx, 01h\n\t\n\txor eax, eax\n\tcmp eax, 00h\n\tje Start\n\t\nOpen_Error&#58;\n\n\tinvoke\tWriteConsoleA, handle_std_out, offset error_file_open, \\\n\t\t\tsizeof error_file_open, offset bytes_written, NULL_PTR\n\t\t\t\n\tmov\t\treturn_code, ERROR_ENUM\n\nFinish&#58;\n\n\tinvoke\tExitProcess, return_code\n\nMain\tendp\n\n\t\tEND\tMain[/code:xu79a91i]\n\nand here's the machine.bin data file:\n\n(err, that didn't work... let me add it as attachment... nevermind... can't do a bin file)\n\n[code:xu79a91i]\u0005\u0004\u0001£D\u0002\u0002\u0005\u0001 \u0005\u0004\u0001£\u0011\u0004\u0006\u0001 \u0005\u0003\u0001¡D\u0001\u0001\u0011\u0001U\u0001 \u0011\u0003\u0001D\u0005\u0005\u0011\u0005D\u0011\u0003\u0006\u0001¡D\u0011\u0005D\u0001\u0001\u0011\u0001\u0003U\u0001 D\u0005\u0005\u0011\u0005\u0001D\u0001\u0001\u0011\u0001U\u0001 D\u0004\u0004\u0011\u0004D\u0011\u0001f\u0003 D\u0011\u0005f\u0004 \u0011\u0001\u0005U\u0001 D\u0004\u0004\u0011\u0004\u0001D\u0001\u0001\u0011\u0001\u0002U\u0001\u0001¤D\u0001\u0004Ì\u0001\u0005\u0004\u0001£\u0005\u0005\u0001¢\u0011\u0002\u0004&quot;\u0005\u0002ª\u0005\u0007ÿc\u00067¦\u0016„ÌqåZÍ\u000b\f\n\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0004\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !&quot;#$%&amp;'()*+,-&#46;/0123456\u000289&#58;;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXY\t&#91;\\&#93;^_`abdefghijklmnop\u0007rstuvwxyz{|}~\u007f€‚ƒ\u0005…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥\u0003§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊË\u0001\nÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãä\bæçèéêëìíîïðñòóôõö÷øùúûüýþÿ®\u0001‹\u001bü/©à\u0011ÖèB$GX31\u0012ã÷Í©ÝeÐ\u0017Mj~\u001fÍß¹Þö\u0003N\u001cýÏ‰%éGý¶5\u0001Šc&quot;‡&#91;R\u000fE#‹Ã©0\n´ÐþÁòðqhíæ\u0015\u0004Ý\u0019-\nW&quot;‡™L€\u0018×'-s'€/À)ž=1\u001dt„dˆ3\u001dr »üÖ&#46;&amp;¤\u0016\\øTmÅâN£Aî\u00128\u001aù‚nÜÅzy\u0002ÅÙt?¤&gt;f6L¿´½š‚6@P•ô’½w¹\u0017¢¾Ž\u001bz˜,\u001eŽ\u0016n«Ê[/code:xu79a91i]",
      "EditableFormat": "bbcode",
      "HTML": "well, I'm sure there's a ton of errors , not just at the end, as probably I got some bad algorithms for my instructions/operations and/or elsewhere code blunders. I still a little confused with the endian-ness for the other operations, especially if the converting is needed to be done or not, and/or how to do it in reverse (little endian to big endian). I tried based off of you helping me with the 'load' operation, though obviously got stuff wrong.<br/><br/>anyways, here's my program... hopefully the format will be preserved...<br/><br/>(sorry, I haven't got around yet to doing the commenting, lol)<br/><br/>(also, I had to paste the header/prototype file into my program, so it takes up a lot of my program, scroll down past it to the rest of my program's code)<br/><br/>(I'm sure I needed to use the arithmetic carry/borrow commands, add:adc/sub:sbb, but I don't understand how to work with carrying/borrowing digits yet)<br/><br/>(also, maybe I needed to use 'lea' too for some address-getting... hmm)<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>;redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; This program's purpose is to emulate a CPU<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/><br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>MAX_RAM\t\t\t\t\tEQU\t\t1024<br/>INVALID_HANDLE_VALUE\t\tEQU\t\t  -1<br/>ERROR_ENUM\t\t\t\tEQU\t\t   1<br/>READ_FILE_ERROR\t\t\tEQU\t\t   0<br/>NULL_PTR\t\t\t\t\tEQU\t\t   0<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t 0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t 0Ah<br/><br/>ADD_ENUM\t\t\t\tEQU\t\t 11h<br/>SUB_ENUM\t\t\t\t\tEQU\t\t 22h<br/>XOR_ENUM\t\t\t\tEQU\t\t 44h<br/>LOAD\t\t\t\t\tEQU\t\t 05h<br/>LOAD_R\t\t\t\t\tEQU\t\t 55h<br/>STORE\t\t\t\t\tEQU\t\t 06h<br/>STORE_R\t\t\t\t\tEQU\t\t 66h<br/>OUT_ENUM\t\t\t\tEQU\t\t0CCh<br/>JNZ_ENUM\t\t\t\t\tEQU\t\t0AAh<br/>HALT\t\t\t\t\tEQU\t\t0FFh<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to emulate a CPU&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>error_file_open\t\t\tbyte\t&quot;ERROR&#58; Unable to open input file&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>file_name\t\t\t\tbyte\t&quot;c&#58;\\redacted\\machine&#46;bin&quot;, 0<br/><br/>program_buffer\t\t\tbyte\tMAX_RAM dup (0)<br/><br/>return_code\t\t\t\tdword\t0<br/><br/>bytes_written\t\t\t\tdword\t0<br/>bytes_read\t\t\t\tdword\t0<br/>file_handle\t\t\t\tdword\t0<br/>file_size\t\t\t\t\tdword\t0<br/>handle_std_out\t\t\t\tdword\t0<br/>handle_std_in\t\t\t\tdword\t0<br/><br/>RA\t\t\t\t\t\tbyte\t6 dup (0) ; RA = register array (R0-R5)<br/><br/>output_value\t\t\t\tdword\t?<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_std_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_std_in, eax<br/><br/>\t;********************************<br/>\t; Open existing file for reading<br/>\t;********************************<br/><br/>\tinvoke\tCreateFileA, offset file_name, GENERIC_READ, FILE_SHARE_NONE, \\<br/>\t\t\tNULL_PTR, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL_PTR<br/>\t\t\t\t<br/>\tcmp\t\teax, INVALID_HANDLE_VALUE<br/>\tje\t\tOpen_Error<br/>\tmov\t\tfile_handle, eax<br/>\t<br/>\t;*******************************************<br/>\t; Determine the size of the file (in bytes)<br/>\t;*******************************************<br/>\t<br/>\tinvoke\tGetFileSize, file_handle, NULL_PTR<br/>\tmov\t\tfile_size, eax<br/>\t<br/>\t;****************************************<br/>\t; Read the entire file into emulator RAM<br/>\t;****************************************<br/><br/>\tinvoke\tReadFile, file_handle, offset program_buffer, file_size, \\<br/>\t\t\toffset bytes_read, NULL_PTR<br/>\t\t\t<br/>\tcmp\t\teax, READ_FILE_ERROR<br/>\tje\t\tFinish<br/>\t<br/>\t;****************<br/>\t; Close the file<br/>\t;****************<br/>\t<br/>\tinvoke\tCloseHandle, file_handle<br/><br/>Pre_Start&#58;<br/><br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET heading, SIZEOF heading, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/>\t\t\t<br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET history, SIZEOF history, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/>\t\t\t<br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET purpose, SIZEOF purpose, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/><br/>\txor ebx, ebx<br/>\t<br/>\tmov ecx, LENGTHOF program_buffer<br/>\t<br/>Start&#58;<br/>\t<br/>\tsub ecx, 01h<br/><br/>\tcmp program_buffer&#91;ebx&#93;, LOAD<br/>\tje Load<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, STORE<br/>\tje Store<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, ADD_ENUM<br/>\tje Add_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, SUB_ENUM<br/>\tje Sub_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, XOR_ENUM<br/>\tje Xor_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, LOAD_R<br/>\tje Load_R<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, STORE_R<br/>\tje Store_R<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, JNZ_ENUM<br/>\tje Jnz_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, OUT_ENUM<br/>\tje Out_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, HALT<br/>\tje Finish<br/><br/>\tcmp ecx, 00h ; or its 01h<br/>\tje Finish<br/>\tadd ebx, 01h<br/>\tjne Start<br/>\t<br/>Load&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tadd ebx, 01h<br/>\tmovzx edx, word ptr program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\tmov RA&#91;eax&#93;, dl<br/>\tadd ebx, 02h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Store&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx ax, RA&#91;0&#93;<br/>\txchg ah, al<br/>\tmov word ptr program_buffer&#91;ebx&#93;, ax<br/>\tadd ebx, 02h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Add_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edi, program_buffer&#91;ebx&#93;<br/>\tmovzx eax, RA&#91;edi&#93;<br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;esi&#93;<br/>\tadd eax, edx<br/>\tmov RA&#91;edi&#93;, al<br/>\tadd ebx, 01h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Sub_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edi, program_buffer&#91;ebx&#93;<br/>\tmovzx eax, RA&#91;edi&#93;<br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;esi&#93;<br/>\tsub eax, edx<br/>\tmov RA&#91;edi&#93;, al<br/>\tadd ebx, 01h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Xor_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmov edi, eax<br/>\tadd ebx, 01h<br/>\tmovzx edx, program_buffer&#91;ebx&#93;<br/>\txor eax, edx<br/>\tmov RA&#91;edi&#93;, al<br/>\tadd ebx, 01h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Load_R&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmovzx edi, RA&#91;eax&#93;<br/>\tadd ebx, 01h<br/>\tmovzx edx, program_buffer&#91;ebx+edi&#93;<br/>\txchg dh, dl<br/>\tmov RA&#91;eax&#93;, dl<br/>\tadd ebx, 02h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Store_R&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edx, RA&#91;0&#93;<br/>\txchg dh, dl<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmovzx edi, RA&#91;eax&#93;<br/>\tadd ebx, 01h<br/>\tmov word ptr program_buffer&#91;ebx+edi&#93;, dx<br/>\tadd ebx, 02h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Jnz_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tcmp eax, 00h<br/>\tadd ebx, 01h<br/>\tjne Start<br/>\tadd ebx, 02h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/><br/>Out_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;eax&#93;<br/><br/>\tmov output_value, edx<br/><br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET output_value, \\<br/>\t\t\tSIZEOF output_value, OFFSET bytes_written, NULL_PTR<br/><br/>\tadd ebx, 01h<br/>\t<br/>\txor eax, eax<br/>\tcmp eax, 00h<br/>\tje Start<br/>\t<br/>Open_Error&#58;<br/><br/>\tinvoke\tWriteConsoleA, handle_std_out, offset error_file_open, \\<br/>\t\t\tsizeof error_file_open, offset bytes_written, NULL_PTR<br/>\t\t\t<br/>\tmov\t\treturn_code, ERROR_ENUM<br/><br/>Finish&#58;<br/><br/>\tinvoke\tExitProcess, return_code<br/><br/>Main\tendp<br/><br/>\t\tEND\tMain</code></pre><br/><br/>and here's the machine.bin data file:<br/><br/>(err, that didn't work... let me add it as attachment... nevermind... can't do a bin file)<br/><br/><pre><code>\u0005\u0004\u0001£D\u0002\u0002\u0005\u0001 \u0005\u0004\u0001£\u0011\u0004\u0006\u0001 \u0005\u0003\u0001¡D\u0001\u0001\u0011\u0001U\u0001 \u0011\u0003\u0001D\u0005\u0005\u0011\u0005D\u0011\u0003\u0006\u0001¡D\u0011\u0005D\u0001\u0001\u0011\u0001\u0003U\u0001 D\u0005\u0005\u0011\u0005\u0001D\u0001\u0001\u0011\u0001U\u0001 D\u0004\u0004\u0011\u0004D\u0011\u0001f\u0003 D\u0011\u0005f\u0004 \u0011\u0001\u0005U\u0001 D\u0004\u0004\u0011\u0004\u0001D\u0001\u0001\u0011\u0001\u0002U\u0001\u0001¤D\u0001\u0004Ì\u0001\u0005\u0004\u0001£\u0005\u0005\u0001¢\u0011\u0002\u0004&quot;\u0005\u0002ª\u0005\u0007ÿc\u00067¦\u0016„ÌqåZÍ\u000b\f<br/>\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0004\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !&quot;#$%&amp;'()*+,-&#46;/0123456\u000289&#58;;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXY\t&#91;\\&#93;^_`abdefghijklmnop\u0007rstuvwxyz{|}~\u007f€‚ƒ\u0005…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥\u0003§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊË\u0001<br/>ÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãä\bæçèéêëìíîïðñòóôõö÷øùúûüýþÿ®\u0001‹\u001bü/©à\u0011ÖèB$GX31\u0012ã÷Í©ÝeÐ\u0017Mj~\u001fÍß¹Þö\u0003N\u001cýÏ‰%éGý¶5\u0001Šc&quot;‡&#91;R\u000fE#‹Ã©0<br/>´ÐþÁòðqhíæ\u0015\u0004Ý\u0019-<br/>W&quot;‡™L€\u0018×'-s'€/À)ž=1\u001dt„dˆ3\u001dr »üÖ&#46;&amp;¤\u0016\\øTmÅâN£Aî\u00128\u001aù‚nÜÅzy\u0002ÅÙt?¤&gt;f6L¿´½š‚6@P•ô’½w¹\u0017¢¾Ž\u001bz˜,\u001eŽ\u0016n«Ê</code></pre>",
      "PostDate": "2016-03-01T17:09:40+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41519",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "As I said - soo close. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Just some minor things here and there, which you should be able to straighten out.\n\nFirst off, it looks like you're using CX to count how many instructions you've executed, with an eye toward exiting when that reaches zero.. That's not right for a couple of reasons. First you set it to the number of bytes in your program but only decrement it if you don't know what an instruction is. So even if you wanted to do that, that's not the way. (If you want to make sure you don't walk off the end of your program buffer, then when you go to read your next opcode, see if ebx &gt;= 1024 and quit if it is.) But that's really more of a tangent, though, because you don't want to count at all! Your program just needs to run, forever, until it hits a HALT. The program may loop 65000 times or 65000*65000 times or who knows how much. Your code just needs to keep executing until it is told to stop. Imagine the running program were to put up a prompt on screen and take input from the user. It might sit and loop for a long time waiting for a keystroke. And it would have to keep running until the user makes it exit. (That's a larger example than what you can probably do with the instructions you have, but I hope that makes sense).\n\nNow to the individual command implementations:\n\n[b:1qzcehqo]Load:[/b:1qzcehqo]\nI understand now why you were asking about the high/low part of DX. The code you have is this (with comments by me):\n\n[code:1qzcehqo]   add ebx, 01h    ; increment past the opcode\n   movzx eax, program_buffer&#91;ebx&#93;    ; read the next byte to get the register\n   add ebx, 01h                  ; increment past the register byte\n   movzx edx, word ptr program_buffer&#91;ebx&#93;     ; load the *address* of the byte to read from memory&#46;\n   xchg dh, dl      ; swap the bytes of the address, so you can use them as a 16-bit number&#46;\n[/code:1qzcehqo]\nHere's where it goes wrong. Right now, in DX you have the *address* of the byte you want to load. You need to actually go and get the byte from memory at that address, just as you have for the other bytes above.\n [code:1qzcehqo] mov dl, program_buffer&#91;edx&#93;    ; &lt;- add this line, which goes out to memory at the address in edx and gets the byte there\n   mov RA&#91;eax&#93;, dl                     ; store the read byte in the register&#46;[/code:1qzcehqo]\n\nThis code is just bizarre to me:\n\n[code:1qzcehqo]   xor eax, eax\n   cmp eax, 00h\n   je Start\n[/code:1qzcehqo]\nFirst of all, doing an xor eax, eax sets the Z/E flag anyway, so you don't even need the compare. More than that, though, unless you actually need eax to be 0 at the start of the loop, you can just replace it with:\n\n[code:1qzcehqo]jmp Start[/code:1qzcehqo]\n\n[b:1qzcehqo]Store[/b:1qzcehqo]\n\nThe code you have is:\n\n[code:1qzcehqo]\n   ; increment past the opcode - rather than do this in every instruction, you could just do it before you start branching&#46;\n   add ebx, 01h \n   ; grab the value in R0\n   movzx ax, RA&#91;0&#93;\n   ; you don't needs to do this&#46; The value you care about is in AL (an 8-bit value)&#46; Swapping just confuses things&#46;\n   xchg ah, al\n  ; here you actually overwrite your own code in the program buffer with 16 bits of data\n   mov word ptr program_buffer&#91;ebx&#93;, ax\n  ; then you skip past the damage&#46; You've actually stored a 16-bit version of R0 over the address you were meant to use&#46;\n   add ebx, 02h\n[/code:1qzcehqo]\nWhat you want to do is:\n\n[code:1qzcehqo]\n   ; increment past the opcode - rather than do this in every instruction, you could just do it before you start branching&#46;\n   add ebx, 01h\n   ; grab the value in R0  &#46; Not sure why you don't just use mov al, RA&#91;0&#93;, but maybe there's a reason&#46;\n   movzx ax, RA&#91;0&#93;\n\n;; Grab the address where you need to store the byte value\n   movzx edx, word ptr program_buffer&#91;ebx&#93;\n;; swap it so you can use it\n   xchg dh, dl\n   add ebx, 02h\n;; store the byte into the desired address\n   mov program_buffer&#91;edx&#93;, al[/code:1qzcehqo]\n\n[b:1qzcehqo]Add, Sub, Xor[/b:1qzcehqo]\nAs far as I can tell, these are ok, apart from the things noted before (the xor stuff at the end, using &quot;inc ebx&quot; instead of &quot;add ebx, 1&quot;, etc).\n\n[b:1qzcehqo]Load_R and Store_R[/b:1qzcehqo]\nBoth of these have the same problems mentioned before for Load and Store, about trying to do things with ebx instead of the address/offset within the instruction. For example, Load_R has:\n\n[code:1qzcehqo]movzx edx, program_buffer&#91;ebx+edi&#93;[/code:1qzcehqo]\n\nand Store_R has\n\n[code:1qzcehqo]mov word ptr program_buffer&#91;ebx+edi&#93;, dx[/code:1qzcehqo]\n\nThey both use ebx, which means you're doing things relative to the current instruction pointer, not the address provided with the instruction. You want to do things relative to the offset which the instruction pointer is pointing to. So you need to load the word (say) into edx that is pointed to by ebx, swap (etc) and then use that instead of ebx.\n\n[b:1qzcehqo]Jnz[/b:1qzcehqo]\nThis the interesting one. Think about what this means conceptually: you are stepping through a program with ebx as your current instruction pointer. The Jnz instruction will, if the specified register is not 0, *change* ebx to be the offset pointed to in the instruction. In other words, this instruction allows you to change where you read your next instruction from.\n\nLet's look at how you could do that:\n\n[code:1qzcehqo]   add ebx, 01h           ; increment to register\n   movzx eax, program_buffer&#91;ebx&#93;   ; load the byte register index\n   add ebx, 01h          ; increment past register to address\n   movzx edx, word ptr program_buffer&#91;ebx&#93;    ; load the address that will be jumped to if register is not 0\n   xchg dh, dl                ; get it in usable form\n   add ebx, 2               ; skip past the addresss\n;; now you're set to do something&#46; You have the register and the address to jump to&#46;\n   cmp byte ptr RA&#91;eax&#93;, 0    ; is the register 0?\n   je Start                   ; go to next instruction\n ;; And here's the magic\n   mov ebx, edx           ; set the instruction pointer to the address that was in the instruction\n   jmp Start                ; go to next instruction\n[/code:1qzcehqo]\n\nAnd the rest seems ok, I think, except you need to get rid of the ecx stuff. If it's an unknown instruction (and it shouldn't be - maybe you just want to jump to an error if it is, as you're off in the weeds somewhere?), then you can just increment the instruction pointer and jmp back to Start.",
      "EditableFormat": "bbcode",
      "HTML": "As I said - soo close. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Just some minor things here and there, which you should be able to straighten out.<br/><br/>First off, it looks like you're using CX to count how many instructions you've executed, with an eye toward exiting when that reaches zero.. That's not right for a couple of reasons. First you set it to the number of bytes in your program but only decrement it if you don't know what an instruction is. So even if you wanted to do that, that's not the way. (If you want to make sure you don't walk off the end of your program buffer, then when you go to read your next opcode, see if ebx &gt;= 1024 and quit if it is.) But that's really more of a tangent, though, because you don't want to count at all! Your program just needs to run, forever, until it hits a HALT. The program may loop 65000 times or 65000*65000 times or who knows how much. Your code just needs to keep executing until it is told to stop. Imagine the running program were to put up a prompt on screen and take input from the user. It might sit and loop for a long time waiting for a keystroke. And it would have to keep running until the user makes it exit. (That's a larger example than what you can probably do with the instructions you have, but I hope that makes sense).<br/><br/>Now to the individual command implementations:<br/><br/><span style=\"font-weight:bold;\">Load:</span><br/>I understand now why you were asking about the high/low part of DX. The code you have is this (with comments by me):<br/><br/><pre><code>   add ebx, 01h    ; increment past the opcode<br/>   movzx eax, program_buffer&#91;ebx&#93;    ; read the next byte to get the register<br/>   add ebx, 01h                  ; increment past the register byte<br/>   movzx edx, word ptr program_buffer&#91;ebx&#93;     ; load the *address* of the byte to read from memory&#46;<br/>   xchg dh, dl      ; swap the bytes of the address, so you can use them as a 16-bit number&#46;<br/></code></pre><br/>Here's where it goes wrong. Right now, in DX you have the *address* of the byte you want to load. You need to actually go and get the byte from memory at that address, just as you have for the other bytes above.<br/> <pre><code> mov dl, program_buffer&#91;edx&#93;    ; &lt;- add this line, which goes out to memory at the address in edx and gets the byte there<br/>   mov RA&#91;eax&#93;, dl                     ; store the read byte in the register&#46;</code></pre><br/><br/>This code is just bizarre to me:<br/><br/><pre><code>   xor eax, eax<br/>   cmp eax, 00h<br/>   je Start<br/></code></pre><br/>First of all, doing an xor eax, eax sets the Z/E flag anyway, so you don't even need the compare. More than that, though, unless you actually need eax to be 0 at the start of the loop, you can just replace it with:<br/><br/><pre><code>jmp Start</code></pre><br/><br/><span style=\"font-weight:bold;\">Store</span><br/><br/>The code you have is:<br/><br/><pre><code><br/>   ; increment past the opcode - rather than do this in every instruction, you could just do it before you start branching&#46;<br/>   add ebx, 01h <br/>   ; grab the value in R0<br/>   movzx ax, RA&#91;0&#93;<br/>   ; you don't needs to do this&#46; The value you care about is in AL (an 8-bit value)&#46; Swapping just confuses things&#46;<br/>   xchg ah, al<br/>  ; here you actually overwrite your own code in the program buffer with 16 bits of data<br/>   mov word ptr program_buffer&#91;ebx&#93;, ax<br/>  ; then you skip past the damage&#46; You've actually stored a 16-bit version of R0 over the address you were meant to use&#46;<br/>   add ebx, 02h<br/></code></pre><br/>What you want to do is:<br/><br/><pre><code><br/>   ; increment past the opcode - rather than do this in every instruction, you could just do it before you start branching&#46;<br/>   add ebx, 01h<br/>   ; grab the value in R0  &#46; Not sure why you don't just use mov al, RA&#91;0&#93;, but maybe there's a reason&#46;<br/>   movzx ax, RA&#91;0&#93;<br/><br/>;; Grab the address where you need to store the byte value<br/>   movzx edx, word ptr program_buffer&#91;ebx&#93;<br/>;; swap it so you can use it<br/>   xchg dh, dl<br/>   add ebx, 02h<br/>;; store the byte into the desired address<br/>   mov program_buffer&#91;edx&#93;, al</code></pre><br/><br/><span style=\"font-weight:bold;\">Add, Sub, Xor</span><br/>As far as I can tell, these are ok, apart from the things noted before (the xor stuff at the end, using &quot;inc ebx&quot; instead of &quot;add ebx, 1&quot;, etc).<br/><br/><span style=\"font-weight:bold;\">Load_R and Store_R</span><br/>Both of these have the same problems mentioned before for Load and Store, about trying to do things with ebx instead of the address/offset within the instruction. For example, Load_R has:<br/><br/><pre><code>movzx edx, program_buffer&#91;ebx+edi&#93;</code></pre><br/><br/>and Store_R has<br/><br/><pre><code>mov word ptr program_buffer&#91;ebx+edi&#93;, dx</code></pre><br/><br/>They both use ebx, which means you're doing things relative to the current instruction pointer, not the address provided with the instruction. You want to do things relative to the offset which the instruction pointer is pointing to. So you need to load the word (say) into edx that is pointed to by ebx, swap (etc) and then use that instead of ebx.<br/><br/><span style=\"font-weight:bold;\">Jnz</span><br/>This the interesting one. Think about what this means conceptually: you are stepping through a program with ebx as your current instruction pointer. The Jnz instruction will, if the specified register is not 0, *change* ebx to be the offset pointed to in the instruction. In other words, this instruction allows you to change where you read your next instruction from.<br/><br/>Let's look at how you could do that:<br/><br/><pre><code>   add ebx, 01h           ; increment to register<br/>   movzx eax, program_buffer&#91;ebx&#93;   ; load the byte register index<br/>   add ebx, 01h          ; increment past register to address<br/>   movzx edx, word ptr program_buffer&#91;ebx&#93;    ; load the address that will be jumped to if register is not 0<br/>   xchg dh, dl                ; get it in usable form<br/>   add ebx, 2               ; skip past the addresss<br/>;; now you're set to do something&#46; You have the register and the address to jump to&#46;<br/>   cmp byte ptr RA&#91;eax&#93;, 0    ; is the register 0?<br/>   je Start                   ; go to next instruction<br/> ;; And here's the magic<br/>   mov ebx, edx           ; set the instruction pointer to the address that was in the instruction<br/>   jmp Start                ; go to next instruction<br/></code></pre><br/><br/>And the rest seems ok, I think, except you need to get rid of the ecx stuff. If it's an unknown instruction (and it shouldn't be - maybe you just want to jump to an error if it is, as you're off in the weeds somewhere?), then you can just increment the instruction pointer and jmp back to Start.",
      "PostDate": "2016-03-01T19:26:58+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41526",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "hmm... now my program seems to run forever, displaying:\n\n(spade) (spade) (spade) ... etc etc etc\n\nI think I followed it along successfully in the debugger... I think it gets to the 'jnz' and then resets the index back to zero, and that's as far as I've tracked it (not going to step through it again, over and over, forever, as my program seems to go on forever, laughs)\n\n-------\n\n&quot;why didn't you use the, for example of eax, ax/ah/al sub-reg-segments, when you could have&quot;\n\npossibly, since its a 32 bit, it's most efficient to use the 32 bit registers over their subdivisions (for example for eax reg: ax, ah, al), but I'm probably totally mistaken on this, as I probably didn't understand the professor when I think he lectured on whatever it was that put this possible notion into my head, lol. I've been wrong on a lot of stuff, as I try to put together a correct understanding of all of these various aspects of assembly, laughs. I think there are some things that we can't do too, like with indirect addresing: [ax/ah/al], in the 80386+ (.386+) masm build(s)\n\nAs I learn assembly, I'll know better when to use larger sizes (eax/ax) vs the smaller sizes (ax/ah/al)\n\nEfficiency is the least of my concerns at the moment... I'm glad if I can get it working correctly... later on I'll know more of all the various operations/instruction sets available, understand better about efficiency, and etc, but for now, I don't care too much about it (as long as the inefficiency of my program isn't so bad that my program runs way too slow of course, lol)\n\n--------\n\nI guess I can post my new program (as maybe I didn't quite understand/follow some of your directions for fixing up correctly the bad operation alogirthms I had), and maybe you can spot mistakes still in my operations. I tried changing the jmps to 'near ptr' jumps, just in case the offset/index distance exceeded that for 'jmp'. I'm using the 'case senstive' option, so not sure if I need to use caps or lower case for the commands (or if they overloaded them, so both upper or lower, work), however, in the deugging, it was jumping around fine, anyways.\n\nthe 'FF' (terminate) in the machine.bit file is offset: 9E h\n\nI'm guessing this correlates to: ebx = 158 d/t ??? I'm not sure what type size ebx is increasing by... I'm adding 01h to it... but not sure if its increasing by a byte (which would correlate, I think, to the 158 d/t = 9E h) or a dword (ebx:32 bits = dword)\n\nI could try to write out (correctly with no mistakes) the machine.bin data, if you even have a means (or want to - as this would mean running my program on an ide, like VS, and trying to troubleshoot it for me --- I'd really hate for you to do this though, so ignore it! The due date is less than 24 hrs away so I don't have time to see if the prof can help debug it for me, and regardless I'm so thankful/greatful that I've been able to come this far, all thanks to you, Jay) of using it.\n\nprobably the best thing is to just check over my operations, seeing if I got them right from what you can generally tell (if there's any glaring bad logic).\n\nI'm still worried that I probably need to use the add/sub with the carry/borrowing (adc/sbb), as I'd think the add/sub arithmetic would involve additional digits, which requires the carrying/borrowing to get the right calculation, right?\n\nI don't really know where to even begin with the debugging in relation to the program algorithm... is there any particular values/addresses that I can follow to tell what is happening correctly and what is not? (If only the prof could have provided a mapping of some or all of the steps/manipulations, so you could use that to figure out where the errors are in your program's algorithms/logic/bit manipulations, etc, sighs)\n\n-----\n\nI think I maybe should put back in the check on exceeding the program_buffer segment... so my program doesn't run forever... (as I doubt that is what the prof intended, along with nicely formatted columns of spade characters being displayed, lol).\n\nhow would I do the 'if/compare' syntax in assembly? I haven't learned how to do the 'if-like conditionals', I only know how to use 'cmp', which was why I had used the 'cmp ecx, 00 h' --- I thought I had it set up correctly, every time the program uses the 'start label/loop section' it decrements the counter, but this logic doesn't work correctly?\n\n------\n\nhere's my new code:\n\n[code:3h1oy8v6];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n;redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; This program's purpose is to emulate a CPU\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\t\t\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\t\t\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nMAX_RAM\t\t\t\t\tEQU\t\t1024\nINVALID_HANDLE_VALUE\tEQU\t\t  -1\nERROR_ENUM\t\t\t\tEQU\t\t   1\nREAD_FILE_ERROR\t\t\tEQU\t\t   0\nNULL_PTR\t\t\t\tEQU\t\t   0\n\nCARRIAGE_RETURN\t\t\tEQU\t\t 0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t 0Ah\n\nADD_ENUM\t\t\t\tEQU\t\t 11h\nSUB_ENUM\t\t\t\tEQU\t\t 22h\nXOR_ENUM\t\t\t\tEQU\t\t 44h\nLOAD\t\t\t\t\tEQU\t\t 05h\nLOAD_R\t\t\t\t\tEQU\t\t 55h\nSTORE\t\t\t\t\tEQU\t\t 06h\nSTORE_R\t\t\t\t\tEQU\t\t 66h\nOUT_ENUM\t\t\t\tEQU\t\t0CCh\nJNZ_ENUM\t\t\t\tEQU\t\t0AAh\nHALT\t\t\t\t\tEQU\t\t0FFh\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to emulate a CPU&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nerror_file_open\t\t\tbyte\t&quot;ERROR&#58; Unable to open input file&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nfile_name\t\t\t\tbyte\t&quot;c&#58;\\redacted\\machine&#46;bin&quot;, 0\n\nprogram_buffer\t\t\tbyte\tMAX_RAM dup (0)\n\nreturn_code\t\t\t\tdword\t0\n\nbytes_written\t\t\tdword\t0\nbytes_read\t\t\t\tdword\t0\nfile_handle\t\t\t\tdword\t0\nfile_size\t\t\t\tdword\t0\nhandle_std_out\t\t\tdword\t0\nhandle_std_in\t\t\tdword\t0\n\nRA\t\t\t\t\t\tbyte\t6 dup (0) ; RA = register array (R0-R5)\n\noutput_value\t\t\tdword\t?\n\ncoding_error\t\t\tbyte\t&quot;You have an error in your code at index&#58; &quot;\n\ncoding_error_index\t\tdword\t?\t\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_std_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_std_in, eax\n\n\t;********************************\n\t; Open existing file for reading\n\t;********************************\n\n\tinvoke\tCreateFileA, offset file_name, GENERIC_READ, FILE_SHARE_NONE, \\\n\t\t\tNULL_PTR, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL_PTR\n\t\t\t\t\n\tcmp\t\teax, INVALID_HANDLE_VALUE\n\tje\t\tOpen_Error\n\tmov\t\tfile_handle, eax\n\t\n\t;*******************************************\n\t; Determine the size of the file (in bytes)\n\t;*******************************************\n\t\n\tinvoke\tGetFileSize, file_handle, NULL_PTR\n\tmov\t\tfile_size, eax\n\t\n\t;****************************************\n\t; Read the entire file into emulator RAM\n\t;****************************************\n\n\tinvoke\tReadFile, file_handle, offset program_buffer, file_size, \\\n\t\t\toffset bytes_read, NULL_PTR\n\t\t\t\n\tcmp\t\teax, READ_FILE_ERROR\n\tje\t\tFinish\n\t\n\t;****************\n\t; Close the file\n\t;****************\n\t\n\tinvoke\tCloseHandle, file_handle\n\nPre_Start&#58;\n\n\tinvoke WriteConsoleA, handle_std_out, OFFSET heading, SIZEOF heading, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\t\t\t\n\tinvoke WriteConsoleA, handle_std_out, OFFSET history, SIZEOF history, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\t\t\t\n\tinvoke WriteConsoleA, handle_std_out, OFFSET purpose, SIZEOF purpose, \\\n\t\t\tOFFSET bytes_written, NULL_PTR\n\n\txor ebx, ebx\n\t\nStart&#58;\n\t\n\tcmp program_buffer&#91;ebx&#93;, LOAD\n\tje Load\n\t\n\tcmp program_buffer&#91;ebx&#93;, STORE\n\tje Store\n\t\n\tcmp program_buffer&#91;ebx&#93;, ADD_ENUM\n\tje Add_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, SUB_ENUM\n\tje Sub_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, XOR_ENUM\n\tje Xor_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, LOAD_R\n\tje Load_R\n\t\n\tcmp program_buffer&#91;ebx&#93;, STORE_R\n\tje Store_R\n\t\n\tcmp program_buffer&#91;ebx&#93;, JNZ_ENUM\n\tje Jnz_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, OUT_ENUM\n\tje Out_Enum\n\t\n\tcmp program_buffer&#91;ebx&#93;, HALT\n\tje Finish\n\t\n\tjmp near ptr Catch_Coding_Error\n\t\nLoad&#58;\n\n\tadd ebx, 01h\n\tmovzx edi, program_buffer&#91;ebx&#93;\n\t\n\tadd ebx, 01h\n\tmovzx edx, word ptr program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\tmov al, program_buffer&#91;edx&#93;\n\t\n\tmov RA&#91;edi&#93;, al\n\t\n\tadd ebx, 02h\n\tjmp near ptr Start\n\nStore&#58;\n\n\tadd ebx, 01h\n\tmovzx edx, word ptr program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\t\n\tmovzx ax, RA&#91;0&#93;\n\t\n\tmov program_buffer&#91;edx&#93;, al\n\t\n\tadd ebx, 02h\n\tjmp near ptr Start\n\nAdd_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx edi, program_buffer&#91;ebx&#93;\n\tmovzx eax, RA&#91;edi&#93;\n\t\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;esi&#93;\n\t\n\tadd eax, edx\n\t\n\tmov RA&#91;edi&#93;, al\n\t\n\tadd ebx, 01h\n\tjmp near ptr Start\n\nSub_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx edi, program_buffer&#91;ebx&#93;\n\tmovzx eax, RA&#91;edi&#93;\n\t\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;esi&#93;\n\t\n\tsub eax, edx\n\t\n\tmov RA&#91;edi&#93;, al\n\t\n\tadd ebx, 01h\n\tjmp near ptr Start\n\nXor_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmov edi, eax\n\t\n\tadd ebx, 01h\n\tmovzx edx, program_buffer&#91;ebx&#93;\n\t\n\txor eax, edx\n\t\n\tmov RA&#91;edi&#93;, al\n\t\n\tadd ebx, 01h\n\tjmp near ptr Start\n\nLoad_R&#58;\n\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edi, RA&#91;esi&#93;\n\t\n\tadd ebx, 01h\n\tmovzx edx, word ptr program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\tmovzx eax, program_buffer&#91;edx+edi&#93;\n\t\n\tmov RA&#91;esi&#93;, al\n\t\n\tadd ebx, 02h\n\tjmp near ptr Start\n\nStore_R&#58;\n\n\tadd ebx, 01h\n\tmovzx esi, program_buffer&#91;ebx&#93;\n\tmovzx edi, RA&#91;esi&#93;\n\t\n\tmovzx eax, RA&#91;0&#93;\n\t\n\tadd ebx, 01h\n\tmovzx edx, word ptr program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\t\n\tmov word ptr program_buffer&#91;edx+edi&#93;, ax\n\t\n\tadd ebx, 02h\n\tjmp near ptr Start\n\nJnz_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmovzx esi, RA&#91;eax&#93;\n\t\n\tadd ebx, 01h\n\tmovzx edx, program_buffer&#91;ebx&#93;\n\txchg dh, dl\n\t\n\tadd ebx, 02h\n\t\n\tcmp esi, dword ptr 00h\n\tje Start\n\tmov ebx, edx\n\tjmp near ptr Start\n\nOut_Enum&#58;\n\n\tadd ebx, 01h\n\tmovzx eax, program_buffer&#91;ebx&#93;\n\tmovzx edx, RA&#91;eax&#93;\n\n\tmov output_value, edx\n\n\tinvoke WriteConsoleA, handle_std_out, OFFSET output_value, \\\n\t\t\tSIZEOF output_value, OFFSET bytes_written, NULL_PTR\n\n\tadd ebx, 01h\n\tjmp near ptr Start\n\nCatch_Coding_Error&#58;\n\n\tinvoke WriteConsoleA, handle_std_out, OFFSET coding_error, \\\n\t\t\tSIZEOF coding_error, OFFSET bytes_written, NULL_PTR\n\t\n\tmov coding_error_index, ebx\n\t\n\tinvoke WriteConsoleA, handle_std_out, OFFSET coding_error_index, \\\n\t\t\tSIZEOF coding_error_index, OFFSET bytes_written, NULL_PTR\n\t\t\t\n\tjmp near ptr Finish\n\t\nOpen_Error&#58;\n\n\tinvoke\tWriteConsoleA, handle_std_out, offset error_file_open, \\\n\t\t\tsizeof error_file_open, offset bytes_written, NULL_PTR\n\t\t\t\n\tmov\t\treturn_code, ERROR_ENUM\n\nFinish&#58;\n\n\tinvoke\tExitProcess, return_code\n\nMain\tendp\n\n\t\tEND\tMain[/code:3h1oy8v6]\n\nI've no idea if my 'catch_coding_error' works or not, as I guess it always was able to do an operation... (unless my catch_coding_error doesn't work)",
      "EditableFormat": "bbcode",
      "HTML": "hmm... now my program seems to run forever, displaying:<br/><br/>(spade) (spade) (spade) ... etc etc etc<br/><br/>I think I followed it along successfully in the debugger... I think it gets to the 'jnz' and then resets the index back to zero, and that's as far as I've tracked it (not going to step through it again, over and over, forever, as my program seems to go on forever, laughs)<br/><br/>-------<br/><br/>&quot;why didn't you use the, for example of eax, ax/ah/al sub-reg-segments, when you could have&quot;<br/><br/>possibly, since its a 32 bit, it's most efficient to use the 32 bit registers over their subdivisions (for example for eax reg: ax, ah, al), but I'm probably totally mistaken on this, as I probably didn't understand the professor when I think he lectured on whatever it was that put this possible notion into my head, lol. I've been wrong on a lot of stuff, as I try to put together a correct understanding of all of these various aspects of assembly, laughs. I think there are some things that we can't do too, like with indirect addresing: [ax/ah/al], in the 80386+ (.386+) masm build(s)<br/><br/>As I learn assembly, I'll know better when to use larger sizes (eax/ax) vs the smaller sizes (ax/ah/al)<br/><br/>Efficiency is the least of my concerns at the moment... I'm glad if I can get it working correctly... later on I'll know more of all the various operations/instruction sets available, understand better about efficiency, and etc, but for now, I don't care too much about it (as long as the inefficiency of my program isn't so bad that my program runs way too slow of course, lol)<br/><br/>--------<br/><br/>I guess I can post my new program (as maybe I didn't quite understand/follow some of your directions for fixing up correctly the bad operation alogirthms I had), and maybe you can spot mistakes still in my operations. I tried changing the jmps to 'near ptr' jumps, just in case the offset/index distance exceeded that for 'jmp'. I'm using the 'case senstive' option, so not sure if I need to use caps or lower case for the commands (or if they overloaded them, so both upper or lower, work), however, in the deugging, it was jumping around fine, anyways.<br/><br/>the 'FF' (terminate) in the machine.bit file is offset: 9E h<br/><br/>I'm guessing this correlates to: ebx = 158 d/t ??? I'm not sure what type size ebx is increasing by... I'm adding 01h to it... but not sure if its increasing by a byte (which would correlate, I think, to the 158 d/t = 9E h) or a dword (ebx:32 bits = dword)<br/><br/>I could try to write out (correctly with no mistakes) the machine.bin data, if you even have a means (or want to - as this would mean running my program on an ide, like VS, and trying to troubleshoot it for me --- I'd really hate for you to do this though, so ignore it! The due date is less than 24 hrs away so I don't have time to see if the prof can help debug it for me, and regardless I'm so thankful/greatful that I've been able to come this far, all thanks to you, Jay) of using it.<br/><br/>probably the best thing is to just check over my operations, seeing if I got them right from what you can generally tell (if there's any glaring bad logic).<br/><br/>I'm still worried that I probably need to use the add/sub with the carry/borrowing (adc/sbb), as I'd think the add/sub arithmetic would involve additional digits, which requires the carrying/borrowing to get the right calculation, right?<br/><br/>I don't really know where to even begin with the debugging in relation to the program algorithm... is there any particular values/addresses that I can follow to tell what is happening correctly and what is not? (If only the prof could have provided a mapping of some or all of the steps/manipulations, so you could use that to figure out where the errors are in your program's algorithms/logic/bit manipulations, etc, sighs)<br/><br/>-----<br/><br/>I think I maybe should put back in the check on exceeding the program_buffer segment... so my program doesn't run forever... (as I doubt that is what the prof intended, along with nicely formatted columns of spade characters being displayed, lol).<br/><br/>how would I do the 'if/compare' syntax in assembly? I haven't learned how to do the 'if-like conditionals', I only know how to use 'cmp', which was why I had used the 'cmp ecx, 00 h' --- I thought I had it set up correctly, every time the program uses the 'start label/loop section' it decrements the counter, but this logic doesn't work correctly?<br/><br/>------<br/><br/>here's my new code:<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>;redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; This program's purpose is to emulate a CPU<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>MAX_RAM\t\t\t\t\tEQU\t\t1024<br/>INVALID_HANDLE_VALUE\tEQU\t\t  -1<br/>ERROR_ENUM\t\t\t\tEQU\t\t   1<br/>READ_FILE_ERROR\t\t\tEQU\t\t   0<br/>NULL_PTR\t\t\t\tEQU\t\t   0<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t 0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t 0Ah<br/><br/>ADD_ENUM\t\t\t\tEQU\t\t 11h<br/>SUB_ENUM\t\t\t\tEQU\t\t 22h<br/>XOR_ENUM\t\t\t\tEQU\t\t 44h<br/>LOAD\t\t\t\t\tEQU\t\t 05h<br/>LOAD_R\t\t\t\t\tEQU\t\t 55h<br/>STORE\t\t\t\t\tEQU\t\t 06h<br/>STORE_R\t\t\t\t\tEQU\t\t 66h<br/>OUT_ENUM\t\t\t\tEQU\t\t0CCh<br/>JNZ_ENUM\t\t\t\tEQU\t\t0AAh<br/>HALT\t\t\t\t\tEQU\t\t0FFh<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to emulate a CPU&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>error_file_open\t\t\tbyte\t&quot;ERROR&#58; Unable to open input file&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>file_name\t\t\t\tbyte\t&quot;c&#58;\\redacted\\machine&#46;bin&quot;, 0<br/><br/>program_buffer\t\t\tbyte\tMAX_RAM dup (0)<br/><br/>return_code\t\t\t\tdword\t0<br/><br/>bytes_written\t\t\tdword\t0<br/>bytes_read\t\t\t\tdword\t0<br/>file_handle\t\t\t\tdword\t0<br/>file_size\t\t\t\tdword\t0<br/>handle_std_out\t\t\tdword\t0<br/>handle_std_in\t\t\tdword\t0<br/><br/>RA\t\t\t\t\t\tbyte\t6 dup (0) ; RA = register array (R0-R5)<br/><br/>output_value\t\t\tdword\t?<br/><br/>coding_error\t\t\tbyte\t&quot;You have an error in your code at index&#58; &quot;<br/><br/>coding_error_index\t\tdword\t?\t<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_std_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_std_in, eax<br/><br/>\t;********************************<br/>\t; Open existing file for reading<br/>\t;********************************<br/><br/>\tinvoke\tCreateFileA, offset file_name, GENERIC_READ, FILE_SHARE_NONE, \\<br/>\t\t\tNULL_PTR, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL_PTR<br/>\t\t\t\t<br/>\tcmp\t\teax, INVALID_HANDLE_VALUE<br/>\tje\t\tOpen_Error<br/>\tmov\t\tfile_handle, eax<br/>\t<br/>\t;*******************************************<br/>\t; Determine the size of the file (in bytes)<br/>\t;*******************************************<br/>\t<br/>\tinvoke\tGetFileSize, file_handle, NULL_PTR<br/>\tmov\t\tfile_size, eax<br/>\t<br/>\t;****************************************<br/>\t; Read the entire file into emulator RAM<br/>\t;****************************************<br/><br/>\tinvoke\tReadFile, file_handle, offset program_buffer, file_size, \\<br/>\t\t\toffset bytes_read, NULL_PTR<br/>\t\t\t<br/>\tcmp\t\teax, READ_FILE_ERROR<br/>\tje\t\tFinish<br/>\t<br/>\t;****************<br/>\t; Close the file<br/>\t;****************<br/>\t<br/>\tinvoke\tCloseHandle, file_handle<br/><br/>Pre_Start&#58;<br/><br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET heading, SIZEOF heading, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/>\t\t\t<br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET history, SIZEOF history, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/>\t\t\t<br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET purpose, SIZEOF purpose, \\<br/>\t\t\tOFFSET bytes_written, NULL_PTR<br/><br/>\txor ebx, ebx<br/>\t<br/>Start&#58;<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, LOAD<br/>\tje Load<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, STORE<br/>\tje Store<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, ADD_ENUM<br/>\tje Add_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, SUB_ENUM<br/>\tje Sub_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, XOR_ENUM<br/>\tje Xor_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, LOAD_R<br/>\tje Load_R<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, STORE_R<br/>\tje Store_R<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, JNZ_ENUM<br/>\tje Jnz_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, OUT_ENUM<br/>\tje Out_Enum<br/>\t<br/>\tcmp program_buffer&#91;ebx&#93;, HALT<br/>\tje Finish<br/>\t<br/>\tjmp near ptr Catch_Coding_Error<br/>\t<br/>Load&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edi, program_buffer&#91;ebx&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx edx, word ptr program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\tmov al, program_buffer&#91;edx&#93;<br/>\t<br/>\tmov RA&#91;edi&#93;, al<br/>\t<br/>\tadd ebx, 02h<br/>\tjmp near ptr Start<br/><br/>Store&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edx, word ptr program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\t<br/>\tmovzx ax, RA&#91;0&#93;<br/>\t<br/>\tmov program_buffer&#91;edx&#93;, al<br/>\t<br/>\tadd ebx, 02h<br/>\tjmp near ptr Start<br/><br/>Add_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edi, program_buffer&#91;ebx&#93;<br/>\tmovzx eax, RA&#91;edi&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;esi&#93;<br/>\t<br/>\tadd eax, edx<br/>\t<br/>\tmov RA&#91;edi&#93;, al<br/>\t<br/>\tadd ebx, 01h<br/>\tjmp near ptr Start<br/><br/>Sub_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx edi, program_buffer&#91;ebx&#93;<br/>\tmovzx eax, RA&#91;edi&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;esi&#93;<br/>\t<br/>\tsub eax, edx<br/>\t<br/>\tmov RA&#91;edi&#93;, al<br/>\t<br/>\tadd ebx, 01h<br/>\tjmp near ptr Start<br/><br/>Xor_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmov edi, eax<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx edx, program_buffer&#91;ebx&#93;<br/>\t<br/>\txor eax, edx<br/>\t<br/>\tmov RA&#91;edi&#93;, al<br/>\t<br/>\tadd ebx, 01h<br/>\tjmp near ptr Start<br/><br/>Load_R&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edi, RA&#91;esi&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx edx, word ptr program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\tmovzx eax, program_buffer&#91;edx+edi&#93;<br/>\t<br/>\tmov RA&#91;esi&#93;, al<br/>\t<br/>\tadd ebx, 02h<br/>\tjmp near ptr Start<br/><br/>Store_R&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx esi, program_buffer&#91;ebx&#93;<br/>\tmovzx edi, RA&#91;esi&#93;<br/>\t<br/>\tmovzx eax, RA&#91;0&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx edx, word ptr program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\t<br/>\tmov word ptr program_buffer&#91;edx+edi&#93;, ax<br/>\t<br/>\tadd ebx, 02h<br/>\tjmp near ptr Start<br/><br/>Jnz_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmovzx esi, RA&#91;eax&#93;<br/>\t<br/>\tadd ebx, 01h<br/>\tmovzx edx, program_buffer&#91;ebx&#93;<br/>\txchg dh, dl<br/>\t<br/>\tadd ebx, 02h<br/>\t<br/>\tcmp esi, dword ptr 00h<br/>\tje Start<br/>\tmov ebx, edx<br/>\tjmp near ptr Start<br/><br/>Out_Enum&#58;<br/><br/>\tadd ebx, 01h<br/>\tmovzx eax, program_buffer&#91;ebx&#93;<br/>\tmovzx edx, RA&#91;eax&#93;<br/><br/>\tmov output_value, edx<br/><br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET output_value, \\<br/>\t\t\tSIZEOF output_value, OFFSET bytes_written, NULL_PTR<br/><br/>\tadd ebx, 01h<br/>\tjmp near ptr Start<br/><br/>Catch_Coding_Error&#58;<br/><br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET coding_error, \\<br/>\t\t\tSIZEOF coding_error, OFFSET bytes_written, NULL_PTR<br/>\t<br/>\tmov coding_error_index, ebx<br/>\t<br/>\tinvoke WriteConsoleA, handle_std_out, OFFSET coding_error_index, \\<br/>\t\t\tSIZEOF coding_error_index, OFFSET bytes_written, NULL_PTR<br/>\t\t\t<br/>\tjmp near ptr Finish<br/>\t<br/>Open_Error&#58;<br/><br/>\tinvoke\tWriteConsoleA, handle_std_out, offset error_file_open, \\<br/>\t\t\tsizeof error_file_open, offset bytes_written, NULL_PTR<br/>\t\t\t<br/>\tmov\t\treturn_code, ERROR_ENUM<br/><br/>Finish&#58;<br/><br/>\tinvoke\tExitProcess, return_code<br/><br/>Main\tendp<br/><br/>\t\tEND\tMain</code></pre><br/><br/>I've no idea if my 'catch_coding_error' works or not, as I guess it always was able to do an operation... (unless my catch_coding_error doesn't work)",
      "PostDate": "2016-03-02T07:00:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41527",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I'm looking through it now, The only thing I see so far is that I was wrong. The XOR handler is not right. Your add and sub ones look to be ok, though, so if you make the XOR one be like those, that will fix that. (You're xor'ing the register indices, not the register contents themselves!) \n\nStill looking...",
      "EditableFormat": "bbcode",
      "HTML": "I'm looking through it now, The only thing I see so far is that I was wrong. The XOR handler is not right. Your add and sub ones look to be ok, though, so if you make the XOR one be like those, that will fix that. (You're xor'ing the register indices, not the register contents themselves!) <br/><br/>Still looking...",
      "PostDate": "2016-03-02T07:49:39+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41528",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Another thought: do your cmp's need to be like\n\n   cmp byte ptr program_buffer[ebx], LOAD\n\n? \nI don't know what the default size for a cmp is. What you could do to help debug it is to do an OUT sort of thing for each instruction. For example, output &quot;L&quot; when you hit a load, etc. Then you could see what's happening better.",
      "EditableFormat": "bbcode",
      "HTML": "Another thought: do your cmp's need to be like<br/><br/>   cmp byte ptr program_buffer[ebx], LOAD<br/><br/>? <br/>I don't know what the default size for a cmp is. What you could do to help debug it is to do an OUT sort of thing for each instruction. For example, output &quot;L&quot; when you hit a load, etc. Then you could see what's happening better.",
      "PostDate": "2016-03-02T07:52:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41529",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "with the xor, do I:\n\nreg1+reg2 = &quot;reg3&quot; and then use &quot;reg3&quot; as the index for getting the value at it (which is then stored into the register) ??\n\nI'm a bit unclear of understanding your post (and unclear of the needed xor logic) on my xor issue...\n\n--------\n\nwhen I do the stepping in the debugger... it seems to be correctly jumping to the instructions:\n\nstart, load, start, xor, start, load, start, add, start, xor, start, store, etc...\n\n(whether it's doing the right manipulation or instruction or using the right values/addresses, is of course another matter entirely, which would be daunting in trying to debug... as far as I can tell)\n\n------\n\nthe debugger's stepping does a pretty good job of what operation it's doing... the problem is with such as when it gets an address or value, is that the right address value, is it doing the correct operation's details/specifics or not...\n\nmaybe the prof will provide a map of what is suppose to be doing (operation order and the values/addresses at each of the steps), or I can take his working solution code, and try to use it to figure out what was going wrong with my code. So, afterwards, I can hopefully be able to learn what was/is going wrong with my program.",
      "EditableFormat": "bbcode",
      "HTML": "with the xor, do I:<br/><br/>reg1+reg2 = &quot;reg3&quot; and then use &quot;reg3&quot; as the index for getting the value at it (which is then stored into the register) ??<br/><br/>I'm a bit unclear of understanding your post (and unclear of the needed xor logic) on my xor issue...<br/><br/>--------<br/><br/>when I do the stepping in the debugger... it seems to be correctly jumping to the instructions:<br/><br/>start, load, start, xor, start, load, start, add, start, xor, start, store, etc...<br/><br/>(whether it's doing the right manipulation or instruction or using the right values/addresses, is of course another matter entirely, which would be daunting in trying to debug... as far as I can tell)<br/><br/>------<br/><br/>the debugger's stepping does a pretty good job of what operation it's doing... the problem is with such as when it gets an address or value, is that the right address value, is it doing the correct operation's details/specifics or not...<br/><br/>maybe the prof will provide a map of what is suppose to be doing (operation order and the values/addresses at each of the steps), or I can take his working solution code, and try to use it to figure out what was going wrong with my code. So, afterwards, I can hopefully be able to learn what was/is going wrong with my program.",
      "PostDate": "2016-03-02T07:56:26+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41530",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "You do the same as in the add and sub, just use the xor instead of add and sub. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> So you could grab the code for sub, copy and paste it to xor and then change the &quot;sub&quot; to &quot;xor&quot;. You want to xor the values (not the indices - so RA[index]) of reg1 and reg2 and store that result in reg1.",
      "EditableFormat": "bbcode",
      "HTML": "You do the same as in the add and sub, just use the xor instead of add and sub. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> So you could grab the code for sub, copy and paste it to xor and then change the &quot;sub&quot; to &quot;xor&quot;. You want to xor the values (not the indices - so RA[index]) of reg1 and reg2 and store that result in reg1.",
      "PostDate": "2016-03-02T08:00:13+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41531",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Another problem: in Store_R, you only want to write a byte value. So make it:\n\n   mov byte ptr program_buffer[edx+edi], al",
      "EditableFormat": "bbcode",
      "HTML": "Another problem: in Store_R, you only want to write a byte value. So make it:<br/><br/>   mov byte ptr program_buffer[edx+edi], al",
      "PostDate": "2016-03-02T08:03:02+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41532",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I added some stuff (responded to some of your questions) to my previous post.\n\n-----\n\nah, I see with the xor, I'm tired... laughs, sorry about not seeing why the xor was wrong.",
      "EditableFormat": "bbcode",
      "HTML": "I added some stuff (responded to some of your questions) to my previous post.<br/><br/>-----<br/><br/>ah, I see with the xor, I'm tired... laughs, sorry about not seeing why the xor was wrong.",
      "PostDate": "2016-03-02T08:05:24+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41533",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:21b9m2x2]the debugger's stepping does a pretty good job of what operation it's doing... the problem is with such as when it gets an address or value, is that the right address value, is it doing the correct operation's details/specifics or not...[/quote:21b9m2x2]\nI had thought about a debugger. I'm glad you have one. I think the main thing is whether you'd be able to do yourself (on paper) what the code is supposed to be doing: step byte by byte through the bin file and &quot;execute&quot; the code. It might be a bit late for that, but it would help you to be sure you understand what's supposed to be happening, by trying it out by hand yourself.\n\nDid the above fixes have any effect?",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>the debugger's stepping does a pretty good job of what operation it's doing... the problem is with such as when it gets an address or value, is that the right address value, is it doing the correct operation's details/specifics or not...</p></blockquote><br/>I had thought about a debugger. I'm glad you have one. I think the main thing is whether you'd be able to do yourself (on paper) what the code is supposed to be doing: step byte by byte through the bin file and &quot;execute&quot; the code. It might be a bit late for that, but it would help you to be sure you understand what's supposed to be happening, by trying it out by hand yourself.<br/><br/>Did the above fixes have any effect?",
      "PostDate": "2016-03-02T08:09:33+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41534",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "haven't tested it yet, give me a min...\n\nya, except I'm not certain I could/would be able to map it out correctly myself... if I can't get the right mapping of it by hand, then I can't use it to check my program, lol. I'm also still a bit shakey with the number systems, as I've not used hexidecimals/binary at all until this assembly class, so don't have much practice with them (too much other homework, not much time to study in more detail for my classes, sighs).\n\n(and even if I could, it'd probably take me a long time to go through it... the machine.bin has an offset of 9E, or 10 rows * 16 columns, for the first FF:terminate, which I'm not particularly excited about doing... that's a lot of manipulation/calculation work for me, if I could even do it correctly, lol)\n\nif I had more time, I'd definately try doing it... not sure if I could do it correctly of course though... (this was something that I had thought about trying to do, but never had the time to get around to it, as I was busy trying to just get to where I am now, thanks again to your help)",
      "EditableFormat": "bbcode",
      "HTML": "haven't tested it yet, give me a min...<br/><br/>ya, except I'm not certain I could/would be able to map it out correctly myself... if I can't get the right mapping of it by hand, then I can't use it to check my program, lol. I'm also still a bit shakey with the number systems, as I've not used hexidecimals/binary at all until this assembly class, so don't have much practice with them (too much other homework, not much time to study in more detail for my classes, sighs).<br/><br/>(and even if I could, it'd probably take me a long time to go through it... the machine.bin has an offset of 9E, or 10 rows * 16 columns, for the first FF:terminate, which I'm not particularly excited about doing... that's a lot of manipulation/calculation work for me, if I could even do it correctly, lol)<br/><br/>if I had more time, I'd definately try doing it... not sure if I could do it correctly of course though... (this was something that I had thought about trying to do, but never had the time to get around to it, as I was busy trying to just get to where I am now, thanks again to your help)",
      "PostDate": "2016-03-02T08:15:58+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41535",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "hmm... I get different characters/symbols now... except it is infinite loop... and crashed/froze my computer when I tried to quit it, lol\n\nsome possible &quot;progress&quot;, I think... if you could call that progress, laughs.\n\nit might be almost &quot;working&quot; now (not that I have any idea of how its suppose to work/look like, lol)... except it has something wrong causing it to skip the FF (terminate) or it is keeping jumping back to index, the problem is in finding what error(s) are causing it to skip the FF or to get it to not jump back to index 0.... hmm...",
      "EditableFormat": "bbcode",
      "HTML": "hmm... I get different characters/symbols now... except it is infinite loop... and crashed/froze my computer when I tried to quit it, lol<br/><br/>some possible &quot;progress&quot;, I think... if you could call that progress, laughs.<br/><br/>it might be almost &quot;working&quot; now (not that I have any idea of how its suppose to work/look like, lol)... except it has something wrong causing it to skip the FF (terminate) or it is keeping jumping back to index, the problem is in finding what error(s) are causing it to skip the FF or to get it to not jump back to index 0.... hmm...",
      "PostDate": "2016-03-02T08:26:11+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41536",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Ok, I see one more problem. When you're doing an &quot;OUT&quot;, it's doing a console write, which takes characters. I'm not sure if in the assignment it says to output as characters or as numbers. (For example, if you have the byte value 0x41, do you output it as text &quot;65&quot; (decimal) or &quot;41&quot; (hex)  or as the ASCII character 'A'?)\n\nBut right now, you're taking a byte value and shoving it into a DWORD output_value and then printing all four bytes of that. It's possible that the console write will hit the null (0) in that buffer and not print those, but it doesn't seem quite right.\n\nIf you're supposed to be printing the byte as an ASCII character, then I'd make output_value a byte and just store the byte there for printing.\n\nIf you're supposed to be outputting it as a number, then you're going to need to convert the hex value from the register into characters to print, in some format. (Hex output is easier, I think, as it's always two characters to output - 0x45 would just be &quot;45&quot; - but to format a byte as decimal only takes up to three digits, so it's just a bit more fiddly.)",
      "EditableFormat": "bbcode",
      "HTML": "Ok, I see one more problem. When you're doing an &quot;OUT&quot;, it's doing a console write, which takes characters. I'm not sure if in the assignment it says to output as characters or as numbers. (For example, if you have the byte value 0x41, do you output it as text &quot;65&quot; (decimal) or &quot;41&quot; (hex)  or as the ASCII character 'A'?)<br/><br/>But right now, you're taking a byte value and shoving it into a DWORD output_value and then printing all four bytes of that. It's possible that the console write will hit the null (0) in that buffer and not print those, but it doesn't seem quite right.<br/><br/>If you're supposed to be printing the byte as an ASCII character, then I'd make output_value a byte and just store the byte there for printing.<br/><br/>If you're supposed to be outputting it as a number, then you're going to need to convert the hex value from the register into characters to print, in some format. (Hex output is easier, I think, as it's always two characters to output - 0x45 would just be &quot;45&quot; - but to format a byte as decimal only takes up to three digits, so it's just a bit more fiddly.)",
      "PostDate": "2016-03-02T08:29:41+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41537",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Also, if you were able to send me the .bin file (e.g. email) I might be able to figure out what it's supposed to be doing... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "Also, if you were able to send me the .bin file (e.g. email) I might be able to figure out what it's supposed to be doing... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-03-02T08:31:29+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41538",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "We don't have any instruction on what is suppose to be outputted... except the given 'out' instruction details:\n\nOUT, CCh, reg1, --, send value in reg1 to out (screen)\n\n&quot;your program should use the windows API WriteConsole to output to the screen&quot;\n\n--------\n\nYou'd think that the program would output some phrase/word (such as &quot;hello world&quot; or &quot;isn't assembly fun ... sarcasm&quot;) in terms of just using simple &quot;common sense&quot;, but that's just a guess, of course. Maybe it outputs some sequence of numbers instead, or it could be anything.\n\n-------\n\nwell, regardless of what it's suppose to output, the problem is that the program never terminates correctly.\n\n----------\n\nI don't want you to try to debug/troubleshoot it, you've done already so much, I don't want you try do the debugging for me. That's too much, and you've already done so much, too much already. You helped me nearly fully understand the program and assembly concepts so well, compared to where I started at. I just need to learn how to debug well on my own.\n\nLet me, maybe after I complete my symester, I can do the debugging myself and see what I was doing wrong, and if I still can't then, then I'll think about whether to get your help on the debugging.\n\nAt the very least, I want to try/make an attempt, at doing the debugging myself, seeing if I can do it by hand, and I'll have the solution code and/or mapping from the prof to help me as well with the debugging.\n\n-------\n\nit's already 1 am here, and I have to submit my program by 5 pm. I don't think I have the time to try to go through it by hand, as I should at least put in all the commenting I've not yet done, as the commenting is important especially with assemby, and the prof obviously tries to emphasize commenting-good documentation. I'm fortunate enough to have gotten this far, thank to you. So, I think this has been more than enough help from you on learning this program.\n\n-----\n\nLet me see if I can learn what I was doing wrong on my own from here.\n\nThank you so very much, Jay!",
      "EditableFormat": "bbcode",
      "HTML": "We don't have any instruction on what is suppose to be outputted... except the given 'out' instruction details:<br/><br/>OUT, CCh, reg1, --, send value in reg1 to out (screen)<br/><br/>&quot;your program should use the windows API WriteConsole to output to the screen&quot;<br/><br/>--------<br/><br/>You'd think that the program would output some phrase/word (such as &quot;hello world&quot; or &quot;isn't assembly fun ... sarcasm&quot;) in terms of just using simple &quot;common sense&quot;, but that's just a guess, of course. Maybe it outputs some sequence of numbers instead, or it could be anything.<br/><br/>-------<br/><br/>well, regardless of what it's suppose to output, the problem is that the program never terminates correctly.<br/><br/>----------<br/><br/>I don't want you to try to debug/troubleshoot it, you've done already so much, I don't want you try do the debugging for me. That's too much, and you've already done so much, too much already. You helped me nearly fully understand the program and assembly concepts so well, compared to where I started at. I just need to learn how to debug well on my own.<br/><br/>Let me, maybe after I complete my symester, I can do the debugging myself and see what I was doing wrong, and if I still can't then, then I'll think about whether to get your help on the debugging.<br/><br/>At the very least, I want to try/make an attempt, at doing the debugging myself, seeing if I can do it by hand, and I'll have the solution code and/or mapping from the prof to help me as well with the debugging.<br/><br/>-------<br/><br/>it's already 1 am here, and I have to submit my program by 5 pm. I don't think I have the time to try to go through it by hand, as I should at least put in all the commenting I've not yet done, as the commenting is important especially with assemby, and the prof obviously tries to emphasize commenting-good documentation. I'm fortunate enough to have gotten this far, thank to you. So, I think this has been more than enough help from you on learning this program.<br/><br/>-----<br/><br/>Let me see if I can learn what I was doing wrong on my own from here.<br/><br/>Thank you so very much, Jay!",
      "PostDate": "2016-03-02T08:44:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41539",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I wasn't so much going to debug (I wasn't planning on using your code, for example) as much as 1) make sure *I* understand what's supposed to be happening, that the way the opcodes is defined in the assignment matches the bin file, and 2) give you a clue about what's supposed to be output.\n\nAs you say, it seems it would output a message, and I was curious what that was. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nBut I can also understand if you don't want to go there.",
      "EditableFormat": "bbcode",
      "HTML": "I wasn't so much going to debug (I wasn't planning on using your code, for example) as much as 1) make sure *I* understand what's supposed to be happening, that the way the opcodes is defined in the assignment matches the bin file, and 2) give you a clue about what's supposed to be output.<br/><br/>As you say, it seems it would output a message, and I was curious what that was. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>But I can also understand if you don't want to go there.",
      "PostDate": "2016-03-02T08:51:27+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41540",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Even if it wouldn't be too much work for you to do that, I already gotten more than enough help from you. I'm quite glad to have gotten to where thanks to you, I've gotten to already (compared to being totally clueless and wrong at the start, lol).\n\nIf you're that curious for your own interests, I can email the bin file sometime after my class tomarrow.\n\nI don't care about getting the assignment done/points, I just want to learn assembly, and you've greatly helped me with that. It's more important that I actually learn to program, than stupid school points/grades. I'm paying the school to get educated, so I can actually get a job, I'm not paying to get meaningless school points/grades. Jobs don't care about meaningless school points/grades, they care if you can program, if you can fix or solve their code, or prevent or find and stop malicious attack in terms of networking and etc. I'm already old, the most important thing is to actually learn the programming. I'm not going to any big prestigious university, I'm just trying to get towards a degree and job as quickly as I can, before it's too late, and I'm stuck doing 24/7 minimum paid jobs, flipping hamburgers and whatever, the rest of my life... ~ Half of the entire U.S. population is unemployed... and maybe half of the employed half have minimum paid jobs, and only part time employment at that (in total poverty), thanks to obama the RETARD. Ya, the U.S. economy/labor force (well the citisen/legal/american/U.S. labor force) is just &quot;rockin man&quot;... (sarcasm). Ya, economic/labor recovery, &quot;my (exploitive) !&quot;",
      "EditableFormat": "bbcode",
      "HTML": "Even if it wouldn't be too much work for you to do that, I already gotten more than enough help from you. I'm quite glad to have gotten to where thanks to you, I've gotten to already (compared to being totally clueless and wrong at the start, lol).<br/><br/>If you're that curious for your own interests, I can email the bin file sometime after my class tomarrow.<br/><br/>I don't care about getting the assignment done/points, I just want to learn assembly, and you've greatly helped me with that. It's more important that I actually learn to program, than stupid school points/grades. I'm paying the school to get educated, so I can actually get a job, I'm not paying to get meaningless school points/grades. Jobs don't care about meaningless school points/grades, they care if you can program, if you can fix or solve their code, or prevent or find and stop malicious attack in terms of networking and etc. I'm already old, the most important thing is to actually learn the programming. I'm not going to any big prestigious university, I'm just trying to get towards a degree and job as quickly as I can, before it's too late, and I'm stuck doing 24/7 minimum paid jobs, flipping hamburgers and whatever, the rest of my life... ~ Half of the entire U.S. population is unemployed... and maybe half of the employed half have minimum paid jobs, and only part time employment at that (in total poverty), thanks to obama the RETARD. Ya, the U.S. economy/labor force (well the citisen/legal/american/U.S. labor force) is just &quot;rockin man&quot;... (sarcasm). Ya, economic/labor recovery, &quot;my (exploitive) !&quot;",
      "PostDate": "2016-03-02T09:08:30+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41541",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I get where you're coming from, and I think you have the right idea - when I was interviewing people for a company I used to work for, having a PhD even didn't matter as much as whether they could actually program.\n\nIf you end up not getting satisfaction and understanding from your instructor when this is all said and done, let me know, and we'll make sure you understand what happened or should have happened - and why - by going through things.",
      "EditableFormat": "bbcode",
      "HTML": "I get where you're coming from, and I think you have the right idea - when I was interviewing people for a company I used to work for, having a PhD even didn't matter as much as whether they could actually program.<br/><br/>If you end up not getting satisfaction and understanding from your instructor when this is all said and done, let me know, and we'll make sure you understand what happened or should have happened - and why - by going through things.",
      "PostDate": "2016-03-02T09:19:14+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41543",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "well... I decided to start on trying to learn this debugging on my own... this is what I've done so far...\n\n(I need to create a program to do this stuff for me, laughs - it took me like at least 3 hrs to do this stuff, wasn't fun!,  <!-- s:x --><img src=\"{SMILIES_PATH}/icon_mad.gif\" alt=\":x\" title=\"Mad\" /><!-- s:x -->)\n(jokingly, I think I got carpal tunnel syndrome from doing this stuff, just joking, thankfully)\n\n-------------\n\nThe &quot;machine.bin&quot; file (hopefully without typos/mistakes):\n\n[code:o1z8gu0a]0000  0000  05 04 01 A3  44 02 02 05  00 01 A0 05  04 01 A3 11  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0010  00 04 06 01  A0 05 03 01  A1 44 01 01  11 01 00 55  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;U\n0000  0020  01 00 A0 11  03 01 44 05  05 11 05 00  44 00 00 11  &#46;&#46;&#46;&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;\n0000  0030  00 03 06 01  1A 44 00 00  11 00 05 44  01 01 11 01  &#46;&#46;&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;\n0000  0040  03 55 01 00  A0 44 05 05  11 05 01 44  01 01 11 01  &#46;U&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;\n0000  0050  00 55 01 00  A0 44 04 04  11 04 00 44  00 00 11 00  &#46;U&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;\n0000  0060  01 66 03 00  A0 44 00 00  11 00 05 66  04 00 A0 11  &#46;f&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;f  &#46;&#46;&#46;&#46;\n0000  0070  01 05 55 01  00 A0 44 04  04 11 04 01  44 01 01 11  &#46;&#46;U&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;\n0000  0080  01 02 55 01  01 A4 44 01  04 CC 01 05  04 01 A3 05  &#46;&#46;U&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0090  05 01 A2 11  02 04 22 05  02 AA 05 00  07 FF 00 00  &#46;&#46;&#46;&#46;  &#46;&#46;&quot;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  00A0  63 06 37 A6  16 84 CC 71  E5 5A CD 0B  0C 0D 0E 0F  c&#46;7&#46;  &#46;&#46;&#46;q  &#46;Z&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  00B0  10 11 12 13  14 15 04 17  18 19 1A 1B  1C 1D 1E 1F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  00C0  20 21 22 23  24 25 26 27  28 29 2A 2B  2C 2D 2E 2F   !&quot;#  $%&amp;'  ()*+  ,-&#46;/\n0000  00D0  30 31 32 33  34 35 36 02  38 39 3A 3B  3C 3D 3E 3F  0123  456&#46;  89&#58;;  &lt;=&gt;?\n0000  00E0  40 41 42 43  44 45 46 47  48 49 4A 4B  4C 4D 4E 4F  @ABC  DEFG  HIJK  LMNO\n0000  00F0  50 51 52 53  54 55 56 57  58 59 09 5B  5C 5D 5E 5F  PQRS  TUVW  XY&#46;&#91;  \\&#93;^_\n0000  0100  60 61 62 63  64 65 66 67  68 69 6A 6B  6C 6D 6E 6F  `ab&#46;  defg  hijk  lmno\n0000  0110  70 07 72 73  74 75 76 77  78 79 7A 7B  7C 7D 7E 7F  p&#46;rs  tuvw  xyz{  |}~&#46;\n0000  0120  80 81 82 83  84 85 86 87  88 89 8A 8B  8C 8D 8E 8F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0130  90 91 92 93  94 95 96 97  98 99 9A 9B  9C 9D 9E 9F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0140  A0 A1 A2 A3  A4 A5 03 A7  A8 A9 AA AB  AC AD AE AF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0150  B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0160  C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  01 0A CE CF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46; \n0000  0170  D0 D1 D2 D3  D4 D5 D6 D7  D8 D9 DA DB  DC DD DE DF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0180  E0 E1 E2 E3  E4 E5 E6 E7  E8 E9 EA EB  EC ED EE EF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  0190  F0 F1 F2 F3  F4 F5 F6 F7  F8 F9 FA FB  FC FD FE FF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;\n0000  01A0  00 00 AE 01  8B 1B FC 2F  A9 E0 11 D6  E8 42 24 47  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;/  &#46;&#46;&#46;&#46;  &#46;B$G\n0000  01B0  58 33 31 12  00 E3 F7 CD  A9 DD 65 D0  17 4D 6A 7E  X31&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;e&#46;  &#46;MJ~\n0000  01C0  1F CD DF B9  DE F6 03 4E  1C FD CF 89  25 E9 47 FD  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;N  &#46;&#46;&#46;&#46;  %&#46;G&#46;\n0000  01D0  B6 35 01 8A  63 22 87 5B  52 0F 45 23  8B C3 A9 30  &#46;5&#46;&#46;  c&quot;&#46;&#91;  R&#46;E#  &#46;&#46;&#46;0\n0000  01E0  0D B4 D0 FE  C1 F2 00 F0  71 68 ED E6  15 04 DD 19  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  qh&#46;&#46;  &#46;&#46;&#46;&#46; \n0000  01F0  2D 0A 9D 57  22 87 99 4C  80 18 D7 27  2D 73 27 80  -&#46;&#46;w  &quot;&#46;&#46;L  &#46;&#46;&#46;'  -s'&#46;\n0000  0200  2F C0 29 9E  8F 3D 31 1D  74 84 64 88  33 1D 72 20  /&#46;)&#46;  &#46;=1&#46;  t&#46;d&#46;  3&#46;r\n0000  0210  BB FC D6 2E  26 A4 16 5C  F8 54 6D C5  E2 4E A3 41  &#46;&#46;&#46;&#46;  &amp;&#46;&#46;\\  &#46;Tm&#46;  &#46;N&#46;A\n0000  0220  EE 12 38 1A  F9 82 6E DC  C5 7A 79 02  C5 D9 74 3F  &#46;&#46;8&#46;  &#46;&#46;n&#46;  &#46;zy&#46;  &#46;&#46;t?\n0000  0230  A4 3E 66 36  4C BF B4 BD  9A 82 36 40  90 50 95 F4  &#46;&gt;f6  L&#46;&#46;&#46;  &#46;&#46;6@  &#46;P&#46;&#46;\n0000  0240  92 BD 77 B9  17 A2 BE 8E  1B 7A 98 2C  1E 8E 16 6E  &#46;&#46;W&#46;  &#46;&#46;&#46;&#46;  z&#46;&#46;,  &#46;&#46;&#46;N\n0000  0250  AB CA                                               &#46;&#46;[/code:o1z8gu0a]\n\nand the first step I'm doing (still working on it), is mapping out the machine.bin operations (I'm now ready to try to fill in the details of the operations for what I'll do next - taking a short-medium break at the moment, lol):\n\n(it's the machine.bin formatted vertically, so I can write in the details of each step/operation... and once that is done, hopefully correctly, I can then use it to compare with my program via debugging)\n\n(again, hopefully without typos/mistakes, lol)\n\n[code:o1z8gu0a]0000  0000  05  &#46;  LOAD\n0000  0001  04  &#46;  REG4\n0000  0002  01  &#46;  01\n0000  0003  A3  &#46;    A3\n\n0000  0004  44  D  XOR\n0000  0005  02  &#46;  REG2\n0000  0006  02  &#46;  REG2\n0000  0007  05  &#46;  LOAD\n\n0000  0008  00  &#46;  REG0\n0000  0009  01  &#46;  01\n0000  000A  A0  &#46;    A0\n0000  000B  05  &#46;  LOAD\n\n0000  000C  04  &#46;  REG4\n0000  000D  01  &#46;  01\n0000  000E  A3  &#46;    A3\n0000  000F  11  &#46;  ADD\n\n--------------------\n\n0000  0010  00  &#46;  REG0\n0000  0011  04  &#46;  REG4\n0000  0012  06  &#46;  STORE\n0000  0013  01  &#46;  01\n\n0000  0014  A0  &#46;    A0\n0000  0015  05  &#46;  LOAD\n0000  0016  03  &#46;  REG3\n0000  0017  01  &#46;  01\n\n0000  0018  A1  &#46;    A1\n0000  0019  44  D  XOR\n0000  001A  01  &#46;  REG1\n0000  001B  01  &#46;  REG1\n\n0000  001C  11  &#46;  ADD\n0000  001D  01  &#46;  REG1\n0000  001E  00  &#46;  REG0\n0000  001F  55  U  LOADR\n\n---------------------\n\n0000  0020  01  &#46;  REG1\n0000  0021  00  &#46;  00\n0000  0022  A0  &#46;    A0\n0000  0023  11  &#46;  ADD\n\n0000  0024  03  &#46;  REG3\n0000  0025  01  &#46;  REG1\n0000  0026  44  D  XOR\n0000  0027  05  &#46;  REG5\n\n0000  0028  05  &#46;  REG5\n0000  0029  11  &#46;  ADD\n0000  002A  05  &#46;  REG5\n0000  002B  00  &#46;  REG0\n\n0000  002C  44  D  XOR\n0000  002D  00  &#46;  REG0\n0000  002E  00  &#46;  REG0\n0000  002F  11  &#46;  ADD\n\n-----------------------\n\n0000  0030  00  &#46;  REG0\n0000  0031  03  &#46;  REG3\n0000  0032  06  &#46;  STORE\n0000  0033  01  &#46;  01\n\n0000  0034  1A  &#46;    1A\n0000  0035  44  D  XOR\n0000  0036  00  &#46;  REG0\n0000  0037  00  &#46;  REG0\n\n0000  0038  11  &#46;  ADD\n0000  0039  00  &#46;  REG0\n0000  003A  05  &#46;  REG5\n0000  003B  44  D  XOR\n\n0000  003C  01  &#46;  REG1\n0000  003D  01  &#46;  REG1\n0000  003E  11  &#46;  ADD\n0000  003F  01  &#46;  REG1\n\n----------------------\n\n0000  0040  03  &#46;  REG3\n0000  0041  55  U  LOADR\n0000  0042  01  &#46;  REG1\n0000  0043  00  &#46;  00\n\n0000  0044  A0  &#46;    A0\n0000  0045  44  D  XOR\n0000  0046  05  &#46;  REG5\n0000  0047  05  &#46;  REG5\n\n0000  0048  11  &#46;  ADD\n0000  0049  05  &#46;  REG5\n0000  004A  01  &#46;  REG1\n0000  004B  44  D  XOR\n\n0000  004C  01  &#46;  REG1\n0000  004D  01  &#46;  REG1\n0000  004E  11  &#46;  ADD\n0000  004F  01  &#46;  REG1\n\n-----------------------\n\n0000  0050  00  &#46;  REG0\n0000  0051  55  U  LOADR\n0000  0052  01  &#46;  REG1\n0000  0053  00  &#46;  00\n\n0000  0054  A0  &#46;    A0\n0000  0055  44  D  XOR\n0000  0056  04  &#46;  REG4\n0000  0057  04  &#46;  REG4\n\n0000  0058  11  &#46;  ADD\n0000  0059  04  &#46;  REG4\n0000  005A  00  &#46;  REG0\n0000  005B  44  D  XOR\n\n0000  005C  00  &#46;  REG0\n0000  005D  00  &#46;  REG0\n0000  005E  11  &#46;  ADD\n0000  005F  00  &#46;  REG0\n\n----------------------\n\n0000  0060  01  &#46;  REG1\n0000  0061  66  f  STORER\n0000  0062  03  &#46;  REG3\n0000  0063  00  &#46;  00\n\n0000  0064  A0  &#46;    A0\n0000  0065  44  D  XOR\n0000  0066  00  &#46;  REG0\n0000  0067  00  &#46;  REG0\n\n0000  0068  11  &#46;  ADD\n0000  0069  00  &#46;  REG0\n0000  006A  05  &#46;  REG5\n0000  006B  66  f  STORER\n\n0000  006C  04  &#46;  REG4\n0000  006D  00  &#46;  00\n0000  006E  A0  &#46;    A0\n0000  006F  11  &#46;  ADD\n\n----------------------\n\n0000  0070  01  &#46;  REG1\n0000  0071  05  &#46;  REG5\n0000  0072  55  U  LOADR\n0000  0073  01  &#46;  REG1\n\n0000  0074  00  &#46;  00\n0000  0075  A0  &#46;    A0\n0000  0076  44  D  XOR\n0000  0077  04  &#46;  REG4\n\n0000  0078  04  &#46;  REG4\n0000  0079  11  &#46;  ADD\n0000  007A  04  &#46;  REG4\n0000  007B  01  &#46;  REG1\n\n0000  007C  44  D  XOR\n0000  007D  01  &#46;  REG1\n0000  007E  01  &#46;  REG1\n0000  007F  11  &#46;  ADD\n\n-----------------------\n\n0000  0080  01  &#46;  REG1\n0000  0081  02  &#46;  REG2\n0000  0082  55  U  LOADR\n0000  0083  01  &#46;  RG1\n\n0000  0084  01  &#46;  01\n0000  0085  A4  &#46;    A4\n0000  0086  44  D  XOR\n0000  0087  01  &#46;  REG1\n\n0000  0088  04  &#46;  REG4\n0000  0089  CC  &#46;  OUT\n0000  008A  01  &#46;  REG1\n0000  008B  05  &#46;  LOAD\n\n0000  008C  04  &#46;  REG2\n0000  008D  01  &#46;  01\n0000  008E  A3  &#46;    A3\n0000  008F  05  &#46;  LOAD\n\n---------------------\n\n0000  0090  05  &#46;  REG5\n0000  0091  01  &#46;  01\n0000  0092  A2  &#46;    A2\n0000  0093  11  &#46;  ADD\n\n0000  0094  02  &#46;  REG2\n0000  0095  04  &#46;  REG4\n0000  0096  22  &quot;  SUB\n0000  0097  05  &#46;  REG5\n\n0000  0098  02  &#46;  REG2\n0000  0099  AA  &#46;  JNZ\n0000  009A  05  &#46;  REG5\n0000  009B  00  &#46;  00\n\n0000  009C  07  &#46;    07\n0000  009D  FF  &#46;  HALT\n0000  009E  00  &#46;  \n0000  009F  00  &#46;\n\n------------------------\n\n0000  00A0  63  c\n0000  00A1  06  &#46;\n0000  00A2  37  7\n0000  00A3  A6  &#46;\n\n0000  00A4  16  &#46;\n0000  00A5  84  &#46;\n0000  00A6  CC  &#46;\n0000  00A7  71  q\n\n0000  00A8  E5  &#46;\n0000  00A9  5A  Z  \n0000  00AA  CD  &#46;\n0000  00AB  0B  &#46;\n\n0000  00AC  0C  &#46;\n0000  00AD  0D  &#46;\n0000  00AE  0E  &#46;\n0000  00AF  0F  &#46;\n\n------------------------\n\n0000  00B0  10  &#46;\n0000  00B1  11  &#46;\n0000  00B2  12  &#46;\n0000  00B3  13  &#46;\n\n0000  00B4  14  &#46;\n0000  00B5  15  &#46;\n0000  00B6  04  &#46;\n0000  00B7  17  &#46;\n\n0000  00B8  18  &#46;\n0000  00B9  19  &#46;\n0000  00BA  1A  &#46;\n0000  00BB  1B  &#46;\n\n0000  00BC  1C  &#46;\n0000  00BD  1D  &#46;\n0000  00BE  1E  &#46;\n0000  00BF  1F  &#46;\n\n----------------------------\n\n0000  00C0  20  \n0000  00C1  21  !\n0000  00C2  22  &quot;\n0000  00C3  23  #\n\n0000  00C4  24  $\n0000  00C5  25  %\n0000  00C6  26  &amp;\n0000  00C7  27  '\n\n0000  00C8  28  (\n0000  00C9  29  )\n0000  00CA  2A  *\n0000  00CB  2B  +\n\n0000  00CC  2C  ,\n0000  00CD  2D  -\n0000  00CE  2E  &#46;\n0000  00CF  2F  /\n\n-----------------\n\n0000  00D0  30  0\n0000  00D1  31  1\n0000  00D2  32  2\n0000  00D3  33  3\n\n0000  00D4  34  4\n0000  00D5  35  5\n0000  00D6  36  6\n0000  00D7  02  &#46;\n\n0000  00D8  38  8\n0000  00D9  39  9\n0000  00DA  3A  &#58;\n0000  00DB  3B  ;\n\n0000  00DC  3C  &lt;\n0000  00DD  3D  =\n0000  00DE  3E  &gt;\n0000  00DF  3F  ?\n\n--------------------\n\n0000  00E0  40  @\n0000  00E1  41  A\n0000  00E2  42  B\n0000  00E3  43  C\n\n0000  00E4  44  D\n0000  00E5  45  E\n0000  00E6  46  F\n0000  00E7  47  G\n\n0000  00E8  48  H\n0000  00E9  49  I\n0000  00EA  4A  J\n0000  00EB  4B  K\n\n0000  00EC  4C  L\n0000  00ED  4D  M\n0000  00EE  4E  N\n0000  00EF  4F  O\n\n---------------------\n\n0000  00F0  50  P\n0000  00F1  51  Q\n0000  00F2  52  R\n0000  00F3  53  S\n\n0000  00F4  54  T\n0000  00F5  55  U\n0000  00F6  56  V\n0000  00F7  57  W\n\n0000  00F8  58  X\n0000  00F9  59  Y\n0000  00FA  09  &#46;\n0000  00FB  5B  &#91;\n\n0000  00FC  5C  \\\n0000  00FD  5D  &#93;\n0000  00FE  5E  ^\n0000  00FF  5F  _\n\n-----------------------\n\n0000  0100  60  `\n0000  0101  61  a\n0000  0102  62  b\n0000  0103  63  &#46;\n\n0000  0104  64  d\n0000  0105  65  e\n0000  0106  66  f\n0000  0107  67  g\n\n0000  0108  68  h\n0000  0109  69  i\n0000  010A  6A  j\n0000  010B  6B  k\n\n0000  010C  6C  l\n0000  010D  6D  m\n0000  010E  6E  n\n0000  010F  6F  o\n\n----------------------\n\n0000  0110  70  p\n0000  0111  07  &#46;\n0000  0112  72  r\n0000  0113  73  s\n\n0000  0114  74  t\n0000  0115  75  u\n0000  0116  76  v\n0000  0117  77  w\n\n0000  0118  78  x\n0000  0119  79  y\n0000  011A  7A  z\n0000  011B  7B  {\n\n0000  011C  7C  |\n0000  011D  7D  }\n0000  011E  7E  ~\n0000  011F  7F  &#46;\n\n-----------------------\n\n0000  0120  80  &#46;\n0000  0121  81  &#46;\n0000  0122  82  &#46;\n0000  0123  83  &#46;\n\n0000  0124  84  &#46;\n0000  0125  85  &#46;\n0000  0126  86  &#46;\n0000  0127  87  &#46;\n\n0000  0128  88  &#46;\n0000  0129  89  &#46;\n0000  012A  8A  &#46;\n0000  012B  8B  &#46;\n\n0000  012C  8C  &#46;\n0000  012D  8D  &#46;\n0000  012E  8E  &#46;\n0000  012F  8F  &#46;\n\n------------------\n\n0000  0130  90  &#46;\n0000  0131  91  &#46;\n0000  0132  92  &#46;\n0000  0133  93  &#46;\n\n0000  0134  94  &#46;\n0000  0135  95  &#46;\n0000  0136  96  &#46;\n0000  0137  97  &#46;\n\n0000  0138  98  &#46;\n0000  0139  99  &#46;\n0000  013A  9A  &#46;\n0000  013B  9B  &#46;\n\n0000  013C  9C  &#46;\n0000  013D  9D  &#46;\n0000  013E  9E  &#46;\n0000  013F  9F  &#46;\n\n----------------------\n\n0000  0140  A0  &#46;\n0000  0141  A1  &#46;\n0000  0142  A2  &#46;\n0000  0143  A3  &#46;\n\n0000  0144  A4  &#46;\n0000  0145  A5  &#46;\n0000  0146  03  &#46;\n0000  0147  A7  &#46;\n\n0000  0148  A8  &#46;\n0000  0149  A9  &#46;\n0000  014A  AA  &#46;\n0000  014B  AB  &#46;\n\n0000  014C  AC  &#46;\n0000  014D  AD  &#46;\n0000  014E  AE  &#46;\n0000  014F  AF  &#46;\n\n-----------------------\n\n0000  0150  B0  &#46;\n0000  0151  B1  &#46;\n0000  0152  B2  &#46;\n0000  0153  B3  &#46;\n\n0000  0154  B4  &#46;\n0000  0155  B5  &#46;\n0000  0156  B6  &#46;\n0000  0157  B7  &#46;\n\n0000  0158  B8  &#46;\n0000  0159  B9  &#46;\n0000  015A  BA  &#46;\n0000  015B  BB  &#46;\n\n0000  015C  BC  &#46;\n0000  015D  BD  &#46;\n0000  015E  BE  &#46;\n0000  015F  BF  &#46;\n\n------------------\n\n0000  0160  C0  &#46;\n0000  0161  C1  &#46;\n0000  0162  C2  &#46;\n0000  0163  C3  &#46;\n\n0000  0164  C4  &#46;\n0000  0165  C5  &#46;\n0000  0166  C6  &#46;\n0000  0167  C7  &#46;\n\n0000  0168  C8  &#46;\n0000  0169  C9  &#46;\n0000  016A  CA  &#46;\n0000  016B  CB  &#46;\n\n0000  016C  01  &#46;\n0000  016D  0A  &#46;\n0000  016E  CE  &#46;\n0000  016F  CF  &#46;\n\n----------------------\n\n0000  0170  D0  &#46;\n0000  0171  D1  &#46;\n0000  0172  D2  &#46;\n0000  0173  D3  &#46;\n\n0000  0174  D4  &#46;\n0000  0175  D5  &#46;\n0000  0176  D6  &#46;\n0000  0177  D7  &#46;\n\n0000  0178  D8  &#46;\n0000  0179  D9  &#46;\n0000  017A  DA  &#46;\n0000  017B  DB  &#46;\n\n0000  017C  DC  &#46;\n0000  017D  DD  &#46;\n0000  017E  DE  &#46;\n0000  017F  DF  &#46;\n\n-----------------------\n\n0000  0180  E0  &#46;\n0000  0181  E1  &#46;\n0000  0182  E2  &#46;\n0000  0183  E3  &#46;\n\n0000  0184  E4  &#46;\n0000  0185  E5  &#46;\n0000  0186  E6  &#46;\n0000  0187  E7  &#46;\n\n0000  0188  E8  &#46;\n0000  0189  E9  &#46;\n0000  018A  EA  &#46;\n0000  018B  EB  &#46;\n\n0000  018C  EC  &#46;\n0000  018D  ED  &#46;\n0000  018E  EE  &#46;\n0000  018F  EF  &#46;\n\n------------------\n\n0000  0190  F0  &#46;\n0000  0191  F1  &#46;\n0000  0192  F2  &#46;\n0000  0193  F3  &#46;\n\n0000  0194  F4  &#46;\n0000  0195  F5  &#46;\n0000  0196  F6  &#46;\n0000  0197  F7  &#46;\n\n0000  0198  F8  &#46;\n0000  0199  F9  &#46;\n0000  019A  FA  &#46;\n0000  019B  FB  &#46;\n\n0000  019C  FC  &#46;\n0000  019D  FD  &#46;\n0000  019E  FE  &#46;\n0000  019F  FF  &#46;\n\n----------------------\n\n0000  01A0  00  &#46;\n0000  01A1  00  &#46;\n0000  01A2  AE  &#46;\n0000  01A3  01  &#46;\n\n0000  01A4  8B  &#46;\n0000  01A5  1B  &#46;\n0000  01A6  FC  &#46;\n0000  01A7  2F  /\n\n0000  01A8  A9  &#46;\n0000  01A9  E0  &#46;\n0000  01AA  11  &#46;\n0000  01AB  D6  &#46;\n\n0000  01AC  E8  &#46;\n0000  01AD  42  B\n0000  01AE  24  $\n0000  01AF  47  G\n\n-----------------------\n\n0000  01B0  58  X\n0000  01B1  33  3\n0000  01B2  31  1\n0000  01B3  12  &#46;\n\n0000  01B4  00  &#46;\n0000  01B5  E3  &#46;\n0000  01B6  F7  &#46;\n0000  01B7  CD  &#46;\n\n0000  01B8  A9  &#46;\n0000  01B9  DD  &#46;\n0000  01BA  65  e\n0000  01BB  D0  &#46;\n\n0000  01BC  17  &#46;\n0000  01BD  4D  M\n0000  01BE  6A  J\n0000  01BF  7E  ~\n\n------------------\n\n0000  01C0  1F  &#46;\n0000  01C1  CD  &#46;\n0000  01C2  DF  &#46;\n0000  01C3  B9  &#46;\n\n0000  01C4  DE  &#46;\n0000  01C5  F6  &#46;\n0000  01C6  03  &#46;\n0000  01C7  4E  N\n\n0000  01C8  1C  &#46;\n0000  01C9  FD  &#46;\n0000  01CA  CF  &#46;\n0000  01CB  89  &#46;\n\n0000  01CC  25  %\n0000  01CD  E9  &#46;\n0000  01CE  47  G\n0000  01CF  FD  &#46;\n\n----------------------\n\n0000  01D0  B6  &#46;\n0000  01D1  35  5\n0000  01D2  01  &#46;\n0000  01D3  8A  &#46;\n\n0000  01D4  63  c\n0000  01D5  22  &quot;\n0000  01D6  87  &#46;\n0000  01D7  5B  &#91;\n\n0000  01D8  52  R\n0000  01D9  0F  &#46;\n0000  01DA  45  E\n0000  01DB  23  #\n\n0000  01DC  8B  &#46;\n0000  01DD  C3  &#46;\n0000  01DE  A9  &#46;\n0000  01DF  30  0\n\n-----------------------\n\n0000  01E0  0D  &#46;\n0000  01E1  B4  &#46;\n0000  01E2  D0  &#46;\n0000  01E3  FE  &#46;\n\n0000  01E4  C1  &#46;\n0000  01E5  F2  &#46;\n0000  01E6  00  &#46;\n0000  01E7  F0  &#46;\n\n0000  01E8  71  q\n0000  01E9  68  h\n0000  01EA  ED  &#46;\n0000  01EB  E6  &#46;\n\n0000  01EC  15  &#46;\n0000  01ED  04  &#46;\n0000  01EE  DD  &#46;\n0000  01EF  19  &#46;\n\n------------------\n\n0000  01F0  2D  -\n0000  01F1  0A  &#46;\n0000  01F2  9D  &#46;\n0000  01F3  57  w\n\n0000  01F4  22  &quot;\n0000  01F5  87  &#46;\n0000  01F6  99  &#46;\n0000  01F7  4C  L\n\n0000  01F8  80  &#46;\n0000  01F9  18  &#46;\n0000  01FA  D7  &#46;\n0000  01FB  27  '\n\n0000  01FC  2D  -\n0000  01FD  73  s\n0000  01FE  27  '\n0000  01FF  80  &#46;\n\n----------------------\n\n0000  0200  2F  /\n0000  0201  C0  &#46;\n0000  0202  29  )\n0000  0203  9E  &#46;\n\n0000  0204  8F  &#46;\n0000  0205  3D  =\n0000  0206  31  1\n0000  0207  1D  &#46;\n\n0000  0208  74  t\n0000  0209  84  &#46;\n0000  020A  64  d\n0000  020B  88  &#46;\n\n0000  020C  33  3\n0000  020D  1D  &#46;\n0000  020E  72  r\n0000  020F  20  \n\n-----------------------\n\n0000  0210  BB  &#46;\n0000  0211  FC  &#46;\n0000  0212  D6  &#46;\n0000  0213  2E  &#46;\n\n0000  0214  26  &amp;\n0000  0215  A4  &#46;\n0000  0216  16  &#46;\n0000  0217  5C  \\\n\n0000  0218  F8  &#46;\n0000  0219  54  T\n0000  021A  6D  m\n0000  021B  C5  &#46;\n\n0000  021C  E2  &#46;\n0000  021D  4E  N\n0000  021E  A3  &#46;\n0000  021F  41  A\n\n------------------\n\n0000  0220  EE  &#46;\n0000  0221  12  &#46;\n0000  0222  38  8\n0000  0223  1A  &#46;\n\n0000  0224  F9  &#46;\n0000  0225  82  &#46;\n0000  0226  6E  n\n0000  0227  DC  &#46;\n\n0000  0228  C5  &#46;\n0000  0229  7A  z\n0000  022A  79  y\n0000  022B  02  &#46;\n\n0000  022C  C5  &#46;\n0000  022D  D9  &#46;\n0000  022E  74  t\n0000  022F  3F  ?\n\n-----------------------\n\n0000  0230  A4  &#46;\n0000  0231  3E  &gt;\n0000  0232  66  f\n0000  0233  36  6\n\n0000  0234  4C  L\n0000  0235  BF  &#46;\n0000  0236  B4  &#46;\n0000  0237  BD  &#46;\n\n0000  0238  9A  &#46;\n0000  0239  82  &#46;\n0000  023A  36  6\n0000  023B  40  @\n\n0000  023C  90  &#46;\n0000  023D  50  P\n0000  023E  95  &#46;\n0000  023F  F4  &#46;\n\n------------------\n\n0000  0240  92  &#46;\n0000  0241  BD  &#46;\n0000  0242  77  W\n0000  0243  B9  &#46;\n\n0000  0244  17  &#46;\n0000  0245  A2  &#46;\n0000  0246  BE  &#46;\n0000  0247  8E  &#46;\n\n0000  0248  1B  z\n0000  0249  7A  &#46;\n0000  024A  98  &#46;\n0000  024B  2C  ,\n\n0000  024C  1E  &#46;\n0000  024D  8E  &#46;\n0000  024E  16  &#46;\n0000  024F  6E  N\n\n----------------\n\n0000  0250  AB  &#46;\n0000  0251  CA  &#46;\n0000  0252\n0000  0253\n\n0000  0254\n0000  0255\n0000  0256\n0000  0257\n\n0000  0258\n0000  0259\n0000  025A\n0000  025B\n\n0000  025C\n0000  025D\n0000  025E\n0000  025F[/code:o1z8gu0a]",
      "EditableFormat": "bbcode",
      "HTML": "well... I decided to start on trying to learn this debugging on my own... this is what I've done so far...<br/><br/>(I need to create a program to do this stuff for me, laughs - it took me like at least 3 hrs to do this stuff, wasn't fun!,  <!-- s:x --><img src=\"{SMILIES_PATH}/icon_mad.gif\" alt=\":x\" title=\"Mad\" /><!-- s:x -->)<br/>(jokingly, I think I got carpal tunnel syndrome from doing this stuff, just joking, thankfully)<br/><br/>-------------<br/><br/>The &quot;machine.bin&quot; file (hopefully without typos/mistakes):<br/><br/><pre><code>0000  0000  05 04 01 A3  44 02 02 05  00 01 A0 05  04 01 A3 11  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0010  00 04 06 01  A0 05 03 01  A1 44 01 01  11 01 00 55  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;U<br/>0000  0020  01 00 A0 11  03 01 44 05  05 11 05 00  44 00 00 11  &#46;&#46;&#46;&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;<br/>0000  0030  00 03 06 01  1A 44 00 00  11 00 05 44  01 01 11 01  &#46;&#46;&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;<br/>0000  0040  03 55 01 00  A0 44 05 05  11 05 01 44  01 01 11 01  &#46;U&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;<br/>0000  0050  00 55 01 00  A0 44 04 04  11 04 00 44  00 00 11 00  &#46;U&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;D  &#46;&#46;&#46;&#46;<br/>0000  0060  01 66 03 00  A0 44 00 00  11 00 05 66  04 00 A0 11  &#46;f&#46;&#46;  &#46;D&#46;&#46;  &#46;&#46;&#46;f  &#46;&#46;&#46;&#46;<br/>0000  0070  01 05 55 01  00 A0 44 04  04 11 04 01  44 01 01 11  &#46;&#46;U&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  D&#46;&#46;&#46;<br/>0000  0080  01 02 55 01  01 A4 44 01  04 CC 01 05  04 01 A3 05  &#46;&#46;U&#46;  &#46;&#46;D&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0090  05 01 A2 11  02 04 22 05  02 AA 05 00  07 FF 00 00  &#46;&#46;&#46;&#46;  &#46;&#46;&quot;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  00A0  63 06 37 A6  16 84 CC 71  E5 5A CD 0B  0C 0D 0E 0F  c&#46;7&#46;  &#46;&#46;&#46;q  &#46;Z&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  00B0  10 11 12 13  14 15 04 17  18 19 1A 1B  1C 1D 1E 1F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  00C0  20 21 22 23  24 25 26 27  28 29 2A 2B  2C 2D 2E 2F   !&quot;#  $%&amp;'  ()*+  ,-&#46;/<br/>0000  00D0  30 31 32 33  34 35 36 02  38 39 3A 3B  3C 3D 3E 3F  0123  456&#46;  89&#58;;  &lt;=&gt;?<br/>0000  00E0  40 41 42 43  44 45 46 47  48 49 4A 4B  4C 4D 4E 4F  @ABC  DEFG  HIJK  LMNO<br/>0000  00F0  50 51 52 53  54 55 56 57  58 59 09 5B  5C 5D 5E 5F  PQRS  TUVW  XY&#46;&#91;  \\&#93;^_<br/>0000  0100  60 61 62 63  64 65 66 67  68 69 6A 6B  6C 6D 6E 6F  `ab&#46;  defg  hijk  lmno<br/>0000  0110  70 07 72 73  74 75 76 77  78 79 7A 7B  7C 7D 7E 7F  p&#46;rs  tuvw  xyz{  |}~&#46;<br/>0000  0120  80 81 82 83  84 85 86 87  88 89 8A 8B  8C 8D 8E 8F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0130  90 91 92 93  94 95 96 97  98 99 9A 9B  9C 9D 9E 9F  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0140  A0 A1 A2 A3  A4 A5 03 A7  A8 A9 AA AB  AC AD AE AF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0150  B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0160  C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  01 0A CE CF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46; <br/>0000  0170  D0 D1 D2 D3  D4 D5 D6 D7  D8 D9 DA DB  DC DD DE DF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0180  E0 E1 E2 E3  E4 E5 E6 E7  E8 E9 EA EB  EC ED EE EF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  0190  F0 F1 F2 F3  F4 F5 F6 F7  F8 F9 FA FB  FC FD FE FF  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;<br/>0000  01A0  00 00 AE 01  8B 1B FC 2F  A9 E0 11 D6  E8 42 24 47  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;/  &#46;&#46;&#46;&#46;  &#46;B$G<br/>0000  01B0  58 33 31 12  00 E3 F7 CD  A9 DD 65 D0  17 4D 6A 7E  X31&#46;  &#46;&#46;&#46;&#46;  &#46;&#46;e&#46;  &#46;MJ~<br/>0000  01C0  1F CD DF B9  DE F6 03 4E  1C FD CF 89  25 E9 47 FD  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;N  &#46;&#46;&#46;&#46;  %&#46;G&#46;<br/>0000  01D0  B6 35 01 8A  63 22 87 5B  52 0F 45 23  8B C3 A9 30  &#46;5&#46;&#46;  c&quot;&#46;&#91;  R&#46;E#  &#46;&#46;&#46;0<br/>0000  01E0  0D B4 D0 FE  C1 F2 00 F0  71 68 ED E6  15 04 DD 19  &#46;&#46;&#46;&#46;  &#46;&#46;&#46;&#46;  qh&#46;&#46;  &#46;&#46;&#46;&#46; <br/>0000  01F0  2D 0A 9D 57  22 87 99 4C  80 18 D7 27  2D 73 27 80  -&#46;&#46;w  &quot;&#46;&#46;L  &#46;&#46;&#46;'  -s'&#46;<br/>0000  0200  2F C0 29 9E  8F 3D 31 1D  74 84 64 88  33 1D 72 20  /&#46;)&#46;  &#46;=1&#46;  t&#46;d&#46;  3&#46;r<br/>0000  0210  BB FC D6 2E  26 A4 16 5C  F8 54 6D C5  E2 4E A3 41  &#46;&#46;&#46;&#46;  &amp;&#46;&#46;\\  &#46;Tm&#46;  &#46;N&#46;A<br/>0000  0220  EE 12 38 1A  F9 82 6E DC  C5 7A 79 02  C5 D9 74 3F  &#46;&#46;8&#46;  &#46;&#46;n&#46;  &#46;zy&#46;  &#46;&#46;t?<br/>0000  0230  A4 3E 66 36  4C BF B4 BD  9A 82 36 40  90 50 95 F4  &#46;&gt;f6  L&#46;&#46;&#46;  &#46;&#46;6@  &#46;P&#46;&#46;<br/>0000  0240  92 BD 77 B9  17 A2 BE 8E  1B 7A 98 2C  1E 8E 16 6E  &#46;&#46;W&#46;  &#46;&#46;&#46;&#46;  z&#46;&#46;,  &#46;&#46;&#46;N<br/>0000  0250  AB CA                                               &#46;&#46;</code></pre><br/><br/>and the first step I'm doing (still working on it), is mapping out the machine.bin operations (I'm now ready to try to fill in the details of the operations for what I'll do next - taking a short-medium break at the moment, lol):<br/><br/>(it's the machine.bin formatted vertically, so I can write in the details of each step/operation... and once that is done, hopefully correctly, I can then use it to compare with my program via debugging)<br/><br/>(again, hopefully without typos/mistakes, lol)<br/><br/><pre><code>0000  0000  05  &#46;  LOAD<br/>0000  0001  04  &#46;  REG4<br/>0000  0002  01  &#46;  01<br/>0000  0003  A3  &#46;    A3<br/><br/>0000  0004  44  D  XOR<br/>0000  0005  02  &#46;  REG2<br/>0000  0006  02  &#46;  REG2<br/>0000  0007  05  &#46;  LOAD<br/><br/>0000  0008  00  &#46;  REG0<br/>0000  0009  01  &#46;  01<br/>0000  000A  A0  &#46;    A0<br/>0000  000B  05  &#46;  LOAD<br/><br/>0000  000C  04  &#46;  REG4<br/>0000  000D  01  &#46;  01<br/>0000  000E  A3  &#46;    A3<br/>0000  000F  11  &#46;  ADD<br/><br/>--------------------<br/><br/>0000  0010  00  &#46;  REG0<br/>0000  0011  04  &#46;  REG4<br/>0000  0012  06  &#46;  STORE<br/>0000  0013  01  &#46;  01<br/><br/>0000  0014  A0  &#46;    A0<br/>0000  0015  05  &#46;  LOAD<br/>0000  0016  03  &#46;  REG3<br/>0000  0017  01  &#46;  01<br/><br/>0000  0018  A1  &#46;    A1<br/>0000  0019  44  D  XOR<br/>0000  001A  01  &#46;  REG1<br/>0000  001B  01  &#46;  REG1<br/><br/>0000  001C  11  &#46;  ADD<br/>0000  001D  01  &#46;  REG1<br/>0000  001E  00  &#46;  REG0<br/>0000  001F  55  U  LOADR<br/><br/>---------------------<br/><br/>0000  0020  01  &#46;  REG1<br/>0000  0021  00  &#46;  00<br/>0000  0022  A0  &#46;    A0<br/>0000  0023  11  &#46;  ADD<br/><br/>0000  0024  03  &#46;  REG3<br/>0000  0025  01  &#46;  REG1<br/>0000  0026  44  D  XOR<br/>0000  0027  05  &#46;  REG5<br/><br/>0000  0028  05  &#46;  REG5<br/>0000  0029  11  &#46;  ADD<br/>0000  002A  05  &#46;  REG5<br/>0000  002B  00  &#46;  REG0<br/><br/>0000  002C  44  D  XOR<br/>0000  002D  00  &#46;  REG0<br/>0000  002E  00  &#46;  REG0<br/>0000  002F  11  &#46;  ADD<br/><br/>-----------------------<br/><br/>0000  0030  00  &#46;  REG0<br/>0000  0031  03  &#46;  REG3<br/>0000  0032  06  &#46;  STORE<br/>0000  0033  01  &#46;  01<br/><br/>0000  0034  1A  &#46;    1A<br/>0000  0035  44  D  XOR<br/>0000  0036  00  &#46;  REG0<br/>0000  0037  00  &#46;  REG0<br/><br/>0000  0038  11  &#46;  ADD<br/>0000  0039  00  &#46;  REG0<br/>0000  003A  05  &#46;  REG5<br/>0000  003B  44  D  XOR<br/><br/>0000  003C  01  &#46;  REG1<br/>0000  003D  01  &#46;  REG1<br/>0000  003E  11  &#46;  ADD<br/>0000  003F  01  &#46;  REG1<br/><br/>----------------------<br/><br/>0000  0040  03  &#46;  REG3<br/>0000  0041  55  U  LOADR<br/>0000  0042  01  &#46;  REG1<br/>0000  0043  00  &#46;  00<br/><br/>0000  0044  A0  &#46;    A0<br/>0000  0045  44  D  XOR<br/>0000  0046  05  &#46;  REG5<br/>0000  0047  05  &#46;  REG5<br/><br/>0000  0048  11  &#46;  ADD<br/>0000  0049  05  &#46;  REG5<br/>0000  004A  01  &#46;  REG1<br/>0000  004B  44  D  XOR<br/><br/>0000  004C  01  &#46;  REG1<br/>0000  004D  01  &#46;  REG1<br/>0000  004E  11  &#46;  ADD<br/>0000  004F  01  &#46;  REG1<br/><br/>-----------------------<br/><br/>0000  0050  00  &#46;  REG0<br/>0000  0051  55  U  LOADR<br/>0000  0052  01  &#46;  REG1<br/>0000  0053  00  &#46;  00<br/><br/>0000  0054  A0  &#46;    A0<br/>0000  0055  44  D  XOR<br/>0000  0056  04  &#46;  REG4<br/>0000  0057  04  &#46;  REG4<br/><br/>0000  0058  11  &#46;  ADD<br/>0000  0059  04  &#46;  REG4<br/>0000  005A  00  &#46;  REG0<br/>0000  005B  44  D  XOR<br/><br/>0000  005C  00  &#46;  REG0<br/>0000  005D  00  &#46;  REG0<br/>0000  005E  11  &#46;  ADD<br/>0000  005F  00  &#46;  REG0<br/><br/>----------------------<br/><br/>0000  0060  01  &#46;  REG1<br/>0000  0061  66  f  STORER<br/>0000  0062  03  &#46;  REG3<br/>0000  0063  00  &#46;  00<br/><br/>0000  0064  A0  &#46;    A0<br/>0000  0065  44  D  XOR<br/>0000  0066  00  &#46;  REG0<br/>0000  0067  00  &#46;  REG0<br/><br/>0000  0068  11  &#46;  ADD<br/>0000  0069  00  &#46;  REG0<br/>0000  006A  05  &#46;  REG5<br/>0000  006B  66  f  STORER<br/><br/>0000  006C  04  &#46;  REG4<br/>0000  006D  00  &#46;  00<br/>0000  006E  A0  &#46;    A0<br/>0000  006F  11  &#46;  ADD<br/><br/>----------------------<br/><br/>0000  0070  01  &#46;  REG1<br/>0000  0071  05  &#46;  REG5<br/>0000  0072  55  U  LOADR<br/>0000  0073  01  &#46;  REG1<br/><br/>0000  0074  00  &#46;  00<br/>0000  0075  A0  &#46;    A0<br/>0000  0076  44  D  XOR<br/>0000  0077  04  &#46;  REG4<br/><br/>0000  0078  04  &#46;  REG4<br/>0000  0079  11  &#46;  ADD<br/>0000  007A  04  &#46;  REG4<br/>0000  007B  01  &#46;  REG1<br/><br/>0000  007C  44  D  XOR<br/>0000  007D  01  &#46;  REG1<br/>0000  007E  01  &#46;  REG1<br/>0000  007F  11  &#46;  ADD<br/><br/>-----------------------<br/><br/>0000  0080  01  &#46;  REG1<br/>0000  0081  02  &#46;  REG2<br/>0000  0082  55  U  LOADR<br/>0000  0083  01  &#46;  RG1<br/><br/>0000  0084  01  &#46;  01<br/>0000  0085  A4  &#46;    A4<br/>0000  0086  44  D  XOR<br/>0000  0087  01  &#46;  REG1<br/><br/>0000  0088  04  &#46;  REG4<br/>0000  0089  CC  &#46;  OUT<br/>0000  008A  01  &#46;  REG1<br/>0000  008B  05  &#46;  LOAD<br/><br/>0000  008C  04  &#46;  REG2<br/>0000  008D  01  &#46;  01<br/>0000  008E  A3  &#46;    A3<br/>0000  008F  05  &#46;  LOAD<br/><br/>---------------------<br/><br/>0000  0090  05  &#46;  REG5<br/>0000  0091  01  &#46;  01<br/>0000  0092  A2  &#46;    A2<br/>0000  0093  11  &#46;  ADD<br/><br/>0000  0094  02  &#46;  REG2<br/>0000  0095  04  &#46;  REG4<br/>0000  0096  22  &quot;  SUB<br/>0000  0097  05  &#46;  REG5<br/><br/>0000  0098  02  &#46;  REG2<br/>0000  0099  AA  &#46;  JNZ<br/>0000  009A  05  &#46;  REG5<br/>0000  009B  00  &#46;  00<br/><br/>0000  009C  07  &#46;    07<br/>0000  009D  FF  &#46;  HALT<br/>0000  009E  00  &#46;  <br/>0000  009F  00  &#46;<br/><br/>------------------------<br/><br/>0000  00A0  63  c<br/>0000  00A1  06  &#46;<br/>0000  00A2  37  7<br/>0000  00A3  A6  &#46;<br/><br/>0000  00A4  16  &#46;<br/>0000  00A5  84  &#46;<br/>0000  00A6  CC  &#46;<br/>0000  00A7  71  q<br/><br/>0000  00A8  E5  &#46;<br/>0000  00A9  5A  Z  <br/>0000  00AA  CD  &#46;<br/>0000  00AB  0B  &#46;<br/><br/>0000  00AC  0C  &#46;<br/>0000  00AD  0D  &#46;<br/>0000  00AE  0E  &#46;<br/>0000  00AF  0F  &#46;<br/><br/>------------------------<br/><br/>0000  00B0  10  &#46;<br/>0000  00B1  11  &#46;<br/>0000  00B2  12  &#46;<br/>0000  00B3  13  &#46;<br/><br/>0000  00B4  14  &#46;<br/>0000  00B5  15  &#46;<br/>0000  00B6  04  &#46;<br/>0000  00B7  17  &#46;<br/><br/>0000  00B8  18  &#46;<br/>0000  00B9  19  &#46;<br/>0000  00BA  1A  &#46;<br/>0000  00BB  1B  &#46;<br/><br/>0000  00BC  1C  &#46;<br/>0000  00BD  1D  &#46;<br/>0000  00BE  1E  &#46;<br/>0000  00BF  1F  &#46;<br/><br/>----------------------------<br/><br/>0000  00C0  20  <br/>0000  00C1  21  !<br/>0000  00C2  22  &quot;<br/>0000  00C3  23  #<br/><br/>0000  00C4  24  $<br/>0000  00C5  25  %<br/>0000  00C6  26  &amp;<br/>0000  00C7  27  '<br/><br/>0000  00C8  28  (<br/>0000  00C9  29  )<br/>0000  00CA  2A  *<br/>0000  00CB  2B  +<br/><br/>0000  00CC  2C  ,<br/>0000  00CD  2D  -<br/>0000  00CE  2E  &#46;<br/>0000  00CF  2F  /<br/><br/>-----------------<br/><br/>0000  00D0  30  0<br/>0000  00D1  31  1<br/>0000  00D2  32  2<br/>0000  00D3  33  3<br/><br/>0000  00D4  34  4<br/>0000  00D5  35  5<br/>0000  00D6  36  6<br/>0000  00D7  02  &#46;<br/><br/>0000  00D8  38  8<br/>0000  00D9  39  9<br/>0000  00DA  3A  &#58;<br/>0000  00DB  3B  ;<br/><br/>0000  00DC  3C  &lt;<br/>0000  00DD  3D  =<br/>0000  00DE  3E  &gt;<br/>0000  00DF  3F  ?<br/><br/>--------------------<br/><br/>0000  00E0  40  @<br/>0000  00E1  41  A<br/>0000  00E2  42  B<br/>0000  00E3  43  C<br/><br/>0000  00E4  44  D<br/>0000  00E5  45  E<br/>0000  00E6  46  F<br/>0000  00E7  47  G<br/><br/>0000  00E8  48  H<br/>0000  00E9  49  I<br/>0000  00EA  4A  J<br/>0000  00EB  4B  K<br/><br/>0000  00EC  4C  L<br/>0000  00ED  4D  M<br/>0000  00EE  4E  N<br/>0000  00EF  4F  O<br/><br/>---------------------<br/><br/>0000  00F0  50  P<br/>0000  00F1  51  Q<br/>0000  00F2  52  R<br/>0000  00F3  53  S<br/><br/>0000  00F4  54  T<br/>0000  00F5  55  U<br/>0000  00F6  56  V<br/>0000  00F7  57  W<br/><br/>0000  00F8  58  X<br/>0000  00F9  59  Y<br/>0000  00FA  09  &#46;<br/>0000  00FB  5B  &#91;<br/><br/>0000  00FC  5C  \\<br/>0000  00FD  5D  &#93;<br/>0000  00FE  5E  ^<br/>0000  00FF  5F  _<br/><br/>-----------------------<br/><br/>0000  0100  60  `<br/>0000  0101  61  a<br/>0000  0102  62  b<br/>0000  0103  63  &#46;<br/><br/>0000  0104  64  d<br/>0000  0105  65  e<br/>0000  0106  66  f<br/>0000  0107  67  g<br/><br/>0000  0108  68  h<br/>0000  0109  69  i<br/>0000  010A  6A  j<br/>0000  010B  6B  k<br/><br/>0000  010C  6C  l<br/>0000  010D  6D  m<br/>0000  010E  6E  n<br/>0000  010F  6F  o<br/><br/>----------------------<br/><br/>0000  0110  70  p<br/>0000  0111  07  &#46;<br/>0000  0112  72  r<br/>0000  0113  73  s<br/><br/>0000  0114  74  t<br/>0000  0115  75  u<br/>0000  0116  76  v<br/>0000  0117  77  w<br/><br/>0000  0118  78  x<br/>0000  0119  79  y<br/>0000  011A  7A  z<br/>0000  011B  7B  {<br/><br/>0000  011C  7C  |<br/>0000  011D  7D  }<br/>0000  011E  7E  ~<br/>0000  011F  7F  &#46;<br/><br/>-----------------------<br/><br/>0000  0120  80  &#46;<br/>0000  0121  81  &#46;<br/>0000  0122  82  &#46;<br/>0000  0123  83  &#46;<br/><br/>0000  0124  84  &#46;<br/>0000  0125  85  &#46;<br/>0000  0126  86  &#46;<br/>0000  0127  87  &#46;<br/><br/>0000  0128  88  &#46;<br/>0000  0129  89  &#46;<br/>0000  012A  8A  &#46;<br/>0000  012B  8B  &#46;<br/><br/>0000  012C  8C  &#46;<br/>0000  012D  8D  &#46;<br/>0000  012E  8E  &#46;<br/>0000  012F  8F  &#46;<br/><br/>------------------<br/><br/>0000  0130  90  &#46;<br/>0000  0131  91  &#46;<br/>0000  0132  92  &#46;<br/>0000  0133  93  &#46;<br/><br/>0000  0134  94  &#46;<br/>0000  0135  95  &#46;<br/>0000  0136  96  &#46;<br/>0000  0137  97  &#46;<br/><br/>0000  0138  98  &#46;<br/>0000  0139  99  &#46;<br/>0000  013A  9A  &#46;<br/>0000  013B  9B  &#46;<br/><br/>0000  013C  9C  &#46;<br/>0000  013D  9D  &#46;<br/>0000  013E  9E  &#46;<br/>0000  013F  9F  &#46;<br/><br/>----------------------<br/><br/>0000  0140  A0  &#46;<br/>0000  0141  A1  &#46;<br/>0000  0142  A2  &#46;<br/>0000  0143  A3  &#46;<br/><br/>0000  0144  A4  &#46;<br/>0000  0145  A5  &#46;<br/>0000  0146  03  &#46;<br/>0000  0147  A7  &#46;<br/><br/>0000  0148  A8  &#46;<br/>0000  0149  A9  &#46;<br/>0000  014A  AA  &#46;<br/>0000  014B  AB  &#46;<br/><br/>0000  014C  AC  &#46;<br/>0000  014D  AD  &#46;<br/>0000  014E  AE  &#46;<br/>0000  014F  AF  &#46;<br/><br/>-----------------------<br/><br/>0000  0150  B0  &#46;<br/>0000  0151  B1  &#46;<br/>0000  0152  B2  &#46;<br/>0000  0153  B3  &#46;<br/><br/>0000  0154  B4  &#46;<br/>0000  0155  B5  &#46;<br/>0000  0156  B6  &#46;<br/>0000  0157  B7  &#46;<br/><br/>0000  0158  B8  &#46;<br/>0000  0159  B9  &#46;<br/>0000  015A  BA  &#46;<br/>0000  015B  BB  &#46;<br/><br/>0000  015C  BC  &#46;<br/>0000  015D  BD  &#46;<br/>0000  015E  BE  &#46;<br/>0000  015F  BF  &#46;<br/><br/>------------------<br/><br/>0000  0160  C0  &#46;<br/>0000  0161  C1  &#46;<br/>0000  0162  C2  &#46;<br/>0000  0163  C3  &#46;<br/><br/>0000  0164  C4  &#46;<br/>0000  0165  C5  &#46;<br/>0000  0166  C6  &#46;<br/>0000  0167  C7  &#46;<br/><br/>0000  0168  C8  &#46;<br/>0000  0169  C9  &#46;<br/>0000  016A  CA  &#46;<br/>0000  016B  CB  &#46;<br/><br/>0000  016C  01  &#46;<br/>0000  016D  0A  &#46;<br/>0000  016E  CE  &#46;<br/>0000  016F  CF  &#46;<br/><br/>----------------------<br/><br/>0000  0170  D0  &#46;<br/>0000  0171  D1  &#46;<br/>0000  0172  D2  &#46;<br/>0000  0173  D3  &#46;<br/><br/>0000  0174  D4  &#46;<br/>0000  0175  D5  &#46;<br/>0000  0176  D6  &#46;<br/>0000  0177  D7  &#46;<br/><br/>0000  0178  D8  &#46;<br/>0000  0179  D9  &#46;<br/>0000  017A  DA  &#46;<br/>0000  017B  DB  &#46;<br/><br/>0000  017C  DC  &#46;<br/>0000  017D  DD  &#46;<br/>0000  017E  DE  &#46;<br/>0000  017F  DF  &#46;<br/><br/>-----------------------<br/><br/>0000  0180  E0  &#46;<br/>0000  0181  E1  &#46;<br/>0000  0182  E2  &#46;<br/>0000  0183  E3  &#46;<br/><br/>0000  0184  E4  &#46;<br/>0000  0185  E5  &#46;<br/>0000  0186  E6  &#46;<br/>0000  0187  E7  &#46;<br/><br/>0000  0188  E8  &#46;<br/>0000  0189  E9  &#46;<br/>0000  018A  EA  &#46;<br/>0000  018B  EB  &#46;<br/><br/>0000  018C  EC  &#46;<br/>0000  018D  ED  &#46;<br/>0000  018E  EE  &#46;<br/>0000  018F  EF  &#46;<br/><br/>------------------<br/><br/>0000  0190  F0  &#46;<br/>0000  0191  F1  &#46;<br/>0000  0192  F2  &#46;<br/>0000  0193  F3  &#46;<br/><br/>0000  0194  F4  &#46;<br/>0000  0195  F5  &#46;<br/>0000  0196  F6  &#46;<br/>0000  0197  F7  &#46;<br/><br/>0000  0198  F8  &#46;<br/>0000  0199  F9  &#46;<br/>0000  019A  FA  &#46;<br/>0000  019B  FB  &#46;<br/><br/>0000  019C  FC  &#46;<br/>0000  019D  FD  &#46;<br/>0000  019E  FE  &#46;<br/>0000  019F  FF  &#46;<br/><br/>----------------------<br/><br/>0000  01A0  00  &#46;<br/>0000  01A1  00  &#46;<br/>0000  01A2  AE  &#46;<br/>0000  01A3  01  &#46;<br/><br/>0000  01A4  8B  &#46;<br/>0000  01A5  1B  &#46;<br/>0000  01A6  FC  &#46;<br/>0000  01A7  2F  /<br/><br/>0000  01A8  A9  &#46;<br/>0000  01A9  E0  &#46;<br/>0000  01AA  11  &#46;<br/>0000  01AB  D6  &#46;<br/><br/>0000  01AC  E8  &#46;<br/>0000  01AD  42  B<br/>0000  01AE  24  $<br/>0000  01AF  47  G<br/><br/>-----------------------<br/><br/>0000  01B0  58  X<br/>0000  01B1  33  3<br/>0000  01B2  31  1<br/>0000  01B3  12  &#46;<br/><br/>0000  01B4  00  &#46;<br/>0000  01B5  E3  &#46;<br/>0000  01B6  F7  &#46;<br/>0000  01B7  CD  &#46;<br/><br/>0000  01B8  A9  &#46;<br/>0000  01B9  DD  &#46;<br/>0000  01BA  65  e<br/>0000  01BB  D0  &#46;<br/><br/>0000  01BC  17  &#46;<br/>0000  01BD  4D  M<br/>0000  01BE  6A  J<br/>0000  01BF  7E  ~<br/><br/>------------------<br/><br/>0000  01C0  1F  &#46;<br/>0000  01C1  CD  &#46;<br/>0000  01C2  DF  &#46;<br/>0000  01C3  B9  &#46;<br/><br/>0000  01C4  DE  &#46;<br/>0000  01C5  F6  &#46;<br/>0000  01C6  03  &#46;<br/>0000  01C7  4E  N<br/><br/>0000  01C8  1C  &#46;<br/>0000  01C9  FD  &#46;<br/>0000  01CA  CF  &#46;<br/>0000  01CB  89  &#46;<br/><br/>0000  01CC  25  %<br/>0000  01CD  E9  &#46;<br/>0000  01CE  47  G<br/>0000  01CF  FD  &#46;<br/><br/>----------------------<br/><br/>0000  01D0  B6  &#46;<br/>0000  01D1  35  5<br/>0000  01D2  01  &#46;<br/>0000  01D3  8A  &#46;<br/><br/>0000  01D4  63  c<br/>0000  01D5  22  &quot;<br/>0000  01D6  87  &#46;<br/>0000  01D7  5B  &#91;<br/><br/>0000  01D8  52  R<br/>0000  01D9  0F  &#46;<br/>0000  01DA  45  E<br/>0000  01DB  23  #<br/><br/>0000  01DC  8B  &#46;<br/>0000  01DD  C3  &#46;<br/>0000  01DE  A9  &#46;<br/>0000  01DF  30  0<br/><br/>-----------------------<br/><br/>0000  01E0  0D  &#46;<br/>0000  01E1  B4  &#46;<br/>0000  01E2  D0  &#46;<br/>0000  01E3  FE  &#46;<br/><br/>0000  01E4  C1  &#46;<br/>0000  01E5  F2  &#46;<br/>0000  01E6  00  &#46;<br/>0000  01E7  F0  &#46;<br/><br/>0000  01E8  71  q<br/>0000  01E9  68  h<br/>0000  01EA  ED  &#46;<br/>0000  01EB  E6  &#46;<br/><br/>0000  01EC  15  &#46;<br/>0000  01ED  04  &#46;<br/>0000  01EE  DD  &#46;<br/>0000  01EF  19  &#46;<br/><br/>------------------<br/><br/>0000  01F0  2D  -<br/>0000  01F1  0A  &#46;<br/>0000  01F2  9D  &#46;<br/>0000  01F3  57  w<br/><br/>0000  01F4  22  &quot;<br/>0000  01F5  87  &#46;<br/>0000  01F6  99  &#46;<br/>0000  01F7  4C  L<br/><br/>0000  01F8  80  &#46;<br/>0000  01F9  18  &#46;<br/>0000  01FA  D7  &#46;<br/>0000  01FB  27  '<br/><br/>0000  01FC  2D  -<br/>0000  01FD  73  s<br/>0000  01FE  27  '<br/>0000  01FF  80  &#46;<br/><br/>----------------------<br/><br/>0000  0200  2F  /<br/>0000  0201  C0  &#46;<br/>0000  0202  29  )<br/>0000  0203  9E  &#46;<br/><br/>0000  0204  8F  &#46;<br/>0000  0205  3D  =<br/>0000  0206  31  1<br/>0000  0207  1D  &#46;<br/><br/>0000  0208  74  t<br/>0000  0209  84  &#46;<br/>0000  020A  64  d<br/>0000  020B  88  &#46;<br/><br/>0000  020C  33  3<br/>0000  020D  1D  &#46;<br/>0000  020E  72  r<br/>0000  020F  20  <br/><br/>-----------------------<br/><br/>0000  0210  BB  &#46;<br/>0000  0211  FC  &#46;<br/>0000  0212  D6  &#46;<br/>0000  0213  2E  &#46;<br/><br/>0000  0214  26  &amp;<br/>0000  0215  A4  &#46;<br/>0000  0216  16  &#46;<br/>0000  0217  5C  \\<br/><br/>0000  0218  F8  &#46;<br/>0000  0219  54  T<br/>0000  021A  6D  m<br/>0000  021B  C5  &#46;<br/><br/>0000  021C  E2  &#46;<br/>0000  021D  4E  N<br/>0000  021E  A3  &#46;<br/>0000  021F  41  A<br/><br/>------------------<br/><br/>0000  0220  EE  &#46;<br/>0000  0221  12  &#46;<br/>0000  0222  38  8<br/>0000  0223  1A  &#46;<br/><br/>0000  0224  F9  &#46;<br/>0000  0225  82  &#46;<br/>0000  0226  6E  n<br/>0000  0227  DC  &#46;<br/><br/>0000  0228  C5  &#46;<br/>0000  0229  7A  z<br/>0000  022A  79  y<br/>0000  022B  02  &#46;<br/><br/>0000  022C  C5  &#46;<br/>0000  022D  D9  &#46;<br/>0000  022E  74  t<br/>0000  022F  3F  ?<br/><br/>-----------------------<br/><br/>0000  0230  A4  &#46;<br/>0000  0231  3E  &gt;<br/>0000  0232  66  f<br/>0000  0233  36  6<br/><br/>0000  0234  4C  L<br/>0000  0235  BF  &#46;<br/>0000  0236  B4  &#46;<br/>0000  0237  BD  &#46;<br/><br/>0000  0238  9A  &#46;<br/>0000  0239  82  &#46;<br/>0000  023A  36  6<br/>0000  023B  40  @<br/><br/>0000  023C  90  &#46;<br/>0000  023D  50  P<br/>0000  023E  95  &#46;<br/>0000  023F  F4  &#46;<br/><br/>------------------<br/><br/>0000  0240  92  &#46;<br/>0000  0241  BD  &#46;<br/>0000  0242  77  W<br/>0000  0243  B9  &#46;<br/><br/>0000  0244  17  &#46;<br/>0000  0245  A2  &#46;<br/>0000  0246  BE  &#46;<br/>0000  0247  8E  &#46;<br/><br/>0000  0248  1B  z<br/>0000  0249  7A  &#46;<br/>0000  024A  98  &#46;<br/>0000  024B  2C  ,<br/><br/>0000  024C  1E  &#46;<br/>0000  024D  8E  &#46;<br/>0000  024E  16  &#46;<br/>0000  024F  6E  N<br/><br/>----------------<br/><br/>0000  0250  AB  &#46;<br/>0000  0251  CA  &#46;<br/>0000  0252<br/>0000  0253<br/><br/>0000  0254<br/>0000  0255<br/>0000  0256<br/>0000  0257<br/><br/>0000  0258<br/>0000  0259<br/>0000  025A<br/>0000  025B<br/><br/>0000  025C<br/>0000  025D<br/>0000  025E<br/>0000  025F</code></pre>",
      "PostDate": "2016-03-02T15:39:21+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41546",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Looks like a good plan! And keep in mind that there won't just be code in the .bin file. There will be data as well. For example, the first instruction is reading from offset 0x01a3, so you can be fairly sure that that will be a data byte and not a code byte. \n\nSo basically you shouldn't have to decode the entire file as instructions, assuming the code doesn't jump all over the place. You might only have to go as far as the HALT, if all the jnz's jump backwards (if that makes sense).\n\nEdit: in fact, from around offset 0xab onward, it definitely looks like data for a while. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> (increasing integers from 0x0b to 0xff).",
      "EditableFormat": "bbcode",
      "HTML": "Looks like a good plan! And keep in mind that there won't just be code in the .bin file. There will be data as well. For example, the first instruction is reading from offset 0x01a3, so you can be fairly sure that that will be a data byte and not a code byte. <br/><br/>So basically you shouldn't have to decode the entire file as instructions, assuming the code doesn't jump all over the place. You might only have to go as far as the HALT, if all the jnz's jump backwards (if that makes sense).<br/><br/>Edit: in fact, from around offset 0xab onward, it definitely looks like data for a while. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> (increasing integers from 0x0b to 0xff).",
      "PostDate": "2016-03-02T16:11:07+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41547",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Did you create the machine.bin file above by hand? If so, there might be a typo (if not, it's just odd). The 1A at 0x34 might be A1.\n\n(BTW, that's some convoluted code there...)",
      "EditableFormat": "bbcode",
      "HTML": "Did you create the machine.bin file above by hand? If so, there might be a typo (if not, it's just odd). The 1A at 0x34 might be A1.<br/><br/>(BTW, that's some convoluted code there...)",
      "PostDate": "2016-03-02T16:44:18+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41548",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Here's something to contemplate while looking through the code, as it might help to simplify it in your mind (since it does this a lot).\n\nWhat is the effect of pairs of instructions like this?\n\n[code:rc3vo2to]xor r2, r2\nadd r2, r1[/code:rc3vo2to]",
      "EditableFormat": "bbcode",
      "HTML": "Here's something to contemplate while looking through the code, as it might help to simplify it in your mind (since it does this a lot).<br/><br/>What is the effect of pairs of instructions like this?<br/><br/><pre><code>xor r2, r2<br/>add r2, r1</code></pre>",
      "PostDate": "2016-03-02T16:53:40+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41549",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "[quote=&quot;jaynabonne&quot;:23dhk8j0]Did you create the machine.bin file above by hand? If so, there might be a typo (if not, it's just odd). The 1A at 0x34 might be A1.\n\n(BTW, that's some convoluted code there...)[/quote:23dhk8j0]\n\nya, that's a typo (thanks for spotting it), it is indeed suppose to be (it is): A1\n\n-----\n\nyes, I did it by hand, lol. at least 3 hrs to do jsut that, one of the first things when I got the time, is to write a program to do this for me, laughs. This program will eventually turn into an assembly debugging/deciphering program... hopefully. HK laughs/grins evilly, I'll have a program that will do/show how a bin file is suppose to run correctly (sometime in the future when I capable of taking it that far)\n\n-----------\n\nI'm pretty methodical and often tri-check everything, so there's probably not too many typos because of it, though can't be perfect, grr\n\n--------\n\n[quote=&quot;jaynabonne&quot;:23dhk8j0]Here's something to contemplate while looking through the code, as it might help to simplify it in your mind (since it does this a lot).\n\nWhat is the effect of pairs of instructions like this?\n\n[code:23dhk8j0]xor r2, r2\nadd r2, r1[/code:23dhk8j0][/quote:23dhk8j0]\n\nthe xor zeros the (first:left) register (if both registers are the same), and then by adding a value to it, you're &quot;setting&quot; it to that new value.\n\nthe xor x1, x2 zeroes it (due to xor truth table logic) and if you xor it again, it returns to its value (zeros when done odd number of times, sets/re-sets it again when done even number of times, thus xor is a &quot;bit toggle&quot;, off-on-off-on: zero-set-zero-set)\n\n---------------------\n\n\n[quote=&quot;jaynabonne&quot;:23dhk8j0]Looks like a good plan! And keep in mind that there won't just be code in the .bin file. There will be data as well. For example, the first instruction is reading from offset 0x01a3, so you can be fairly sure that that will be a data byte and not a code byte. \n\nSo basically you shouldn't have to decode the entire file as instructions, assuming the code doesn't jump all over the place. You might only have to go as far as the HALT, if all the jnz's jump backwards (if that makes sense).\n\nEdit: in fact, from around offset 0xab onward, it definitely looks like data for a while. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> (increasing integers from 0x0b to 0xff).[/quote:23dhk8j0]\n\nI think the main difficulty/issue will be with following (accurately) the adding and subtracting, especially with the addressing '[eax+ebx]' stuff (which is likely for jumping into the data segment to get or set a value there), and in figuring out why its not/never terminating...\n\n---\n\nah, so the bin file is just like assembly code, with a &quot;code segment&quot; and a &quot;data segment&quot;.\n\nso, the upper fourth is the code segment with the opcodes and opdata and then on the far right is any of the flags involved with those operations\n\nthan the data segment with the character/symbol values\n\nsome empty segment: extra segment, heap/free segment, etc ???\n\nand I guess the bottom (4th) segment is another data segment ???\n\ndo the double quotes in the far right column, make the data between them a logical/virtual array segment ??? (like with networking how you can logically/virtually make subnetworks/groups, even though the physical architecture is completely different)\n\n&quot; .... c.... 7.... q..... Z....!...&quot;\n\n&quot;...[....R....E....#.....0.......q......h.....-......w....&quot;",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>jaynabonne wrote:</cite>Did you create the machine.bin file above by hand? If so, there might be a typo (if not, it's just odd). The 1A at 0x34 might be A1.<br/><br/>(BTW, that's some convoluted code there...)</blockquote><br/><br/>ya, that's a typo (thanks for spotting it), it is indeed suppose to be (it is): A1<br/><br/>-----<br/><br/>yes, I did it by hand, lol. at least 3 hrs to do jsut that, one of the first things when I got the time, is to write a program to do this for me, laughs. This program will eventually turn into an assembly debugging/deciphering program... hopefully. HK laughs/grins evilly, I'll have a program that will do/show how a bin file is suppose to run correctly (sometime in the future when I capable of taking it that far)<br/><br/>-----------<br/><br/>I'm pretty methodical and often tri-check everything, so there's probably not too many typos because of it, though can't be perfect, grr<br/><br/>--------<br/><br/><blockquote><cite>jaynabonne wrote:</cite>Here's something to contemplate while looking through the code, as it might help to simplify it in your mind (since it does this a lot).<br/><br/>What is the effect of pairs of instructions like this?<br/><br/><pre><code>xor r2, r2<br/>add r2, r1</code></pre></blockquote><br/><br/>the xor zeros the (first:left) register (if both registers are the same), and then by adding a value to it, you're &quot;setting&quot; it to that new value.<br/><br/>the xor x1, x2 zeroes it (due to xor truth table logic) and if you xor it again, it returns to its value (zeros when done odd number of times, sets/re-sets it again when done even number of times, thus xor is a &quot;bit toggle&quot;, off-on-off-on: zero-set-zero-set)<br/><br/>---------------------<br/><br/><br/><blockquote><cite>jaynabonne wrote:</cite>Looks like a good plan! And keep in mind that there won't just be code in the .bin file. There will be data as well. For example, the first instruction is reading from offset 0x01a3, so you can be fairly sure that that will be a data byte and not a code byte. <br/><br/>So basically you shouldn't have to decode the entire file as instructions, assuming the code doesn't jump all over the place. You might only have to go as far as the HALT, if all the jnz's jump backwards (if that makes sense).<br/><br/>Edit: in fact, from around offset 0xab onward, it definitely looks like data for a while. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> (increasing integers from 0x0b to 0xff).</blockquote><br/><br/>I think the main difficulty/issue will be with following (accurately) the adding and subtracting, especially with the addressing '[eax+ebx]' stuff (which is likely for jumping into the data segment to get or set a value there), and in figuring out why its not/never terminating...<br/><br/>---<br/><br/>ah, so the bin file is just like assembly code, with a &quot;code segment&quot; and a &quot;data segment&quot;.<br/><br/>so, the upper fourth is the code segment with the opcodes and opdata and then on the far right is any of the flags involved with those operations<br/><br/>than the data segment with the character/symbol values<br/><br/>some empty segment: extra segment, heap/free segment, etc ???<br/><br/>and I guess the bottom (4th) segment is another data segment ???<br/><br/>do the double quotes in the far right column, make the data between them a logical/virtual array segment ??? (like with networking how you can logically/virtually make subnetworks/groups, even though the physical architecture is completely different)<br/><br/>&quot; .... c.... 7.... q..... Z....!...&quot;<br/><br/>&quot;...[....R....E....#.....0.......q......h.....-......w....&quot;",
      "PostDate": "2016-03-02T17:20:37+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41550",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "If it's any consolation, I did a quick mockup of a parser in Javascript, and I can't get anything but gibberish when I run this &quot;bin&quot;. I'll see if I can figure out why. It doesn't hang though...\n\n[quote:1wirs90i]the xor zeros the (first:left) register (if both registers are the same), and then by adding a value to it, you're &quot;setting&quot; it to that new value.[/quote:1wirs90i]\n\nYep. So those two instructions are how this processor does a &quot;mov&quot;.\n\nWhat it looks like top me is that the data from 0x1a4 on is an encoded message, and the data from 0x00a0 on is a table used to do the decoding.",
      "EditableFormat": "bbcode",
      "HTML": "If it's any consolation, I did a quick mockup of a parser in Javascript, and I can't get anything but gibberish when I run this &quot;bin&quot;. I'll see if I can figure out why. It doesn't hang though...<br/><br/><blockquote><p>the xor zeros the (first:left) register (if both registers are the same), and then by adding a value to it, you're &quot;setting&quot; it to that new value.</p></blockquote><br/><br/>Yep. So those two instructions are how this processor does a &quot;mov&quot;.<br/><br/>What it looks like top me is that the data from 0x1a4 on is an encoded message, and the data from 0x00a0 on is a table used to do the decoding.",
      "PostDate": "2016-03-02T18:12:59+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41551",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I didn't make that realization/conenction (that it's a mov), laughs, thanks for pointing it out!\n\nso this assignment is somewhat having us decrypt an encrypted message?",
      "EditableFormat": "bbcode",
      "HTML": "I didn't make that realization/conenction (that it's a mov), laughs, thanks for pointing it out!<br/><br/>so this assignment is somewhat having us decrypt an encrypted message?",
      "PostDate": "2016-03-02T18:16:53+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41552",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "It looks like it. I'm wondering if there could be some signed/unsigned whackiness going on. \n\nOk, that was it (to some extent). I needed to make sure my 8-bit values stayed 8-bit. I get this now:\n\n'You either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, N\u007fÕsñúó¼ü}kQ\u001dø,´\u001anD¬o²õü¤2§ÃÙâ÷äµ°\u0004\n\nYou'd think someone teaching a course would be able to spell &quot;interpreter&quot;. (Sorry, couldn't resist.)\n\nThere might still be a problem, given that the bytes after the comma are garbage.",
      "EditableFormat": "bbcode",
      "HTML": "It looks like it. I'm wondering if there could be some signed/unsigned whackiness going on. <br/><br/>Ok, that was it (to some extent). I needed to make sure my 8-bit values stayed 8-bit. I get this now:<br/><br/>'You either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, N\u007fÕsñúó¼ü}kQ\u001dø,´\u001anD¬o²õü¤2§ÃÙâ÷äµ°\u0004<br/><br/>You'd think someone teaching a course would be able to spell &quot;interpreter&quot;. (Sorry, couldn't resist.)<br/><br/>There might still be a problem, given that the bytes after the comma are garbage.",
      "PostDate": "2016-03-02T18:35:47+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41553",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "To be honest, I suspect a typo in the data somewhere. Once the stream gets wrong, it will stay wrong.\n\nIn case you're interested, here's the Javascript code. (I assume since you're giving out the bin file that the class is done.)\n\n[code:q9zdkhyj]    var runner = {\n        execute&#58; function(data) {\n            var ip = 0;\n            var r = &#91;0,0,0,0,0,0&#93;;\n\n            var readByte = function() {\n                return data&#91;ip++&#93;;\n            };\n            var readWord = function() {\n                return readByte()*256 + readByte();\n            };\n\n            var s = &quot;&quot;;\n            var done = false;\n            var reg1, reg2, address;\n\n            while (!done) {\n                var opcode = readByte();\n                switch (opcode) {\n                    case 0x11&#58;\n                        // ADD reg1 reg2 (reg1 = reg1 + reg2)\n                        reg1 = readByte();\n                        reg2 = readByte();\n                        r&#91;reg1&#93; = (r&#91;reg1&#93; + r&#91;reg2&#93;) &amp; 0x00ff;\n                        break;\n\n                    case 0x22&#58;\n                        // SUB reg1, reg2 (reg1 = reg1 - reg2\n                        reg1 = readByte();\n                        reg2 = readByte();\n                        r&#91;reg1&#93; = (r&#91;reg1&#93; - r&#91;reg2&#93;) &amp; 0x00ff;\n                        break;\n\n                    case 0x44&#58;\n                        // XOR reg1, reg2 (reg1 = reg1 ^ reg2\n                        reg1 = readByte();\n                        reg2 = readByte();\n                        r&#91;reg1&#93; = r&#91;reg1&#93; ^ r&#91;reg2&#93;;\n                        break;\n                    case 0x05&#58;\n                        // LOAD reg1, address (reg1 = &#91;address&#93;\n                        reg1 = readByte();\n                        address = readWord();\n                        r&#91;reg1&#93; = data&#91;address&#93;;\n                        break;\n                    case 0x55&#58;\n                        // LOADR reg1, address (reg1 = &#91;address+reg1&#93;\n                        reg1 = readByte();\n                        address = readWord();\n                        r&#91;reg1&#93; = data&#91;address + r&#91;reg1&#93;&#93;;\n                        break;\n                    case 0x06&#58;\n                        // STORE address (&#91;address&#93; = r0)\n                        address = readWord();\n                        data&#91;address&#93; = r&#91;0&#93;;\n                        break;\n                    case 0x66&#58;\n                        // STORER reg1, address (&#91;address+reg1&#93; = r0)\n                        reg1 = readByte();\n                        address = readWord();\n                        data&#91;address + r&#91;reg1&#93;&#93; = r&#91;0&#93;;\n                        break;\n                    case 0xcc&#58;\n                        // OUT reg1 (output character in reg1)\n                        reg1 = readByte();\n                        s += String&#46;fromCharCode(r&#91;reg1&#93;);\n                        break;\n                    case 0xaa&#58;\n                        // JNZ reg1, address\n                        reg1 = readByte();\n                        address = readWord();\n                        if (r&#91;reg1&#93; !== 0)\n                            ip = address;\n                        break;\n                    case 0xff&#58;\n                        done = true;\n                        break;\n                }\n            }\n            return s;\n        }\n    };\n\n    var bin = &#91;\n        0x05,0x04,0x01,0xA3,0x44,0x02,0x02,0x05,0x00,0x01,0xA0,0x05,0x04,0x01,0xA3,0x11,\n        0x00,0x04,0x06,0x01,0xA0,0x05,0x03,0x01,0xA1,0x44,0x01,0x01,0x11,0x01,0x00,0x55,\n        0x01,0x00,0xA0,0x11,0x03,0x01,0x44,0x05,0x05,0x11,0x05,0x00,0x44,0x00,0x00,0x11,\n        0x00,0x03,0x06,0x01,0xA1,0x44,0x00,0x00,0x11,0x00,0x05,0x44,0x01,0x01,0x11,0x01,\n        0x03,0x55,0x01,0x00,0xA0,0x44,0x05,0x05,0x11,0x05,0x01,0x44,0x01,0x01,0x11,0x01,\n        0x00,0x55,0x01,0x00,0xA0,0x44,0x04,0x04,0x11,0x04,0x00,0x44,0x00,0x00,0x11,0x00,\n        0x01,0x66,0x03,0x00,0xA0,0x44,0x00,0x00,0x11,0x00,0x05,0x66,0x04,0x00,0xA0,0x11,\n        0x01,0x05,0x55,0x01,0x00,0xA0,0x44,0x04,0x04,0x11,0x04,0x01,0x44,0x01,0x01,0x11,\n        0x01,0x02,0x55,0x01,0x01,0xA4,0x44,0x01,0x04,0xCC,0x01,0x05,0x04,0x01,0xA3,0x05,\n        0x05,0x01,0xA2,0x11,0x02,0x04,0x22,0x05,0x02,0xAA,0x05,0x00,0x07,0xFF,0x00,0x00,\n        0x63,0x06,0x37,0xA6,0x16,0x84,0xCC,0x71,0xE5,0x5A,0xCD,0x0B,0x0C,0x0D,0x0E,0x0F,\n        0x10,0x11,0x12,0x13,0x14,0x15,0x04,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,\n        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,\n        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x02,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,\n        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,\n        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x09,0x5B,0x5C,0x5D,0x5E,0x5F,\n        0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,\n        0x70,0x07,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,\n        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,\n        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,\n        0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x03,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,\n        0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,\n        0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x01,0x0A,0xCE,0xCF,\n        0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,\n        0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,\n        0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,\n        0x00,0x00,0xAE,0x01,0x8B,0x1B,0xFC,0x2F,0xA9,0xE0,0x11,0xD6,0xE8,0x42,0x24,0x47,\n        0x58,0x33,0x31,0x12,0x00,0xE3,0xF7,0xCD,0xA9,0xDD,0x65,0xD0,0x17,0x4D,0x6A,0x7E,\n        0x1F,0xCD,0xDF,0xB9,0xDE,0xF6,0x03,0x4E,0x1C,0xFD,0xCF,0x89,0x25,0xE9,0x47,0xFD,\n        0xB6,0x35,0x01,0x8A,0x63,0x22,0x87,0x5B,0x52,0x0F,0x45,0x23,0x8B,0xC3,0xA9,0x30,\n        0x0D,0xB4,0xD0,0xFE,0xC1,0xF2,0x00,0xF0,0x71,0x68,0xED,0xE6,0x15,0x04,0xDD,0x19,\n        0x2D,0x0A,0x9D,0x57,0x22,0x87,0x99,0x4C,0x80,0x18,0xD7,0x27,0x2D,0x73,0x27,0x80,\n        0x2F,0xC0,0x29,0x9E,0x8F,0x3D,0x31,0x1D,0x74,0x84,0x64,0x88,0x33,0x1D,0x72,0x20,\n        0xBB,0xFC,0xD6,0x2E,0x26,0xA4,0x16,0x5C,0xF8,0x54,0x6D,0xC5,0xE2,0x4E,0xA3,0x41,\n        0xEE,0x12,0x38,0x1A,0xF9,0x82,0x6E,0xDC,0xC5,0x7A,0x79,0x02,0xC5,0xD9,0x74,0x3F,\n        0xA4,0x3E,0x66,0x36,0x4C,0xBF,0xB4,0xBD,0x9A,0x82,0x36,0x40,0x90,0x50,0x95,0xF4,\n        0x92,0xBD,0x77,0xB9,0x17,0xA2,0xBE,0x8E,0x1B,0x7A,0x98,0x2C,0x1E,0x8E,0x16,0x6E,\n        0xAB,0xCA&#93;;\n\n    var result = runner&#46;execute(bin);\n\n    console&#46;log(result);\n\n[/code:q9zdkhyj]",
      "EditableFormat": "bbcode",
      "HTML": "To be honest, I suspect a typo in the data somewhere. Once the stream gets wrong, it will stay wrong.<br/><br/>In case you're interested, here's the Javascript code. (I assume since you're giving out the bin file that the class is done.)<br/><br/><pre><code>    var runner = {<br/>        execute&#58; function(data) {<br/>            var ip = 0;<br/>            var r = &#91;0,0,0,0,0,0&#93;;<br/><br/>            var readByte = function() {<br/>                return data&#91;ip++&#93;;<br/>            };<br/>            var readWord = function() {<br/>                return readByte()*256 + readByte();<br/>            };<br/><br/>            var s = &quot;&quot;;<br/>            var done = false;<br/>            var reg1, reg2, address;<br/><br/>            while (!done) {<br/>                var opcode = readByte();<br/>                switch (opcode) {<br/>                    case 0x11&#58;<br/>                        // ADD reg1 reg2 (reg1 = reg1 + reg2)<br/>                        reg1 = readByte();<br/>                        reg2 = readByte();<br/>                        r&#91;reg1&#93; = (r&#91;reg1&#93; + r&#91;reg2&#93;) &amp; 0x00ff;<br/>                        break;<br/><br/>                    case 0x22&#58;<br/>                        // SUB reg1, reg2 (reg1 = reg1 - reg2<br/>                        reg1 = readByte();<br/>                        reg2 = readByte();<br/>                        r&#91;reg1&#93; = (r&#91;reg1&#93; - r&#91;reg2&#93;) &amp; 0x00ff;<br/>                        break;<br/><br/>                    case 0x44&#58;<br/>                        // XOR reg1, reg2 (reg1 = reg1 ^ reg2<br/>                        reg1 = readByte();<br/>                        reg2 = readByte();<br/>                        r&#91;reg1&#93; = r&#91;reg1&#93; ^ r&#91;reg2&#93;;<br/>                        break;<br/>                    case 0x05&#58;<br/>                        // LOAD reg1, address (reg1 = &#91;address&#93;<br/>                        reg1 = readByte();<br/>                        address = readWord();<br/>                        r&#91;reg1&#93; = data&#91;address&#93;;<br/>                        break;<br/>                    case 0x55&#58;<br/>                        // LOADR reg1, address (reg1 = &#91;address+reg1&#93;<br/>                        reg1 = readByte();<br/>                        address = readWord();<br/>                        r&#91;reg1&#93; = data&#91;address + r&#91;reg1&#93;&#93;;<br/>                        break;<br/>                    case 0x06&#58;<br/>                        // STORE address (&#91;address&#93; = r0)<br/>                        address = readWord();<br/>                        data&#91;address&#93; = r&#91;0&#93;;<br/>                        break;<br/>                    case 0x66&#58;<br/>                        // STORER reg1, address (&#91;address+reg1&#93; = r0)<br/>                        reg1 = readByte();<br/>                        address = readWord();<br/>                        data&#91;address + r&#91;reg1&#93;&#93; = r&#91;0&#93;;<br/>                        break;<br/>                    case 0xcc&#58;<br/>                        // OUT reg1 (output character in reg1)<br/>                        reg1 = readByte();<br/>                        s += String&#46;fromCharCode(r&#91;reg1&#93;);<br/>                        break;<br/>                    case 0xaa&#58;<br/>                        // JNZ reg1, address<br/>                        reg1 = readByte();<br/>                        address = readWord();<br/>                        if (r&#91;reg1&#93; !== 0)<br/>                            ip = address;<br/>                        break;<br/>                    case 0xff&#58;<br/>                        done = true;<br/>                        break;<br/>                }<br/>            }<br/>            return s;<br/>        }<br/>    };<br/><br/>    var bin = &#91;<br/>        0x05,0x04,0x01,0xA3,0x44,0x02,0x02,0x05,0x00,0x01,0xA0,0x05,0x04,0x01,0xA3,0x11,<br/>        0x00,0x04,0x06,0x01,0xA0,0x05,0x03,0x01,0xA1,0x44,0x01,0x01,0x11,0x01,0x00,0x55,<br/>        0x01,0x00,0xA0,0x11,0x03,0x01,0x44,0x05,0x05,0x11,0x05,0x00,0x44,0x00,0x00,0x11,<br/>        0x00,0x03,0x06,0x01,0xA1,0x44,0x00,0x00,0x11,0x00,0x05,0x44,0x01,0x01,0x11,0x01,<br/>        0x03,0x55,0x01,0x00,0xA0,0x44,0x05,0x05,0x11,0x05,0x01,0x44,0x01,0x01,0x11,0x01,<br/>        0x00,0x55,0x01,0x00,0xA0,0x44,0x04,0x04,0x11,0x04,0x00,0x44,0x00,0x00,0x11,0x00,<br/>        0x01,0x66,0x03,0x00,0xA0,0x44,0x00,0x00,0x11,0x00,0x05,0x66,0x04,0x00,0xA0,0x11,<br/>        0x01,0x05,0x55,0x01,0x00,0xA0,0x44,0x04,0x04,0x11,0x04,0x01,0x44,0x01,0x01,0x11,<br/>        0x01,0x02,0x55,0x01,0x01,0xA4,0x44,0x01,0x04,0xCC,0x01,0x05,0x04,0x01,0xA3,0x05,<br/>        0x05,0x01,0xA2,0x11,0x02,0x04,0x22,0x05,0x02,0xAA,0x05,0x00,0x07,0xFF,0x00,0x00,<br/>        0x63,0x06,0x37,0xA6,0x16,0x84,0xCC,0x71,0xE5,0x5A,0xCD,0x0B,0x0C,0x0D,0x0E,0x0F,<br/>        0x10,0x11,0x12,0x13,0x14,0x15,0x04,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,<br/>        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,<br/>        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x02,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,<br/>        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,<br/>        0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x09,0x5B,0x5C,0x5D,0x5E,0x5F,<br/>        0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,<br/>        0x70,0x07,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,<br/>        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,<br/>        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,<br/>        0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x03,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,<br/>        0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,<br/>        0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x01,0x0A,0xCE,0xCF,<br/>        0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,<br/>        0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,<br/>        0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,<br/>        0x00,0x00,0xAE,0x01,0x8B,0x1B,0xFC,0x2F,0xA9,0xE0,0x11,0xD6,0xE8,0x42,0x24,0x47,<br/>        0x58,0x33,0x31,0x12,0x00,0xE3,0xF7,0xCD,0xA9,0xDD,0x65,0xD0,0x17,0x4D,0x6A,0x7E,<br/>        0x1F,0xCD,0xDF,0xB9,0xDE,0xF6,0x03,0x4E,0x1C,0xFD,0xCF,0x89,0x25,0xE9,0x47,0xFD,<br/>        0xB6,0x35,0x01,0x8A,0x63,0x22,0x87,0x5B,0x52,0x0F,0x45,0x23,0x8B,0xC3,0xA9,0x30,<br/>        0x0D,0xB4,0xD0,0xFE,0xC1,0xF2,0x00,0xF0,0x71,0x68,0xED,0xE6,0x15,0x04,0xDD,0x19,<br/>        0x2D,0x0A,0x9D,0x57,0x22,0x87,0x99,0x4C,0x80,0x18,0xD7,0x27,0x2D,0x73,0x27,0x80,<br/>        0x2F,0xC0,0x29,0x9E,0x8F,0x3D,0x31,0x1D,0x74,0x84,0x64,0x88,0x33,0x1D,0x72,0x20,<br/>        0xBB,0xFC,0xD6,0x2E,0x26,0xA4,0x16,0x5C,0xF8,0x54,0x6D,0xC5,0xE2,0x4E,0xA3,0x41,<br/>        0xEE,0x12,0x38,0x1A,0xF9,0x82,0x6E,0xDC,0xC5,0x7A,0x79,0x02,0xC5,0xD9,0x74,0x3F,<br/>        0xA4,0x3E,0x66,0x36,0x4C,0xBF,0xB4,0xBD,0x9A,0x82,0x36,0x40,0x90,0x50,0x95,0xF4,<br/>        0x92,0xBD,0x77,0xB9,0x17,0xA2,0xBE,0x8E,0x1B,0x7A,0x98,0x2C,0x1E,0x8E,0x16,0x6E,<br/>        0xAB,0xCA&#93;;<br/><br/>    var result = runner&#46;execute(bin);<br/><br/>    console&#46;log(result);<br/><br/></code></pre>",
      "PostDate": "2016-03-02T18:45:11+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41558",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "hmm... so I didn't deal with signed/unsigned such as with the add/sub operations?\n\n(also, I can try to scour for the typos in my hand written bin file vs the real bin file, not sure if I can find them though)\n\n-------\n\nI found a typo:\n\n0000 0103: 63 -&gt; 00\n\nI put in 63, but it was suppose to be 00:\n\n60 61 62 00 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",
      "EditableFormat": "bbcode",
      "HTML": "hmm... so I didn't deal with signed/unsigned such as with the add/sub operations?<br/><br/>(also, I can try to scour for the typos in my hand written bin file vs the real bin file, not sure if I can find them though)<br/><br/>-------<br/><br/>I found a typo:<br/><br/>0000 0103: 63 -&gt; 00<br/><br/>I put in 63, but it was suppose to be 00:<br/><br/>60 61 62 00 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",
      "PostDate": "2016-03-02T20:14:31+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41560",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I don't know if you had, since your registers were 8-bit anyway. But when I was simulating it in Javascript, adding two numbers could result in a value being larger than 0x255, which would stay that large as opposed to having extra bits dropped when shoved into a real 8-bit register,\n\nFor example, if you have an 8-bit register with value 0xff, and you add 1 to it, it wraps back to 0. But in my code, it would become 256 (0x100) since Javascript variables aren't limited to 8 bits. So I had to put some &quot;and 0x00ff&quot;'s in there to clamp it.\n\nBut I don't think your code would have that problem. It was just me. It is something to keep in mind, though.",
      "EditableFormat": "bbcode",
      "HTML": "I don't know if you had, since your registers were 8-bit anyway. But when I was simulating it in Javascript, adding two numbers could result in a value being larger than 0x255, which would stay that large as opposed to having extra bits dropped when shoved into a real 8-bit register,<br/><br/>For example, if you have an 8-bit register with value 0xff, and you add 1 to it, it wraps back to 0. But in my code, it would become 256 (0x100) since Javascript variables aren't limited to 8 bits. So I had to put some &quot;and 0x00ff&quot;'s in there to clamp it.<br/><br/>But I don't think your code would have that problem. It was just me. It is something to keep in mind, though.",
      "PostDate": "2016-03-02T20:23:28+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41561",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:4wet17kb](also, I can try to scour for the typos in my hand written bin file vs the real bin file, not sure if I can find them though)[/quote:4wet17kb]\n\nYou could also email me the bin file, if it would be easier. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I could hex dump it and send it back to you.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>(also, I can try to scour for the typos in my hand written bin file vs the real bin file, not sure if I can find them though)</p></blockquote><br/><br/>You could also email me the bin file, if it would be easier. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I could hex dump it and send it back to you.",
      "PostDate": "2016-03-02T20:26:30+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41562",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I just found another error in the latest code you posted.\n\nIn the jnz_enum handler, you need this:\n\n[code:2aju1k7g]movzx edx, program_buffer&#91;ebx&#93;[/code:2aju1k7g]\n\nto be this:\n\n[code:2aju1k7g]movzx edx, word ptr program_buffer&#91;ebx&#93;[/code:2aju1k7g]\n\nOtherwise, it will only read the 8-bit value into edx instead of a 16-bit value. That's the danger of something like movzx, where it's &quot;overloaded&quot; with different flavors, and you have to be careful which one you use.\n\nThat would actually explain why it loops forever - the address was 00 07, and it would grab the 00 byte instead of the 0007 word, jump back to the beginning, and reset the R2 loop index to 0.",
      "EditableFormat": "bbcode",
      "HTML": "I just found another error in the latest code you posted.<br/><br/>In the jnz_enum handler, you need this:<br/><br/><pre><code>movzx edx, program_buffer&#91;ebx&#93;</code></pre><br/><br/>to be this:<br/><br/><pre><code>movzx edx, word ptr program_buffer&#91;ebx&#93;</code></pre><br/><br/>Otherwise, it will only read the 8-bit value into edx instead of a 16-bit value. That's the danger of something like movzx, where it's &quot;overloaded&quot; with different flavors, and you have to be careful which one you use.<br/><br/>That would actually explain why it loops forever - the address was 00 07, and it would grab the 00 byte instead of the 0007 word, jump back to the beginning, and reset the R2 loop index to 0.",
      "PostDate": "2016-03-02T20:37:42+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41563",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "it doesn't take too long (halfway through them already), I just have to make sure I don't miss any typos...\n\nhmm.. then where's my mistake in my operations/code, grr..\n\nyour answer suggests that it's quite a lot of work to track/map through it, as it does several resets to zero (it has to get a lot of characters and start over each time)... it'd take me some time to go through every step... which I'm going to do, but that's a lot of steps to find all the values, address, and movements, and etc... to then try to find where the issue is with my my program isn't working... fun fun...",
      "EditableFormat": "bbcode",
      "HTML": "it doesn't take too long (halfway through them already), I just have to make sure I don't miss any typos...<br/><br/>hmm.. then where's my mistake in my operations/code, grr..<br/><br/>your answer suggests that it's quite a lot of work to track/map through it, as it does several resets to zero (it has to get a lot of characters and start over each time)... it'd take me some time to go through every step... which I'm going to do, but that's a lot of steps to find all the values, address, and movements, and etc... to then try to find where the issue is with my my program isn't working... fun fun...",
      "PostDate": "2016-03-02T20:38:09+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41564",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "oops... a simple mistake I overlooked/missed in my code, thanks for spotting it.\n\nI just posted a typo I found in the previous post of mine or a few posts back...\n\n0000 0103: 63 -&gt; 00\n\nI put in 63, but it is suppose to be: 00\n\n60 61 62 00 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",
      "EditableFormat": "bbcode",
      "HTML": "oops... a simple mistake I overlooked/missed in my code, thanks for spotting it.<br/><br/>I just posted a typo I found in the previous post of mine or a few posts back...<br/><br/>0000 0103: 63 -&gt; 00<br/><br/>I put in 63, but it is suppose to be: 00<br/><br/>60 61 62 00 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",
      "PostDate": "2016-03-02T20:38:56+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41565",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "That's better. Now I get this:\n\n'You either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, whichever way, well done!  The ke&amp;&quot;\u0012~/1\u001b-çÁadwÔÊ\u001f³úüLë\u0002Õ2¶\u001dv/&quot;Ï\th\u0003G!½\u0014ô'\n\nSo probably still something somewhere.\n\nBe sure to check out my code correction above. I bet if you fix that (plus the other corrections I gave you), your assembly might actually work!",
      "EditableFormat": "bbcode",
      "HTML": "That's better. Now I get this:<br/><br/>'You either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, whichever way, well done!  The ke&amp;&quot;\u0012~/1\u001b-çÁadwÔÊ\u001f³úüLë\u0002Õ2¶\u001dv/&quot;Ï\th\u0003G!½\u0014ô'<br/><br/>So probably still something somewhere.<br/><br/>Be sure to check out my code correction above. I bet if you fix that (plus the other corrections I gave you), your assembly might actually work!",
      "PostDate": "2016-03-02T20:51:06+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41566",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "oh wow, wow, wow, it works, it works, it works !!!!\n\n(I just can't bloody read the font on the command line prompt box, laughs...)\n\nYou either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, whichever way, well done! The key you rebuilt is 'eMuL8T0r!'. Chilliwilli.\n\nI'm not sure on that last part... lol (the font is really hard for me to read...)\n\n-----\n\nbloody simple mistake on my part with not having that last 'word ptr'... and I thought it was something more complex/deep with my operation algorithm logic/manipulation/calculations, laughs.",
      "EditableFormat": "bbcode",
      "HTML": "oh wow, wow, wow, it works, it works, it works !!!!<br/><br/>(I just can't bloody read the font on the command line prompt box, laughs...)<br/><br/>You either disassembled the code + rewrote it, wrote an interpretter or tied your brain in knots, whichever way, well done! The key you rebuilt is 'eMuL8T0r!'. Chilliwilli.<br/><br/>I'm not sure on that last part... lol (the font is really hard for me to read...)<br/><br/>-----<br/><br/>bloody simple mistake on my part with not having that last 'word ptr'... and I thought it was something more complex/deep with my operation algorithm logic/manipulation/calculations, laughs.",
      "PostDate": "2016-03-02T20:53:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41567",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Woo hoo! Congrats. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "Woo hoo! Congrats. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-03-02T20:54:57+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41568",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "All thanks to you! <!-- s:D --><img src=\"{SMILIES_PATH}/icon_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D -->\n\nI have to thank you 2^16 times, and I think I only thanked you ~ 30 times so far <!-- s;) --><img src=\"{SMILIES_PATH}/icon_wink.gif\" alt=\";)\" title=\"Wink\" /><!-- s;) -->\n\n--------\n\nmy (hand) re-write of the machine.bin, probably still have some typos in it, preventing it from working for you\n\n(I'll email the file to you a bit later on, as I got to do some of my other homework I've been putting off due to working on this assembly lab, as it's easier that way, no typos)",
      "EditableFormat": "bbcode",
      "HTML": "All thanks to you! <!-- s:D --><img src=\"{SMILIES_PATH}/icon_biggrin.gif\" alt=\":D\" title=\"Very Happy\" /><!-- s:D --><br/><br/>I have to thank you 2^16 times, and I think I only thanked you ~ 30 times so far <!-- s;) --><img src=\"{SMILIES_PATH}/icon_wink.gif\" alt=\";)\" title=\"Wink\" /><!-- s;) --><br/><br/>--------<br/><br/>my (hand) re-write of the machine.bin, probably still have some typos in it, preventing it from working for you<br/><br/>(I'll email the file to you a bit later on, as I got to do some of my other homework I've been putting off due to working on this assembly lab, as it's easier that way, no typos)",
      "PostDate": "2016-03-02T20:55:34+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41569",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "lol. No problem. I'm glad we got there in the end. You had the vast majority of it right. I think if you had more time, you would have worked out the few minor issues.",
      "EditableFormat": "bbcode",
      "HTML": "lol. No problem. I'm glad we got there in the end. You had the vast majority of it right. I think if you had more time, you would have worked out the few minor issues.",
      "PostDate": "2016-03-02T20:59:14+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41708",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Sorry about this Jay, but I'm stumped again on our next assignment:\n\n(it's due this wed., the 16th, so only got a short window left on it to get any possible help, as I've been trying to do it on my own, sighs)\n\nevaluating/parsing a mathematical equation\n\nusing this (user inputted) equation syntax:\n\nnumber(space)operator(space)number\n\nthe 'numbers' (operands 1+2) are from a single digit char to signed dwords (bit 32:sign + 2^31:value), aka: 1 to 11 characters, range: -(2^31) to +(2^31), -2147483648 to +2147483648\n\noperator: +, -, *, /\n\ntwo required functions (procedures):\n\nASCII to Decimal :: args: esi=source array address, ecx=source array size :: decimal value return=eax :: preserve other regs\n\nDecimal to ASCII :: generated ascii characters needed (including the sign) to display decimal value return=ecx :: args: reg=destination array address, ecx=max size of destination array :: preserve other regs\n\nalso, we don't have to verify that the input is valid; all input will be valid\n\n--------\n\nafter 3 days of trying to do just the first part (ascii to decimal function) myself, in mostly total failure (a lot of it was jsut trying to figure out what exactly was the logic design that the two required functions were asking of me, and how to do their design), I found this:\n\n<!-- m --><a class=\"postlink\" href=\"http://www.winasm.net/forum/index.php?showtopic=2724\">http://www.winasm.net/forum/index.php?showtopic=2724</a><!-- m -->\n\nand I think I partly understand it, but not fully... if you could explain it to me, I'd be appreciative. In my 3 days of trying to figure out the logic on my own... I was actually on the right track... except... I was trying to figure out how to do the bit shifting without doing bit shifting, lol. I was hoping I could put the decimals into an array, and then byte ptr move that array into eax, lol. I tried... sighs.\n\nI'm not clear on how the flags work (carry), especially in relation to the arithmetic operations, and whether I need to do 'neg eax', if my operand(s) are negative, or whether I actually use/put the decimal value of the '-' char into, or if I add in a '1' to, the highest/most significant (32/31) bit of eax, instead.\n\nI don't understand the bit shifting and/or bit arithmetic, nor its carrying/borrowing, nor the carry flag and nor its role, at all, sighs.\n\n-------\n\nmy undertanding:\n\n1. the person's (the link above) code (the ascii to decimal function) will ret an operand's decimal value, meaning that I need to get the size/length of the operand for it to do so, meaning further that I need to do this twice, once for each operand. the user input array will be max length of 27: 11~operand1 + 3~space~operator~space + 11 operand2 + carriagereturn~newlinefeed)\n\n2. not sure how I handle the operator in terms of whether I need to get its decimal value or just use a comparison for what operation to do\n\n3. handle the possible operations, divide by zero error, prompt user of under/over flow\n\n4. for the decimal to ascii function, do I need to actually convert from the decimal values back into the ascii or will it automatically display correctly the ascii from the decimal values? Also, I believe that I need to make a new array (of max length: 11~operand1 + 3~space~operator~space + 11~operand2 + 3~space~equals~space + 11:result~answer)",
      "EditableFormat": "bbcode",
      "HTML": "Sorry about this Jay, but I'm stumped again on our next assignment:<br/><br/>(it's due this wed., the 16th, so only got a short window left on it to get any possible help, as I've been trying to do it on my own, sighs)<br/><br/>evaluating/parsing a mathematical equation<br/><br/>using this (user inputted) equation syntax:<br/><br/>number(space)operator(space)number<br/><br/>the 'numbers' (operands 1+2) are from a single digit char to signed dwords (bit 32:sign + 2^31:value), aka: 1 to 11 characters, range: -(2^31) to +(2^31), -2147483648 to +2147483648<br/><br/>operator: +, -, *, /<br/><br/>two required functions (procedures):<br/><br/>ASCII to Decimal :: args: esi=source array address, ecx=source array size :: decimal value return=eax :: preserve other regs<br/><br/>Decimal to ASCII :: generated ascii characters needed (including the sign) to display decimal value return=ecx :: args: reg=destination array address, ecx=max size of destination array :: preserve other regs<br/><br/>also, we don't have to verify that the input is valid; all input will be valid<br/><br/>--------<br/><br/>after 3 days of trying to do just the first part (ascii to decimal function) myself, in mostly total failure (a lot of it was jsut trying to figure out what exactly was the logic design that the two required functions were asking of me, and how to do their design), I found this:<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.winasm.net/forum/index.php?showtopic=2724\">http://www.winasm.net/forum/index.php?showtopic=2724</a><!-- m --><br/><br/>and I think I partly understand it, but not fully... if you could explain it to me, I'd be appreciative. In my 3 days of trying to figure out the logic on my own... I was actually on the right track... except... I was trying to figure out how to do the bit shifting without doing bit shifting, lol. I was hoping I could put the decimals into an array, and then byte ptr move that array into eax, lol. I tried... sighs.<br/><br/>I'm not clear on how the flags work (carry), especially in relation to the arithmetic operations, and whether I need to do 'neg eax', if my operand(s) are negative, or whether I actually use/put the decimal value of the '-' char into, or if I add in a '1' to, the highest/most significant (32/31) bit of eax, instead.<br/><br/>I don't understand the bit shifting and/or bit arithmetic, nor its carrying/borrowing, nor the carry flag and nor its role, at all, sighs.<br/><br/>-------<br/><br/>my undertanding:<br/><br/>1. the person's (the link above) code (the ascii to decimal function) will ret an operand's decimal value, meaning that I need to get the size/length of the operand for it to do so, meaning further that I need to do this twice, once for each operand. the user input array will be max length of 27: 11~operand1 + 3~space~operator~space + 11 operand2 + carriagereturn~newlinefeed)<br/><br/>2. not sure how I handle the operator in terms of whether I need to get its decimal value or just use a comparison for what operation to do<br/><br/>3. handle the possible operations, divide by zero error, prompt user of under/over flow<br/><br/>4. for the decimal to ascii function, do I need to actually convert from the decimal values back into the ascii or will it automatically display correctly the ascii from the decimal values? Also, I believe that I need to make a new array (of max length: 11~operand1 + 3~space~operator~space + 11~operand2 + 3~space~equals~space + 11:result~answer)",
      "PostDate": "2016-03-14T16:09:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41709",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "A few immediate thoughts:\n\n1) I wouldn't bother with all the bit shifting. It's an optimization to use (n &lt;&lt; 3) + (n &lt;&lt; 1) instead of simply multiplying the stupid thing by 10. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Back in &quot;the old days&quot;, you would resort to such tricks for performance reasons, but I doubt you need to worry about that for this assignment. Just know that if you were using this a lot (e.g. parsing XML SOAP requests on a heavily hit server) it might matter. But you don't need that for your work. \n\n2) As well, the carry check is to see if the addition has overflowed (that is, the number is too large to fit in 32-bits). If you're guaranteed to have valid numbers, you don't need to worry about that either. (I do see you mention overflow, but that will probably happen more when you do the actual operation, not when you're parsing the numbers.)\n\n3) You will need to neg eax (or whatever you're accumulating in) if the initial character is a '-'. Simply setting the high bit would not work - you need to take the real two's-complement negative or it won't be right.\n\nThe basic idea behind converting ASCII to a number is to take the digits one by one, from left to right in this case. As you take each digit, multiply what you have so far by 10 (move it up a numeric &quot;slot&quot;) and then add the ASCII digit - '0' (the ASCII for 0) to form the next part of the sum. You do need to check the initial character for a '-' sign, and you need to know when you have run out of digits for the first number by looking for a non-numeric (your operation character, for example).\n\nFor converting back to ASCII, the easiest way to process it is to generate the digits backwards or use recursion (e.g. to get digits for n, if n &gt; 10, then get digits for n/10 and add n mod 10 as a digit to the result. Iteratively is more or less the same thing.) The problem with working it iteratively backwards is the digits come out in reverse order... Recursion solves that problem since you dive down to the first digit before you work your way back up the stack, adding the digits in order. We can discuss that further if you like. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> The alternative to working it backwards is to work out the largest power of 10 that the number has (e.g. for 12589, your initial divisor would be 10000), and then use that for your divisor, dividing your divisor by 10 each time until you get to 1. I don't have that details of that algorithm in my head at the moment, but it could be worked out.\n\nI'm leaving work now for home, but let me know what you think so far.",
      "EditableFormat": "bbcode",
      "HTML": "A few immediate thoughts:<br/><br/>1) I wouldn't bother with all the bit shifting. It's an optimization to use (n &lt;&lt; 3) + (n &lt;&lt; 1) instead of simply multiplying the stupid thing by 10. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Back in &quot;the old days&quot;, you would resort to such tricks for performance reasons, but I doubt you need to worry about that for this assignment. Just know that if you were using this a lot (e.g. parsing XML SOAP requests on a heavily hit server) it might matter. But you don't need that for your work. <br/><br/>2) As well, the carry check is to see if the addition has overflowed (that is, the number is too large to fit in 32-bits). If you're guaranteed to have valid numbers, you don't need to worry about that either. (I do see you mention overflow, but that will probably happen more when you do the actual operation, not when you're parsing the numbers.)<br/><br/>3) You will need to neg eax (or whatever you're accumulating in) if the initial character is a '-'. Simply setting the high bit would not work - you need to take the real two's-complement negative or it won't be right.<br/><br/>The basic idea behind converting ASCII to a number is to take the digits one by one, from left to right in this case. As you take each digit, multiply what you have so far by 10 (move it up a numeric &quot;slot&quot;) and then add the ASCII digit - '0' (the ASCII for 0) to form the next part of the sum. You do need to check the initial character for a '-' sign, and you need to know when you have run out of digits for the first number by looking for a non-numeric (your operation character, for example).<br/><br/>For converting back to ASCII, the easiest way to process it is to generate the digits backwards or use recursion (e.g. to get digits for n, if n &gt; 10, then get digits for n/10 and add n mod 10 as a digit to the result. Iteratively is more or less the same thing.) The problem with working it iteratively backwards is the digits come out in reverse order... Recursion solves that problem since you dive down to the first digit before you work your way back up the stack, adding the digits in order. We can discuss that further if you like. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> The alternative to working it backwards is to work out the largest power of 10 that the number has (e.g. for 12589, your initial divisor would be 10000), and then use that for your divisor, dividing your divisor by 10 each time until you get to 1. I don't have that details of that algorithm in my head at the moment, but it could be worked out.<br/><br/>I'm leaving work now for home, but let me know what you think so far.",
      "PostDate": "2016-03-14T17:26:50+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41719",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I found that my prof also provided sample code for 'ascii to bcd', in which his code also checks for ( and then does the proper &quot;bit placing/accumulating' ) if the array is even or odd in length. Do I need to utilize this for my code? (though, I'm not able to follow/understand his code to well, I'm a bit clue-less on understanding all of this, so I'd probably have trouble implementing his code design into my attempted code design at this stuff)\n\nI'm still a bit confused on some specifics with the ascii to decimal conversion, using the online person's code (the link I provided in previous post):\n\n********\nedit:\nI understand that I can just do 'x10', but I'd need that explained to me in how it's working as well, so since I think I'm somewhat understanding the bit shifting, maybe we should just stay with using that (and it is optimized code design that we should be using regardless of if it actually makes a difference or not in this case), and explain how this bit shifting and carrying works, as I just need to understand these specifics to understand it, whereas if we were to use the 'x10', I'd probably need a lot more explaining of how it works and how to properly apply it... well, whatever, maybe you should decide which will be easier for you to use, to help me, and I'll just go with that.\n********\n\nthe bit shifting is initially using '0' (=30h), and then the next char-number is the first char-number of the array, correct? Am I right to presume that this is to get the size of the shifting/multiplying (aka: 0-9 -&gt; decimal -&gt; x10 for digit shifting) ??? So, do I want to do the same for my code, or do I want to take whatever the array's first 0-9 char-number is and use that for my initial bit shifting, instead of '0' (30h), or do I want to actually take the sign (if there is a sign), and use that as my first char-number??? Also, aside of whether I apply it first or not, do/am I even suppose to use the sign within this entire &quot;bit-placing/accumulating&quot; proceedure at all or not? Also, If I'm not applying the sign into the eax (this is the holding array for the bit parsing / accumulation), how do I handle the highest bit not being used (bit 32) by the bit accumulation/parsing, is this why the person's code is using '0' (30h), or do I just use the first char-number of the array for the highest bit or should I skip past the highest bit and start with the second highest bit (bit 31) ?\n\nalso when doing the bit shifting... do I need to do anything with the carry, as if I do the 'shl 3' correctly, the first char-number gets its high bit pushed into the carry slot, correct ??? Do I need to add it back into the highest bit, or does it do that for me ??? Also, when I do the shift again for the next char-number, don't I completely lose my first char-number (and so for for each additional char-number added) ??? I'm not really understanding how this 'bit placement/accumulating' is working, presumably correctly (or do I need to do anything with it, like adding back in the carry slot's values, or having to shift it back 3 to the right, etc etc etc) ... ???\n\n--------\n\nI'll probably need some help with figuring out how to do the recursion or iteration for converting it back into the ascii... but I'll try on my own... if I even get that far... sighs\n\n------\n\nall of this, different number system and bit using, arithmetic is totally new to me, so I'm a bit lost, depsite that I probably should be understanding it, I did get to calculus, but that was many years ago... I'm finding myself just not as smart in math as I was back then, sighs. I guess those brain cells are dying off, as I'm getting older and older, laughs-sighs. Also, back then, none of my math classes ever covered using different number systems and bits manipulation/arithmetic. No computer science word problems, lol.",
      "EditableFormat": "bbcode",
      "HTML": "I found that my prof also provided sample code for 'ascii to bcd', in which his code also checks for ( and then does the proper &quot;bit placing/accumulating' ) if the array is even or odd in length. Do I need to utilize this for my code? (though, I'm not able to follow/understand his code to well, I'm a bit clue-less on understanding all of this, so I'd probably have trouble implementing his code design into my attempted code design at this stuff)<br/><br/>I'm still a bit confused on some specifics with the ascii to decimal conversion, using the online person's code (the link I provided in previous post):<br/><br/>********<br/>edit:<br/>I understand that I can just do 'x10', but I'd need that explained to me in how it's working as well, so since I think I'm somewhat understanding the bit shifting, maybe we should just stay with using that (and it is optimized code design that we should be using regardless of if it actually makes a difference or not in this case), and explain how this bit shifting and carrying works, as I just need to understand these specifics to understand it, whereas if we were to use the 'x10', I'd probably need a lot more explaining of how it works and how to properly apply it... well, whatever, maybe you should decide which will be easier for you to use, to help me, and I'll just go with that.<br/>********<br/><br/>the bit shifting is initially using '0' (=30h), and then the next char-number is the first char-number of the array, correct? Am I right to presume that this is to get the size of the shifting/multiplying (aka: 0-9 -&gt; decimal -&gt; x10 for digit shifting) ??? So, do I want to do the same for my code, or do I want to take whatever the array's first 0-9 char-number is and use that for my initial bit shifting, instead of '0' (30h), or do I want to actually take the sign (if there is a sign), and use that as my first char-number??? Also, aside of whether I apply it first or not, do/am I even suppose to use the sign within this entire &quot;bit-placing/accumulating&quot; proceedure at all or not? Also, If I'm not applying the sign into the eax (this is the holding array for the bit parsing / accumulation), how do I handle the highest bit not being used (bit 32) by the bit accumulation/parsing, is this why the person's code is using '0' (30h), or do I just use the first char-number of the array for the highest bit or should I skip past the highest bit and start with the second highest bit (bit 31) ?<br/><br/>also when doing the bit shifting... do I need to do anything with the carry, as if I do the 'shl 3' correctly, the first char-number gets its high bit pushed into the carry slot, correct ??? Do I need to add it back into the highest bit, or does it do that for me ??? Also, when I do the shift again for the next char-number, don't I completely lose my first char-number (and so for for each additional char-number added) ??? I'm not really understanding how this 'bit placement/accumulating' is working, presumably correctly (or do I need to do anything with it, like adding back in the carry slot's values, or having to shift it back 3 to the right, etc etc etc) ... ???<br/><br/>--------<br/><br/>I'll probably need some help with figuring out how to do the recursion or iteration for converting it back into the ascii... but I'll try on my own... if I even get that far... sighs<br/><br/>------<br/><br/>all of this, different number system and bit using, arithmetic is totally new to me, so I'm a bit lost, depsite that I probably should be understanding it, I did get to calculus, but that was many years ago... I'm finding myself just not as smart in math as I was back then, sighs. I guess those brain cells are dying off, as I'm getting older and older, laughs-sighs. Also, back then, none of my math classes ever covered using different number systems and bits manipulation/arithmetic. No computer science word problems, lol.",
      "PostDate": "2016-03-14T22:30:58+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41722",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "What might help is to break it down to simple cases. Let's work through a few, and see if it becomes clear at all.\n\nFirst case is a single digit.\n\nImagine that someone enters the number &quot;9&quot; in the string as ASCII. You'd want that to show up as the value 9 in your register when all is said and done. But the value you get when you read that character from the buffer actually has value 57 (0x39). The number zero has ASCII value 48. (See this table, if it helps: <!-- m --><a class=\"postlink\" href=\"http://ascii.cl/\">http://ascii.cl/</a><!-- m --> ). So in order to get your '9' converted to the number 9, you need to subtract the value '0' (ASCII 48) from your '9' to give you the value 9 (57-48 = 9). You will need to do that with each digit you read as you read it. That's why the code you linked to is subtracting '0' from the value before adding it to the buffer.\n\nSo that is straightforward. To convert from ASCII to a value for a single digit, you subtract '0' (the ASCII value for the character '0').\n\nConsider now the case where someone types the number &quot;35&quot;. The first character you read from the buffer will be '3'. You subtract '0' from that to get 3. If that were the last digit, you'd be done (as before). But looking forward, you see the next character is another digit. How do you deal with it?\n\nYou deal with it as you would numbers in general. When *you* look at the number &quot;35&quot; you think &quot;thirty-five&quot; or &quot;three tens and five&quot;, or 3x10 + 5. Similarly, &quot;732&quot; would be seven hundreds, three tens and 2 ones: 7x10x10 + 3x10 + 2. As you go up in digits, they are multiplied by another 10.\n\nAs before, assume you've read the '3' and have the value 3 in your register. Now you read the '5'. What do you do with it? Well, first of all, it's clear now that the '3' you had before was actually 3 tens and what you have next is 5 ones (so far). So in order to make room for the new digit coming in, you need to multiply the current value by 10: 3 -&gt; 30. Then you subtract '0' from '5' to get 5, and add that in: 30 + 5 -&gt; 35.\n\nIf you were then to find more digits, you'd continue to do the same thing: multiply by ten to &quot;shift&quot; the digit left. Then add in the next one. If the characters were &quot;781&quot;, your register would have successively values 7, 78 and then 781, as you encounter each digit.\n\n'7' -&gt; 7\n'8' -&gt; 7x10 + 8 = 78\n'1' -&gt; 78x10 + 1 = 781\n\nIt looks like the first digit is special, but it isn't. If you prime your register with 0, then you can do the same in all cases:\n\nInitialize to 0\n'7' -&gt; 0x10 + 7 = 7\n'8' -&gt; 7x10 + 8 = 78\n'1' -&gt; 78x10 + 1 = 781\n\nThat's the basic idea for reading an ASCII string of digits and converting it to a number: for each digit, multiply your current accumulator by 10 and then add in the the normalized (value - '0') digit.\n\nNow, you can do shifts if you want. But I personally would just do something like &quot;imul eax,10&quot; and be done with it.\n\nAlso, you shouldn't see a carry unless you overflow a 32-bit number. You can decide if you want to deal with that (it would be some sort of error condition), but if the teacher said the numbers will always be legal, then you can dispense with that.",
      "EditableFormat": "bbcode",
      "HTML": "What might help is to break it down to simple cases. Let's work through a few, and see if it becomes clear at all.<br/><br/>First case is a single digit.<br/><br/>Imagine that someone enters the number &quot;9&quot; in the string as ASCII. You'd want that to show up as the value 9 in your register when all is said and done. But the value you get when you read that character from the buffer actually has value 57 (0x39). The number zero has ASCII value 48. (See this table, if it helps: <!-- m --><a class=\"postlink\" href=\"http://ascii.cl/\">http://ascii.cl/</a><!-- m --> ). So in order to get your '9' converted to the number 9, you need to subtract the value '0' (ASCII 48) from your '9' to give you the value 9 (57-48 = 9). You will need to do that with each digit you read as you read it. That's why the code you linked to is subtracting '0' from the value before adding it to the buffer.<br/><br/>So that is straightforward. To convert from ASCII to a value for a single digit, you subtract '0' (the ASCII value for the character '0').<br/><br/>Consider now the case where someone types the number &quot;35&quot;. The first character you read from the buffer will be '3'. You subtract '0' from that to get 3. If that were the last digit, you'd be done (as before). But looking forward, you see the next character is another digit. How do you deal with it?<br/><br/>You deal with it as you would numbers in general. When *you* look at the number &quot;35&quot; you think &quot;thirty-five&quot; or &quot;three tens and five&quot;, or 3x10 + 5. Similarly, &quot;732&quot; would be seven hundreds, three tens and 2 ones: 7x10x10 + 3x10 + 2. As you go up in digits, they are multiplied by another 10.<br/><br/>As before, assume you've read the '3' and have the value 3 in your register. Now you read the '5'. What do you do with it? Well, first of all, it's clear now that the '3' you had before was actually 3 tens and what you have next is 5 ones (so far). So in order to make room for the new digit coming in, you need to multiply the current value by 10: 3 -&gt; 30. Then you subtract '0' from '5' to get 5, and add that in: 30 + 5 -&gt; 35.<br/><br/>If you were then to find more digits, you'd continue to do the same thing: multiply by ten to &quot;shift&quot; the digit left. Then add in the next one. If the characters were &quot;781&quot;, your register would have successively values 7, 78 and then 781, as you encounter each digit.<br/><br/>'7' -&gt; 7<br/>'8' -&gt; 7x10 + 8 = 78<br/>'1' -&gt; 78x10 + 1 = 781<br/><br/>It looks like the first digit is special, but it isn't. If you prime your register with 0, then you can do the same in all cases:<br/><br/>Initialize to 0<br/>'7' -&gt; 0x10 + 7 = 7<br/>'8' -&gt; 7x10 + 8 = 78<br/>'1' -&gt; 78x10 + 1 = 781<br/><br/>That's the basic idea for reading an ASCII string of digits and converting it to a number: for each digit, multiply your current accumulator by 10 and then add in the the normalized (value - '0') digit.<br/><br/>Now, you can do shifts if you want. But I personally would just do something like &quot;imul eax,10&quot; and be done with it.<br/><br/>Also, you shouldn't see a carry unless you overflow a 32-bit number. You can decide if you want to deal with that (it would be some sort of error condition), but if the teacher said the numbers will always be legal, then you can dispense with that.",
      "PostDate": "2016-03-14T23:13:14+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41723",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "As far as converting from a number back to ASCII, keep the basic trick in mind: given your current number N, then N mod 10 is the next lowest digit of the number (e.g. 783 mod 10 is 3). And N div 10 is the remaining digits (e.g. 783 / 10 = 78). Multiplying by 10 shifts a digit left. Dividing by 10 shifts a digit right. And to convert from the digit back to ASCII, you have to add '0' back on before putting it in the buffer to turn it into a printable ASCII digit.\n\nWhere do you get mod (also known as &quot;the remainder&quot;)? Look at the &quot;div&quot; instruction:\n\n<!-- m --><a class=\"postlink\" href=\"https://pdos.csail.mit.edu/6.828/2009/readings/i386/DIV.htm\">https://pdos.csail.mit.edu/6.828/2009/r ... 86/DIV.htm</a><!-- m -->\n\nIt gives you both at once!\n\n[code:2wqvr2en]Size    Dividend     Divisor   Quotient   Remainder\n    byte    AX           r/m8       AL          AH\n    word    DX&#58;AX        r/m16      AX          DX\n    dword   EDX&#58;EAX      r/m32      EAX         EDX\n[/code:2wqvr2en]",
      "EditableFormat": "bbcode",
      "HTML": "As far as converting from a number back to ASCII, keep the basic trick in mind: given your current number N, then N mod 10 is the next lowest digit of the number (e.g. 783 mod 10 is 3). And N div 10 is the remaining digits (e.g. 783 / 10 = 78). Multiplying by 10 shifts a digit left. Dividing by 10 shifts a digit right. And to convert from the digit back to ASCII, you have to add '0' back on before putting it in the buffer to turn it into a printable ASCII digit.<br/><br/>Where do you get mod (also known as &quot;the remainder&quot;)? Look at the &quot;div&quot; instruction:<br/><br/><!-- m --><a class=\"postlink\" href=\"https://pdos.csail.mit.edu/6.828/2009/readings/i386/DIV.htm\">https://pdos.csail.mit.edu/6.828/2009/r ... 86/DIV.htm</a><!-- m --><br/><br/>It gives you both at once!<br/><br/><pre><code>Size    Dividend     Divisor   Quotient   Remainder<br/>    byte    AX           r/m8       AL          AH<br/>    word    DX&#58;AX        r/m16      AX          DX<br/>    dword   EDX&#58;EAX      r/m32      EAX         EDX<br/></code></pre>",
      "PostDate": "2016-03-14T23:17:53+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41727",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "If you follow the above for converting back, then it's easy to generate the number in reverse.\n\n[code:2xasxzeq]while N &gt;= 10\n    store next digit&#58; (N mod 10) + '0'\n    N = N /10\nstore last digit&#58; (N mod 10) + '0'[/code:2xasxzeq]\n\nHowever, if your number is 9462, you'd get digits '2', '6, '4' and '9, in that order. If you know how many digits you'll be generating up front (D), then you could start D bytes into the buffer and just work your way backwards. You can do that by dividing by 10 until you hit a number less than 10, counting how many divides you do. (e.g. 15689 would divide by 10 four times before you're left with 1, so you would start 4 bytes into the buffer and work backwards).\n\nThe recursive  approach is more interesting, but let the above all digest first (and I'm off to bed). Let me know which bits are still unclear, at least about the first part. That part should be fairly straightforward. Going back to ASCII is the trickier part.",
      "EditableFormat": "bbcode",
      "HTML": "If you follow the above for converting back, then it's easy to generate the number in reverse.<br/><br/><pre><code>while N &gt;= 10<br/>    store next digit&#58; (N mod 10) + '0'<br/>    N = N /10<br/>store last digit&#58; (N mod 10) + '0'</code></pre><br/><br/>However, if your number is 9462, you'd get digits '2', '6, '4' and '9, in that order. If you know how many digits you'll be generating up front (D), then you could start D bytes into the buffer and just work your way backwards. You can do that by dividing by 10 until you hit a number less than 10, counting how many divides you do. (e.g. 15689 would divide by 10 four times before you're left with 1, so you would start 4 bytes into the buffer and work backwards).<br/><br/>The recursive  approach is more interesting, but let the above all digest first (and I'm off to bed). Let me know which bits are still unclear, at least about the first part. That part should be fairly straightforward. Going back to ASCII is the trickier part.",
      "PostDate": "2016-03-14T23:30:41+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41728",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "quick question, for indirect addressing...\n\narray address: esi\narray length: ecx\n\ndoes ' esi[-ecx] ' reference index 0; Is esi[-ecx] == esi[0]; and is esi[ - (ecx-1: pretend ecx got dec/sub) ] == esi[1]; eci[ - (ecx - 2) ] == esi[2], ???\n\nas, should I use this method above (if it works) or just increment 'ebx' (from 0: xor ebx, ebx) ???\n(as if I can use ecx, then I can reference from the beginning or from the end: more versatile, compared to incrementing ebx from 0: ya, I could get the ending values too when using ebx, but I think it'd take at least 1 more operation...)\n\n----------\n\nalso, should I use the string operations (I don't know if you're familiar with them-don't know what version they got added: lods, stos, movs, cmps, etc: err... do I use byte/word/dword ???) or not (I don't need to use them, I can use the normal operations/instructions) ???\n\n------------\n\nah, so with the (left: x10) shifting (ascii to decimal), I shouldn't be getting any carry, and also the first char-number shouldn't be pushed into bit 32 (or do I use '0' as the first char-number so that bit 32 gets '0', and then afterword, I do the neg if neded, ???), ???\n\nbtw, does it matter if I use hexidecimal ('0' = 30h), or do I have to use decimal ('0' = 48t); is '01h' the same  as '1t' for the bit working/shifting (48 t = 0011 0000 y = 30 h) ???\n\ninput: -1234567\neax: 0000 0000\n\n1: 31h - 30h = 1h\neax: 0000 0001\nx10 (my brain can't process this in terms of bit/binary shifting, lol) / shl 3\neax: 0000 1000\n```+0011 0000\neax: 0011 1000\n```+0011 0000\neax: 0110 1000\nis this correct ?\n\n2: 32h - 30h = 2\neax: 0110 1010\nx10 (my brain can't process x10 in terms of bit/binary shifting, lol), so I'm using instead: shl 3\n`` 0 1101 0100\n`` 1 1010 1000\n`` 1 0101 0000\neax: 0101 0000\n```+0011 0000\neax: 1000 0000\n```+0011 0000\neax: 1011 0000\n\nI'm lost... argh... is this correct? or am I completely lost?",
      "EditableFormat": "bbcode",
      "HTML": "quick question, for indirect addressing...<br/><br/>array address: esi<br/>array length: ecx<br/><br/>does ' esi[-ecx] ' reference index 0; Is esi[-ecx] == esi[0]; and is esi[ - (ecx-1: pretend ecx got dec/sub) ] == esi[1]; eci[ - (ecx - 2) ] == esi[2], ???<br/><br/>as, should I use this method above (if it works) or just increment 'ebx' (from 0: xor ebx, ebx) ???<br/>(as if I can use ecx, then I can reference from the beginning or from the end: more versatile, compared to incrementing ebx from 0: ya, I could get the ending values too when using ebx, but I think it'd take at least 1 more operation...)<br/><br/>----------<br/><br/>also, should I use the string operations (I don't know if you're familiar with them-don't know what version they got added: lods, stos, movs, cmps, etc: err... do I use byte/word/dword ???) or not (I don't need to use them, I can use the normal operations/instructions) ???<br/><br/>------------<br/><br/>ah, so with the (left: x10) shifting (ascii to decimal), I shouldn't be getting any carry, and also the first char-number shouldn't be pushed into bit 32 (or do I use '0' as the first char-number so that bit 32 gets '0', and then afterword, I do the neg if neded, ???), ???<br/><br/>btw, does it matter if I use hexidecimal ('0' = 30h), or do I have to use decimal ('0' = 48t); is '01h' the same  as '1t' for the bit working/shifting (48 t = 0011 0000 y = 30 h) ???<br/><br/>input: -1234567<br/>eax: 0000 0000<br/><br/>1: 31h - 30h = 1h<br/>eax: 0000 0001<br/>x10 (my brain can't process this in terms of bit/binary shifting, lol) / shl 3<br/>eax: 0000 1000<br/>```+0011 0000<br/>eax: 0011 1000<br/>```+0011 0000<br/>eax: 0110 1000<br/>is this correct ?<br/><br/>2: 32h - 30h = 2<br/>eax: 0110 1010<br/>x10 (my brain can't process x10 in terms of bit/binary shifting, lol), so I'm using instead: shl 3<br/>`` 0 1101 0100<br/>`` 1 1010 1000<br/>`` 1 0101 0000<br/>eax: 0101 0000<br/>```+0011 0000<br/>eax: 1000 0000<br/>```+0011 0000<br/>eax: 1011 0000<br/><br/>I'm lost... argh... is this correct? or am I completely lost?",
      "PostDate": "2016-03-14T23:49:53+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41733",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "To be honest, I would not be concerned with bits and shifting. Or even binary. It's only going to confuse things. That's I was suggesting just sticking with multiplying by 10, because *it's what the algorithm is doing*, as opposed to the bit shifty fiddliness which is just trying to do an optimal x10 anyway. You would have the exact same algorithm even if you were writing it (say) in Javascript - or Quest! But we can go there a little if you wish.\n\nYour internal digits you store without the ASCII-ness, So when you get your first digit, You want eax in the end to be the actual value of the number.\n\nSo you would start out with eax as 0.\n\nFirst digit, 1:\n\nimul eax, 10               00000000   (still 0)\nget next byte from array into ebx (movzx etc).     ebx = '1'\nsub bl, '0'                                                             ebx = 1 (a character will always fit in the low byte, so you can just sub on bl)\nadd eax, ebx             00000001   (after first digit, value is 1)\n\nSecond digit, 2:\n\nimul eax, 10               00001010   (now 10, or 0ah)\nget next byte from array into ebx (movzx etc).      ebx = '2'\nsub bl, '0'                                                             ebx = 2\nadd eax, ebx             00001100   (after second digit, value is 12)\n\nThird digit, 3:\n\nimul eax, 10               00010100   (now 36, or 024h)\nget next byte from array into ebx (movzx etc).       ebx = '3'\nsub bl, '0'                                                               ebx = 3\nadd eax, ebx             00010111   (after third digit, value is 39)\n\nYou're not accumulating the 30h stuff in there. You're stripping it out. Just x10 and then add (the digit-'0'). And you can use any sort of number notation you wish. 32 va 020h is the same number, just specified differently. It doesn't matter internally. That's why using '0' makes more sense in this case, because it actually has to do with characters. as opposed to a sort of magic number like 48 or 030h.\n\nAs far as your first question goes, I don't know. But that's an interesting idea. Try it out! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nThe lods instruction (at least how I knew it) is just shorthand for loading and incrementing. So lodsb is just\n\nmov al, [esi]\nadd esi, 1\n\nlodsw is just:\n\nmov ax, [esi]\nadd esi, 2\n\netc. So it's up to you if you want to use it or not. Again, that's really more of an optimization, but if you happen to have things set up where esi points to what you want and you want to load the value into al and have esi incremented when you're done, then it might fit.",
      "EditableFormat": "bbcode",
      "HTML": "To be honest, I would not be concerned with bits and shifting. Or even binary. It's only going to confuse things. That's I was suggesting just sticking with multiplying by 10, because *it's what the algorithm is doing*, as opposed to the bit shifty fiddliness which is just trying to do an optimal x10 anyway. You would have the exact same algorithm even if you were writing it (say) in Javascript - or Quest! But we can go there a little if you wish.<br/><br/>Your internal digits you store without the ASCII-ness, So when you get your first digit, You want eax in the end to be the actual value of the number.<br/><br/>So you would start out with eax as 0.<br/><br/>First digit, 1:<br/><br/>imul eax, 10               00000000   (still 0)<br/>get next byte from array into ebx (movzx etc).     ebx = '1'<br/>sub bl, '0'                                                             ebx = 1 (a character will always fit in the low byte, so you can just sub on bl)<br/>add eax, ebx             00000001   (after first digit, value is 1)<br/><br/>Second digit, 2:<br/><br/>imul eax, 10               00001010   (now 10, or 0ah)<br/>get next byte from array into ebx (movzx etc).      ebx = '2'<br/>sub bl, '0'                                                             ebx = 2<br/>add eax, ebx             00001100   (after second digit, value is 12)<br/><br/>Third digit, 3:<br/><br/>imul eax, 10               00010100   (now 36, or 024h)<br/>get next byte from array into ebx (movzx etc).       ebx = '3'<br/>sub bl, '0'                                                               ebx = 3<br/>add eax, ebx             00010111   (after third digit, value is 39)<br/><br/>You're not accumulating the 30h stuff in there. You're stripping it out. Just x10 and then add (the digit-'0'). And you can use any sort of number notation you wish. 32 va 020h is the same number, just specified differently. It doesn't matter internally. That's why using '0' makes more sense in this case, because it actually has to do with characters. as opposed to a sort of magic number like 48 or 030h.<br/><br/>As far as your first question goes, I don't know. But that's an interesting idea. Try it out! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>The lods instruction (at least how I knew it) is just shorthand for loading and incrementing. So lodsb is just<br/><br/>mov al, [esi]<br/>add esi, 1<br/><br/>lodsw is just:<br/><br/>mov ax, [esi]<br/>add esi, 2<br/><br/>etc. So it's up to you if you want to use it or not. Again, that's really more of an optimization, but if you happen to have things set up where esi points to what you want and you want to load the value into al and have esi incremented when you're done, then it might fit.",
      "PostDate": "2016-03-15T07:21:40+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41734",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "And what I would do is get it to work for simple cases, and then extend it. For example, just get it working parsing positive numbers as a first step. Then once that's working, make the minor changes needed to handle negative numbers. If you incrementally evolve your code rather than trying to wrap your head around the entire algorithm at once, it can become much easier. Find the next incremental step and do it:\n\n1) make it work for a single digit. Get the structure of the algorithm in place.\n2) make it work for two digits, but keep it working for one. That requires you to check for the second digit conditionally (an &quot;if&quot;) and to merge them together.\n3) convert your &quot;if&quot; into a loop to handle all digits. At this point you can handle positive numbers.\n4) add the special code to check the first character for a '-'. If so, remember that state, skip the character and do what you did before for a positive number, but then coming back at the end to negate the result.\n\n(This, by the way, is the essence of TDD, except you do the above in the context of writing tests, so you can be sure you don't break previous behavior as you add new behavior.).",
      "EditableFormat": "bbcode",
      "HTML": "And what I would do is get it to work for simple cases, and then extend it. For example, just get it working parsing positive numbers as a first step. Then once that's working, make the minor changes needed to handle negative numbers. If you incrementally evolve your code rather than trying to wrap your head around the entire algorithm at once, it can become much easier. Find the next incremental step and do it:<br/><br/>1) make it work for a single digit. Get the structure of the algorithm in place.<br/>2) make it work for two digits, but keep it working for one. That requires you to check for the second digit conditionally (an &quot;if&quot;) and to merge them together.<br/>3) convert your &quot;if&quot; into a loop to handle all digits. At this point you can handle positive numbers.<br/>4) add the special code to check the first character for a '-'. If so, remember that state, skip the character and do what you did before for a positive number, but then coming back at the end to negate the result.<br/><br/>(This, by the way, is the essence of TDD, except you do the above in the context of writing tests, so you can be sure you don't break previous behavior as you add new behavior.).",
      "PostDate": "2016-03-15T07:29:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41735",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "question about using:\n\nEQU (equates ~ enumeration, as I'm trying to get into the habit of not use 'magic numbers' ~ obviously for human usage having lots of these &quot;variables:equates/enums&quot; are good, so long as your program can handle the mem usage of using/creating all of these &quot;variables&quot;, is this the general philosophy / best practice ??? Is it preferred to use equates even when they'd be static, non-dynamic, anyways, or shold you just plug in the literal values into all the individual code lines ??? for example of a static equate like NULL_PTR, as it's always 0, why not just use 0, why waste your mem / stack space ??? I know that by using equates you're commenting about what they represent, but besides this human reason, is there any reason to use an equate if it's just going to be static, instead of the literal values ???)\n\nis there a difference with using them in terms of setting them to: decimal or hexidecimal ???\n\nfor example:\n\nNULL_PTR EQU 0 t/d\nvs\nNULL_PTR EQU 00 h\nvs\nASCII_ZERO EQU = 48 t/d\nvs\nASCII_ZERO EQU = 30 h\nvs\nNULL_PTR EQU 48 t/d\nvs\nNULL_PTR EQU 30 h\nvs\nASCII_ZERO EQU = 0 t/d\nvs\nASCII_ZERO EQU = 00 h\n\nI'm confused with when I need to use &quot;ASCII_values&quot; vs &quot;actual_numeric_value/digits&quot;\n\nfor example, for 'ExitProcess' do I use '0' (30 h ~ 48 t/d) or do I use 0 (0 d/t ~ 00 h) ???\n\nor another example:\n\ncmp byte ptr [esi], ??? ; this is the checking compare to if you've got a value for your operand (the other is its out of bounds value of, for a dword, 9)\n\ndo I use '0' (30 h ~ 48 d/t) or 0 (00 h ~ 0 d/t) ???\n\n-------------\n\nah, so I was just wrongly using the 'ASCII' binary values (in just trying to understand how the shl is working ~ I know I can just use the shifting code, but I want to understand it), instead of the actual 0-9 values in trying to do the shifting work on paper, to understand it. whoops (no wonder it was coming out so weirdly for me on paper), laughs.\n\nEDIT: thank you for the examples of all of the types/ways of doing it, that helps a lot with understanding what is going on!\n\nEDIT 2: (Timing their execution would be a good way to examine/delve into processing speed optimization, they'd make for a good test case, hehe)\n\n------\n\nI'll post my code up soon of what I got done so far (still just working on stuff up to the 'asci to decimal' function and that function itself too ~ I haven't yet started on the operation coding nor the 'decimal to ascii' coding) ... as I likely have some errors/syntax (still unsure of when I need to use the data type pointers vs not needing them, so I probably went a little overboard with them). I program too slow, sighs. This is another thing I really need to improve upon... but right now, I still waste a lot of time trying to come up with the needed logic and/or design constructs for my programs, which prevent me from quickly doing these programs (as well as not being a fast typer in general, let alone to even slower, for me, of code-syntax typing), sighs.\n\nI don't have any testable code yet... I need to learn how to quickly set up code/program in assembly that can run/be tested... sighs.",
      "EditableFormat": "bbcode",
      "HTML": "question about using:<br/><br/>EQU (equates ~ enumeration, as I'm trying to get into the habit of not use 'magic numbers' ~ obviously for human usage having lots of these &quot;variables:equates/enums&quot; are good, so long as your program can handle the mem usage of using/creating all of these &quot;variables&quot;, is this the general philosophy / best practice ??? Is it preferred to use equates even when they'd be static, non-dynamic, anyways, or shold you just plug in the literal values into all the individual code lines ??? for example of a static equate like NULL_PTR, as it's always 0, why not just use 0, why waste your mem / stack space ??? I know that by using equates you're commenting about what they represent, but besides this human reason, is there any reason to use an equate if it's just going to be static, instead of the literal values ???)<br/><br/>is there a difference with using them in terms of setting them to: decimal or hexidecimal ???<br/><br/>for example:<br/><br/>NULL_PTR EQU 0 t/d<br/>vs<br/>NULL_PTR EQU 00 h<br/>vs<br/>ASCII_ZERO EQU = 48 t/d<br/>vs<br/>ASCII_ZERO EQU = 30 h<br/>vs<br/>NULL_PTR EQU 48 t/d<br/>vs<br/>NULL_PTR EQU 30 h<br/>vs<br/>ASCII_ZERO EQU = 0 t/d<br/>vs<br/>ASCII_ZERO EQU = 00 h<br/><br/>I'm confused with when I need to use &quot;ASCII_values&quot; vs &quot;actual_numeric_value/digits&quot;<br/><br/>for example, for 'ExitProcess' do I use '0' (30 h ~ 48 t/d) or do I use 0 (0 d/t ~ 00 h) ???<br/><br/>or another example:<br/><br/>cmp byte ptr [esi], ??? ; this is the checking compare to if you've got a value for your operand (the other is its out of bounds value of, for a dword, 9)<br/><br/>do I use '0' (30 h ~ 48 d/t) or 0 (00 h ~ 0 d/t) ???<br/><br/>-------------<br/><br/>ah, so I was just wrongly using the 'ASCII' binary values (in just trying to understand how the shl is working ~ I know I can just use the shifting code, but I want to understand it), instead of the actual 0-9 values in trying to do the shifting work on paper, to understand it. whoops (no wonder it was coming out so weirdly for me on paper), laughs.<br/><br/>EDIT: thank you for the examples of all of the types/ways of doing it, that helps a lot with understanding what is going on!<br/><br/>EDIT 2: (Timing their execution would be a good way to examine/delve into processing speed optimization, they'd make for a good test case, hehe)<br/><br/>------<br/><br/>I'll post my code up soon of what I got done so far (still just working on stuff up to the 'asci to decimal' function and that function itself too ~ I haven't yet started on the operation coding nor the 'decimal to ascii' coding) ... as I likely have some errors/syntax (still unsure of when I need to use the data type pointers vs not needing them, so I probably went a little overboard with them). I program too slow, sighs. This is another thing I really need to improve upon... but right now, I still waste a lot of time trying to come up with the needed logic and/or design constructs for my programs, which prevent me from quickly doing these programs (as well as not being a fast typer in general, let alone to even slower, for me, of code-syntax typing), sighs.<br/><br/>I don't have any testable code yet... I need to learn how to quickly set up code/program in assembly that can run/be tested... sighs.",
      "PostDate": "2016-03-15T10:08:19+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41736",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The shifting code is doing a specific manipulation to generate a x10. It uses the fact that 10 = 8 + 2. So &quot;times 10&quot; is &quot;times 8 &quot;+ &quot;times 2&quot;. To get a &quot;times 8&quot;, you shift left three times. To get a &quot;times 2&quot; you shift left once, or add the number again. \n\nIf eax had the number, then you can do this:\n\nmov ebx, eax     ; save number\nshl eax, 3          ; *8\nadd eax, ebx     '; *9\nadd eax, ebx     '; *10\n\nor\n\nmov ebx, eax     ; save number\nshl eax, 3          ; *8\nshl ebx, 1          ; *2\nadd eax, ebx     '; *10\n\nor \n\nmov ebx, eax     ; save number\nadd eax, ebx     '; *2\nadd eax, ebx     '; *3\nadd eax, ebx     '; *4\nadd eax, ebx     '; *5\nadd eax, ebx     '; *6\nadd eax, ebx     '; *7\nadd eax, ebx     '; *8\nadd eax, ebx     '; *9\nadd eax, ebx     '; *10\n\nor\n\nmul eax, 10",
      "EditableFormat": "bbcode",
      "HTML": "The shifting code is doing a specific manipulation to generate a x10. It uses the fact that 10 = 8 + 2. So &quot;times 10&quot; is &quot;times 8 &quot;+ &quot;times 2&quot;. To get a &quot;times 8&quot;, you shift left three times. To get a &quot;times 2&quot; you shift left once, or add the number again. <br/><br/>If eax had the number, then you can do this:<br/><br/>mov ebx, eax     ; save number<br/>shl eax, 3          ; *8<br/>add eax, ebx     '; *9<br/>add eax, ebx     '; *10<br/><br/>or<br/><br/>mov ebx, eax     ; save number<br/>shl eax, 3          ; *8<br/>shl ebx, 1          ; *2<br/>add eax, ebx     '; *10<br/><br/>or <br/><br/>mov ebx, eax     ; save number<br/>add eax, ebx     '; *2<br/>add eax, ebx     '; *3<br/>add eax, ebx     '; *4<br/>add eax, ebx     '; *5<br/>add eax, ebx     '; *6<br/>add eax, ebx     '; *7<br/>add eax, ebx     '; *8<br/>add eax, ebx     '; *9<br/>add eax, ebx     '; *10<br/><br/>or<br/><br/>mul eax, 10",
      "PostDate": "2016-03-15T10:39:12+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41738",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Note: I edited my previous post (some extra questions there), if you wouldn't mind looking over it again to see my new questions, I'd be appreciative.\n\n-------------------\n\nhere's my work so far... still trying to figure out the &quot;program flow/order&quot; and some functions too, ...\n\nmaking the labels be procedures will probably help simplify it for me, ...\n\nI'm just trying to work/brainstorm the functions and program flow/order out for now, but will probably move them to being procedures.\n\n[code:ehcbwp9k];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to emulate/parse a mathematical equation\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\nINPUT_BUFFER_SIZE\t\tEQU\t\t1Bh\nOUTPUT_BUFFER_SIZE\t\tEQU\t\t29h\n\nSPACE\t\t\t\t\tEQU\t\t20h\n\nQUESTION_MARK\t\t\tEQU\t\t3Fh\n\nEQUAL\t\t\t\t\tEQU\t\t3Dh\n\nNEGATIVE\t\t\t\tEQU\t\t2Dh\n\nADDITION\t\t\t\tEQU\t\t2Bh\nSUBTRACTION\t\t\t\tEQU\t\t2Dh\nMULTIPLICATION\t\t\tEQU\t\t2Ah\nDIVISON\t\t\t\t\tEQU\t\t2Ch\n\nZERO\t\t\t\t\tEQU\t\t30h\nONE\t\t\t\t\t\tEQU\t\t31h\nTWO\t\t\t\t\t\tEQU\t\t32h\nTHREE\t\t\t\t\tEQU\t\t33h\nFOUR\t\t\t\t\tEQU\t\t34h\nFIVE\t\t\t\t\tEQU\t\t35h\nSIX\t\t\t\t\t\tEQU\t\t36h\nSEVEN\t\t\t\t\tEQU\t\t37h\nEIGHT\t\t\t\t\tEQU\t\t38h\nNINE\t\t\t\t\tEQU\t\t39h\n\nRETURN_ERROR\t\t\tEQU\t\t01h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\\n\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\ninput_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\\n\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noutput_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\\n\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ndivision_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\\n\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noverflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nunderflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ninput_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (QUESTION_MARK)\n\noutput_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (QUESTION_MARK)\n\noperand_1\t\t\t\tsdword\tQUESTION_MARK\noperand_2\t\t\t\tsdword\tQUESTION_MARK\nresult_value\t\t\tsdword\tQUESTION_MARK\n\t\t\t\t\t\t\t\t\nreturn_code\t\t\t\tdword\tNULL_POINTER\n\nbytes_written\t\t\tdword\tQUESTION_MARK\nbytes_read\t\t\t\tdword\tQUESTION_MARK\nhandle_standard_out\t\tdword\tQUESTION_MARK\nhandle_standard_in\t\tdword\tQUESTION_MARK\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_stardard_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_standard_in, eax\n\t\n\t;**************\n\t; Program Info\n\t;**************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\\n\t\t\tsizeof history, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\n\t;***********************\n\t; Prompt for User Input\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\\n\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Get User Input\n\t;****************\n\t\n\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\\n\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER\n\t\n\t;*********\n\t; Program\n\t;*********\n\t\n\tPre_Start&#58;\n\t\n\t\tmov\t\tesi, offset input_buffer\n\t\tmovzx\tebp, byte ptr bytes_read\n\t\n\t\tmov \tedi, offset output_buffer\n\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE\n\t\n\t\txor \teax, eax\n\t\txor \tebx, ebx\n\t\txor \tecx, ecx\n\t\n\tGet_Operand_Size&#58;\n\t\t\n\t\tcmp\t\tesi&#91;ebx&#93;, SPACE\n\t\tje\t\tSet_Operand_Size\n\t\t\n\t\tadd\t\tebx, byte ptr ONE\n\t\t\n\t\tjmp\t\tGet_Operand_Size\n\t\t\n\tSet_Operand_Size&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\n\tStart&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\t\n\tAddition&#58;\n\t\n\t\tadc\t\toperand_1, operand_2\n\t\n\tSubtraction&#58;\n\t\n\t\tsbb\t\toperand_1, operand_2\n\t\n\tMultiplication&#58;\n\t\n\t\timul\toperand_1, operand_2\n\t\n\tDivision&#58;\n\t\n\t\tcmp \toperand_2, ZERO\n\t\tje\t\tDivision_By_Zero\n\t\n\t\tidiv\toperand_1, operand_2\n\t\n\t;***********************\n\t; Display Output Prompt\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\\n\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Display Output\n\t;****************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\\n\t\t\tsizeof xxx, offset bytes_written, NULL_POINTER\n\t\t\t\n\tInvalid_Input&#58;\n\t\n\t\tmovzx\treturn_code, RETURN_ERROR\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, return_code\n\t\t\t\nMain\tendp\n\t\t\t\n\t\nASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,\n\n\tlocal\tsign_value\tbyte\tZERO\n\t\t\n\tlocal \tPre_Start_ASCII_To_Decimal&#58;\n\t\t\n\t\tcmp\t\tbyte ptr &#91;esi&#93;,\tZERO\n\t\tje\t\tInvalid_Input\n\t\t\n\t\tcmp\t\tbyte ptr &#91;esi&#93;,\tNINE\n\t\tje\t\tInvalid_Input\n\t\t\n\t\tmovzx\tedx, byte ptr eax\n\t\tsub\t\tedx, ZERO\n\t\tadd\t\teax, edx\n\n\tlocal\tStart_ASCII_To_Decimal&#58;\n\t\t\n\t\tcmp\t\tecx, ZERO\n\t\tje\t\tSign_ASCII_To_Decimal\n\t\t\n\t\tmovzx \tedx, eax\n\t\tshl\t\teax, byte ptr THREE\n\t\tadd\t\teax, edx\n\t\tadd\t\teax, edx\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;-ecx&#93;\n\t\tsub\t\tedx, ZERO\n\t\tadd\t\teax, edx\n\t\t\n\t\tsub\t\tecx, byte ptr ONE\n\t\t\n\t\tjmp\t\tStart_ASCII_To_Decimal\n\t\t\n\tlocal \tSign_ASCII_To_Decimal&#58;\n\t\n\t\tcmp\t\tesi&#91;ebx&#93;, SIGN\n\t\tjne\t\tFinish_ASCII_To_Decimal\n\t\t\n\t\tneg\t\teax\n\t\t\n\tlocal\tFinish_ASCII_To_Decimal&#58;\n\t\n\t\tret\n\nASCII_To_Decimal endp\n\nDecimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,\n\t\t\n\t\tret\n\t\t\nDecimal_To_ASCII endp\n\t\t\t\n\t\tend Main[/code:ehcbwp9k]",
      "EditableFormat": "bbcode",
      "HTML": "Note: I edited my previous post (some extra questions there), if you wouldn't mind looking over it again to see my new questions, I'd be appreciative.<br/><br/>-------------------<br/><br/>here's my work so far... still trying to figure out the &quot;program flow/order&quot; and some functions too, ...<br/><br/>making the labels be procedures will probably help simplify it for me, ...<br/><br/>I'm just trying to work/brainstorm the functions and program flow/order out for now, but will probably move them to being procedures.<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to emulate/parse a mathematical equation<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>INPUT_BUFFER_SIZE\t\tEQU\t\t1Bh<br/>OUTPUT_BUFFER_SIZE\t\tEQU\t\t29h<br/><br/>SPACE\t\t\t\t\tEQU\t\t20h<br/><br/>QUESTION_MARK\t\t\tEQU\t\t3Fh<br/><br/>EQUAL\t\t\t\t\tEQU\t\t3Dh<br/><br/>NEGATIVE\t\t\t\tEQU\t\t2Dh<br/><br/>ADDITION\t\t\t\tEQU\t\t2Bh<br/>SUBTRACTION\t\t\t\tEQU\t\t2Dh<br/>MULTIPLICATION\t\t\tEQU\t\t2Ah<br/>DIVISON\t\t\t\t\tEQU\t\t2Ch<br/><br/>ZERO\t\t\t\t\tEQU\t\t30h<br/>ONE\t\t\t\t\t\tEQU\t\t31h<br/>TWO\t\t\t\t\t\tEQU\t\t32h<br/>THREE\t\t\t\t\tEQU\t\t33h<br/>FOUR\t\t\t\t\tEQU\t\t34h<br/>FIVE\t\t\t\t\tEQU\t\t35h<br/>SIX\t\t\t\t\t\tEQU\t\t36h<br/>SEVEN\t\t\t\t\tEQU\t\t37h<br/>EIGHT\t\t\t\t\tEQU\t\t38h<br/>NINE\t\t\t\t\tEQU\t\t39h<br/><br/>RETURN_ERROR\t\t\tEQU\t\t01h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\<br/>\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>input_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\<br/>\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>output_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\<br/>\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>division_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\<br/>\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>overflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>underflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t<br/>\t\t\t\t\t\t\t\t<br/>input_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (QUESTION_MARK)<br/><br/>output_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (QUESTION_MARK)<br/><br/>operand_1\t\t\t\tsdword\tQUESTION_MARK<br/>operand_2\t\t\t\tsdword\tQUESTION_MARK<br/>result_value\t\t\tsdword\tQUESTION_MARK<br/>\t\t\t\t\t\t\t\t<br/>return_code\t\t\t\tdword\tNULL_POINTER<br/><br/>bytes_written\t\t\tdword\tQUESTION_MARK<br/>bytes_read\t\t\t\tdword\tQUESTION_MARK<br/>handle_standard_out\t\tdword\tQUESTION_MARK<br/>handle_standard_in\t\tdword\tQUESTION_MARK<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_stardard_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_standard_in, eax<br/>\t<br/>\t;**************<br/>\t; Program Info<br/>\t;**************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\<br/>\t\t\tsizeof history, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;***********************<br/>\t; Prompt for User Input<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\<br/>\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Get User Input<br/>\t;****************<br/>\t<br/>\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\<br/>\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER<br/>\t<br/>\t;*********<br/>\t; Program<br/>\t;*********<br/>\t<br/>\tPre_Start&#58;<br/>\t<br/>\t\tmov\t\tesi, offset input_buffer<br/>\t\tmovzx\tebp, byte ptr bytes_read<br/>\t<br/>\t\tmov \tedi, offset output_buffer<br/>\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE<br/>\t<br/>\t\txor \teax, eax<br/>\t\txor \tebx, ebx<br/>\t\txor \tecx, ecx<br/>\t<br/>\tGet_Operand_Size&#58;<br/>\t\t<br/>\t\tcmp\t\tesi&#91;ebx&#93;, SPACE<br/>\t\tje\t\tSet_Operand_Size<br/>\t\t<br/>\t\tadd\t\tebx, byte ptr ONE<br/>\t\t<br/>\t\tjmp\t\tGet_Operand_Size<br/>\t\t<br/>\tSet_Operand_Size&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t<br/>\tStart&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\t<br/>\tAddition&#58;<br/>\t<br/>\t\tadc\t\toperand_1, operand_2<br/>\t<br/>\tSubtraction&#58;<br/>\t<br/>\t\tsbb\t\toperand_1, operand_2<br/>\t<br/>\tMultiplication&#58;<br/>\t<br/>\t\timul\toperand_1, operand_2<br/>\t<br/>\tDivision&#58;<br/>\t<br/>\t\tcmp \toperand_2, ZERO<br/>\t\tje\t\tDivision_By_Zero<br/>\t<br/>\t\tidiv\toperand_1, operand_2<br/>\t<br/>\t;***********************<br/>\t; Display Output Prompt<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\<br/>\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Display Output<br/>\t;****************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\<br/>\t\t\tsizeof xxx, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tInvalid_Input&#58;<br/>\t<br/>\t\tmovzx\treturn_code, RETURN_ERROR<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, return_code<br/>\t\t\t<br/>Main\tendp<br/>\t\t\t<br/>\t<br/>ASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,<br/><br/>\tlocal\tsign_value\tbyte\tZERO<br/>\t\t<br/>\tlocal \tPre_Start_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tcmp\t\tbyte ptr &#91;esi&#93;,\tZERO<br/>\t\tje\t\tInvalid_Input<br/>\t\t<br/>\t\tcmp\t\tbyte ptr &#91;esi&#93;,\tNINE<br/>\t\tje\t\tInvalid_Input<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr eax<br/>\t\tsub\t\tedx, ZERO<br/>\t\tadd\t\teax, edx<br/><br/>\tlocal\tStart_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tcmp\t\tecx, ZERO<br/>\t\tje\t\tSign_ASCII_To_Decimal<br/>\t\t<br/>\t\tmovzx \tedx, eax<br/>\t\tshl\t\teax, byte ptr THREE<br/>\t\tadd\t\teax, edx<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;-ecx&#93;<br/>\t\tsub\t\tedx, ZERO<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tsub\t\tecx, byte ptr ONE<br/>\t\t<br/>\t\tjmp\t\tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal \tSign_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tcmp\t\tesi&#91;ebx&#93;, SIGN<br/>\t\tjne\t\tFinish_ASCII_To_Decimal<br/>\t\t<br/>\t\tneg\t\teax<br/>\t\t<br/>\tlocal\tFinish_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tret<br/><br/>ASCII_To_Decimal endp<br/><br/>Decimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,<br/>\t\t<br/>\t\tret<br/>\t\t<br/>Decimal_To_ASCII endp<br/>\t\t\t<br/>\t\tend Main</code></pre>",
      "PostDate": "2016-03-15T12:23:51+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41739",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[code:1ftfqc1k]add      ebx, byte ptr ONE[/code:1ftfqc1k]\nThis is going to kill you. You just want to increment ebx by 1 (&quot;inc ebx&quot; would do or &quot;add ebx, 1&quot;). You're adding the ASCII value of '1' onto it, which is adding 31h. Not what you want at all.\n\n[code:1ftfqc1k]      cmp      byte ptr &#91;esi&#93;,   ZERO\n      je      Invalid_Input\n      \n      cmp      byte ptr &#91;esi&#93;,   NINE\n      je      Invalid_Input[/code:1ftfqc1k]\nGo back and look at the original code. It was not &quot;je&quot;. It was using the carry to test for below or above. The code should be saying, &quot;If the value is below '0' or above '9', then jump to invalid input.&quot; What you have is &quot;If the value is EQUAL to '0' or EQUAL to '9', then go invalid.&quot;\n\n[code:1ftfqc1k]      shl      eax, byte ptr THREE\n&#46;&#46;&#46;\n  sub      ecx, byte ptr ONE[/code:1ftfqc1k]\n\nYou're conflating things again. You need those to be the values 3 and 1, not '3' (33h) and '1' (31h). I don't see any reason to use EQU's for common numbers like that, the way the code is above (that is, for bare numbers like 3 or 1). You would set an EQU to assign a name to a bare number (e.g. &quot;DAYS_IN_WEEK&quot; = 7), but simply having the symbolic name THREE for the number 3 adds no semantic content whatsoever and actually obscures things, given the extra indirection someone reading your code would need to go through to be sure what's going on. It's only marginally better to use ONE to refer to '1', but even then to me it seems more obscure, unless you name then &quot;ONE_CHAR&quot; or something to indicate the character value for '1'. \n\n\n[code:1ftfqc1k]      movzx   edx, byte ptr eax\n      sub      edx, ZERO\n      add      eax, edx\n\n   local   Start_ASCII_To_Decimal&#58;[/code:1ftfqc1k]\n\nI have no idea what this code is meant to do. EAX doesn't even have a legitimate value at this point - it's not an input parameter and you've never assigned it a value.\n\n[code:1ftfqc1k]cmp      esi&#91;ebx&#93;, SIGN[/code:1ftfqc1k]\nSimilarly, ebx has no value assigned either. Plus you want to check the first character in the string for the minus sign, so you need to do it up front. Otherwise, your bounds checks for '0'-'9' will force it to jump out before you even get to the first digit. (In other words, you need to have a special check and advance off of it before you begin looking at digits. Because it's not a digit.)\n\nFinally, you're reading the string backwards, using your -ecx trick. You don't want to do that. You need to process the number from most significant to least significant as I showed above. If you read the number backwards, then you read the ones digit first, multiply it by 10, etc. which I hope you can see is wrong. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> If you do want to read it backwards, then you should maintain a multiplier which starts off 1 and then becomes 10, 100, etc in turn that you'd multiply onto your next digit to put it in the right place.",
      "EditableFormat": "bbcode",
      "HTML": "<pre><code>add      ebx, byte ptr ONE</code></pre><br/>This is going to kill you. You just want to increment ebx by 1 (&quot;inc ebx&quot; would do or &quot;add ebx, 1&quot;). You're adding the ASCII value of '1' onto it, which is adding 31h. Not what you want at all.<br/><br/><pre><code>      cmp      byte ptr &#91;esi&#93;,   ZERO<br/>      je      Invalid_Input<br/>      <br/>      cmp      byte ptr &#91;esi&#93;,   NINE<br/>      je      Invalid_Input</code></pre><br/>Go back and look at the original code. It was not &quot;je&quot;. It was using the carry to test for below or above. The code should be saying, &quot;If the value is below '0' or above '9', then jump to invalid input.&quot; What you have is &quot;If the value is EQUAL to '0' or EQUAL to '9', then go invalid.&quot;<br/><br/><pre><code>      shl      eax, byte ptr THREE<br/>&#46;&#46;&#46;<br/>  sub      ecx, byte ptr ONE</code></pre><br/><br/>You're conflating things again. You need those to be the values 3 and 1, not '3' (33h) and '1' (31h). I don't see any reason to use EQU's for common numbers like that, the way the code is above (that is, for bare numbers like 3 or 1). You would set an EQU to assign a name to a bare number (e.g. &quot;DAYS_IN_WEEK&quot; = 7), but simply having the symbolic name THREE for the number 3 adds no semantic content whatsoever and actually obscures things, given the extra indirection someone reading your code would need to go through to be sure what's going on. It's only marginally better to use ONE to refer to '1', but even then to me it seems more obscure, unless you name then &quot;ONE_CHAR&quot; or something to indicate the character value for '1'. <br/><br/><br/><pre><code>      movzx   edx, byte ptr eax<br/>      sub      edx, ZERO<br/>      add      eax, edx<br/><br/>   local   Start_ASCII_To_Decimal&#58;</code></pre><br/><br/>I have no idea what this code is meant to do. EAX doesn't even have a legitimate value at this point - it's not an input parameter and you've never assigned it a value.<br/><br/><pre><code>cmp      esi&#91;ebx&#93;, SIGN</code></pre><br/>Similarly, ebx has no value assigned either. Plus you want to check the first character in the string for the minus sign, so you need to do it up front. Otherwise, your bounds checks for '0'-'9' will force it to jump out before you even get to the first digit. (In other words, you need to have a special check and advance off of it before you begin looking at digits. Because it's not a digit.)<br/><br/>Finally, you're reading the string backwards, using your -ecx trick. You don't want to do that. You need to process the number from most significant to least significant as I showed above. If you read the number backwards, then you read the ones digit first, multiply it by 10, etc. which I hope you can see is wrong. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> If you do want to read it backwards, then you should maintain a multiplier which starts off 1 and then becomes 10, 100, etc in turn that you'd multiply onto your next digit to put it in the right place.",
      "PostDate": "2016-03-15T12:49:27+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41743",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "here's my updated (hopefully fully fixed up and logic is correct) code work:\n\n[code:34carqa7];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to emulate/parse a mathematical equation\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\nMAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh\nMAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h\n\nSPACE\t\t\t\t\tEQU\t\t20h\n\nEQUAL\t\t\t\t\tEQU\t\t3Dh\n\nNEGATIVE\t\t\t\tEQU\t\t2Dh\n\nADDITION\t\t\t\tEQU\t\t2Bh\nSUBTRACTION\t\t\t\tEQU\t\t2Dh\nMULTIPLICATION\t\t\tEQU\t\t2Ah\nDIVISON\t\t\t\t\tEQU\t\t2Ch\n\nZERO_ASCII\t\t\t\tEQU\t\t30h\n\nRETURN_ERROR\t\t\tEQU\t\t01h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;,\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\\n\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\ninput_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\\n\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noutput_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\\n\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ndivision_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\\n\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noverflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nunderflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ninput_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)\n\noutput_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)\n\noperand_1\t\t\t\tsdword\t?\noperand_2\t\t\t\tsdword\t?\nresult_value\t\t\tsdword\t?\n\t\t\t\t\t\t\t\t\nreturn_code\t\t\t\tdword\t00h\n\nbytes_read\t\t\t\tdword\t?\nbytes_written\t\t\tdword\t?\nhandle_standard_out\t\tdword\t?\nhandle_standard_in\t\tdword\t?\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_stardard_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_standard_in, eax\n\t\n\t;**************\n\t; Program Info\n\t;**************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\\n\t\t\tsizeof history, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset credit, \\\n\t\t\tsizeof credit, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\n\t;***********************\n\t; Prompt for User Input\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\\n\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Get User Input\n\t;****************\n\t\n\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\\n\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER\n\t\n\t;*********\n\t; Program\n\t;*********\n\t\n\tPre_Start&#58;\n\t\n\t\tmov\t\tesi, offset input_buffer\n\t\tmovzx\tebp, bytes_read\n\t\n\t\tmov \tedi, offset output_buffer\n\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE\n\t\n\t\txor \teax, eax\n\t\txor \tebx, ebx\n\t\txor \tecx, ecx\n\t\n\tGet_Operand_Size&#58;\n\t\t\n\t\tcmp\t\tesi&#91;ebx&#93;, SPACE\n\t\tje\t\tSet_Operand_Size\n\t\t\n\t\tcmp\t\tesi&#91;ebx&#93;, CARRIAGE_RETURN\n\t\tje\t\tSet_Operand_Size\n\t\t\n\t\tadd\t\tebx, 01h\n\t\t\n\t\tjmp\t\tGet_Operand_Size\n\t\t\n\tSet_Operand_Size&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\n\tStart&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\tmovzx\toperand_1, eax\n\t\tadd\t\tebx, 01h\n\t\tjnp\t\tGet_Operand_Size\n\t\t\n\t\t; need to handle getting operator\n\t\t\n\t\t; need to handle getting operand_2\n\t\t\n\tAddition&#58;\n\t\n\t\tadc\t\toperand_1, operand_2\n\t\n\tSubtraction&#58;\n\t\n\t\tsbb\t\toperand_1, operand_2\n\t\n\tMultiplication&#58;\n\t\n\t\timul\toperand_1, operand_2\n\t\n\tDivision&#58;\n\t\n\t\tcmp \toperand_2, 00h\n\t\tje\t\tDivision_By_Zero\n\t\n\t\tidiv\toperand_1, operand_2\n\t\n\t;***********************\n\t; Display Output Prompt\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\\n\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Display Output\n\t;****************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\\n\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER\n\t\t\t\n\tInvalid_Input&#58;\n\t\n\t\tmovzx\treturn_code, RETURN_ERROR\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, return_code\n\t\t\t\nMain\tendp\n\t\t\t\n\t\nASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,\n\t\t\n\tlocal \tPre_Start_ASCII_To_Decimal&#58;\n\t\t\n\t\txor\t\tebx, ebx\n\t\t\n\t\tcmp\t\tesi&#91;ebx&#93;, SIGN\n\t\tje\t\tSign_To_Zero_ASCII_To_Decimal\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h\n\t\tjb\t\tInvalid_Input\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h\n\t\tja\t\tInvalid_Input\t\t\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\n\tlocal\tStart_ASCII_To_Decimal&#58;\n\t\t\n\t\tcmp\t\tecx, 00h\n\t\tje\t\tIs_Sign_ASCII_To_Decimal\n\t\t\n\t\tmovzx \tedx, eax\n\t\tshl\t\teax, 03h\n\t\tadd\t\teax, edx\n\t\tadd\t\teax, edx\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\t\tsub\t\tecx, 01h\n\t\t\n\t\tjmp\t\tStart_ASCII_To_Decimal\n\t\t\n\tlocal\tSign_To_Zero_ASCII_To_Decimal&#58;\n\t\n\t\tmovzx\tedx, byte ptr eax\n\t\tsub\t\tedx, ZERO_ASCII\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\t\t\n\t\tjmp \tStart_ASCII_To_Decimal\n\t\t\n\tlocal \tIs_Sign_ASCII_To_Decimal&#58;\n\t\n\t\tcmp\t\tesi&#91;01h&#93;, SIGN\n\t\tjne\t\tFinish_ASCII_To_Decimal\n\t\t\n\t\tneg\t\teax\n\t\t\n\tlocal\tFinish_ASCII_To_Decimal&#58;\n\t\n\t\tret\n\nASCII_To_Decimal endp\n\nDecimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,\n\t\t\n\t\tret\n\t\t\nDecimal_To_ASCII endp\n\t\t\t\n\t\tend Main[/code:34carqa7]",
      "EditableFormat": "bbcode",
      "HTML": "here's my updated (hopefully fully fixed up and logic is correct) code work:<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to emulate/parse a mathematical equation<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>MAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh<br/>MAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h<br/><br/>SPACE\t\t\t\t\tEQU\t\t20h<br/><br/>EQUAL\t\t\t\t\tEQU\t\t3Dh<br/><br/>NEGATIVE\t\t\t\tEQU\t\t2Dh<br/><br/>ADDITION\t\t\t\tEQU\t\t2Bh<br/>SUBTRACTION\t\t\t\tEQU\t\t2Dh<br/>MULTIPLICATION\t\t\tEQU\t\t2Ah<br/>DIVISON\t\t\t\t\tEQU\t\t2Ch<br/><br/>ZERO_ASCII\t\t\t\tEQU\t\t30h<br/><br/>RETURN_ERROR\t\t\tEQU\t\t01h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;,<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\<br/>\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>input_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\<br/>\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>output_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\<br/>\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>division_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\<br/>\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>overflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>underflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t<br/>\t\t\t\t\t\t\t\t<br/>input_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)<br/><br/>output_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)<br/><br/>operand_1\t\t\t\tsdword\t?<br/>operand_2\t\t\t\tsdword\t?<br/>result_value\t\t\tsdword\t?<br/>\t\t\t\t\t\t\t\t<br/>return_code\t\t\t\tdword\t00h<br/><br/>bytes_read\t\t\t\tdword\t?<br/>bytes_written\t\t\tdword\t?<br/>handle_standard_out\t\tdword\t?<br/>handle_standard_in\t\tdword\t?<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_stardard_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_standard_in, eax<br/>\t<br/>\t;**************<br/>\t; Program Info<br/>\t;**************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\<br/>\t\t\tsizeof history, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset credit, \\<br/>\t\t\tsizeof credit, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;***********************<br/>\t; Prompt for User Input<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\<br/>\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Get User Input<br/>\t;****************<br/>\t<br/>\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\<br/>\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER<br/>\t<br/>\t;*********<br/>\t; Program<br/>\t;*********<br/>\t<br/>\tPre_Start&#58;<br/>\t<br/>\t\tmov\t\tesi, offset input_buffer<br/>\t\tmovzx\tebp, bytes_read<br/>\t<br/>\t\tmov \tedi, offset output_buffer<br/>\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE<br/>\t<br/>\t\txor \teax, eax<br/>\t\txor \tebx, ebx<br/>\t\txor \tecx, ecx<br/>\t<br/>\tGet_Operand_Size&#58;<br/>\t\t<br/>\t\tcmp\t\tesi&#91;ebx&#93;, SPACE<br/>\t\tje\t\tSet_Operand_Size<br/>\t\t<br/>\t\tcmp\t\tesi&#91;ebx&#93;, CARRIAGE_RETURN<br/>\t\tje\t\tSet_Operand_Size<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\t<br/>\t\tjmp\t\tGet_Operand_Size<br/>\t\t<br/>\tSet_Operand_Size&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t<br/>\tStart&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\tmovzx\toperand_1, eax<br/>\t\tadd\t\tebx, 01h<br/>\t\tjnp\t\tGet_Operand_Size<br/>\t\t<br/>\t\t; need to handle getting operator<br/>\t\t<br/>\t\t; need to handle getting operand_2<br/>\t\t<br/>\tAddition&#58;<br/>\t<br/>\t\tadc\t\toperand_1, operand_2<br/>\t<br/>\tSubtraction&#58;<br/>\t<br/>\t\tsbb\t\toperand_1, operand_2<br/>\t<br/>\tMultiplication&#58;<br/>\t<br/>\t\timul\toperand_1, operand_2<br/>\t<br/>\tDivision&#58;<br/>\t<br/>\t\tcmp \toperand_2, 00h<br/>\t\tje\t\tDivision_By_Zero<br/>\t<br/>\t\tidiv\toperand_1, operand_2<br/>\t<br/>\t;***********************<br/>\t; Display Output Prompt<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\<br/>\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Display Output<br/>\t;****************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\<br/>\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tInvalid_Input&#58;<br/>\t<br/>\t\tmovzx\treturn_code, RETURN_ERROR<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, return_code<br/>\t\t\t<br/>Main\tendp<br/>\t\t\t<br/>\t<br/>ASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,<br/>\t\t<br/>\tlocal \tPre_Start_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\txor\t\tebx, ebx<br/>\t\t<br/>\t\tcmp\t\tesi&#91;ebx&#93;, SIGN<br/>\t\tje\t\tSign_To_Zero_ASCII_To_Decimal<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h<br/>\t\tjb\t\tInvalid_Input<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h<br/>\t\tja\t\tInvalid_Input\t\t<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/><br/>\tlocal\tStart_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tcmp\t\tecx, 00h<br/>\t\tje\t\tIs_Sign_ASCII_To_Decimal<br/>\t\t<br/>\t\tmovzx \tedx, eax<br/>\t\tshl\t\teax, 03h<br/>\t\tadd\t\teax, edx<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\tsub\t\tecx, 01h<br/>\t\t<br/>\t\tjmp\t\tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal\tSign_To_Zero_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tmovzx\tedx, byte ptr eax<br/>\t\tsub\t\tedx, ZERO_ASCII<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\t<br/>\t\tjmp \tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal \tIs_Sign_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tcmp\t\tesi&#91;01h&#93;, SIGN<br/>\t\tjne\t\tFinish_ASCII_To_Decimal<br/>\t\t<br/>\t\tneg\t\teax<br/>\t\t<br/>\tlocal\tFinish_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tret<br/><br/>ASCII_To_Decimal endp<br/><br/>Decimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,<br/>\t\t<br/>\t\tret<br/>\t\t<br/>Decimal_To_ASCII endp<br/>\t\t\t<br/>\t\tend Main</code></pre>",
      "PostDate": "2016-03-15T17:07:52+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41744",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "This is much better! Still a few issues, which should be easily cleaned up.\n\n[code:38i8n83f]     movzx   edx, byte ptr esi&#91;ebx&#93;\n      sub      edx, ZERO_CHAR\n      add      eax, edx\n      \n      add      ebx, 01h\n[/code:38i8n83f]\nI'm not sure why you're handling the first character specially. If you simply xor eax, eax and fall into the loop, it will work. The way it is now, since you've processed the first character, you should decrement ecx before entering the loop. Otherwise, you'll try to process one too many characters.\n\nAlso, you don't specify eax as an input parameter, and yet you're using the fact (I assume) that it's been zeroed outside the function, which is really dangerous (since it's not obvious to the caller). If you do want to prime the loop this way, besides incrementing ecx, you should just mov the value into eax and subtract ZERO_CHAR, without all the edx business (which just uses an extra register when you can use eax alone). If you do want to keep the code you have, be sure to zero out eax before using it. Otherwise, the second time you call the function to get the second number, you're going to have a rude surprise.\n\nThe sign check can be much simpler (and it doesn't really work as is, since it doesn't advance the off the sign character and it also doesn't even read from the buffer - it just uses eax, which is 0, and then subtracts CHAR_ZERO from it, which makes it go negative. You really just need something like &quot;if the first character in the buffer is '-', skip it (inc ebx)&quot;). Then your later check will negate the number.\n\nAnd at the end where you check the sign character again, you use esi[01h]. But the first character is at offset 0. So it should be esi[0].\n\nHope that helps! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "This is much better! Still a few issues, which should be easily cleaned up.<br/><br/><pre><code>     movzx   edx, byte ptr esi&#91;ebx&#93;<br/>      sub      edx, ZERO_CHAR<br/>      add      eax, edx<br/>      <br/>      add      ebx, 01h<br/></code></pre><br/>I'm not sure why you're handling the first character specially. If you simply xor eax, eax and fall into the loop, it will work. The way it is now, since you've processed the first character, you should decrement ecx before entering the loop. Otherwise, you'll try to process one too many characters.<br/><br/>Also, you don't specify eax as an input parameter, and yet you're using the fact (I assume) that it's been zeroed outside the function, which is really dangerous (since it's not obvious to the caller). If you do want to prime the loop this way, besides incrementing ecx, you should just mov the value into eax and subtract ZERO_CHAR, without all the edx business (which just uses an extra register when you can use eax alone). If you do want to keep the code you have, be sure to zero out eax before using it. Otherwise, the second time you call the function to get the second number, you're going to have a rude surprise.<br/><br/>The sign check can be much simpler (and it doesn't really work as is, since it doesn't advance the off the sign character and it also doesn't even read from the buffer - it just uses eax, which is 0, and then subtracts CHAR_ZERO from it, which makes it go negative. You really just need something like &quot;if the first character in the buffer is '-', skip it (inc ebx)&quot;). Then your later check will negate the number.<br/><br/>And at the end where you check the sign character again, you use esi[01h]. But the first character is at offset 0. So it should be esi[0].<br/><br/>Hope that helps! <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-03-15T18:32:40+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41750",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm still a bit confused with Procedures and Parameters (for some reason in assembly I'm not understanding them - they seem a bit different to me from high level languages), along with the use of the registers (either directly or through using them with Parameters).\n\nIf I understand correctly, the 'uses' key-word/command, merely copies the registers' (original) values into/onto the stack for storage, so that once you're done with the procedure, those original values are loaded/copied/moved back into your registers, over-writing whatever values were currently in them from your procedure operations.\n\nWith this understanding, then why would you need to indirectly (via parameters) use registers in/for your procedures ???\n\nUnofrtunately, the required given procedure only mentions/specifies that the array source address (in esi) and its size/length (in ecx) are to be used as its args.\n\nabout the parameters/args, I presume this means I have to assign the esi and ecx to parameter_variables, which I can use directly or pass back into esi and ecx (not undertanding the point of this... seems pointless/redundant/un-needed extra operation/s) ???\n\n-------\n\nI'm not sure what you mean in regards to the 'eax' not being known to the caller? (I am aware that I need to xor eax before doing operand 2)\n\ndo you mean that I should have the 'xor eax' inside of the 'asci to decimal' procedure? I'm not sure if this can be done or not (at least probably not with my haphazard design setup/program flow/logic) ... \n\n--------\n\nI'm a bit confused too on what you say in regards to the sign operations, I'm not sure what I need to do or change, I'm not quite able to follow/see what you're trying to tell/explain to me (I'm probably having these issues due to being so tired).\n\n-------\n\nalso...\n\nI'm a bit confused on how I would adjust the code to not have to use the 'edx' step with the 'ascii to decimal' operations...\n\n... let me post up my new code work, so you can see with what I've done, and got to work with (or need to change/fix up, as not sure if some of my logic and etc is right, also my program flow/logic is a bit confusing and not optimized, as I'm having a bit of trouble with how to design this stuff well, laughs-sighs)\n\nI'm still having quite a lot of trouble with good program flow/logic/design... this project is a bit too complex for me to get it and design it well at least currently (and I've already am nearly up on my time to work on this program, as it's due in exactly 15 hrs from now, I probably won't be able to complete it, not even sure if I can even get to tackling the arithmetic operations and then the decimal to ascii, and I'm really getting sick of this program, as I've been working on it literally non-stop since saturday - which was why I was so brain dead and getting confused with the equates and the literal values vs the ascii values - sleep has been few and far in-between as I'm really trying to get this program done as much as I can, yet I'm trying to get as much work on it as I can, a miracle will be needed to get it completed, let alone working... with more time, I can definately get this figure out, with probably some needed help from you, but my time's almost out), sighs...",
      "EditableFormat": "bbcode",
      "HTML": "I'm still a bit confused with Procedures and Parameters (for some reason in assembly I'm not understanding them - they seem a bit different to me from high level languages), along with the use of the registers (either directly or through using them with Parameters).<br/><br/>If I understand correctly, the 'uses' key-word/command, merely copies the registers' (original) values into/onto the stack for storage, so that once you're done with the procedure, those original values are loaded/copied/moved back into your registers, over-writing whatever values were currently in them from your procedure operations.<br/><br/>With this understanding, then why would you need to indirectly (via parameters) use registers in/for your procedures ???<br/><br/>Unofrtunately, the required given procedure only mentions/specifies that the array source address (in esi) and its size/length (in ecx) are to be used as its args.<br/><br/>about the parameters/args, I presume this means I have to assign the esi and ecx to parameter_variables, which I can use directly or pass back into esi and ecx (not undertanding the point of this... seems pointless/redundant/un-needed extra operation/s) ???<br/><br/>-------<br/><br/>I'm not sure what you mean in regards to the 'eax' not being known to the caller? (I am aware that I need to xor eax before doing operand 2)<br/><br/>do you mean that I should have the 'xor eax' inside of the 'asci to decimal' procedure? I'm not sure if this can be done or not (at least probably not with my haphazard design setup/program flow/logic) ... <br/><br/>--------<br/><br/>I'm a bit confused too on what you say in regards to the sign operations, I'm not sure what I need to do or change, I'm not quite able to follow/see what you're trying to tell/explain to me (I'm probably having these issues due to being so tired).<br/><br/>-------<br/><br/>also...<br/><br/>I'm a bit confused on how I would adjust the code to not have to use the 'edx' step with the 'ascii to decimal' operations...<br/><br/>... let me post up my new code work, so you can see with what I've done, and got to work with (or need to change/fix up, as not sure if some of my logic and etc is right, also my program flow/logic is a bit confusing and not optimized, as I'm having a bit of trouble with how to design this stuff well, laughs-sighs)<br/><br/>I'm still having quite a lot of trouble with good program flow/logic/design... this project is a bit too complex for me to get it and design it well at least currently (and I've already am nearly up on my time to work on this program, as it's due in exactly 15 hrs from now, I probably won't be able to complete it, not even sure if I can even get to tackling the arithmetic operations and then the decimal to ascii, and I'm really getting sick of this program, as I've been working on it literally non-stop since saturday - which was why I was so brain dead and getting confused with the equates and the literal values vs the ascii values - sleep has been few and far in-between as I'm really trying to get this program done as much as I can, yet I'm trying to get as much work on it as I can, a miracle will be needed to get it completed, let alone working... with more time, I can definately get this figure out, with probably some needed help from you, but my time's almost out), sighs...",
      "PostDate": "2016-03-16T09:02:44+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41751",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "here's my current code work:\n\n(sorry about not having any comments, haven't had the time for them, as I'm just trying to progress on the actual program)\n\n(I know my program design/flow/logic is really bad and haphazard, my apologizes with having to try to figure it out without any comments... if I had more time, I'd have the comments so you could at least follow it along a bit more easily. It takes me time and multiple versions to get my programs a bit organized, as I'm still really a newbie at programming. As you can see, my initial program/coding is really bad and disorganized, I slowly with time and tries, get it cleaned up and somewhat readable/followable ... I'm really weak at good programming logic and program flow/design, still, obviously. I'm a bit better with the high level languages, as I've been doing them longer, having more experience with them, but this assembly is new, and you're seeing me at the beginning, probably like how I was when I first learned of quest and tried to learn to code with quest ~3 yrs ago, lol)\n\n(I'm not that smart, so I have to rely on lots of trial and error, to slowly get to better designed code and programs, it takes me a lot of revisions)\n\n[code:1xh9dnpm];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to emulate/parse a mathematical equation\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\nMAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh\nMAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h\n\nSPACE\t\t\t\t\tEQU\t\t20h\n\nEQUAL\t\t\t\t\tEQU\t\t3Dh\n\nNEGATIVE\t\t\t\tEQU\t\t2Dh\n\nADDITION\t\t\t\tEQU\t\t2Bh\nSUBTRACTION\t\t\t\tEQU\t\t2Dh\nMULTIPLICATION\t\t\tEQU\t\t2Ah\nDIVISON\t\t\t\t\tEQU\t\t2Ch\n\nZERO_ASCII\t\t\t\tEQU\t\t30h\n\nRETURN_ERROR\t\t\tEQU\t\t01h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;,\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\\n\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\ninput_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\\n\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noutput_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\\n\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ndivision_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\\n\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noverflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nunderflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ninput_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)\n\noutput_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)\n\noperator_variable\t\tbyte\t?\n\noperand_1\t\t\t\tsdword\t?\noperand_2\t\t\t\tsdword\t?\t\t\nresult_value\t\t\tsdword\t?\n\t\t\t\t\t\t\t\t\nreturn_code\t\t\t\tdword\t00h\n\nbytes_read\t\t\t\tdword\t?\nbytes_written\t\t\tdword\t?\nhandle_standard_out\t\tdword\t?\nhandle_standard_in\t\tdword\t?\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_stardard_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_standard_in, eax\n\t\n\t;**************\n\t; Program Info\n\t;**************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\\n\t\t\tsizeof history, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\n\t;***********************\n\t; Prompt for User Input\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\\n\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Get User Input\n\t;****************\n\t\n\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\\n\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER\n\t\n\t;*********\n\t; Program\n\t;*********\n\t\n\tPre_Start&#58;\n\t\n\t\tmov\t\tesi, offset input_buffer\n\t\n\t\tmov \tedi, offset output_buffer\n\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE\n\n\t\txor \tebx, ebx\n\t\txor \tecx, ecx\n\t\t\n\tStart&#58;\n\t\n\t\txor\t\teax, eax\n\t\n\tGet_Operand_Length&#58;\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SPACE\n\t\tje\t\tSet_Operand_1_Length\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, CARRIAGE_RETURN\n\t\tje\t\tSet_Operand_2_Length\n\t\t\n\t\tadd\t\tebx, 01h\n\t\t\n\t\tjmp\t\tGet_Operand_Length\n\t\t\n\tSet_Operand_1_Length&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\tsub\t\tecx, ebp\n\t\n\tOperand_1&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\tmovzx\toperand_1, eax\n\t\tmovzx\tebp, ebx\n\t\n\tSkip_To_Operator&#58;\n\t\n\t\tadd\t\tebx, 02h\n\t\n\tStore_Operator&#58;\n\t\t\n\t\tmovzx\toperator_variable, byte ptr esi&#91;ebx&#93;\n\t\n\tSkip_Past_Operator_To_Handling_Operand_2&#58;\n\t\t\n\t\tadd\t\tebx, 02h\n\t\tjnp\t\tStart\n\t\t\n\tSet_Operand_2_Length&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\tsub\t\tecx, ebp\n\t\n\tOperand_2&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\tmovzx\toperand_2, eax\n\t\tmovzx\tebp, ebx\n\t\t\n\tDetermining_Arithmetic_Operation&#58;\n\t\n\t\tmovzx \tebp, operator_variable\n\t\n\t\tcmp\t\tebp, ADDITION\n\t\tje\t\tAddition\n\t\t\n\t\tcmp\t\tebp, SUBTRACTION\n\t\tje\t\tSubtraction\n\t\t\n\t\tcmp\t\tebp, MULTIPLICATION\n\t\tje\t\tMultiplication\n\t\t\n\t\tcmp\t\tebp, DIVISION\n\t\tje\t\tDivision\n\t\t\n\tAddition&#58;\n\t\n\t\tadc\t\toperand_1, operand_2\n\t\t\n\t\tjmp \tOutput\n\t\n\tSubtraction&#58;\n\t\n\t\tsbb\t\toperand_1, operand_2\n\t\t\n\t\tjmp \tOutput\n\t\n\tMultiplication&#58;\n\t\n\t\timul\toperand_1, operand_2\n\t\t\n\t\tjmp \tOutput\n\t\n\tDivision&#58;\n\t\n\t\tcmp \toperand_2, 00h\n\t\tje\t\tDivision_By_Zero\n\t\n\t\tidiv\toperand_1, operand_2\n\t\t\n\t\tjmp \tOutput\n\t\n\tOutput&#58;\n\t\n\t;***********************\n\t; Display Output Prompt\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\\n\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Display Output\n\t;****************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\\n\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER\n\t\t\t\n\tInvalid_Input&#58;\n\t\n\t\tmovzx\treturn_code, RETURN_ERROR\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, return_code\n\t\t\t\nMain\tendp\n\t\t\t\n\t\nASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,\n\t\t\n\tlocal \tPre_Start_ASCII_To_Decimal&#58;\n\t\t\n\t\txor\t\tebx, ebx\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SIGN\n\t\tje\t\tNext_Index_ASCII_To_Decimal\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h\n\t\tjb\t\tInvalid_Input\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h\n\t\tja\t\tInvalid_Input\t\t\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\n\tlocal\tStart_ASCII_To_Decimal&#58;\n\t\t\n\t\tcmp\t\tecx, 00h\n\t\tje\t\tIs_Sign_ASCII_To_Decimal\n\t\t\n\t\tmovzx \tedx, eax\n\t\tshl\t\teax, 03h\n\t\tadd\t\teax, edx\n\t\tadd\t\teax, edx\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\t\tsub\t\tecx, 01h\n\t\t\n\t\tjmp\t\tStart_ASCII_To_Decimal\n\t\t\n\tlocal\tNext_Index_ASCII_To_Decimal&#58;\n\t\t\n\t\tadd\t\tebx, 01h\n\t\tsub\t\tecx, 01h\n\t\t\n\t\tjmp \tStart_ASCII_To_Decimal\n\t\t\n\tlocal \tIs_Sign_ASCII_To_Decimal&#58;\n\t\n\t\tcmp\t\tbyte ptr esi&#91;00h&#93;, SIGN\n\t\tjne\t\tFinish_ASCII_To_Decimal\n\t\t\n\t\tneg\t\teax\n\t\t\n\tlocal\tFinish_ASCII_To_Decimal&#58;\n\t\n\t\tret\n\nASCII_To_Decimal endp\n\nDecimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,\n\t\t\n\t\tret\n\t\t\nDecimal_To_ASCII endp\n\t\t\t\n\t\tend Main[/code:1xh9dnpm]",
      "EditableFormat": "bbcode",
      "HTML": "here's my current code work:<br/><br/>(sorry about not having any comments, haven't had the time for them, as I'm just trying to progress on the actual program)<br/><br/>(I know my program design/flow/logic is really bad and haphazard, my apologizes with having to try to figure it out without any comments... if I had more time, I'd have the comments so you could at least follow it along a bit more easily. It takes me time and multiple versions to get my programs a bit organized, as I'm still really a newbie at programming. As you can see, my initial program/coding is really bad and disorganized, I slowly with time and tries, get it cleaned up and somewhat readable/followable ... I'm really weak at good programming logic and program flow/design, still, obviously. I'm a bit better with the high level languages, as I've been doing them longer, having more experience with them, but this assembly is new, and you're seeing me at the beginning, probably like how I was when I first learned of quest and tried to learn to code with quest ~3 yrs ago, lol)<br/><br/>(I'm not that smart, so I have to rely on lots of trial and error, to slowly get to better designed code and programs, it takes me a lot of revisions)<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to emulate/parse a mathematical equation<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>MAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh<br/>MAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h<br/><br/>SPACE\t\t\t\t\tEQU\t\t20h<br/><br/>EQUAL\t\t\t\t\tEQU\t\t3Dh<br/><br/>NEGATIVE\t\t\t\tEQU\t\t2Dh<br/><br/>ADDITION\t\t\t\tEQU\t\t2Bh<br/>SUBTRACTION\t\t\t\tEQU\t\t2Dh<br/>MULTIPLICATION\t\t\tEQU\t\t2Ah<br/>DIVISON\t\t\t\t\tEQU\t\t2Ch<br/><br/>ZERO_ASCII\t\t\t\tEQU\t\t30h<br/><br/>RETURN_ERROR\t\t\tEQU\t\t01h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;,<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\<br/>\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>input_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\<br/>\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>output_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\<br/>\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>division_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\<br/>\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>overflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>underflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t<br/>\t\t\t\t\t\t\t\t<br/>input_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)<br/><br/>output_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)<br/><br/>operator_variable\t\tbyte\t?<br/><br/>operand_1\t\t\t\tsdword\t?<br/>operand_2\t\t\t\tsdword\t?\t\t<br/>result_value\t\t\tsdword\t?<br/>\t\t\t\t\t\t\t\t<br/>return_code\t\t\t\tdword\t00h<br/><br/>bytes_read\t\t\t\tdword\t?<br/>bytes_written\t\t\tdword\t?<br/>handle_standard_out\t\tdword\t?<br/>handle_standard_in\t\tdword\t?<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_stardard_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_standard_in, eax<br/>\t<br/>\t;**************<br/>\t; Program Info<br/>\t;**************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\<br/>\t\t\tsizeof history, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;***********************<br/>\t; Prompt for User Input<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\<br/>\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Get User Input<br/>\t;****************<br/>\t<br/>\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\<br/>\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER<br/>\t<br/>\t;*********<br/>\t; Program<br/>\t;*********<br/>\t<br/>\tPre_Start&#58;<br/>\t<br/>\t\tmov\t\tesi, offset input_buffer<br/>\t<br/>\t\tmov \tedi, offset output_buffer<br/>\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE<br/><br/>\t\txor \tebx, ebx<br/>\t\txor \tecx, ecx<br/>\t\t<br/>\tStart&#58;<br/>\t<br/>\t\txor\t\teax, eax<br/>\t<br/>\tGet_Operand_Length&#58;<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SPACE<br/>\t\tje\t\tSet_Operand_1_Length<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, CARRIAGE_RETURN<br/>\t\tje\t\tSet_Operand_2_Length<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\t<br/>\t\tjmp\t\tGet_Operand_Length<br/>\t\t<br/>\tSet_Operand_1_Length&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t\tsub\t\tecx, ebp<br/>\t<br/>\tOperand_1&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\tmovzx\toperand_1, eax<br/>\t\tmovzx\tebp, ebx<br/>\t<br/>\tSkip_To_Operator&#58;<br/>\t<br/>\t\tadd\t\tebx, 02h<br/>\t<br/>\tStore_Operator&#58;<br/>\t\t<br/>\t\tmovzx\toperator_variable, byte ptr esi&#91;ebx&#93;<br/>\t<br/>\tSkip_Past_Operator_To_Handling_Operand_2&#58;<br/>\t\t<br/>\t\tadd\t\tebx, 02h<br/>\t\tjnp\t\tStart<br/>\t\t<br/>\tSet_Operand_2_Length&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t\tsub\t\tecx, ebp<br/>\t<br/>\tOperand_2&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\tmovzx\toperand_2, eax<br/>\t\tmovzx\tebp, ebx<br/>\t\t<br/>\tDetermining_Arithmetic_Operation&#58;<br/>\t<br/>\t\tmovzx \tebp, operator_variable<br/>\t<br/>\t\tcmp\t\tebp, ADDITION<br/>\t\tje\t\tAddition<br/>\t\t<br/>\t\tcmp\t\tebp, SUBTRACTION<br/>\t\tje\t\tSubtraction<br/>\t\t<br/>\t\tcmp\t\tebp, MULTIPLICATION<br/>\t\tje\t\tMultiplication<br/>\t\t<br/>\t\tcmp\t\tebp, DIVISION<br/>\t\tje\t\tDivision<br/>\t\t<br/>\tAddition&#58;<br/>\t<br/>\t\tadc\t\toperand_1, operand_2<br/>\t\t<br/>\t\tjmp \tOutput<br/>\t<br/>\tSubtraction&#58;<br/>\t<br/>\t\tsbb\t\toperand_1, operand_2<br/>\t\t<br/>\t\tjmp \tOutput<br/>\t<br/>\tMultiplication&#58;<br/>\t<br/>\t\timul\toperand_1, operand_2<br/>\t\t<br/>\t\tjmp \tOutput<br/>\t<br/>\tDivision&#58;<br/>\t<br/>\t\tcmp \toperand_2, 00h<br/>\t\tje\t\tDivision_By_Zero<br/>\t<br/>\t\tidiv\toperand_1, operand_2<br/>\t\t<br/>\t\tjmp \tOutput<br/>\t<br/>\tOutput&#58;<br/>\t<br/>\t;***********************<br/>\t; Display Output Prompt<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\<br/>\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Display Output<br/>\t;****************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\<br/>\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tInvalid_Input&#58;<br/>\t<br/>\t\tmovzx\treturn_code, RETURN_ERROR<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, return_code<br/>\t\t\t<br/>Main\tendp<br/>\t\t\t<br/>\t<br/>ASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,<br/>\t\t<br/>\tlocal \tPre_Start_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\txor\t\tebx, ebx<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SIGN<br/>\t\tje\t\tNext_Index_ASCII_To_Decimal<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h<br/>\t\tjb\t\tInvalid_Input<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h<br/>\t\tja\t\tInvalid_Input\t\t<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/><br/>\tlocal\tStart_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tcmp\t\tecx, 00h<br/>\t\tje\t\tIs_Sign_ASCII_To_Decimal<br/>\t\t<br/>\t\tmovzx \tedx, eax<br/>\t\tshl\t\teax, 03h<br/>\t\tadd\t\teax, edx<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\tsub\t\tecx, 01h<br/>\t\t<br/>\t\tjmp\t\tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal\tNext_Index_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\tsub\t\tecx, 01h<br/>\t\t<br/>\t\tjmp \tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal \tIs_Sign_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tcmp\t\tbyte ptr esi&#91;00h&#93;, SIGN<br/>\t\tjne\t\tFinish_ASCII_To_Decimal<br/>\t\t<br/>\t\tneg\t\teax<br/>\t\t<br/>\tlocal\tFinish_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tret<br/><br/>ASCII_To_Decimal endp<br/><br/>Decimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,<br/>\t\t<br/>\t\tret<br/>\t\t<br/>Decimal_To_ASCII endp<br/>\t\t\t<br/>\t\tend Main</code></pre>",
      "PostDate": "2016-03-16T09:32:06+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41755",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "newer code:\n\n[code:2332htc7];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to emulate/parse a mathematical equation\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\nMAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh\nMAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h\n\nSPACE\t\t\t\t\tEQU\t\t20h\n\nEQUAL\t\t\t\t\tEQU\t\t3Dh\n\nNEGATIVE\t\t\t\tEQU\t\t2Dh\n\nADDITION\t\t\t\tEQU\t\t2Bh\nSUBTRACTION\t\t\t\tEQU\t\t2Dh\nMULTIPLICATION\t\t\tEQU\t\t2Ah\nDIVISON\t\t\t\t\tEQU\t\t2Ch\n\nZERO_ASCII\t\t\t\tEQU\t\t30h\n\nRETURN_ERROR\t\t\tEQU\t\t01h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;redacted&quot;,\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\\n\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\ninput_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\\n\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noutput_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\\n\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ndivision_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\\n\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\noverflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\nunderflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ninput_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)\n\noutput_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)\n\noperator_variable\t\tbyte\t?\n\noperand_1\t\t\t\tsdword\t?\noperand_2\t\t\t\tsdword\t?\t\t\nresult_value\t\t\tsdword\t?\n\t\t\t\t\t\t\t\t\nreturn_code\t\t\t\tdword\t00h\n\nbytes_read\t\t\t\tdword\t?\nbytes_written\t\t\tdword\t?\nhandle_standard_out\t\tdword\t?\nhandle_standard_in\t\tdword\t?\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain Proc\n\n\t;*******************************\n\t; Get handle to standard output\n\t;*******************************\n\t\n\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE\n\tmov\t\thandle_stardard_out, eax\n\t\n\t;******************************\n\t; Get handle to standard input\n\t;******************************\n\n\tinvoke\tGetStdHandle, STD_INPUT_HANDLE\n\tmov\t\thandle_standard_in, eax\n\t\n\t;**************\n\t; Program Info\n\t;**************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\\n\t\t\tsizeof history, offset bytes_written, NULL_POINTER\n\t\t\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\\n\t\t\tsizeof heading, offset bytes_written, NULL_POINTER\n\t\n\t;***********************\n\t; Prompt for User Input\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\\n\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Get User Input\n\t;****************\n\t\n\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\\n\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER\n\t\n\t;*********\n\t; Program\n\t;*********\n\t\n\tPre_Start&#58;\n\t\n\t\tmov\t\tesi, offset input_buffer\n\t\n\t\tmov \tedi, offset output_buffer\n\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE\n\n\t\txor \tebx, ebx\n\t\txor \tecx, ecx\n\t\t\n\tStart&#58;\n\t\n\t\txor\t\teax, eax\n\t\n\tGet_Operand_Length&#58;\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SPACE\n\t\tje\t\tSet_Operand_1_Length\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, CARRIAGE_RETURN\n\t\tje\t\tSet_Operand_2_Length\n\t\t\n\t\tadd\t\tebx, 01h\n\t\t\n\t\tjmp\t\tGet_Operand_Length\n\t\t\n\tSet_Operand_1_Length&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\tsub\t\tecx, ebp\n\t\n\tOperand_1&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\tmovzx\toperand_1, eax\n\t\tmovzx\tebp, ebx\n\t\n\tSkip_To_Operator&#58;\n\t\n\t\tadd\t\tebx, 02h\n\t\n\tStore_Operator&#58;\n\t\t\n\t\tmovzx\toperator_variable, byte ptr esi&#91;ebx&#93;\n\t\n\tSkip_Past_Operator_To_Handling_Operand_2&#58;\n\t\t\n\t\tadd\t\tebx, 02h\n\t\tjnp\t\tStart\n\t\t\n\tSet_Operand_2_Length&#58;\n\t\n\t\tmovzx \tecx, ebx\n\t\tsub\t\tecx, ebp\n\t\n\tOperand_2&#58;\n\t\n\t\tcall\tASCII_To_Decimal (esi, ecx)\n\t\tmovzx\toperand_2, eax\n\t\t\n\tStoring_Actual_Array_Length&#58;\n\t\n;\t\tmovzx\txxx_variable, ebx\n;\t\tmovzx\tecx, ebx\n\n\tZeroing_Registers&#58;\n\n;\t\txor \teax, eax\n;\t\txor\t\tecx, ecx\n;\t\txor\t\tedx, edx\n\t\t\n\tDetermining_Arithmetic_Operation&#58;\n\t\n\t\tmovzx \tebp, operator_variable\n\t\n\t\tcmp\t\tebp, ADDITION\n\t\tje\t\tAddition\n\t\t\n\t\tcmp\t\tebp, SUBTRACTION\n\t\tje\t\tSubtraction\n\t\t\n\t\tcmp\t\tebp, MULTIPLICATION\n\t\tje\t\tMultiplication\n\t\t\n\t\tcmp\t\tebp, DIVISION\n\t\tje\t\tDivision\n\t\t\n\tAddition&#58;\n\t\n\t\tmov\t\teax, dword ptr operand_1 + 4\n\t\tmov\t\tecx, dword ptr operand_2 + 4\n\t\tadc\t\teax, ecx\n\t\tmov\t\tdword ptr result_value + 4, eax\n\t\t\n\t\tjmp \tConversion\n\t\n\tSubtraction&#58;\n\t\n\t\tmov\t\teax, dword ptr operand_1 + 4\n\t\tmov\t\tecx, dword ptr operand_2 + 4\n\t\tsbb\t\teax, ecx\n\t\tmov\t\tdword ptr result_value + 4, eax\n\t\t\n\t\tjmp \tConversion\n\t\n\tMultiplication&#58;\n\t\n\t\tmov\t\teax, dword ptr operand_1\n\t\tmov\t\tecx, dword ptr operand_2\n\t\timul\tecx\n\t\tmov\t\tdword ptr result_value, eax\n\t\t\n\t\tjmp \tConversion\n\t\n\tDivision&#58;\n\t\n\t\tmov\t\teax, dword ptr operand_1\n\t\tmov\t\tecx, dword ptr operand_2\n\t\tidiv\tecx\n\t\tmov\t\tdword ptr result_value, eax\n\t\t\n\t\tjmp \tConversion\n\t\t\n\tConversion&#58;\n\t\n\t\tcall\tDecimal_To_ASCII\n\t\n\tOutput&#58;\n\t\n\t;***********************\n\t; Display Output Prompt\n\t;***********************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\\n\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER\n\t\n\t;****************\n\t; Display Output\n\t;****************\n\t\n\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\\n\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER\n\t\n\tjmp\tFinish\n\t\n\tInvalid_Input&#58;\n\t\n\t\tmovzx\treturn_code, RETURN_ERROR\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, return_code\n\t\t\t\nMain\tendp\n\t\t\t\n\t\nASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,\n\t\t\n\tlocal \tPre_Start_ASCII_To_Decimal&#58;\n\t\t\n\t\txor\t\tebx, ebx\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SIGN\n\t\tje\t\tNext_Index_ASCII_To_Decimal\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h\n\t\tjb\t\tInvalid_Input\n\t\t\n\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h\n\t\tja\t\tInvalid_Input\t\t\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\n\tlocal\tStart_ASCII_To_Decimal&#58;\n\t\t\n\t\tcmp\t\tecx, 00h\n\t\tje\t\tIs_Sign_ASCII_To_Decimal\n\t\t\n\t\tmovzx \tedx, eax\n\t\tshl\t\teax, 03h\n\t\tadd\t\teax, edx\n\t\tadd\t\teax, edx\n\t\t\n\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;\n\t\tsub\t\tedx, ZERO_CHAR\n\t\tadd\t\teax, edx\n\t\t\n\t\tadd\t\tebx, 01h\n\t\tsub\t\tecx, 01h\n\t\t\n\t\tjmp\t\tStart_ASCII_To_Decimal\n\t\t\n\tlocal\tNext_Index_ASCII_To_Decimal&#58;\n\t\t\n\t\tadd\t\tebx, 01h\n\t\tsub\t\tecx, 01h\n\t\t\n\t\tjmp \tStart_ASCII_To_Decimal\n\t\t\n\tlocal \tIs_Sign_ASCII_To_Decimal&#58;\n\t\n\t\tcmp\t\tbyte ptr esi&#91;00h&#93;, SIGN\n\t\tjne\t\tFinish_ASCII_To_Decimal\n\t\t\n\t\tneg\t\teax\n\t\t\n\tlocal\tFinish_ASCII_To_Decimal&#58;\n\t\n\t\tret\n\nASCII_To_Decimal endp\n\nDecimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,\n\t\t\n\t\tret\n\t\t\nDecimal_To_ASCII endp\n\t\t\t\n\t\tend Main[/code:2332htc7]",
      "EditableFormat": "bbcode",
      "HTML": "newer code:<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to emulate/parse a mathematical equation<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>MAX_INPUT_BUFFER_SIZE\tEQU\t\t1Bh<br/>MAX_OUTPUT_BUFFER_SIZE\tEQU\t\t29h<br/><br/>SPACE\t\t\t\t\tEQU\t\t20h<br/><br/>EQUAL\t\t\t\t\tEQU\t\t3Dh<br/><br/>NEGATIVE\t\t\t\tEQU\t\t2Dh<br/><br/>ADDITION\t\t\t\tEQU\t\t2Bh<br/>SUBTRACTION\t\t\t\tEQU\t\t2Dh<br/>MULTIPLICATION\t\t\tEQU\t\t2Ah<br/>DIVISON\t\t\t\t\tEQU\t\t2Ch<br/><br/>ZERO_ASCII\t\t\t\tEQU\t\t30h<br/><br/>RETURN_ERROR\t\t\tEQU\t\t01h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;redacted&quot;,<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to evaluate/parse&quot;,\\<br/>\t\t\t\t\t\t\t\t&quot; a mathematical equation&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>input_prompt\t\t\tbyte\t&quot;Enter a mathematical equation in the form of&quot;\\<br/>\t\t\t\t\t\t\t\t&quot;, &lt;value(space)operation(space)value&gt; , &#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>output_prompt\t\t\tbyte\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED,\\<br/>\t\t\t\t\t\t\t\t&quot;The result is&#58;&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>division_by_zero\t\tbyte\t&quot;Error&#58; Division by zero, result is undefined&quot;\\<br/>\t\t\t\t\t\t\t\t, CARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>overflow_flagged\t\tbyte\t&quot;Overflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>underflow_flagged\t\tbyte\t&quot;Underflow occurred&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\t\t\t\t\t\t\t\t<br/>\t\t\t\t\t\t\t\t<br/>input_buffer\t\t\tbyte\tINPUT_BUFFER_SIZE dup (?)<br/><br/>output_buffer\t\t\tbyte\tOUTPUT_BUFFER_SIZE dup (?)<br/><br/>operator_variable\t\tbyte\t?<br/><br/>operand_1\t\t\t\tsdword\t?<br/>operand_2\t\t\t\tsdword\t?\t\t<br/>result_value\t\t\tsdword\t?<br/>\t\t\t\t\t\t\t\t<br/>return_code\t\t\t\tdword\t00h<br/><br/>bytes_read\t\t\t\tdword\t?<br/>bytes_written\t\t\tdword\t?<br/>handle_standard_out\t\tdword\t?<br/>handle_standard_in\t\tdword\t?<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main Proc<br/><br/>\t;*******************************<br/>\t; Get handle to standard output<br/>\t;*******************************<br/>\t<br/>\tinvoke\tGetStdHandle, STD_OUTPUT_HANDLE<br/>\tmov\t\thandle_stardard_out, eax<br/>\t<br/>\t;******************************<br/>\t; Get handle to standard input<br/>\t;******************************<br/><br/>\tinvoke\tGetStdHandle, STD_INPUT_HANDLE<br/>\tmov\t\thandle_standard_in, eax<br/>\t<br/>\t;**************<br/>\t; Program Info<br/>\t;**************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset heading, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset history, \\<br/>\t\t\tsizeof history, offset bytes_written, NULL_POINTER<br/>\t\t\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset purpose, \\<br/>\t\t\tsizeof heading, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;***********************<br/>\t; Prompt for User Input<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset input_prompt, \\<br/>\t\t\tsizeof input_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Get User Input<br/>\t;****************<br/>\t<br/>\tinvoke\tReadConsoleA, handle_standard_in, offset input_buffer, \\<br/>\t\t\tsizeof input_buffer, offset bytes_read, NULL_POINTER<br/>\t<br/>\t;*********<br/>\t; Program<br/>\t;*********<br/>\t<br/>\tPre_Start&#58;<br/>\t<br/>\t\tmov\t\tesi, offset input_buffer<br/>\t<br/>\t\tmov \tedi, offset output_buffer<br/>\t\tmovzx\tedx, OUTPUT_BUFFER_SIZE<br/><br/>\t\txor \tebx, ebx<br/>\t\txor \tecx, ecx<br/>\t\t<br/>\tStart&#58;<br/>\t<br/>\t\txor\t\teax, eax<br/>\t<br/>\tGet_Operand_Length&#58;<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SPACE<br/>\t\tje\t\tSet_Operand_1_Length<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, CARRIAGE_RETURN<br/>\t\tje\t\tSet_Operand_2_Length<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\t<br/>\t\tjmp\t\tGet_Operand_Length<br/>\t\t<br/>\tSet_Operand_1_Length&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t\tsub\t\tecx, ebp<br/>\t<br/>\tOperand_1&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\tmovzx\toperand_1, eax<br/>\t\tmovzx\tebp, ebx<br/>\t<br/>\tSkip_To_Operator&#58;<br/>\t<br/>\t\tadd\t\tebx, 02h<br/>\t<br/>\tStore_Operator&#58;<br/>\t\t<br/>\t\tmovzx\toperator_variable, byte ptr esi&#91;ebx&#93;<br/>\t<br/>\tSkip_Past_Operator_To_Handling_Operand_2&#58;<br/>\t\t<br/>\t\tadd\t\tebx, 02h<br/>\t\tjnp\t\tStart<br/>\t\t<br/>\tSet_Operand_2_Length&#58;<br/>\t<br/>\t\tmovzx \tecx, ebx<br/>\t\tsub\t\tecx, ebp<br/>\t<br/>\tOperand_2&#58;<br/>\t<br/>\t\tcall\tASCII_To_Decimal (esi, ecx)<br/>\t\tmovzx\toperand_2, eax<br/>\t\t<br/>\tStoring_Actual_Array_Length&#58;<br/>\t<br/>;\t\tmovzx\txxx_variable, ebx<br/>;\t\tmovzx\tecx, ebx<br/><br/>\tZeroing_Registers&#58;<br/><br/>;\t\txor \teax, eax<br/>;\t\txor\t\tecx, ecx<br/>;\t\txor\t\tedx, edx<br/>\t\t<br/>\tDetermining_Arithmetic_Operation&#58;<br/>\t<br/>\t\tmovzx \tebp, operator_variable<br/>\t<br/>\t\tcmp\t\tebp, ADDITION<br/>\t\tje\t\tAddition<br/>\t\t<br/>\t\tcmp\t\tebp, SUBTRACTION<br/>\t\tje\t\tSubtraction<br/>\t\t<br/>\t\tcmp\t\tebp, MULTIPLICATION<br/>\t\tje\t\tMultiplication<br/>\t\t<br/>\t\tcmp\t\tebp, DIVISION<br/>\t\tje\t\tDivision<br/>\t\t<br/>\tAddition&#58;<br/>\t<br/>\t\tmov\t\teax, dword ptr operand_1 + 4<br/>\t\tmov\t\tecx, dword ptr operand_2 + 4<br/>\t\tadc\t\teax, ecx<br/>\t\tmov\t\tdword ptr result_value + 4, eax<br/>\t\t<br/>\t\tjmp \tConversion<br/>\t<br/>\tSubtraction&#58;<br/>\t<br/>\t\tmov\t\teax, dword ptr operand_1 + 4<br/>\t\tmov\t\tecx, dword ptr operand_2 + 4<br/>\t\tsbb\t\teax, ecx<br/>\t\tmov\t\tdword ptr result_value + 4, eax<br/>\t\t<br/>\t\tjmp \tConversion<br/>\t<br/>\tMultiplication&#58;<br/>\t<br/>\t\tmov\t\teax, dword ptr operand_1<br/>\t\tmov\t\tecx, dword ptr operand_2<br/>\t\timul\tecx<br/>\t\tmov\t\tdword ptr result_value, eax<br/>\t\t<br/>\t\tjmp \tConversion<br/>\t<br/>\tDivision&#58;<br/>\t<br/>\t\tmov\t\teax, dword ptr operand_1<br/>\t\tmov\t\tecx, dword ptr operand_2<br/>\t\tidiv\tecx<br/>\t\tmov\t\tdword ptr result_value, eax<br/>\t\t<br/>\t\tjmp \tConversion<br/>\t\t<br/>\tConversion&#58;<br/>\t<br/>\t\tcall\tDecimal_To_ASCII<br/>\t<br/>\tOutput&#58;<br/>\t<br/>\t;***********************<br/>\t; Display Output Prompt<br/>\t;***********************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_prompt, \\<br/>\t\t\tsizeof output_prompt, offset bytes_written, NULL_POINTER<br/>\t<br/>\t;****************<br/>\t; Display Output<br/>\t;****************<br/>\t<br/>\tinvoke\tWriteConsoleA, handle_standard_out, offset output_buffer, \\<br/>\t\t\tsizeof output_buffer, offset bytes_written, NULL_POINTER<br/>\t<br/>\tjmp\tFinish<br/>\t<br/>\tInvalid_Input&#58;<br/>\t<br/>\t\tmovzx\treturn_code, RETURN_ERROR<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, return_code<br/>\t\t\t<br/>Main\tendp<br/>\t\t\t<br/>\t<br/>ASCII_To_Decimal proc stdcall uses ebx ecx edx esi edi ebp,<br/>\t\t<br/>\tlocal \tPre_Start_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\txor\t\tebx, ebx<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, SIGN<br/>\t\tje\t\tNext_Index_ASCII_To_Decimal<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;, 00h<br/>\t\tjb\t\tInvalid_Input<br/>\t\t<br/>\t\tcmp\t\tbyte ptr esi&#91;ebx&#93;,\t09h<br/>\t\tja\t\tInvalid_Input\t\t<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/><br/>\tlocal\tStart_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tcmp\t\tecx, 00h<br/>\t\tje\t\tIs_Sign_ASCII_To_Decimal<br/>\t\t<br/>\t\tmovzx \tedx, eax<br/>\t\tshl\t\teax, 03h<br/>\t\tadd\t\teax, edx<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tmovzx\tedx, byte ptr esi&#91;ebx&#93;<br/>\t\tsub\t\tedx, ZERO_CHAR<br/>\t\tadd\t\teax, edx<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\tsub\t\tecx, 01h<br/>\t\t<br/>\t\tjmp\t\tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal\tNext_Index_ASCII_To_Decimal&#58;<br/>\t\t<br/>\t\tadd\t\tebx, 01h<br/>\t\tsub\t\tecx, 01h<br/>\t\t<br/>\t\tjmp \tStart_ASCII_To_Decimal<br/>\t\t<br/>\tlocal \tIs_Sign_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tcmp\t\tbyte ptr esi&#91;00h&#93;, SIGN<br/>\t\tjne\t\tFinish_ASCII_To_Decimal<br/>\t\t<br/>\t\tneg\t\teax<br/>\t\t<br/>\tlocal\tFinish_ASCII_To_Decimal&#58;<br/>\t<br/>\t\tret<br/><br/>ASCII_To_Decimal endp<br/><br/>Decimal_To_ASCII proc stdcall uses eax ebx edx esi edi ebp,<br/>\t\t<br/>\t\tret<br/>\t\t<br/>Decimal_To_ASCII endp<br/>\t\t\t<br/>\t\tend Main</code></pre>",
      "PostDate": "2016-03-16T11:45:07+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41756",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:3qsbzg8v]If I understand correctly, the 'uses' key-word/command, merely copies the registers' (original) values into/onto the stack for storage, so that once you're done with the procedure, those original values are loaded/copied/moved back into your registers, over-writing whatever values were currently in them from your procedure operations.\n\nWith this understanding, then why would you need to indirectly (via parameters) use registers in/for your procedures ???\n\nUnofrtunately, the required given procedure only mentions/specifies that the array source address (in esi) and its size/length (in ecx) are to be used as its args.[/quote:3qsbzg8v]\nThat was my point. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You're not setting eax to *anything* before you do your first &quot;add      eax, edx&quot;. So you're effectively using a register with an unknown value. It happens to be 0 in this case initially because you have xor'd it at the program start (for what reason, I don't know), which means the first number will *happen* to come out correctly, but not after that. You defintiely *don't* want to do that. If you want to do the add (which I still don't think you want or need to do initially), then you should at least set eax to 0 beforehand *in the function*. \n\nAs far as the sign goes, it looks like you fixed it - if there is a sign, you just increment past it, which is good.\n\nYou still have the problem of processing one too many characters in the non-signed case, since you're processing the first one outside the loop and not decrementing ecx when you add ebx, 01h before entering the loop. Rather than do that though, I still think you should just xor eax, eax to prime it and fall into the loop. There's no reason to process the first digit specially. (In fact, think about what happens if ecx comes in as 0! Or 1 even.)\n\nAlso, your check for the digit being in the range '0' - '9' is only being done on the first character. You should either move the check into the loop or just get rid of it (the requirements for this state the numbers will be legal. So validating them is not necessary. But if you're going to do it, then do it for all the characters).\n\nSo I think this code:\n\n[code:3qsbzg8v]   local    Pre_Start_ASCII_To_Decimal&#58;\n      \n      xor      ebx, ebx\n      \n      cmp      byte ptr esi&#91;ebx&#93;, SIGN\n      je      Next_Index_ASCII_To_Decimal\n      \n      cmp      byte ptr esi&#91;ebx&#93;, 00h\n      jb      Invalid_Input\n      \n      cmp      byte ptr esi&#91;ebx&#93;,   09h\n      ja      Invalid_Input      \n      \n      movzx   edx, byte ptr esi&#91;ebx&#93;\n      sub      edx, ZERO_CHAR\n      add      eax, edx\n      \n      add      ebx, 01h\n   local   Start_ASCII_To_Decimal&#58;\n\n[/code:3qsbzg8v]\nshould just be this:\n [code:3qsbzg8v]   local    Pre_Start_ASCII_To_Decimal&#58;\n      xor      ebx, ebx\n      xor      eax, eax\n      \n      cmp      byte ptr esi&#91;ebx&#93;, SIGN\n      jne      Start_ASCII_To_Decimal\n\n      inc ebx\n      dec ecx\n\n   local   Start_ASCII_To_Decimal&#58;\n[/code:3qsbzg8v]\n\nor this if you want to validate the characters:\n\n [code:3qsbzg8v]   local    Pre_Start_ASCII_To_Decimal&#58;\n      xor      ebx, ebx\n      xor      eax, eax\n      \n      cmp      byte ptr esi&#91;ebx&#93;, SIGN\n      jne      Start_ASCII_To_Decimal\n\n      inc ebx\n      dec ecx\n\n   local   Start_ASCII_To_Decimal&#58;\n\n      cmp      byte ptr esi&#91;ebx&#93;, 00h\n      jb      Invalid_Input\n      \n      cmp      byte ptr esi&#91;ebx&#93;,   09h\n      ja      Invalid_Input   \n      \n[/code:3qsbzg8v]\n\nMoving on, for this code:\n\n[code:3qsbzg8v]   Addition&#58;\n   \n      mov      eax, dword ptr operand_1 + 4\n      mov      ecx, dword ptr operand_2 + 4\n      adc      eax, ecx\n      mov      dword ptr result_value + 4, eax\n      \n      jmp    Conversion[/code:3qsbzg8v]\nI don't know why you're adding 4 onto the variable. The variable is only 4 bytes big to begin with. so you're effectively moving beyond it. You don't do that for multiply and divide, so perhaps that was something needed to be fixed? (The same goes for subtraction.)\n\nAnd you're using &quot;adc&quot; instead of &quot;add&quot;. Instead of simply adding the two numbers, you're actually adding the two numbers *plus the carry*, but it's unclear what the carry will actually be at that point. So you could randomly end up with off by 1 problems. The same goes with sbb in your subtraction. A simple &quot;sub&quot; will do. \n\nYou would use &quot;adc&quot; and &quot;sbb&quot; when you're doing multi-stage additions or subtractions, where you need to propagate any carry or borrow from the previous addition/subtraction to the next stage. You can also use them for weird tricks, but we don't need to go there... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I can't see any reason to use them in this case.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>If I understand correctly, the 'uses' key-word/command, merely copies the registers' (original) values into/onto the stack for storage, so that once you're done with the procedure, those original values are loaded/copied/moved back into your registers, over-writing whatever values were currently in them from your procedure operations.<br/><br/>With this understanding, then why would you need to indirectly (via parameters) use registers in/for your procedures ???<br/><br/>Unofrtunately, the required given procedure only mentions/specifies that the array source address (in esi) and its size/length (in ecx) are to be used as its args.</p></blockquote><br/>That was my point. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You're not setting eax to *anything* before you do your first &quot;add      eax, edx&quot;. So you're effectively using a register with an unknown value. It happens to be 0 in this case initially because you have xor'd it at the program start (for what reason, I don't know), which means the first number will *happen* to come out correctly, but not after that. You defintiely *don't* want to do that. If you want to do the add (which I still don't think you want or need to do initially), then you should at least set eax to 0 beforehand *in the function*. <br/><br/>As far as the sign goes, it looks like you fixed it - if there is a sign, you just increment past it, which is good.<br/><br/>You still have the problem of processing one too many characters in the non-signed case, since you're processing the first one outside the loop and not decrementing ecx when you add ebx, 01h before entering the loop. Rather than do that though, I still think you should just xor eax, eax to prime it and fall into the loop. There's no reason to process the first digit specially. (In fact, think about what happens if ecx comes in as 0! Or 1 even.)<br/><br/>Also, your check for the digit being in the range '0' - '9' is only being done on the first character. You should either move the check into the loop or just get rid of it (the requirements for this state the numbers will be legal. So validating them is not necessary. But if you're going to do it, then do it for all the characters).<br/><br/>So I think this code:<br/><br/><pre><code>   local    Pre_Start_ASCII_To_Decimal&#58;<br/>      <br/>      xor      ebx, ebx<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;, SIGN<br/>      je      Next_Index_ASCII_To_Decimal<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;, 00h<br/>      jb      Invalid_Input<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;,   09h<br/>      ja      Invalid_Input      <br/>      <br/>      movzx   edx, byte ptr esi&#91;ebx&#93;<br/>      sub      edx, ZERO_CHAR<br/>      add      eax, edx<br/>      <br/>      add      ebx, 01h<br/>   local   Start_ASCII_To_Decimal&#58;<br/><br/></code></pre><br/>should just be this:<br/> <pre><code>   local    Pre_Start_ASCII_To_Decimal&#58;<br/>      xor      ebx, ebx<br/>      xor      eax, eax<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;, SIGN<br/>      jne      Start_ASCII_To_Decimal<br/><br/>      inc ebx<br/>      dec ecx<br/><br/>   local   Start_ASCII_To_Decimal&#58;<br/></code></pre><br/><br/>or this if you want to validate the characters:<br/><br/> <pre><code>   local    Pre_Start_ASCII_To_Decimal&#58;<br/>      xor      ebx, ebx<br/>      xor      eax, eax<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;, SIGN<br/>      jne      Start_ASCII_To_Decimal<br/><br/>      inc ebx<br/>      dec ecx<br/><br/>   local   Start_ASCII_To_Decimal&#58;<br/><br/>      cmp      byte ptr esi&#91;ebx&#93;, 00h<br/>      jb      Invalid_Input<br/>      <br/>      cmp      byte ptr esi&#91;ebx&#93;,   09h<br/>      ja      Invalid_Input   <br/>      <br/></code></pre><br/><br/>Moving on, for this code:<br/><br/><pre><code>   Addition&#58;<br/>   <br/>      mov      eax, dword ptr operand_1 + 4<br/>      mov      ecx, dword ptr operand_2 + 4<br/>      adc      eax, ecx<br/>      mov      dword ptr result_value + 4, eax<br/>      <br/>      jmp    Conversion</code></pre><br/>I don't know why you're adding 4 onto the variable. The variable is only 4 bytes big to begin with. so you're effectively moving beyond it. You don't do that for multiply and divide, so perhaps that was something needed to be fixed? (The same goes for subtraction.)<br/><br/>And you're using &quot;adc&quot; instead of &quot;add&quot;. Instead of simply adding the two numbers, you're actually adding the two numbers *plus the carry*, but it's unclear what the carry will actually be at that point. So you could randomly end up with off by 1 problems. The same goes with sbb in your subtraction. A simple &quot;sub&quot; will do. <br/><br/>You would use &quot;adc&quot; and &quot;sbb&quot; when you're doing multi-stage additions or subtractions, where you need to propagate any carry or borrow from the previous addition/subtraction to the next stage. You can also use them for weird tricks, but we don't need to go there... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> I can't see any reason to use them in this case.",
      "PostDate": "2016-03-16T12:34:08+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41757",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ah, thanks for all the help! I have no clue on how to do the arithmetic operations... we got power point slides on the instruction sets, so I was just using them, and saw that the example was a 'word' with '+2', so that's where my '+4' came from, as I'm like okay maybe I do +4 for dwords lol, as I think I'm using dwords as the regs are dwords/32 bits, or should I use a different data type?\n\nalright, so I don't need to use the adc/sbb, right? I just used them as I thought I'd need them to deal with the flags (carry/sign/zero/etc) ... I really have no clue on any of this arithmetic stuff, I've never done it before, and don't understand it at all.\n\nhow do I handle the arithmetic, and possibly flag usages too ???\n\nI found an online edu resource that gets a bit into explaining the multiplication for me:\n\nalgorithms: repeated addition, 'shift and' add, parallel multiplication, \n\nnegative numbers:\n\nconvert to positive, multiply, then convert back to negative if only one was negative,\netc etc etc\n\n------------\n\nhow much do the instruction sets handle, vs what you have to do/account for ???",
      "EditableFormat": "bbcode",
      "HTML": "ah, thanks for all the help! I have no clue on how to do the arithmetic operations... we got power point slides on the instruction sets, so I was just using them, and saw that the example was a 'word' with '+2', so that's where my '+4' came from, as I'm like okay maybe I do +4 for dwords lol, as I think I'm using dwords as the regs are dwords/32 bits, or should I use a different data type?<br/><br/>alright, so I don't need to use the adc/sbb, right? I just used them as I thought I'd need them to deal with the flags (carry/sign/zero/etc) ... I really have no clue on any of this arithmetic stuff, I've never done it before, and don't understand it at all.<br/><br/>how do I handle the arithmetic, and possibly flag usages too ???<br/><br/>I found an online edu resource that gets a bit into explaining the multiplication for me:<br/><br/>algorithms: repeated addition, 'shift and' add, parallel multiplication, <br/><br/>negative numbers:<br/><br/>convert to positive, multiply, then convert back to negative if only one was negative,<br/>etc etc etc<br/><br/>------------<br/><br/>how much do the instruction sets handle, vs what you have to do/account for ???",
      "PostDate": "2016-03-16T15:00:01+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41764",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote=&quot;HegemonKhan&quot;:7yer494s]ah, thanks for all the help! I have no clue on how to do the arithmetic operations... we got power point slides on the instruction sets, so I was just using them, and saw that the example was a 'word' with '+2', so that's where my '+4' came from, as I'm like okay maybe I do +4 for dwords lol, as I think I'm using dwords as the regs are dwords/32 bits, or should I use a different data type?\n\n[/quote:7yer494s]\n\ndwords should be fine. You said initially that you need to support 32-bit values, and that serves that perfectly.\n\n[quote=&quot;HegemonKhan&quot;:7yer494s]alright, so I don't need to use the adc/sbb, right? I just used them as I thought I'd need them to deal with the flags (carry/sign/zero/etc) ... I really have no clue on any of this arithmetic stuff, I've never done it before, and don't understand it at all.\n\nhow do I handle the arithmetic, and possibly flag usages too ???\n[/quote:7yer494s]\n\nYou can use the overflow bit after addition or subtraction to see if it overflowed (jo/jno, etc).\n\nFor multiplication, if you use the single operand form of an IMUL (e.g. IMUL EBX), then it multiples EAX by the operand, and the 64-bit result is put in EDX:EAX. So you'd be able to check for overflow by seeing if EDX is not either 0 (for a positive result) or 0xFFFFFFFF (for a negative result). Any thing other than those two would indicate bits straying beyond 32-bits and would be an overflow\n\nFor division, it should never overflow, as you can't divide two 32-bit numbers and have it exceed 32-bits (the largest you could have is MAXINT / 1, which is still just MAXINT). But you do need to check for 0 in the divisor (what you're dividing by) before you divide. If you try to divide by 0, it gives an exception!\n\n[quote=&quot;HegemonKhan&quot;:7yer494s]I found an online edu resource that gets a bit into explaining the multiplication for me:\n\nalgorithms: repeated addition, 'shift and' add, parallel multiplication, \n\nnegative numbers:\n\nconvert to positive, multiply, then convert back to negative if only one was negative,\netc etc etc\n\n------------\n\nhow much do the instruction sets handle, vs what you have to do/account for ???[/quote:7yer494s]\nYou don't need to do all the shifts and adds and things. We had to do that back before processors had multiply and divide instructions, but there is just no need to any more, unless you're exploring how it works (which you don't need to do for this assignment, and it just complicates things).",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>HegemonKhan wrote:</cite>ah, thanks for all the help! I have no clue on how to do the arithmetic operations... we got power point slides on the instruction sets, so I was just using them, and saw that the example was a 'word' with '+2', so that's where my '+4' came from, as I'm like okay maybe I do +4 for dwords lol, as I think I'm using dwords as the regs are dwords/32 bits, or should I use a different data type?<br/><br/></blockquote><br/><br/>dwords should be fine. You said initially that you need to support 32-bit values, and that serves that perfectly.<br/><br/><blockquote><cite>HegemonKhan wrote:</cite>alright, so I don't need to use the adc/sbb, right? I just used them as I thought I'd need them to deal with the flags (carry/sign/zero/etc) ... I really have no clue on any of this arithmetic stuff, I've never done it before, and don't understand it at all.<br/><br/>how do I handle the arithmetic, and possibly flag usages too ???<br/></blockquote><br/><br/>You can use the overflow bit after addition or subtraction to see if it overflowed (jo/jno, etc).<br/><br/>For multiplication, if you use the single operand form of an IMUL (e.g. IMUL EBX), then it multiples EAX by the operand, and the 64-bit result is put in EDX:EAX. So you'd be able to check for overflow by seeing if EDX is not either 0 (for a positive result) or 0xFFFFFFFF (for a negative result). Any thing other than those two would indicate bits straying beyond 32-bits and would be an overflow<br/><br/>For division, it should never overflow, as you can't divide two 32-bit numbers and have it exceed 32-bits (the largest you could have is MAXINT / 1, which is still just MAXINT). But you do need to check for 0 in the divisor (what you're dividing by) before you divide. If you try to divide by 0, it gives an exception!<br/><br/><blockquote><cite>HegemonKhan wrote:</cite>I found an online edu resource that gets a bit into explaining the multiplication for me:<br/><br/>algorithms: repeated addition, 'shift and' add, parallel multiplication, <br/><br/>negative numbers:<br/><br/>convert to positive, multiply, then convert back to negative if only one was negative,<br/>etc etc etc<br/><br/>------------<br/><br/>how much do the instruction sets handle, vs what you have to do/account for ???</blockquote><br/>You don't need to do all the shifts and adds and things. We had to do that back before processors had multiply and divide instructions, but there is just no need to any more, unless you're exploring how it works (which you don't need to do for this assignment, and it just complicates things).",
      "PostDate": "2016-03-16T19:23:44+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41775",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "thank you again, for all of your help Jay!\n\nlet me see if I can learn the rest of this program from the solution code/program that will be available after my class today, and if not then I can ask you for help as I need it. I really appreciate all of your help, as I really want to learn assembly, and get better at writing code/program for/with it. And I of course need to learn these basics of bit shifting, arithmetic, and understanding and working with the flags. I'm really greatful for the tremendous help you've already given me, I've been learning so much, thank you Jay!",
      "EditableFormat": "bbcode",
      "HTML": "thank you again, for all of your help Jay!<br/><br/>let me see if I can learn the rest of this program from the solution code/program that will be available after my class today, and if not then I can ask you for help as I need it. I really appreciate all of your help, as I really want to learn assembly, and get better at writing code/program for/with it. And I of course need to learn these basics of bit shifting, arithmetic, and understanding and working with the flags. I'm really greatful for the tremendous help you've already given me, I've been learning so much, thank you Jay!",
      "PostDate": "2016-03-16T22:26:14+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41776",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "No problem! Good luck and have fun. <!-- s;) --><img src=\"{SMILIES_PATH}/icon_wink.gif\" alt=\";)\" title=\"Wink\" /><!-- s;) -->",
      "EditableFormat": "bbcode",
      "HTML": "No problem! Good luck and have fun. <!-- s;) --><img src=\"{SMILIES_PATH}/icon_wink.gif\" alt=\";)\" title=\"Wink\" /><!-- s;) -->",
      "PostDate": "2016-03-16T22:29:35+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41792",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "we got one more assembly assignment (having c++ run an assembly program; assembly obviously can't be inline/inside of the c++ file), but we're now otherwise shifting over to computer architecture now... this will be fun... hopefully I can get this stuff... never done any electronics/electricty/engineering/physics stuff, so it might be a bit daunting for me... especially all of the logic gates and etc... but meh, I got to learn sometime, and it's now hehe, FULL SPEED AHEAD! (and if I fail the class, meh, at my age the bad grade doesn't mean much, it's more worthwhile to get what I can out of the class for what I paid for the class vs dropping out just to not get a bad grade. I take it again, and hopefully do better, now having some learning/knowledge already for the second attempt at it. The extra cost/money ain't cool, but meh, I'm trying/tried my best, sometimes people just fail at some things, and it takes them more tries, than other people. Ya, it'd be nice only need one attempt and success, but that's not always the case).\n\n-------------\n\nI had casually known a really smart student/peer in high school, who out of high school, got accepted to this college/university, I don't know how it compares to other universities/colleges (I'm not that learned on quality of university CS courses ~ been lazy), but I think it is pretty prestigious... as this person/student/peer was REALLY REALLY REALLY smart, really really good at math, physics, and programming. Anyways, it's daunting, at how little I actually know/progressed in CS, compared to what's out there... a PhD, is a long long long long ways off, laughs, sighs... Just learning what I can now at a junior college before going to a university to work towards my bachelors, and maybe some kind of job, lol. Masters and Ph. D, are far off in the future if things go well... sighs.\n\n<!-- m --><a class=\"postlink\" href=\"https://www.cs.hmc.edu/program/course-descriptions/\">https://www.cs.hmc.edu/program/course-descriptions/</a><!-- m -->\n\nso, much to still learn... and probably way beyond my ability (I'm not good at math, sighs).",
      "EditableFormat": "bbcode",
      "HTML": "we got one more assembly assignment (having c++ run an assembly program; assembly obviously can't be inline/inside of the c++ file), but we're now otherwise shifting over to computer architecture now... this will be fun... hopefully I can get this stuff... never done any electronics/electricty/engineering/physics stuff, so it might be a bit daunting for me... especially all of the logic gates and etc... but meh, I got to learn sometime, and it's now hehe, FULL SPEED AHEAD! (and if I fail the class, meh, at my age the bad grade doesn't mean much, it's more worthwhile to get what I can out of the class for what I paid for the class vs dropping out just to not get a bad grade. I take it again, and hopefully do better, now having some learning/knowledge already for the second attempt at it. The extra cost/money ain't cool, but meh, I'm trying/tried my best, sometimes people just fail at some things, and it takes them more tries, than other people. Ya, it'd be nice only need one attempt and success, but that's not always the case).<br/><br/>-------------<br/><br/>I had casually known a really smart student/peer in high school, who out of high school, got accepted to this college/university, I don't know how it compares to other universities/colleges (I'm not that learned on quality of university CS courses ~ been lazy), but I think it is pretty prestigious... as this person/student/peer was REALLY REALLY REALLY smart, really really good at math, physics, and programming. Anyways, it's daunting, at how little I actually know/progressed in CS, compared to what's out there... a PhD, is a long long long long ways off, laughs, sighs... Just learning what I can now at a junior college before going to a university to work towards my bachelors, and maybe some kind of job, lol. Masters and Ph. D, are far off in the future if things go well... sighs.<br/><br/><!-- m --><a class=\"postlink\" href=\"https://www.cs.hmc.edu/program/course-descriptions/\">https://www.cs.hmc.edu/program/course-descriptions/</a><!-- m --><br/><br/>so, much to still learn... and probably way beyond my ability (I'm not good at math, sighs).",
      "PostDate": "2016-03-17T11:35:31+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41793",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "If it makes you feel any better, I don't even have a degree. I was already working as a programmer while in college, and for various reasons, I took a &quot;leave of absence&quot; from school and have never gone back. Of course, I was doing what I loved, and the past several decades have been a lifelong course in computer science. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> There's no doubt lots I don't know (CS is a huge field), and I often wonder what I would have learned in a more formal environment, but I don't regret it. Sometimes I think about going back, but... what does a degree get me that knowledge from something like Udemy won't? \n\n(Of course, I do have the luxury of lots of working experience, which helps me when getting jobs. I wouldn't even begin to suggest to anyone to *not* get a degree when starting out. It just happened to work out the way it did for me.)\n\nBack to your first point, I was an electronics hobbyist before the programming bug bit me (casual reading and experimenting and taking things apart to see how they worked during my teen years). If you have any questions about any of that, feel free to ask here as well. I may not know the answer, but I might. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "If it makes you feel any better, I don't even have a degree. I was already working as a programmer while in college, and for various reasons, I took a &quot;leave of absence&quot; from school and have never gone back. Of course, I was doing what I loved, and the past several decades have been a lifelong course in computer science. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> There's no doubt lots I don't know (CS is a huge field), and I often wonder what I would have learned in a more formal environment, but I don't regret it. Sometimes I think about going back, but... what does a degree get me that knowledge from something like Udemy won't? <br/><br/>(Of course, I do have the luxury of lots of working experience, which helps me when getting jobs. I wouldn't even begin to suggest to anyone to *not* get a degree when starting out. It just happened to work out the way it did for me.)<br/><br/>Back to your first point, I was an electronics hobbyist before the programming bug bit me (casual reading and experimenting and taking things apart to see how they worked during my teen years). If you have any questions about any of that, feel free to ask here as well. I may not know the answer, but I might. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-03-17T12:36:21+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "41794",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Definately, especially with the U.S. school system... it really is becoming obsolete, some U.S. schools have just somewhat started to modernize, but lots of the old teaching practices are still used (droning lectures... read boring book chapters, take tests, etc etc etc, argh!), which just don't work anymore in today's high speed and time-scarce world, which despite that, actually require much more hands-on and practice/experience/repetition of the material, too. We got the internet, we can look up the info/terms/etc, what we can't look up is guidance/practice/eperience/etc of topics, designs, logic, and etc programming aspects.\n\nYa, most poeple learn stuff on their own (internet). If you alredy learned the material on your own, you ace school classes. If you haven't you struggle... this is epsecially the case with programming classes. I already learned a bit of high level language stuff thanks to quest, so C++/Java were mostly easy classes. But, I've never learned assembly language ahead of time, so I'm struggling with it (the class) now. I see this with everyone. People who're struggling in the programming classes are the ones who're learning the material for their first time, and for everyone who breeze through the class with ease, are those who already know the material (makes you think why they're even taking the class, aside from merely being required to do so, unless there's some kind of test to bypass the class to more advanced classes, which is generally rare). That's been my experience with the teaching. They teach more for those who already know a bit of the material (here's some lecturing, and here's the programming assignment, go do it), whereas teaching for those new to the material, should involve more walking through programs and concepts/designs/logic, etc. Don't get me wrong, teachers don't have much time, for teaching, so they do the best of with what they got, as a lot of my classes only meet once a week and are only 3 hrs, so that's not much time for the teacher to teach a more guiding/walkthrough approach (whereas 3 hrs is a long long long time for lectures, argh. Scientifically, humans can only do an hr of lecture, any time beyond an hour, we just can't maintain attention upon it)",
      "EditableFormat": "bbcode",
      "HTML": "Definately, especially with the U.S. school system... it really is becoming obsolete, some U.S. schools have just somewhat started to modernize, but lots of the old teaching practices are still used (droning lectures... read boring book chapters, take tests, etc etc etc, argh!), which just don't work anymore in today's high speed and time-scarce world, which despite that, actually require much more hands-on and practice/experience/repetition of the material, too. We got the internet, we can look up the info/terms/etc, what we can't look up is guidance/practice/eperience/etc of topics, designs, logic, and etc programming aspects.<br/><br/>Ya, most poeple learn stuff on their own (internet). If you alredy learned the material on your own, you ace school classes. If you haven't you struggle... this is epsecially the case with programming classes. I already learned a bit of high level language stuff thanks to quest, so C++/Java were mostly easy classes. But, I've never learned assembly language ahead of time, so I'm struggling with it (the class) now. I see this with everyone. People who're struggling in the programming classes are the ones who're learning the material for their first time, and for everyone who breeze through the class with ease, are those who already know the material (makes you think why they're even taking the class, aside from merely being required to do so, unless there's some kind of test to bypass the class to more advanced classes, which is generally rare). That's been my experience with the teaching. They teach more for those who already know a bit of the material (here's some lecturing, and here's the programming assignment, go do it), whereas teaching for those new to the material, should involve more walking through programs and concepts/designs/logic, etc. Don't get me wrong, teachers don't have much time, for teaching, so they do the best of with what they got, as a lot of my classes only meet once a week and are only 3 hrs, so that's not much time for the teacher to teach a more guiding/walkthrough approach (whereas 3 hrs is a long long long time for lectures, argh. Scientifically, humans can only do an hr of lecture, any time beyond an hour, we just can't maintain attention upon it)",
      "PostDate": "2016-03-17T13:05:57+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "42020",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "new lab asssignment (last assembly lab, after this, it's just the digital circuitry project with the logic gates and etc):\n\nwrite a (32-bit) assembly procedure that will be called from a C++ (32-bit) program. Can't do in-line assembly in the C++ program obviously. Will be provided the C++ program that will call/run our assembly procedure.\n\nObviously, also can't do/use:\n\n.MODEL flat, C\nMyProc proc C\nspecifying a start label in your end directive\n\npurpose:\n\nthe assembly procedure is to compress a data buffer using RLE (Run Length Encoding).\n\nthe function prototype for the RLE procedure:\n\nDWORD RLE_Encode (char *InputBuf, DWORD InputLength, char OutputBuf)\n\nInput:\n\nInputBuf ; Buffer to compress\n\nInputLength ; number of bytes in InputBuf\n\nOutput:\n\nOutputBuf ; RLE converted data is returned here\n\nReturns:\n\n; size of RLE data\n\nthis algoritm can be used to decode an RLE encode buffer:\n\nRead the first byte of data, if the two most significant bits are set, then the 6 least significant bytes represent a repeat count, and the next byte is the actual data byte to be repeated. If the two most significant bits are not set then the repeat count is equal to 1 and the byte read is the actual byte.\n\n------------\n\nI'm not even really understanding exactly what I'm doing in this assignment... so, I'm finding the instructions a bit vague as I'm unable to understand exactly what I'm doing here with this assignment.\n\nI guess I'm taking some kind of data, and trying to compress it into a smaller size. (C++ program calls on/runs the assembly procedure to...) Am I taking in the RLE encoded data, and compressing that data into a smaller size to be then used by the C++ program?\n\nAlso, this assignment sounds/seems like it's similar to the virtual CPU emulation, where I was reading/using the opcodes, and doing various operations based upon them. Is generally the same thing to be used for this assignment, or no?\n\nat least for me, the C++ program doesn't help too much with understanding what I'm to do with this assignment (and/or I'm just not able to understand it). Though if you want to see it, I can post/pm it to you, as maybe it can help you with what's going on, better than it does for me.\n\n---------\n\nI'm not sure on the correct syntax for the prototype... this is my guess at it:\n\nRLE Encode PROTO : BYTE, : DWORD, : BYTE\n\n; do I need to include the return type into the prototype? if yes, does it go before the label or somewhere in the list of parameter data types (and where, as I know placement matters, as this matches up with the push-pop-to-from-stack and parameter-order that the call uses) ???\n\n; was I correct to use 'BYTE' for 'char' ??? (is 'char' 1 byte?), or should it be 'WORD' (is 'char' 2 bytes?), or should it be 'DWORD' (is 'char' the C size of 'int', = 4 bytes?), or should I use 'char' (I didn't notice a font color change though when I typed in 'char' in assembly file, that's why I'm guessing at using 'BYTE' instead)\n\n; I presume I can place prototypes anywhere (or at least above/before the '.data' section, or do the prototypes need to go into the '.data' section, or even maybe-possibly the '.code' section?)\n\n-------\n\nalso, for the actual procedure, do I use 'char' or ( do I use 'byte/word/dword' ) as the parameters' date type ???\n\n-------\n\nright now, I just need some help with the general direction of what to do/what this assignment is about... I'm just a bit lost in how to go about just starting this assignment, so I'm not sure where or what to even begin with doing or figuring out.\n\n------\n\nI've done badly on some (enough that I'm probably not even going to pass the class now) assignments/labs and tests, so I'm just interested now in just learning how to do this assembly stuff, so if (which is likely now, unless I ace everything else which is obviously not possible with already my struggle with the material/programming) I need to take the class again, I'll have some knowledge and practice on how to do this assembly programming which I'm ve been struggling with this time around, so I'll do better next time I take the class, hopefully understanding assembly programming well by then, and do much better the second time around. I just want to have these assignments/programs explained, so I can learn and practice them, hopefully becoming good at them, and understand better how to program in assembly and related conceptual understandings of doing assembly programming. I'm still really struggling with the bit manipulation stuff too, sighs.\n\n(After the symester/class, if you don't mind..., I'd like to revisit the, in general bit-manipulation and bit-arithmetic, programming, as I'm still really struggling with that stuff still, sighs, and it's extremely important/vital to learn, as it's a major use/fundamentals/basics in/for/with doing assembly programming)\n\nAgain, I'm so greatful for all the help you've given me already on understanding and learning as much as I have of assembly thanks to your help, Jay!\n\n----------\n\nin the meantime, I'll be trying to see what I can research on how to do this (not the old arithment one, I mean this current RLE) assignment, on my own too.",
      "EditableFormat": "bbcode",
      "HTML": "new lab asssignment (last assembly lab, after this, it's just the digital circuitry project with the logic gates and etc):<br/><br/>write a (32-bit) assembly procedure that will be called from a C++ (32-bit) program. Can't do in-line assembly in the C++ program obviously. Will be provided the C++ program that will call/run our assembly procedure.<br/><br/>Obviously, also can't do/use:<br/><br/>.MODEL flat, C<br/>MyProc proc C<br/>specifying a start label in your end directive<br/><br/>purpose:<br/><br/>the assembly procedure is to compress a data buffer using RLE (Run Length Encoding).<br/><br/>the function prototype for the RLE procedure:<br/><br/>DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char OutputBuf)<br/><br/>Input:<br/><br/>InputBuf ; Buffer to compress<br/><br/>InputLength ; number of bytes in InputBuf<br/><br/>Output:<br/><br/>OutputBuf ; RLE converted data is returned here<br/><br/>Returns:<br/><br/>; size of RLE data<br/><br/>this algoritm can be used to decode an RLE encode buffer:<br/><br/>Read the first byte of data, if the two most significant bits are set, then the 6 least significant bytes represent a repeat count, and the next byte is the actual data byte to be repeated. If the two most significant bits are not set then the repeat count is equal to 1 and the byte read is the actual byte.<br/><br/>------------<br/><br/>I'm not even really understanding exactly what I'm doing in this assignment... so, I'm finding the instructions a bit vague as I'm unable to understand exactly what I'm doing here with this assignment.<br/><br/>I guess I'm taking some kind of data, and trying to compress it into a smaller size. (C++ program calls on/runs the assembly procedure to...) Am I taking in the RLE encoded data, and compressing that data into a smaller size to be then used by the C++ program?<br/><br/>Also, this assignment sounds/seems like it's similar to the virtual CPU emulation, where I was reading/using the opcodes, and doing various operations based upon them. Is generally the same thing to be used for this assignment, or no?<br/><br/>at least for me, the C++ program doesn't help too much with understanding what I'm to do with this assignment (and/or I'm just not able to understand it). Though if you want to see it, I can post/pm it to you, as maybe it can help you with what's going on, better than it does for me.<br/><br/>---------<br/><br/>I'm not sure on the correct syntax for the prototype... this is my guess at it:<br/><br/>RLE Encode PROTO : BYTE, : DWORD, : BYTE<br/><br/>; do I need to include the return type into the prototype? if yes, does it go before the label or somewhere in the list of parameter data types (and where, as I know placement matters, as this matches up with the push-pop-to-from-stack and parameter-order that the call uses) ???<br/><br/>; was I correct to use 'BYTE' for 'char' ??? (is 'char' 1 byte?), or should it be 'WORD' (is 'char' 2 bytes?), or should it be 'DWORD' (is 'char' the C size of 'int', = 4 bytes?), or should I use 'char' (I didn't notice a font color change though when I typed in 'char' in assembly file, that's why I'm guessing at using 'BYTE' instead)<br/><br/>; I presume I can place prototypes anywhere (or at least above/before the '.data' section, or do the prototypes need to go into the '.data' section, or even maybe-possibly the '.code' section?)<br/><br/>-------<br/><br/>also, for the actual procedure, do I use 'char' or ( do I use 'byte/word/dword' ) as the parameters' date type ???<br/><br/>-------<br/><br/>right now, I just need some help with the general direction of what to do/what this assignment is about... I'm just a bit lost in how to go about just starting this assignment, so I'm not sure where or what to even begin with doing or figuring out.<br/><br/>------<br/><br/>I've done badly on some (enough that I'm probably not even going to pass the class now) assignments/labs and tests, so I'm just interested now in just learning how to do this assembly stuff, so if (which is likely now, unless I ace everything else which is obviously not possible with already my struggle with the material/programming) I need to take the class again, I'll have some knowledge and practice on how to do this assembly programming which I'm ve been struggling with this time around, so I'll do better next time I take the class, hopefully understanding assembly programming well by then, and do much better the second time around. I just want to have these assignments/programs explained, so I can learn and practice them, hopefully becoming good at them, and understand better how to program in assembly and related conceptual understandings of doing assembly programming. I'm still really struggling with the bit manipulation stuff too, sighs.<br/><br/>(After the symester/class, if you don't mind..., I'd like to revisit the, in general bit-manipulation and bit-arithmetic, programming, as I'm still really struggling with that stuff still, sighs, and it's extremely important/vital to learn, as it's a major use/fundamentals/basics in/for/with doing assembly programming)<br/><br/>Again, I'm so greatful for all the help you've given me already on understanding and learning as much as I have of assembly thanks to your help, Jay!<br/><br/>----------<br/><br/>in the meantime, I'll be trying to see what I can research on how to do this (not the old arithment one, I mean this current RLE) assignment, on my own too.",
      "PostDate": "2016-03-31T19:29:46+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42021",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Well, this class certainly gets into interesting things. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nSo if I read this right, you need to write the encoding part of an encoder/decoder pair. You will receive a buffer of unencoded data, and you'll need to encode it and write it to the output buffer. It tells you how to decode, but I don't think that's what you need to code. At least, that's what I took away.\n\nThe prototype you have looks wrong to me. I think it should be this:\n\nDWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);\n\nIt takes a char* input buffer and the length of that input buffer, it writes the encoded data into OutputBuf (which is also a pointer), and then it returns the length of the encoded data, so you know how big the encoded data ended up being.\n\nIt is correct to use BYTE for the data type; you'll be reading and writing bytes. (Technically, the signature for the C function should probably be &quot;unsigned char*&quot; instead of just &quot;char*&quot;, but that won't make any difference to your assembly code.)\n\nWhat I don't know about is how to set up the assembly function. I know the general mechanics of how the C code will call the assembly code, but the code you have shown me so far had additional directives that I've never used, so I don't know if there is a trivially easy way to set it up. I'll try to describe how we did it (and this article speaks to it as well: <!-- m --><a class=\"postlink\" href=\"https://banisterfiend.wordpress.com/2008/08/15/calling-an-asm-function-from-c/\">https://banisterfiend.wordpress.com/200 ... on-from-c/</a><!-- m -->)\n\nWhen the C code calls your assembly language code, it will push the arguments onto the stack. Then it will call your function. The arguments are pushed onto the stack in reverse order (and the stack grows downward), so the arguments will be in order left to right on the stack. It would look like this:\n\n[code:2eptmril]\nESP +0                 +4                             +8                                  +12\n       Return address | Argument 1 (input buf) | Argument 2 (input length) | Argument 3 (output buf)\n       [/code:2eptmril]\n\nUnless there are special directives to set this up for you, what you would do is first save the EBP register by pushing it. This leaves the stack looking like this:\n\n[code:2eptmril]\nESP +0           +4               +8                             +12                            +16\n       saved ebp | Return address | Argument 1 (input buf) | Argument 2 (input length) | Argument 3 (output buf)[/code:2eptmril]\n\nThen you would mov ebp, esp. That allows you to access the parameters from the stack.\nSo: first argument would be at dword ptr [ebp+8], argument two would be at dword ptr [ebp+12], etc. In this case, they're all 32-bit values (I assume).\n\nNow, as I said, you might not need to do all that. I'll see if I can find any references online whether masm has special directives to wrap your function and automatically handle it. But if not, that's how you'd have to do it.\n\nThe return value is expected to be in EAX. So the length of the encoded data must end up there.\n\nFinally, since C code has variable arguments (potentially), only the caller knows how many were actually pushed. So you don't need to clean up the stack in your code (that is, remove the arguments). There are some calling conventions like the &quot;Pascal&quot; calling convention where you do, but you shouldn't have to for this.\n\nLet me break it here and then pick up again to talk about the run length encoding.",
      "EditableFormat": "bbcode",
      "HTML": "Well, this class certainly gets into interesting things. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>So if I read this right, you need to write the encoding part of an encoder/decoder pair. You will receive a buffer of unencoded data, and you'll need to encode it and write it to the output buffer. It tells you how to decode, but I don't think that's what you need to code. At least, that's what I took away.<br/><br/>The prototype you have looks wrong to me. I think it should be this:<br/><br/>DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);<br/><br/>It takes a char* input buffer and the length of that input buffer, it writes the encoded data into OutputBuf (which is also a pointer), and then it returns the length of the encoded data, so you know how big the encoded data ended up being.<br/><br/>It is correct to use BYTE for the data type; you'll be reading and writing bytes. (Technically, the signature for the C function should probably be &quot;unsigned char*&quot; instead of just &quot;char*&quot;, but that won't make any difference to your assembly code.)<br/><br/>What I don't know about is how to set up the assembly function. I know the general mechanics of how the C code will call the assembly code, but the code you have shown me so far had additional directives that I've never used, so I don't know if there is a trivially easy way to set it up. I'll try to describe how we did it (and this article speaks to it as well: <!-- m --><a class=\"postlink\" href=\"https://banisterfiend.wordpress.com/2008/08/15/calling-an-asm-function-from-c/\">https://banisterfiend.wordpress.com/200 ... on-from-c/</a><!-- m -->)<br/><br/>When the C code calls your assembly language code, it will push the arguments onto the stack. Then it will call your function. The arguments are pushed onto the stack in reverse order (and the stack grows downward), so the arguments will be in order left to right on the stack. It would look like this:<br/><br/><pre><code><br/>ESP +0                 +4                             +8                                  +12<br/>       Return address | Argument 1 (input buf) | Argument 2 (input length) | Argument 3 (output buf)<br/>       </code></pre><br/><br/>Unless there are special directives to set this up for you, what you would do is first save the EBP register by pushing it. This leaves the stack looking like this:<br/><br/><pre><code><br/>ESP +0           +4               +8                             +12                            +16<br/>       saved ebp | Return address | Argument 1 (input buf) | Argument 2 (input length) | Argument 3 (output buf)</code></pre><br/><br/>Then you would mov ebp, esp. That allows you to access the parameters from the stack.<br/>So: first argument would be at dword ptr [ebp+8], argument two would be at dword ptr [ebp+12], etc. In this case, they're all 32-bit values (I assume).<br/><br/>Now, as I said, you might not need to do all that. I'll see if I can find any references online whether masm has special directives to wrap your function and automatically handle it. But if not, that's how you'd have to do it.<br/><br/>The return value is expected to be in EAX. So the length of the encoded data must end up there.<br/><br/>Finally, since C code has variable arguments (potentially), only the caller knows how many were actually pushed. So you don't need to clean up the stack in your code (that is, remove the arguments). There are some calling conventions like the &quot;Pascal&quot; calling convention where you do, but you shouldn't have to for this.<br/><br/>Let me break it here and then pick up again to talk about the run length encoding.",
      "PostDate": "2016-03-31T20:47:48+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42022",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "The run length encoding has two forms: if the two high bits of the byte are set, then the bottom six are the length, and the next byte after the count byte is the data byte to use. If the two top bits aren't both set, then the byte is just the data byte. So if you had this *encoded*:\n\nC8  (11001000)\nFF\n\nthe decoder would decode 8 0FFh bytes.\n\nCF  (11001111)\n00\n\nthe decoder would decode 15 (00fh) 00 bytes\n\nAA (10101010)\n\nthe decoder would decode a single 0AAh byte.\n\n00 (00000000)\n\nthe decoder would decode a single 000h byte.\n\nFF  (11111111)\nCC\n\nthe decoder would decode 63 (111111b = 03fh) 0cch bytes\n\nNow, your assignment is to go the other way - to create the encoded data. A truly inefficient way would be to take each incoming byte and just slap 0c1h onto the front of it. So 1, 2, 3, 4, 9, 10 would become 0xc1, 1, 0xc1, 2, 0xc1, 3, 0xc1, 4, 0xc1, 9, 0xc1, 10. That is just literally saying each byte is a single byte. Somewhat ironically, that particular set of data *would* look like that, because there are no duplicates in the data stream there.\n\nBut if you had this data: 00 00 00 00 00 00 01 02 02 02 02 00 10, it's better to get this:\n\n0c6h 00 0c1h 01 0c4h 02 0c1h 00 0c1h 10\n\nthan replicate all the bytes out (e.g. 6 copies of 0c1h 00).\n\nThe basic algorithm is to have a loop over the data - while you have data, keep going. You need to count identical bytes in a row in the source stream and write how many you get to the output when you hit some other byte (or the end of stream). There are some tricks to this:\n\n1) You need to stop counting when you reach the end of the source buffer. If you have any data counted at that point, you need to flush it to the output buffer as the final count.\n2) You need to stop counting when you reach 03fh (63). You can only encode 6 bits worth of count at a time, so when you reach that count, you need to flush the count/data pair to the output and then go back to counting as if you were starting afresh.\n3) If you end up with a single byte to write to the output but its two high bits are both set (if reg &amp; 0c0h == 0c0h), then you need to write it out as a repeated count sequence but with a count of 1. So if you have a single byte 47h, then you can write to the output as 47h. But if you have a single byte c6h, then you have to write it as c1h c6h. Otherwise the decoder would hit the 0c6 and think it's a count byte when you mean it to be a data byte, and it would get all confused.\n\nI hope that's enough to digest for now. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\nLet me know what questions you have still or next.",
      "EditableFormat": "bbcode",
      "HTML": "The run length encoding has two forms: if the two high bits of the byte are set, then the bottom six are the length, and the next byte after the count byte is the data byte to use. If the two top bits aren't both set, then the byte is just the data byte. So if you had this *encoded*:<br/><br/>C8  (11001000)<br/>FF<br/><br/>the decoder would decode 8 0FFh bytes.<br/><br/>CF  (11001111)<br/>00<br/><br/>the decoder would decode 15 (00fh) 00 bytes<br/><br/>AA (10101010)<br/><br/>the decoder would decode a single 0AAh byte.<br/><br/>00 (00000000)<br/><br/>the decoder would decode a single 000h byte.<br/><br/>FF  (11111111)<br/>CC<br/><br/>the decoder would decode 63 (111111b = 03fh) 0cch bytes<br/><br/>Now, your assignment is to go the other way - to create the encoded data. A truly inefficient way would be to take each incoming byte and just slap 0c1h onto the front of it. So 1, 2, 3, 4, 9, 10 would become 0xc1, 1, 0xc1, 2, 0xc1, 3, 0xc1, 4, 0xc1, 9, 0xc1, 10. That is just literally saying each byte is a single byte. Somewhat ironically, that particular set of data *would* look like that, because there are no duplicates in the data stream there.<br/><br/>But if you had this data: 00 00 00 00 00 00 01 02 02 02 02 00 10, it's better to get this:<br/><br/>0c6h 00 0c1h 01 0c4h 02 0c1h 00 0c1h 10<br/><br/>than replicate all the bytes out (e.g. 6 copies of 0c1h 00).<br/><br/>The basic algorithm is to have a loop over the data - while you have data, keep going. You need to count identical bytes in a row in the source stream and write how many you get to the output when you hit some other byte (or the end of stream). There are some tricks to this:<br/><br/>1) You need to stop counting when you reach the end of the source buffer. If you have any data counted at that point, you need to flush it to the output buffer as the final count.<br/>2) You need to stop counting when you reach 03fh (63). You can only encode 6 bits worth of count at a time, so when you reach that count, you need to flush the count/data pair to the output and then go back to counting as if you were starting afresh.<br/>3) If you end up with a single byte to write to the output but its two high bits are both set (if reg &amp; 0c0h == 0c0h), then you need to write it out as a repeated count sequence but with a count of 1. So if you have a single byte 47h, then you can write to the output as 47h. But if you have a single byte c6h, then you have to write it as c1h c6h. Otherwise the decoder would hit the 0c6 and think it's a count byte when you mean it to be a data byte, and it would get all confused.<br/><br/>I hope that's enough to digest for now. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/>Let me know what questions you have still or next.",
      "PostDate": "2016-03-31T21:03:12+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42024",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Oh, and I forgot to add: if you use this standard prolog in your function:\n\n[code:1qjjr0oz]myproc proc\n    push ebp\n    mov ebp, esp[/code:1qjjr0oz]\n\nthen be sure you have this at the end before you return:\n\n[code:1qjjr0oz]    pop ebp\n    ret\nendp[/code:1qjjr0oz]",
      "EditableFormat": "bbcode",
      "HTML": "Oh, and I forgot to add: if you use this standard prolog in your function:<br/><br/><pre><code>myproc proc<br/>    push ebp<br/>    mov ebp, esp</code></pre><br/><br/>then be sure you have this at the end before you return:<br/><br/><pre><code>    pop ebp<br/>    ret<br/>endp</code></pre>",
      "PostDate": "2016-03-31T21:46:45+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42025",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I got class now (evening classes), and when I get back it'll be late-nighttime, so, I'll get back to you tomarrow, trying to digest as much of it as I can, lol.",
      "EditableFormat": "bbcode",
      "HTML": "I got class now (evening classes), and when I get back it'll be late-nighttime, so, I'll get back to you tomarrow, trying to digest as much of it as I can, lol.",
      "PostDate": "2016-03-31T21:59:09+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42033",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "[quote=&quot;Jaynabonne&quot;:156m07pn]The prototype you have looks wrong to me. I think it should be this:\n\nDWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);\n\nIt takes a char* input buffer and the length of that input buffer, it writes the encoded data into OutputBuf (which is also a pointer), and then it returns the length of the encoded data, so you know how big the encoded data ended up being.\n\nIt is correct to use BYTE for the data type; you'll be reading and writing bytes. (Technically, the signature for the C function should probably be &quot;unsigned char*&quot; instead of just &quot;char*&quot;, but that won't make any difference to your assembly code.)[/quote:156m07pn]\n\nso... the ASM/C++ (whichever is actually calling/using/doing) the ASM procedure, is able to use the 'char' data type, correct?\n\n(I know they're data type pointers: pointers to the 'data type' Objects/Classes, which is why I left them off in my post's question, but, as I, wasn't sure on what data type to use: 'char' vs 'byte/word/dword', so I was just asking about what data type I was suppose to be using. Sorry about the confusion with my ignoring of the pointer aspect of them. BTW, in ASM, are there pointers, byte *b, * operator instruction sets, or do we just use the indirect addressing ???)\n\nbut... you say it is correct to use 'byte'...\n\nso, I'm confused... do I use 'char' for the prototype and the actual procedure's (declaration/initialization) header, but for the body, I use 'byte', or do I just use 'byte' everywhere (prototype and header and body), instead of 'char', or do I use 'char' for everything ???\n\n-------\n\nI'm not sure what you mean by directives, but we can use the old way of pushing-popping to-from the stack manually (along with using the 'call' instruction), or we can use the 'invoke' instruction, which will do the pushing-popping to-from the stack for us, we just need to add them as arguments-parameters. But, I'm not sure if this is what you're refering to...\n\nthen, for the procedure, we can use the 'uses' which will preserve the following (self inputted-written) listed registers for us, along with being able to specify any parameters we wish to use, in the header.\n\nif you're refering to how C++ and ASM work together, (how the C++ calls the ASM procedure), I'm not sure myself exactly...\n\nI've been looking at these resources so far:\n\n<!-- m --><a class=\"postlink\" href=\"https://courses.engr.illinois.edu/ece390/books/labmanual/c-prog-mixing.html\">https://courses.engr.illinois.edu/ece39 ... ixing.html</a><!-- m -->\n<!-- m --><a class=\"postlink\" href=\"http://lavernasbrute.blogspot.com/2010/02/calling-assembly-functions-in-c.html\">http://lavernasbrute.blogspot.com/2010/ ... -in-c.html</a><!-- m -->\n<!-- m --><a class=\"postlink\" href=\"http://www.c-jump.com/CIS77/MLabs/M13highlvl/lecture.html\">http://www.c-jump.com/CIS77/MLabs/M13hi ... cture.html</a><!-- m -->\n\ntrying to find resource on the procedure syntax/format and its options for you:\n\n<!-- m --><a class=\"postlink\" href=\"http://www.masmforum.com/board/index.php?PHPSESSID=786dd40408172108b65a5a36b09c88c0&amp;topic=14381.0\">http://www.masmforum.com/board/index.ph ... ic=14381.0</a><!-- m --> (this seems to have pretty good/informative posts by devndave, see his/her big post)",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>Jaynabonne wrote:</cite>The prototype you have looks wrong to me. I think it should be this:<br/><br/>DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);<br/><br/>It takes a char* input buffer and the length of that input buffer, it writes the encoded data into OutputBuf (which is also a pointer), and then it returns the length of the encoded data, so you know how big the encoded data ended up being.<br/><br/>It is correct to use BYTE for the data type; you'll be reading and writing bytes. (Technically, the signature for the C function should probably be &quot;unsigned char*&quot; instead of just &quot;char*&quot;, but that won't make any difference to your assembly code.)</blockquote><br/><br/>so... the ASM/C++ (whichever is actually calling/using/doing) the ASM procedure, is able to use the 'char' data type, correct?<br/><br/>(I know they're data type pointers: pointers to the 'data type' Objects/Classes, which is why I left them off in my post's question, but, as I, wasn't sure on what data type to use: 'char' vs 'byte/word/dword', so I was just asking about what data type I was suppose to be using. Sorry about the confusion with my ignoring of the pointer aspect of them. BTW, in ASM, are there pointers, byte *b, * operator instruction sets, or do we just use the indirect addressing ???)<br/><br/>but... you say it is correct to use 'byte'...<br/><br/>so, I'm confused... do I use 'char' for the prototype and the actual procedure's (declaration/initialization) header, but for the body, I use 'byte', or do I just use 'byte' everywhere (prototype and header and body), instead of 'char', or do I use 'char' for everything ???<br/><br/>-------<br/><br/>I'm not sure what you mean by directives, but we can use the old way of pushing-popping to-from the stack manually (along with using the 'call' instruction), or we can use the 'invoke' instruction, which will do the pushing-popping to-from the stack for us, we just need to add them as arguments-parameters. But, I'm not sure if this is what you're refering to...<br/><br/>then, for the procedure, we can use the 'uses' which will preserve the following (self inputted-written) listed registers for us, along with being able to specify any parameters we wish to use, in the header.<br/><br/>if you're refering to how C++ and ASM work together, (how the C++ calls the ASM procedure), I'm not sure myself exactly...<br/><br/>I've been looking at these resources so far:<br/><br/><!-- m --><a class=\"postlink\" href=\"https://courses.engr.illinois.edu/ece390/books/labmanual/c-prog-mixing.html\">https://courses.engr.illinois.edu/ece39 ... ixing.html</a><!-- m --><br/><!-- m --><a class=\"postlink\" href=\"http://lavernasbrute.blogspot.com/2010/02/calling-assembly-functions-in-c.html\">http://lavernasbrute.blogspot.com/2010/ ... -in-c.html</a><!-- m --><br/><!-- m --><a class=\"postlink\" href=\"http://www.c-jump.com/CIS77/MLabs/M13highlvl/lecture.html\">http://www.c-jump.com/CIS77/MLabs/M13hi ... cture.html</a><!-- m --><br/><br/>trying to find resource on the procedure syntax/format and its options for you:<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.masmforum.com/board/index.php?PHPSESSID=786dd40408172108b65a5a36b09c88c0&amp;topic=14381.0\">http://www.masmforum.com/board/index.ph ... ic=14381.0</a><!-- m --> (this seems to have pretty good/informative posts by devndave, see his/her big post)",
      "PostDate": "2016-04-01T18:48:20+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42034",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "I may have slightly mis-spoke: your C routine will pass pointers to char - the type that corresponds to char is byte. But what you receive on the stack is not a char, but rather an address to the buffer. So you'll get a pointer for the input buffer, a dword for the input size, and a pointer to the output buffer. You'll use the pointers to access bytes.\n\nProto and invoke are used to call into C function from MASM. You're calling into your assembly from C. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> \n\nLooking up &quot;uses&quot; took me to what I was looking for. You can see the page here:\n\n<!-- m --><a class=\"postlink\" href=\"http://www.winasm.net/forum/index.php?showtopic=2083\">http://www.winasm.net/forum/index.php?showtopic=2083</a><!-- m -->\n\nSo you might be able to use something like this (instead of doing the ebp management yourself):\n\n[code:1lky37xa]&#46;model flat, c  ; specify C calling convention\n\nRlEncode PROC sourceBuffer&#58;LPVOID, sourceSize&#58;DWORD, outputBuffer&#58;LPVOID\n\n    mov esi, sourceBuffer\n    mov ecx, sourceSize\n    mov edi, outputBuffer\n\n; do stuff with them\n\n    ret\nRlEncode endp[/code:1lky37xa]",
      "EditableFormat": "bbcode",
      "HTML": "I may have slightly mis-spoke: your C routine will pass pointers to char - the type that corresponds to char is byte. But what you receive on the stack is not a char, but rather an address to the buffer. So you'll get a pointer for the input buffer, a dword for the input size, and a pointer to the output buffer. You'll use the pointers to access bytes.<br/><br/>Proto and invoke are used to call into C function from MASM. You're calling into your assembly from C. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> <br/><br/>Looking up &quot;uses&quot; took me to what I was looking for. You can see the page here:<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.winasm.net/forum/index.php?showtopic=2083\">http://www.winasm.net/forum/index.php?showtopic=2083</a><!-- m --><br/><br/>So you might be able to use something like this (instead of doing the ebp management yourself):<br/><br/><pre><code>&#46;model flat, c  ; specify C calling convention<br/><br/>RlEncode PROC sourceBuffer&#58;LPVOID, sourceSize&#58;DWORD, outputBuffer&#58;LPVOID<br/><br/>    mov esi, sourceBuffer<br/>    mov ecx, sourceSize<br/>    mov edi, outputBuffer<br/><br/>; do stuff with them<br/><br/>    ret<br/>RlEncode endp</code></pre>",
      "PostDate": "2016-04-01T19:08:05+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42035",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm still trying to digest the rest... just woke up... (I was tired... I'm getting old, argh), going to get something to eat first, for some brain food, for tackling this stuff, laughs. I'll get back to looking through the rest of your post, after I eat. I'll see what I can do on my own from it, and post further questions/help as I come to them, as I try to do what I can for now.\n\n------------\n\nwe can't use the 'C' calling convention, as that would make this more easy for us, the prof wants us to learn to do this without using that (and other such) method(s).\n\nhere's what we can't do:\n\n(1) in-line assembly in the C++ program\n(2) .MODEL flat, C\n(3) MyProc proc C\n(4) specifying a start label in your end directive\n\n-----------\n\nthis post by devndave seems to explain it well, showing/explaining both ways (old/manual and new/auto):\n\n<!-- m --><a class=\"postlink\" href=\"http://www.masmforum.com/board/index.php?PHPSESSID=786dd40408172108b65a5a36b09c88c0&amp;topic=14381.msg114921#msg114921\">http://www.masmforum.com/board/index.ph ... #msg114921</a><!-- m -->\n\neven I'm understanding it pretty well now!",
      "EditableFormat": "bbcode",
      "HTML": "I'm still trying to digest the rest... just woke up... (I was tired... I'm getting old, argh), going to get something to eat first, for some brain food, for tackling this stuff, laughs. I'll get back to looking through the rest of your post, after I eat. I'll see what I can do on my own from it, and post further questions/help as I come to them, as I try to do what I can for now.<br/><br/>------------<br/><br/>we can't use the 'C' calling convention, as that would make this more easy for us, the prof wants us to learn to do this without using that (and other such) method(s).<br/><br/>here's what we can't do:<br/><br/>(1) in-line assembly in the C++ program<br/>(2) .MODEL flat, C<br/>(3) MyProc proc C<br/>(4) specifying a start label in your end directive<br/><br/>-----------<br/><br/>this post by devndave seems to explain it well, showing/explaining both ways (old/manual and new/auto):<br/><br/><!-- m --><a class=\"postlink\" href=\"http://www.masmforum.com/board/index.php?PHPSESSID=786dd40408172108b65a5a36b09c88c0&amp;topic=14381.msg114921#msg114921\">http://www.masmforum.com/board/index.ph ... #msg114921</a><!-- m --><br/><br/>even I'm understanding it pretty well now!",
      "PostDate": "2016-04-01T19:16:49+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42036",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Ah, ok. I understand now. So, yeah, you'll need to do it manually as I described before. That page I just sent you actually shows what the proc-with-parameters stuff turns into, assembly-wise. It's pretty much what I had detailed before - push ebp / mov ebp, esp / reference parameters via [ebp+offset].",
      "EditableFormat": "bbcode",
      "HTML": "Ah, ok. I understand now. So, yeah, you'll need to do it manually as I described before. That page I just sent you actually shows what the proc-with-parameters stuff turns into, assembly-wise. It's pretty much what I had detailed before - push ebp / mov ebp, esp / reference parameters via [ebp+offset].",
      "PostDate": "2016-04-01T19:46:21+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42037",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I think I'm kinda somewhat getting the encoding/decoding part, except, how do you know what to do, as I don't know if we've got the data used for the encoding-decoding (I'll check if it's in the C++ program we're given)...\n\nwhere does your '1,2,3,4,9,10' come from, or are those just example values?\n\n------\n\nmaybe it'd be better if I describe as I understand it, and you can correct me on what I've got wrong...\n\n[quote=&quot;JayNabonne&quot;:1f75xye9]The run length encoding has two forms: if the two high bits of the byte are set, then the bottom six are the length, and the next byte after the count byte is the data byte to use. If the two top bits aren't both set, then the byte is just the data byte. So if you had this *encoded*:\n\nC8 (11001000)\nFF\n\nthe decoder would decode 8 0FFh bytes.\n\nCF (11001111)\n00\n\nthe decoder would decode 15 (00fh) 00 bytes\n\nAA (10101010)\n\nthe decoder would decode a single 0AAh byte.\n\n00 (00000000)\n\nthe decoder would decode a single 000h byte.\n\nFF (11111111)\nCC\n\nthe decoder would decode 63 (111111b = 03fh) 0cch bytes[/quote:1f75xye9]\n\nI think I get this...\n\nactual data (decoded):\n\n(this has larger size, so actually when/if decoding the encoded data, we're expanding the size of it)\n\nFFFF-FFFF-FFFF-FFFF-0000-0000-0000-0000-0000-0000-0000-000X-AA00-3F3F...(62 more 3Fs = 31 more 3F3Fs) // actual form, I think...\n\n// separated to match up with your example, for easier understanding for us humans:\n\nFF-FF-FF-FF--FF-FF-FF-FF\n00-00-00-00--00-00-00-00--00-00-00-00--00-00-00-XX\nAA\n00\n3F.......................................................(x63)\n\nencoded data:\n\n(this has smaller size, thus the encoding of the data &quot;decompresses&quot; it)\n\nC8FF-CF00-AA00-FFCC // actual form, I think...\n\n// separated to match up with your example, for easier understanding for us humans:\n\nC8FF\nCF00\nAA\n00\nFFCC\n\n--------------\n\nis this correct ???\n\n--------------\n\nand for what I need to do with ASM procedure is to iterate through the expanded (actual/decoded) data, looking for when the values change (when the count ends for doing the encryption for each of these segments of data), as this marks the different operations/whatever of the encryption algorithm I'm to do to encrypt (and thus compress) the data.\n\nexample pseudocode:\n\nstart:\nstore (new/next) value\ncmp stored_value' bits (7+6), 11h ; to determine which operation I do\ncmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)\nloop start\n\nis this correct ???",
      "EditableFormat": "bbcode",
      "HTML": "I think I'm kinda somewhat getting the encoding/decoding part, except, how do you know what to do, as I don't know if we've got the data used for the encoding-decoding (I'll check if it's in the C++ program we're given)...<br/><br/>where does your '1,2,3,4,9,10' come from, or are those just example values?<br/><br/>------<br/><br/>maybe it'd be better if I describe as I understand it, and you can correct me on what I've got wrong...<br/><br/><blockquote><cite>JayNabonne wrote:</cite>The run length encoding has two forms: if the two high bits of the byte are set, then the bottom six are the length, and the next byte after the count byte is the data byte to use. If the two top bits aren't both set, then the byte is just the data byte. So if you had this *encoded*:<br/><br/>C8 (11001000)<br/>FF<br/><br/>the decoder would decode 8 0FFh bytes.<br/><br/>CF (11001111)<br/>00<br/><br/>the decoder would decode 15 (00fh) 00 bytes<br/><br/>AA (10101010)<br/><br/>the decoder would decode a single 0AAh byte.<br/><br/>00 (00000000)<br/><br/>the decoder would decode a single 000h byte.<br/><br/>FF (11111111)<br/>CC<br/><br/>the decoder would decode 63 (111111b = 03fh) 0cch bytes</blockquote><br/><br/>I think I get this...<br/><br/>actual data (decoded):<br/><br/>(this has larger size, so actually when/if decoding the encoded data, we're expanding the size of it)<br/><br/>FFFF-FFFF-FFFF-FFFF-0000-0000-0000-0000-0000-0000-0000-000X-AA00-3F3F...(62 more 3Fs = 31 more 3F3Fs) // actual form, I think...<br/><br/>// separated to match up with your example, for easier understanding for us humans:<br/><br/>FF-FF-FF-FF--FF-FF-FF-FF<br/>00-00-00-00--00-00-00-00--00-00-00-00--00-00-00-XX<br/>AA<br/>00<br/>3F.......................................................(x63)<br/><br/>encoded data:<br/><br/>(this has smaller size, thus the encoding of the data &quot;decompresses&quot; it)<br/><br/>C8FF-CF00-AA00-FFCC // actual form, I think...<br/><br/>// separated to match up with your example, for easier understanding for us humans:<br/><br/>C8FF<br/>CF00<br/>AA<br/>00<br/>FFCC<br/><br/>--------------<br/><br/>is this correct ???<br/><br/>--------------<br/><br/>and for what I need to do with ASM procedure is to iterate through the expanded (actual/decoded) data, looking for when the values change (when the count ends for doing the encryption for each of these segments of data), as this marks the different operations/whatever of the encryption algorithm I'm to do to encrypt (and thus compress) the data.<br/><br/>example pseudocode:<br/><br/>start:<br/>store (new/next) value<br/>cmp stored_value' bits (7+6), 11h ; to determine which operation I do<br/>cmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)<br/>loop start<br/><br/>is this correct ???",
      "PostDate": "2016-04-01T21:29:43+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42038",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:2cj499mt]where does your '1,2,3,4,9,10' come from, or are those just example values?[/quote:2cj499mt]\nYeah, they were just example values.\n\nAs far as the rest goes, it's more or less right. The main thing to help you avoid any confusion is to really just treat them as bytes. You're grouping them as if they're 16-bit words, and they're not. You take them a byte at a time. Your decoded data was close. It would actually be:\n\nFF-FF-FF-FF--FF-FF-FF-FF\n00-00-00-00--00-00-00-00--00-00-00-00--00-00-00-AA\n00\nCC.......................................................(x63)\n\n(I don't know where the XX came from, but I think it had to do with you looking at it as 16-bit words.)\n\nSimilarly, the encoded data would be just:\nC8 FF CF 00 AA 00 FF CC\n\nEight consecutive bytes...\n\nAnd, yes, the basic algorithm is to count consecutive matching bytes and then write them the correct way. (e.g. a repeat count &gt; 1 would be stored as the two byte form, count + data. A single byte would be stored in the single byte form - just the data byte -  unless it has the two top bits set, in which case you need to store it as count-of-1 + data byte, to avoid confusing the decoder).",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>where does your '1,2,3,4,9,10' come from, or are those just example values?</p></blockquote><br/>Yeah, they were just example values.<br/><br/>As far as the rest goes, it's more or less right. The main thing to help you avoid any confusion is to really just treat them as bytes. You're grouping them as if they're 16-bit words, and they're not. You take them a byte at a time. Your decoded data was close. It would actually be:<br/><br/>FF-FF-FF-FF--FF-FF-FF-FF<br/>00-00-00-00--00-00-00-00--00-00-00-00--00-00-00-AA<br/>00<br/>CC.......................................................(x63)<br/><br/>(I don't know where the XX came from, but I think it had to do with you looking at it as 16-bit words.)<br/><br/>Similarly, the encoded data would be just:<br/>C8 FF CF 00 AA 00 FF CC<br/><br/>Eight consecutive bytes...<br/><br/>And, yes, the basic algorithm is to count consecutive matching bytes and then write them the correct way. (e.g. a repeat count &gt; 1 would be stored as the two byte form, count + data. A single byte would be stored in the single byte form - just the data byte -  unless it has the two top bits set, in which case you need to store it as count-of-1 + data byte, to avoid confusing the decoder).",
      "PostDate": "2016-04-01T21:41:30+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42039",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "example pseudocode:\n\nstart:\nstore (new/next) value\ncmp stored_value's bits (7+6), 11h ; to determine which operation I do\ncmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)\nloop start\n\nis this correct ???\n\n(I just edited this into my last post), I was too slow, lol\n\n-------\n\nya, you understood about my 'X/XX/NA' correctly! I wasn't sure if the next value (AA) went into its lsb, or if I were to place a '00' into its hsb and the 'AA' would be in the next unit (byte):\n\n{00}-00-00-00--00-00-00-00--00-00-00-00--00-00-(00)-[AA]\n00\nCC... (just caught that it's CC, and not 3F - oops on my part)\n\nor\n\n[00]-{00}-00-00--00-00-00-00--00-00-00-00--00-00-00-(00) ; shifted right\nAA\n00\nCC... (just caught that it's CC, and not 3F - oops on my part)\n\nbut, you already answered this now, just explaining what my confusion was, which you correctly understood and answered already.\n\n---------\n\nmy mind is still 'bit manipulation' focused from that arithmetic lab and test, I've jsut done... being able to work with bytes (reg's subdivisions: ax, ha, la), makes this much easier than the bits within a byte... lol",
      "EditableFormat": "bbcode",
      "HTML": "example pseudocode:<br/><br/>start:<br/>store (new/next) value<br/>cmp stored_value's bits (7+6), 11h ; to determine which operation I do<br/>cmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)<br/>loop start<br/><br/>is this correct ???<br/><br/>(I just edited this into my last post), I was too slow, lol<br/><br/>-------<br/><br/>ya, you understood about my 'X/XX/NA' correctly! I wasn't sure if the next value (AA) went into its lsb, or if I were to place a '00' into its hsb and the 'AA' would be in the next unit (byte):<br/><br/>{00}-00-00-00--00-00-00-00--00-00-00-00--00-00-(00)-[AA]<br/>00<br/>CC... (just caught that it's CC, and not 3F - oops on my part)<br/><br/>or<br/><br/>[00]-{00}-00-00--00-00-00-00--00-00-00-00--00-00-00-(00) ; shifted right<br/>AA<br/>00<br/>CC... (just caught that it's CC, and not 3F - oops on my part)<br/><br/>but, you already answered this now, just explaining what my confusion was, which you correctly understood and answered already.<br/><br/>---------<br/><br/>my mind is still 'bit manipulation' focused from that arithmetic lab and test, I've jsut done... being able to work with bytes (reg's subdivisions: ax, ha, la), makes this much easier than the bits within a byte... lol",
      "PostDate": "2016-04-01T21:45:39+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42040",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:mj9kebs6]ya, you understood about my 'X/XX/NA' correctly! I wasn't sure if the next value (AA) went into its lsb, or if I were to place a '00' into its hsb and the 'AA' would be in the next unit (byte)[/quote:mj9kebs6]\nJust to be clear... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> If by &quot;lsb&quot; you mean &quot;least significant byte&quot; (as opposed to least significant bit), then I wouldn't even look at it that way, because that implies a multi-byte value. But you don't need to combine the bytes with each other in any way. Just keep them bytes. So 'AA' goes into the next byte address, period, just as all the previous bytes did, one by one.\n\n[quote:mj9kebs6]example pseudocode:\n\nstart:\nstore (new/next) value\ncmp stored_value' bits (7+6), 11h ; to determine which operation I do\ncmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)\nloop start\n\nis this correct ???[/quote:mj9kebs6]\nWhat I would do first is imagine how you would do it by hand. Forget bits and all that. Let's say I gave you the following data:\n\n1 1 6 6 6 8 8 2 4 4 4 4 5 5 9\n\nYou would first look at the 1, then you'd look at the 1 after it and count two 1's. Then you'd look at the next value, and it's 6, which doesn't match 1. So then you output what you have so far:\n\n&quot;I have two ones.&quot;\n\nThen you continue on with the 6's. You have one so far. So you look at the next and it's still 6, so you bump your count to 2, you look at the next and you bump your count to 3. Then the one after that is 8, so now you know how many 6's you have. So you then say:\n\n&quot;I have three sixes.&quot;\n\nAnd you'd proceed on.\n\nThe counting you all do in registers. You need to know what value you're looking for and how many you have so far. The part where you &quot;say&quot; how much you have is where you write it to the output buffer. And what you write to the output buffer depends on what you have. Multiple bytes get written as the two-byte form (count + data). A single byte without the two high bits set gets written as a single byte. And a single byte with the two top bits set gets written as count-of-1 + data. But that happens *after* you have counted! The first thing you need to do is count. Then once you've counted, you figure out what to write to the output buffer.\n\nOne thing you may notice (which makes it slightly tricky) is that sometimes you're reading a byte to get the first value to compare, whereas other times, you're reading bytes to compare to what you have. To me that implies a two part loop: you have an outer loop that you jump back to when the value changes, and you'd have an inner loop you loop back to while you still have matching values.\n\nSomething like this (IGNORE IF YOU WANT TO WORK IT OUT YOURSELF):\n\n\n\n\n\n[code:mj9kebs6]outer&#58;\n    read next byte\n    inc position in buffer\n    dec source bytes left - if 0, jump to finish&#46;\n    set count to 1\ninner&#58;\n    compare next value in buffer (buffer + offset + 1)to current value\n    if not equal jump to write\n    inc position in buffer\n    inc count\n    dec source bytes left - if 0, jump to finish&#46;\n    jmp inner\n\nwrite&#58; \n    write the count + data to buffer as detailed above\n    jmp outer\n\nfinish&#58; \n    write the count + data to buffer as detailed above    &lt;- could be your own subroutine since you need it in two places&#46;\n    load up eax with the final count\n    return[/code:mj9kebs6]\n\nIf you use esi for the input buffer and edi for the output buffer, then you can use lodsb and stosb. But you don't have to.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>ya, you understood about my 'X/XX/NA' correctly! I wasn't sure if the next value (AA) went into its lsb, or if I were to place a '00' into its hsb and the 'AA' would be in the next unit (byte)</p></blockquote><br/>Just to be clear... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> If by &quot;lsb&quot; you mean &quot;least significant byte&quot; (as opposed to least significant bit), then I wouldn't even look at it that way, because that implies a multi-byte value. But you don't need to combine the bytes with each other in any way. Just keep them bytes. So 'AA' goes into the next byte address, period, just as all the previous bytes did, one by one.<br/><br/><blockquote><p>example pseudocode:<br/><br/>start:<br/>store (new/next) value<br/>cmp stored_value' bits (7+6), 11h ; to determine which operation I do<br/>cmps buffer_data, stored_value ; checking for when the value changes (end of current data value's count)<br/>loop start<br/><br/>is this correct ???</p></blockquote><br/>What I would do first is imagine how you would do it by hand. Forget bits and all that. Let's say I gave you the following data:<br/><br/>1 1 6 6 6 8 8 2 4 4 4 4 5 5 9<br/><br/>You would first look at the 1, then you'd look at the 1 after it and count two 1's. Then you'd look at the next value, and it's 6, which doesn't match 1. So then you output what you have so far:<br/><br/>&quot;I have two ones.&quot;<br/><br/>Then you continue on with the 6's. You have one so far. So you look at the next and it's still 6, so you bump your count to 2, you look at the next and you bump your count to 3. Then the one after that is 8, so now you know how many 6's you have. So you then say:<br/><br/>&quot;I have three sixes.&quot;<br/><br/>And you'd proceed on.<br/><br/>The counting you all do in registers. You need to know what value you're looking for and how many you have so far. The part where you &quot;say&quot; how much you have is where you write it to the output buffer. And what you write to the output buffer depends on what you have. Multiple bytes get written as the two-byte form (count + data). A single byte without the two high bits set gets written as a single byte. And a single byte with the two top bits set gets written as count-of-1 + data. But that happens *after* you have counted! The first thing you need to do is count. Then once you've counted, you figure out what to write to the output buffer.<br/><br/>One thing you may notice (which makes it slightly tricky) is that sometimes you're reading a byte to get the first value to compare, whereas other times, you're reading bytes to compare to what you have. To me that implies a two part loop: you have an outer loop that you jump back to when the value changes, and you'd have an inner loop you loop back to while you still have matching values.<br/><br/>Something like this (IGNORE IF YOU WANT TO WORK IT OUT YOURSELF):<br/><br/><br/><br/><br/><br/><pre><code>outer&#58;<br/>    read next byte<br/>    inc position in buffer<br/>    dec source bytes left - if 0, jump to finish&#46;<br/>    set count to 1<br/>inner&#58;<br/>    compare next value in buffer (buffer + offset + 1)to current value<br/>    if not equal jump to write<br/>    inc position in buffer<br/>    inc count<br/>    dec source bytes left - if 0, jump to finish&#46;<br/>    jmp inner<br/><br/>write&#58; <br/>    write the count + data to buffer as detailed above<br/>    jmp outer<br/><br/>finish&#58; <br/>    write the count + data to buffer as detailed above    &lt;- could be your own subroutine since you need it in two places&#46;<br/>    load up eax with the final count<br/>    return</code></pre><br/><br/>If you use esi for the input buffer and edi for the output buffer, then you can use lodsb and stosb. But you don't have to.",
      "PostDate": "2016-04-01T22:09:13+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42041",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ah thanks, I think I had this notion myself, just didn't go into the full-entire individual steps in my pseudocode (it was just to be a brief main point skeleton pseudocode, I was aware that there were more steps involved, just lazy and didn't want to write them all in), so I was already knowing how to do it generally.\n\nthough, I wasn't quite sure on how/what I was to do with my code after the counting (the storing of it as: &lt;count&gt;&lt;value&gt;  or &lt;value&gt;, and how to handle the different cases of it), so your explaining of that specific was helpful... and I'd probably not realize the need for nested looping (2 loops, like when getting/working with a 2D array's/matrix' values)... I would've had a lot of grief and/or bugging of you, so this has helped me avoid the grief and the bugging of you about what to do with once I got the counting, lol.",
      "EditableFormat": "bbcode",
      "HTML": "ah thanks, I think I had this notion myself, just didn't go into the full-entire individual steps in my pseudocode (it was just to be a brief main point skeleton pseudocode, I was aware that there were more steps involved, just lazy and didn't want to write them all in), so I was already knowing how to do it generally.<br/><br/>though, I wasn't quite sure on how/what I was to do with my code after the counting (the storing of it as: &lt;count&gt;&lt;value&gt;  or &lt;value&gt;, and how to handle the different cases of it), so your explaining of that specific was helpful... and I'd probably not realize the need for nested looping (2 loops, like when getting/working with a 2D array's/matrix' values)... I would've had a lot of grief and/or bugging of you, so this has helped me avoid the grief and the bugging of you about what to do with once I got the counting, lol.",
      "PostDate": "2016-04-01T22:24:52+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42042",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Let me know if you have any more questions. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "Let me know if you have any more questions. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2016-04-01T22:30:48+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42043",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I should be good now... i think I got the actual procedure's operations down... baring any unforeseen issues as I try to do it... so, at this point, my only possible other questions might be with the setting up of the procedure (its heading and etc), but let me see what I can do, if I can get it all working, and if not then I'll ask the questions I'll have. Give me a day or two, to see if I can do this on my own, unless I run into problems, then I'll be posting those questions right away, lol. It'll probably take me a day or 2 to get this assignment done, baring any issues that might arise. I'm not the fastest programmer yet, especially when I got to work out how to do the code, and I need to take breaks as the sitting for too long gets irrating (I don't have the best chair), and I just get tired too from staring at the computer screen for too long and from also just from coding, takes a lot of brain power, as I'm not that smart.\n\nAgain, Thank You, Jay! You really explain these things well, helping me get the concept down/understood really well, along with helping me fixing or troubleshoot the actual code implementation too. You really helped me understand this assembly programming! I've been getting the assembly and computer architecture stuff pretty well, from the class, but the class doesn't really help with how to do these labs, which are totally new to me, so I've had a hard time doing them on my own, as I often don't know where to begin. But, you've been giving me that initial explanation or starting point hint/push, and from that, I'm then able to generally get and do the lab mostly on my own. So, I'm pretty happy with myself, baring my poor test taking and some assignments, hurting my grade, grr (I used to be so good at doing tests, don't know what happened in my getting old/older, lol. Guess, I'm losing my test-taking brain cells, sighs). In terms of the material though, I think I'm learning and understand it, which is what matters for me. I can't be a programmer if I don't know how to program, lol. So, I thank you for helping me with that initial push/hint/understanding of how these labs work, along with the class lectures and materials and etc, I am doing to not bad in learning this assembly and computer architecture (I was able to get the boolean algebra, those k-maps, and etc stuff on my own, ya!). As all the concepts, tactics, designs, and methods that I've learned of the high level languages, from quest, didn't prepare me for the NEW/UNIQUE concepts, tactics, methods, and designs that are involved with low level languages, like assembly. This is why I needed that initial explanation/help/hint/push, as I never learned of opcode/instructions and bit arithmetic/manipulation designs from quest, and my C++ and Java classes. And this (assembly) class unfortunately never really helped with this transition into these new concepts and designs. We just cover the the syntax, formatting, and the usage of the various instruction sets/commands, but not the ceptual designs of doing programming in assembly. It's hard if you don't already know of those conceptual designs. Hard to intuitively come up with them or realize them, on your own, out of the blue (at least for my level of intelligence, anyways).",
      "EditableFormat": "bbcode",
      "HTML": "I should be good now... i think I got the actual procedure's operations down... baring any unforeseen issues as I try to do it... so, at this point, my only possible other questions might be with the setting up of the procedure (its heading and etc), but let me see what I can do, if I can get it all working, and if not then I'll ask the questions I'll have. Give me a day or two, to see if I can do this on my own, unless I run into problems, then I'll be posting those questions right away, lol. It'll probably take me a day or 2 to get this assignment done, baring any issues that might arise. I'm not the fastest programmer yet, especially when I got to work out how to do the code, and I need to take breaks as the sitting for too long gets irrating (I don't have the best chair), and I just get tired too from staring at the computer screen for too long and from also just from coding, takes a lot of brain power, as I'm not that smart.<br/><br/>Again, Thank You, Jay! You really explain these things well, helping me get the concept down/understood really well, along with helping me fixing or troubleshoot the actual code implementation too. You really helped me understand this assembly programming! I've been getting the assembly and computer architecture stuff pretty well, from the class, but the class doesn't really help with how to do these labs, which are totally new to me, so I've had a hard time doing them on my own, as I often don't know where to begin. But, you've been giving me that initial explanation or starting point hint/push, and from that, I'm then able to generally get and do the lab mostly on my own. So, I'm pretty happy with myself, baring my poor test taking and some assignments, hurting my grade, grr (I used to be so good at doing tests, don't know what happened in my getting old/older, lol. Guess, I'm losing my test-taking brain cells, sighs). In terms of the material though, I think I'm learning and understand it, which is what matters for me. I can't be a programmer if I don't know how to program, lol. So, I thank you for helping me with that initial push/hint/understanding of how these labs work, along with the class lectures and materials and etc, I am doing to not bad in learning this assembly and computer architecture (I was able to get the boolean algebra, those k-maps, and etc stuff on my own, ya!). As all the concepts, tactics, designs, and methods that I've learned of the high level languages, from quest, didn't prepare me for the NEW/UNIQUE concepts, tactics, methods, and designs that are involved with low level languages, like assembly. This is why I needed that initial explanation/help/hint/push, as I never learned of opcode/instructions and bit arithmetic/manipulation designs from quest, and my C++ and Java classes. And this (assembly) class unfortunately never really helped with this transition into these new concepts and designs. We just cover the the syntax, formatting, and the usage of the various instruction sets/commands, but not the ceptual designs of doing programming in assembly. It's hard if you don't already know of those conceptual designs. Hard to intuitively come up with them or realize them, on your own, out of the blue (at least for my level of intelligence, anyways).",
      "PostDate": "2016-04-01T22:40:21+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42074",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "after 3 days... and even looking at your code (thanks by the way, I needed it as I would have completely not have figured out what I hope I got figured out now, argh), I think I finally got hopefully some functional operational logic... grrr. Initially, the more I tried to understand it, the more confused I got, 3 days of working on just the operational logic... HK is very stupid, sighs.\n\nAnyways, if you could look at the operational logic (the procedure/the procedure's algorithm), and see if it looks like it works, or if I got some logic and/or syntax and/or (bit) arithmetic/manipulations issues with it. This is my best guess after 3 days of working on it.\n\n--------\n\nafter that, then we can tackle getting the rest of my code correct for this C++ reading/usage of my ASM procedure stuff.\n\n--------\n\nanyways, here's my entire code (there's some redundancy and/or mis-match of things, as I just added them for notes as I read/researched, not knowing what to do with them, or if I even need them or not):\n\n[code:1ru7wlse];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; Credit (those who helped me)\n;------------------------------------------------------------------------------\n\n; Online person Jay\n; (various online webpage resources, that I need to add in here still)\n; (a few colleagues' help too)\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to encode (compress) a data file&#46;\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\t\t\n\t\tPUBLIC RLE_Encode\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; Prototypes\n;------------------------------------------------------------------------------\n\nDWORD\tRLE_Encode\t(char *InputBuf, DWORD InputLength, char *OutputBuf) public\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016&quot;,\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ncredit\t\t\t\t\tbyte\t&quot;Credits (those who helped me)&#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED, \\\n\t\t\t\t\t\t\t\t&quot;Online person Jay&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to encode &quot;, \\\n\t\t\t\t\t\t\t\t&quot;(compress) a data file&#46;&quot; \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain \tProc\n\n\tpush eax\n\tcall RLE_Encode\n\t\n\t;**********************\n\t; Terminating Program\n\t;**********************\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, NULL_POINTER\n\nMain\tendp\n\n;************\n; Procedures\n;************\n\nDWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf) proc public \\\n\t\tstdcall uses ebx, ecx, edx, esi, edi, ebp, esp\n\t\n\tpush\teax\n\n;\tpush\tebp\n;\tmovzx\tebp, esp\n;\tI ran out of registers, not sure what to do, if I can't directly use esp if I need to, if I need to use ebp (storing esp)\n;\tI'm using ebx for tallying-storing the each-time-counts\n;\tI'm using ebp for tallying-getting the length of edi, would 'lengthof edi' work for this instead, or no?\n;\tI'm using eax for storing the each-time-initial value\n;\tI'm using ecx for subtracting the length of the buffer (&quot;EoVs&#58; End of Values -- in the input buffer&quot;)\n;\tI'm using edx for storing the the next value, to compare more efficiently (reg&#58;reg) with eax (storing the each-time-initial value)\n;\tI could do reg&#58;mem for the comparison (not using/freeing up the edx), I think I can design-wise anyways, but this would be less efficient than doing reg&#58;reg\n\t\n\tmovzx\tesi, InputBuf\n\tmovzx\tecx, InputLength\n\tmovzx\tedi, OutputBuf\n\t\n\txor\t\tedx, edx\t\n\t\n\tOuter_Loop&#58;\n\t\n\tmovzx\teax, byte ptr &#91;esp&#93;&#91;esi&#93;\n\tmovzx\tebx, 01h\n\tsub\t\tecx, 01h\n\tcmp\t\tecx, 00h\n\tje\t\tSingle_Byte_One\n\tadd\t\tesi, 01h\n\t\n\tInner_Loop&#58;\n\t\n\tmovzx\tedx, byte ptr &#91;esp&#93;&#91;esi&#93;\n\tcmp\t\teax, edx\n\tjne\t\tSingle_Byte_One\n\t\n\tadd\t\tesi, 01h\n\tadd\t\tebx, 01h\n\tsub\t\tecx, 01h\n\t\n\tcmp\t\tebx, 3Fh\n\tje\t\tMultiple_Byte\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tMultiple_Byte\n\t\n\tjmp\t\tInner_Loop\n\t\n\tMultiple_Byte&#58;\n\t\n\tadd\t\tebx, 0C0h\n\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr ebx\n\tadd\t\tedi, 01h\n\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax\n\tadd\t\tedi, 01h\n\tadd\t\tebp, 02h\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tSingle_Byte_Two&#58;\n\n\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr 0C1h\n\tadd\t\tedi, 01h\n\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax\n\tadd\t\tedi, 01h\n\tadd\t\tebp, 02h\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tSingle_Byte_One&#58;\n\t\n\tcmp\t\tebx, 01h\n\tjne\t\tMultiple_Byte\n\t\n\tcmp\t\tah, 0Ch\n\tjae\t\tSingle_Byte_Two\n\t\n\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax\n\tadd\t\tedi, 01h\n\tadd\t\tebp, 01h\n\t\n\tcmp\t\tecx, 00h\n\tjne\t\tOuter_Loop\n\t\n\tFinish\n\t\n\tmovzx\teax, ebp\n\t\n\tpop\t\tebp\n\tpop\t\teax\n\t\t\n\tret\n\nRLE_Encode endp\n\n;*************************\n; Program End/Termination\n;*************************\n\n\t\tend Main[/code:1ru7wlse]\n\n----------------------------------------\n\nP.S.\n\nhere's some of my colleagues discussing about the assignment (about trying to get the C++ program to, call/link to, the masm32 procedure):\n\n&quot;I am undergoing great difficulty in trying to call an asm file in c++ without using c as a language specifier. I keep getting a Linker Error due to multiple conflicting symbols. Anyone know how to fix this problem without copying and pasting the disassembly into my project? (redacted)&quot;\n\n&quot;I am also having the same problem. From what I've looked up, the object files need to be linked but I'm not sure how to do this so I emailed Professor (redacted). I'll try and post his reponse here when he replies. (redacted)&quot;\n\n&quot;After a lot of struggle I was finally able to find a solution to this problem. The problem is because of trying to use parameter lists in the procedure declaration. If you try to do this, the assembler needs to know what language convention it should follow for use with the parameters. Because we are not allowed to specify a language type of the project, the only option is to not use the built in parameter lists. This means you need to manually get your parameters off of the stack. You can do this using the ebp register inside your procedure. At the location of [ebp + 4] we will find the return address for the procedure, at the location [ebp + 8] we will find the parameter that was pushed last. For the project, the parameters are pushed from right to left, so the parameter at [ebp + 8] will be the address of the input buffer. You can then get the other parameters by adding the number of bytes in the data type. (redacted)&quot;\n\n&quot;I'm having difficulty with this as well, I'm not able to get past the linker error despite avoiding the parameter list within the procedure. My instinct is that the C++ compiler won't recognize the procedure as the proper function that it is looking for since the parameters aren't defined. I might be wrong, but if someone else has any ideas on how to get past this I would really appreciate it. (redacted)&quot;\n\n&quot;\nThe linker should still be able to link correctly even without the parameters. Here is what I have for my procedure prototype and the start directives, hopefully this will help:\n\n.586\n.MODEL flat\n_RLE_Encode proto\n.data\n.code\n_RLE_Encode  proc public\n(redacted)\n&quot;\n\n&quot;You may not need the underscore, as I believe that the default (via not specifying a different one) call convention is stdcall, which will place the underscores automatically for you, but I could be wrong, as I'm not sure if this still applies for when this MASM32 procedure is to be called by the C++ program. (redacted)&quot;\n\n&quot;I don't think so because when I remove the underscores I get linker errors. If you have problems without them I would suggest trying it with them. (redacted)&quot;\n\n&quot;\nI'm not sure if the 'uses' means that we need to do more displacement (to get past these stack items manually), or not (MASM32/C++ handles it automatically for us).\n\nI'm also not sure if we are to push the registers a second time to the stack, when using the 'uses' too. I'm still confused at exactly how the MASM32 to C++ works in regards to the stack. My understanding is that the stack is the connection/bridge between the MASM32 and C++, for them to work together. So, I'm not sure what needs to be pushed (or pushed again) or possibly not need to be pushed.\n\nI guess I could just not use the 'uses', and manually push/pop them instead, along with applying the correct additional displayment required.\n(redacted)\n&quot;\n\n&quot;\nI don't think you will need to use any extra displacement because of the USES. Because of the way the stack frame is set up you can access the parameters using [ebp + offset] and then the uses will modify esp and not ebp.\n\nFor exactly what to do with USES, that is up to you. Using USES is just syntax sugar, you can do exactly what USES does by hand, if you want to. All USES does is translate into a series of pushes and pops. If you write &quot;USES ebx ecx edx&quot;, the assembler will translate this into:\n\npush ebx\npush ecx\npush edx\n\n;The rest of your procedure goes here:\n\npop edx\npop ecx\npop edx\n(redacted)\n&quot;",
      "EditableFormat": "bbcode",
      "HTML": "after 3 days... and even looking at your code (thanks by the way, I needed it as I would have completely not have figured out what I hope I got figured out now, argh), I think I finally got hopefully some functional operational logic... grrr. Initially, the more I tried to understand it, the more confused I got, 3 days of working on just the operational logic... HK is very stupid, sighs.<br/><br/>Anyways, if you could look at the operational logic (the procedure/the procedure's algorithm), and see if it looks like it works, or if I got some logic and/or syntax and/or (bit) arithmetic/manipulations issues with it. This is my best guess after 3 days of working on it.<br/><br/>--------<br/><br/>after that, then we can tackle getting the rest of my code correct for this C++ reading/usage of my ASM procedure stuff.<br/><br/>--------<br/><br/>anyways, here's my entire code (there's some redundancy and/or mis-match of things, as I just added them for notes as I read/researched, not knowing what to do with them, or if I even need them or not):<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/>; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; Credit (those who helped me)<br/>;------------------------------------------------------------------------------<br/><br/>; Online person Jay<br/>; (various online webpage resources, that I need to add in here still)<br/>; (a few colleagues' help too)<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to encode (compress) a data file&#46;<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/>\t\t<br/>\t\tPUBLIC RLE_Encode<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; Prototypes<br/>;------------------------------------------------------------------------------<br/><br/>DWORD\tRLE_Encode\t(char *InputBuf, DWORD InputLength, char *OutputBuf) public<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016&quot;,<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>credit\t\t\t\t\tbyte\t&quot;Credits (those who helped me)&#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED, \\<br/>\t\t\t\t\t\t\t\t&quot;Online person Jay&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to encode &quot;, \\<br/>\t\t\t\t\t\t\t\t&quot;(compress) a data file&#46;&quot; \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main \tProc<br/><br/>\tpush eax<br/>\tcall RLE_Encode<br/>\t<br/>\t;**********************<br/>\t; Terminating Program<br/>\t;**********************<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, NULL_POINTER<br/><br/>Main\tendp<br/><br/>;************<br/>; Procedures<br/>;************<br/><br/>DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf) proc public \\<br/>\t\tstdcall uses ebx, ecx, edx, esi, edi, ebp, esp<br/>\t<br/>\tpush\teax<br/><br/>;\tpush\tebp<br/>;\tmovzx\tebp, esp<br/>;\tI ran out of registers, not sure what to do, if I can't directly use esp if I need to, if I need to use ebp (storing esp)<br/>;\tI'm using ebx for tallying-storing the each-time-counts<br/>;\tI'm using ebp for tallying-getting the length of edi, would 'lengthof edi' work for this instead, or no?<br/>;\tI'm using eax for storing the each-time-initial value<br/>;\tI'm using ecx for subtracting the length of the buffer (&quot;EoVs&#58; End of Values -- in the input buffer&quot;)<br/>;\tI'm using edx for storing the the next value, to compare more efficiently (reg&#58;reg) with eax (storing the each-time-initial value)<br/>;\tI could do reg&#58;mem for the comparison (not using/freeing up the edx), I think I can design-wise anyways, but this would be less efficient than doing reg&#58;reg<br/>\t<br/>\tmovzx\tesi, InputBuf<br/>\tmovzx\tecx, InputLength<br/>\tmovzx\tedi, OutputBuf<br/>\t<br/>\txor\t\tedx, edx\t<br/>\t<br/>\tOuter_Loop&#58;<br/>\t<br/>\tmovzx\teax, byte ptr &#91;esp&#93;&#91;esi&#93;<br/>\tmovzx\tebx, 01h<br/>\tsub\t\tecx, 01h<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tSingle_Byte_One<br/>\tadd\t\tesi, 01h<br/>\t<br/>\tInner_Loop&#58;<br/>\t<br/>\tmovzx\tedx, byte ptr &#91;esp&#93;&#91;esi&#93;<br/>\tcmp\t\teax, edx<br/>\tjne\t\tSingle_Byte_One<br/>\t<br/>\tadd\t\tesi, 01h<br/>\tadd\t\tebx, 01h<br/>\tsub\t\tecx, 01h<br/>\t<br/>\tcmp\t\tebx, 3Fh<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tjmp\t\tInner_Loop<br/>\t<br/>\tMultiple_Byte&#58;<br/>\t<br/>\tadd\t\tebx, 0C0h<br/>\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr ebx<br/>\tadd\t\tedi, 01h<br/>\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax<br/>\tadd\t\tedi, 01h<br/>\tadd\t\tebp, 02h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tSingle_Byte_Two&#58;<br/><br/>\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr 0C1h<br/>\tadd\t\tedi, 01h<br/>\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax<br/>\tadd\t\tedi, 01h<br/>\tadd\t\tebp, 02h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tSingle_Byte_One&#58;<br/>\t<br/>\tcmp\t\tebx, 01h<br/>\tjne\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tah, 0Ch<br/>\tjae\t\tSingle_Byte_Two<br/>\t<br/>\tmovzx\t&#91;esp&#93;&#91;edi&#93;, byte ptr eax<br/>\tadd\t\tedi, 01h<br/>\tadd\t\tebp, 01h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tjne\t\tOuter_Loop<br/>\t<br/>\tFinish<br/>\t<br/>\tmovzx\teax, ebp<br/>\t<br/>\tpop\t\tebp<br/>\tpop\t\teax<br/>\t\t<br/>\tret<br/><br/>RLE_Encode endp<br/><br/>;*************************<br/>; Program End/Termination<br/>;*************************<br/><br/>\t\tend Main</code></pre><br/><br/>----------------------------------------<br/><br/>P.S.<br/><br/>here's some of my colleagues discussing about the assignment (about trying to get the C++ program to, call/link to, the masm32 procedure):<br/><br/>&quot;I am undergoing great difficulty in trying to call an asm file in c++ without using c as a language specifier. I keep getting a Linker Error due to multiple conflicting symbols. Anyone know how to fix this problem without copying and pasting the disassembly into my project? (redacted)&quot;<br/><br/>&quot;I am also having the same problem. From what I've looked up, the object files need to be linked but I'm not sure how to do this so I emailed Professor (redacted). I'll try and post his reponse here when he replies. (redacted)&quot;<br/><br/>&quot;After a lot of struggle I was finally able to find a solution to this problem. The problem is because of trying to use parameter lists in the procedure declaration. If you try to do this, the assembler needs to know what language convention it should follow for use with the parameters. Because we are not allowed to specify a language type of the project, the only option is to not use the built in parameter lists. This means you need to manually get your parameters off of the stack. You can do this using the ebp register inside your procedure. At the location of [ebp + 4] we will find the return address for the procedure, at the location [ebp + 8] we will find the parameter that was pushed last. For the project, the parameters are pushed from right to left, so the parameter at [ebp + 8] will be the address of the input buffer. You can then get the other parameters by adding the number of bytes in the data type. (redacted)&quot;<br/><br/>&quot;I'm having difficulty with this as well, I'm not able to get past the linker error despite avoiding the parameter list within the procedure. My instinct is that the C++ compiler won't recognize the procedure as the proper function that it is looking for since the parameters aren't defined. I might be wrong, but if someone else has any ideas on how to get past this I would really appreciate it. (redacted)&quot;<br/><br/>&quot;<br/>The linker should still be able to link correctly even without the parameters. Here is what I have for my procedure prototype and the start directives, hopefully this will help:<br/><br/>.586<br/>.MODEL flat<br/>_RLE_Encode proto<br/>.data<br/>.code<br/>_RLE_Encode  proc public<br/>(redacted)<br/>&quot;<br/><br/>&quot;You may not need the underscore, as I believe that the default (via not specifying a different one) call convention is stdcall, which will place the underscores automatically for you, but I could be wrong, as I'm not sure if this still applies for when this MASM32 procedure is to be called by the C++ program. (redacted)&quot;<br/><br/>&quot;I don't think so because when I remove the underscores I get linker errors. If you have problems without them I would suggest trying it with them. (redacted)&quot;<br/><br/>&quot;<br/>I'm not sure if the 'uses' means that we need to do more displacement (to get past these stack items manually), or not (MASM32/C++ handles it automatically for us).<br/><br/>I'm also not sure if we are to push the registers a second time to the stack, when using the 'uses' too. I'm still confused at exactly how the MASM32 to C++ works in regards to the stack. My understanding is that the stack is the connection/bridge between the MASM32 and C++, for them to work together. So, I'm not sure what needs to be pushed (or pushed again) or possibly not need to be pushed.<br/><br/>I guess I could just not use the 'uses', and manually push/pop them instead, along with applying the correct additional displayment required.<br/>(redacted)<br/>&quot;<br/><br/>&quot;<br/>I don't think you will need to use any extra displacement because of the USES. Because of the way the stack frame is set up you can access the parameters using [ebp + offset] and then the uses will modify esp and not ebp.<br/><br/>For exactly what to do with USES, that is up to you. Using USES is just syntax sugar, you can do exactly what USES does by hand, if you want to. All USES does is translate into a series of pushes and pops. If you write &quot;USES ebx ecx edx&quot;, the assembler will translate this into:<br/><br/>push ebx<br/>push ecx<br/>push edx<br/><br/>;The rest of your procedure goes here:<br/><br/>pop edx<br/>pop ecx<br/>pop edx<br/>(redacted)<br/>&quot;",
      "PostDate": "2016-04-04T12:44:15+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42095",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "So some things. \n\nFirst, I don't think you need to use movzx so much. You only need to use that when you are reading a smaller byte value than the target is, so that you need it to be &quot;zero extended&quot; to the larger type (e.g. loading a byte into a 32-bit register). So, for example, you would never use &quot;movzx ebp, esp&quot;, because ebp and esp are the same size. You would just use &quot;mov ebp, esp&quot;. \n\nAnd something like &quot;movzx   [esp][edi], byte ptr ebx&quot; is wrong on a number of levels. First, you don't want to be using esp at all, example to set up the stack frame in the beginning. edi will point to the output buffer, period. There are no additional offsets needed. Just [edi]. And then this is using &quot;movzx&quot;, which is an *extending* move, when in reality you just want to store a byte into a byte location. So this can all be reduced to:\n\nmov [edi], bl\n\nI don't even know if you can specify &quot;byte ptr ebx&quot;. It's just the low half of the register, which is what bl is (which is clearer to use).\n\nAs far as writing out the data, you can't know in your upper loop which case it will be (single, muliple) because that is determined by the count. For example, you have:\n\n[code:1r4edgqd]   movzx   edx, byte ptr &#91;esp&#93;&#91;esi&#93;\n   cmp      eax, edx\n   jne      Single_Byte_One[/code:1r4edgqd]\nFirst, it should be &quot;mov dl, byte ptr [esi]&quot; <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\nSecond, you have the code jumping straight to Single_Byte_One, which is outputting a single byte. But you don't know if it will - you have to see what your count is (1 or more than 1) to determine how to output the data. If the count is greater than one, then it's a multi byte case.\n\nA tip: while you can accumulate the output buffer size, you can get away with not doing that, if it helps. You can simply subtract OutputBuf from edi when done to see how many bytes you wrote:\n\n[code:1r4edgqd]mov eax, edi\nsub eax, OutputBuf[/code:1r4edgqd]\n\n(It also frees up ebp to be used for your frame pointer. Even if you used the built-in parameters and calling convention code, I bet that using ebp is off limits, since it's used to hold the frame pointer.)\n\nThere is a lot that's good here. If you can straighten out the outputting, so that you have a single &quot;write&quot; entry point that checks the count and the data byte and writes appropriately, then it will be quite far along.\n\nOne thing to keep in mind is that you are dealing with bytes here. You don't need to do all of this zero extension to 32-bit. Use the eight bits registers you have. A single 32-bit eax or ebx can hold two 8 bits values (e.g. al and ah, bl and bh). That should free up some registers if you find you need them.\n\nAnd don't be afraid to use &quot;inc&quot; and &quot;dec&quot; instead of adding and subtracting one. Not only is it more compact (and more efficient and clearer), but if anyone who knows assembly ever looks at your code, they will wonder why it was done the other way. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->\n\nAs far as the comments you wrote from others, getting the naming convention correct is important as far as linking goes. But there is another consideration: with a C calling convention, the caller cleans up the stack. With a stdcall calling convention, the *called* function (that is, your code in this case) needs to clean up the stack before returning. It's not hard, but it needs to be done. Otherwise, you'll end up with a crash eventually. If you can get your function declared without stdcall, it might be easier. But if not, it's not too hard to make it work (you just need to specify how many bytes to remove from the stack when you return).\n\nI don't know how much help you want with this, so I'll stop at this point. But we could go through the code in more detail if you want.",
      "EditableFormat": "bbcode",
      "HTML": "So some things. <br/><br/>First, I don't think you need to use movzx so much. You only need to use that when you are reading a smaller byte value than the target is, so that you need it to be &quot;zero extended&quot; to the larger type (e.g. loading a byte into a 32-bit register). So, for example, you would never use &quot;movzx ebp, esp&quot;, because ebp and esp are the same size. You would just use &quot;mov ebp, esp&quot;. <br/><br/>And something like &quot;movzx   [esp][edi], byte ptr ebx&quot; is wrong on a number of levels. First, you don't want to be using esp at all, example to set up the stack frame in the beginning. edi will point to the output buffer, period. There are no additional offsets needed. Just [edi]. And then this is using &quot;movzx&quot;, which is an *extending* move, when in reality you just want to store a byte into a byte location. So this can all be reduced to:<br/><br/>mov [edi], bl<br/><br/>I don't even know if you can specify &quot;byte ptr ebx&quot;. It's just the low half of the register, which is what bl is (which is clearer to use).<br/><br/>As far as writing out the data, you can't know in your upper loop which case it will be (single, muliple) because that is determined by the count. For example, you have:<br/><br/><pre><code>   movzx   edx, byte ptr &#91;esp&#93;&#91;esi&#93;<br/>   cmp      eax, edx<br/>   jne      Single_Byte_One</code></pre><br/>First, it should be &quot;mov dl, byte ptr [esi]&quot; <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/>Second, you have the code jumping straight to Single_Byte_One, which is outputting a single byte. But you don't know if it will - you have to see what your count is (1 or more than 1) to determine how to output the data. If the count is greater than one, then it's a multi byte case.<br/><br/>A tip: while you can accumulate the output buffer size, you can get away with not doing that, if it helps. You can simply subtract OutputBuf from edi when done to see how many bytes you wrote:<br/><br/><pre><code>mov eax, edi<br/>sub eax, OutputBuf</code></pre><br/><br/>(It also frees up ebp to be used for your frame pointer. Even if you used the built-in parameters and calling convention code, I bet that using ebp is off limits, since it's used to hold the frame pointer.)<br/><br/>There is a lot that's good here. If you can straighten out the outputting, so that you have a single &quot;write&quot; entry point that checks the count and the data byte and writes appropriately, then it will be quite far along.<br/><br/>One thing to keep in mind is that you are dealing with bytes here. You don't need to do all of this zero extension to 32-bit. Use the eight bits registers you have. A single 32-bit eax or ebx can hold two 8 bits values (e.g. al and ah, bl and bh). That should free up some registers if you find you need them.<br/><br/>And don't be afraid to use &quot;inc&quot; and &quot;dec&quot; instead of adding and subtracting one. Not only is it more compact (and more efficient and clearer), but if anyone who knows assembly ever looks at your code, they will wonder why it was done the other way. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --><br/><br/>As far as the comments you wrote from others, getting the naming convention correct is important as far as linking goes. But there is another consideration: with a C calling convention, the caller cleans up the stack. With a stdcall calling convention, the *called* function (that is, your code in this case) needs to clean up the stack before returning. It's not hard, but it needs to be done. Otherwise, you'll end up with a crash eventually. If you can get your function declared without stdcall, it might be easier. But if not, it's not too hard to make it work (you just need to specify how many bytes to remove from the stack when you return).<br/><br/>I don't know how much help you want with this, so I'll stop at this point. But we could go through the code in more detail if you want.",
      "PostDate": "2016-04-04T20:08:38+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42097",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I still don't really understand the stack and/or the stack frame, and its ordering/displacement/offset/address stuff completely.\n\n--------------\n\nI'm a bit confused on the 'mov ebp, esp' in what exactly it is for, as I think you can say I can do this:\n\nmov reg, [reg]\nexample: eax, [esi]\n\nwhereas, I thought I'd need to do this? :\n\nmov eax, [ebp][esi]\n\nor even this:\n\nmov eax, [ebp+12] ; mov eax, [param1]\n\n-------\n\nalso, do I need to do this? :\n\nmov ebp, esi\nadd [ebp], displacement\n\nto get past the slots for the stack frame pointer, return address pointer, parameters (if I end up using or required to use them), and etc:\n\n(if I understand this stack construction/deconstruction/ordering stuff)\n(assumming they're all 'byte' in size...)\n[ebp+0] = stack frame pointer\n[ebp+4] = return address\n[ebp+8] = param1\n[ebp+12] = param2\netc etc etc\n\n------\n\nI use 'add' as I thought it was slightly more efficient than 'inc'... I keep getting opposite statements... inc is more efficient, no, add is more efficient, no, inc is more efficient... it feels like the nutrition/science &quot;surveys&quot;, one survey says this food is good for you, another survey comes out saying that food is bad for you, another survey comes out saying that food is good for you... etc etc etc\n\nI wish I could get some final clarification on which is more efficient... sighs. I used 'inc' originally as I thought it was more efficient, then I'm told that it is actually 'add' that is more efficient, so I use 'add'. Then I'm told that 'inc' is more efficient. I use inc again, then I'm told 'add' is more efficient, arg\n\n----------------\n\nI think my 'Single_Byte_One' will check and jump it to the correct label operation (Multiple_Byte or Single_Byte_Two)\n\nSingle_Byte_One: this will write single bytes which don't have the upper 2 bits set, or act as a re-direct-hub to the labels to handle the other two cases (if there's multiple bytes: count &gt; 1, or if the single byte has the 2 upper bits set, which means it must write 2 bytes).\n\nSingle_Byte_Two: this is for writing single bytes which have the two upper bits set, thus it's actually writing 2 bytes into the output buffer.\n\nMultiple_Byte: this is for writing multiple bytes (having a count &gt; 1)\n\nall 3 of these label-operations, check if it's done reading/writing, jumping to Finish (I couldn't figure out a more efficient way/design, sighs)\n\nI think my logic is right... as to which I have the jumps going to, but please notifify me if any are incorrect.\n\nif the Outer_Loop hits ecx = 0, then I know it's only a single byte (thus it jumps to the Single_Byte_One), however, it can have its upper bits set, which means I need it to jump to Single_Byte_Two, to handle the writing of its 2 bytes: [C0 + count][value of initial slot value stored in eax, which I have the Single_Byte_One being able to handle, it'll send/jump to Single_Byte_Two if the upper bits are set]\n\nif the Inner_Loop fails the comparison, it can be a single byte (which can either have its upper bits set or not) or a multiple byte, and thus it jumps to Single_Byte_One (which will check if it needs to redirect it to Multiple_Byte or Single_Byte_Two, or not).\n\nif the Inner_loop doesn't fail the comparison, then it *IS* a multiple byte, and is thus jumped to that label-operation (Multiple_Byte) if it has reached the end of its available looping (3Fh, as 40h would cause C0, C0+40, to overflow into the next byte, right? 1100:0000 + 0100:0000 = 0000:0001::0000:0000) or if ecx = 0\n\n---------\n\nbtw, is this correct bit-manipulation/arithmetic, which I used ?, will this work correctly? :\n\nfor writing the set upper bits single byte into its 2 bytes:\n\nfor Single_Byte_Two and Multiple_Byte:\n\n[0xC:0 h + (count value) h] // :: [2nd byte that holds initial value stored in eax, X:X h or XXXX:XXXX y]\n\n0xC:0 h to 0xF:F h\n\n0xC:0 h + 3:F h = 0xF:F h\n\n(0xC:0 h = 1100:0000 y)\n+  (3:F h = 0011:1111 y)\n___________________\n\n[0xF:F h = 1111:1111 y] // :: [2nd byte that holds the initial value stored in eax, X:X h or XXXX:XXXX y]\n\nright ???\n\ndo I need to use 'adc' instead, how do I handle the overflow from the low nibble (count value) into the upper nibble ??\n\nor do I not use 'add/adc', and instead just mov the values into the byte's nibbles (high and low), but how would I deal with moving the overflow from the lower nibble into the upepr nibble ???\n\n-----------------------------\n\nhere's my new code:\n\n(I'm a little confused between increasing the address itself vs working with, adding/moving,  the value/s at that address, in regards to whether I enclose it within the brackets or not)\n\n(for now, I'm just leaving it as the movzx 32-bit regs and byte ptr stuff usage, I'll go back later and see if I can convert it successfully over to using the 16 and 8 bit sub-division regs, and whether I need the 'byte ptrs' or not, later)\n\n[code:3jbq7kws];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; Credit (those who helped me)\n;------------------------------------------------------------------------------\n\n; Online person Jay\n; online resources\n; colleagues\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to encode (compress) a data file&#46;\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\t\t\n\t\tPUBLIC RLE_Encode\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; Prototypes\n;------------------------------------------------------------------------------\n\nDWORD\tRLE_Encode\t(char *InputBuf, DWORD InputLength, char *OutputBuf) public\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\nCARRIAGE_RETURN\t\t\tEQU\t\t0Dh\nNEW_LINE_FEED\t\t\tEQU\t\t0Ah\n\nNULL_POINTER\t\t\tEQU\t\t00h\n\n;***********\n; VARIABLES\n;***********\n\nheading\t\t\t\t\tbyte\t&quot;Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016&quot;,\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\nhistory\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\ncredit\t\t\t\t\tbyte\t&quot;Credits (those who helped me)&#58; &quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED, \\\n\t\t\t\t\t\t\t\t&quot;Online person Jay&quot;, \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\t\t\t\t\t\t\t\t\npurpose\t\t\t\t\tbyte\t&quot;This program's purpose is to encode &quot;, \\\n\t\t\t\t\t\t\t\t&quot;(compress) a data file&#46;&quot; \\\n\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\nMain \tProc\n\n\tpush eax\n\tcall RLE_Encode\n\t\n\t;**********************\n\t; Terminating Program\n\t;**********************\n\t\n\tFinish&#58;\n\t\n\tinvoke\tExitProcess, NULL_POINTER\n\nMain\tendp\n\n;************\n; Procedures\n;************\n\nDWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf) proc public \\\n\t\tstdcall uses ebx, ecx, edx, esi, edi, ebp, esp\n\n\tpush\tebp\n\tmovzx\tebp, esp\n\n\tpush\teax\n\t\n\tmovzx\tesi, InputBuf\n\tmovzx\tecx, InputLength\n\tmovzx\tedi, OutputBuf\n\t\n\txor\t\tedx, edx\t\n\t\n\tOuter_Loop&#58;\n\t\n\tmovzx\teax, byte ptr esi\n\tmovzx\tebx, 01h\n\tadd\t\t&#91;esi&#93;, 01h\n\tsub\t\tecx, 01h\n\tcmp\t\tecx, 00h\n\tje\t\tSingle_Byte_One\n\t\n\t\n\tInner_Loop&#58;\n\t\n\tmovzx\tedx, byte ptr esi\n\tcmp\t\teax, edx\n\tjne\t\tSingle_Byte_One\n\t\n\tadd\t\t&#91;esi&#93;, 01h\n\tadd\t\tebx, 01h\n\tsub\t\tecx, 01h\n\t\n\tcmp\t\tebx, 3Fh\n\tje\t\tMultiple_Byte\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tMultiple_Byte\n\t\n\tjmp\t\tInner_Loop\n\t\n\tMultiple_Byte&#58;\n\t\n\tadd\t\tebx, 0C0h\n\t\n\tmovzx\tedi, byte ptr ebx\n\tadd\t\t&#91;edi&#93;, 01h\n\t\n\tmovzx\tedi, byte ptr eax\n\tadd\t\t&#91;edi&#93;, 01h\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tSingle_Byte_Two&#58;\n\n\tmovzx\tedi, byte ptr 0C1h\n\tadd\t\t&#91;edi&#93;, 01h\n\t\n\tmovzx\tedi, byte ptr eax\n\tadd\t\t&#91;edi&#93;, 01h\n\t\n\tcmp\t\tecx, 00h\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tSingle_Byte_One&#58;\n\t\n\tcmp\t\tebx, 01h\n\tjne\t\tMultiple_Byte\n\t\n\tcmp\t\tah, 0Ch\n\tjae\t\tSingle_Byte_Two\n\t\n\tmovzx\tedi, byte ptr eax\n\tadd\t\t&#91;edi&#93;, 01h\n\t\n\tcmp\t\tecx, 00h\n\tjne\t\tOuter_Loop\n\t\n\tFinish\n\t\n\tmov\t\teax, &#91;edi&#93;\n\tsub\t\teax, &#91;OutputBuf&#93;\n\t\n\tpop\t\teax\n\tpop\t\tebp\n\t\t\n\tret\n\nRLE_Encode endp\n\n;*************************\n; Program End/Termination\n;*************************\n\n\t\tend Main[/code:3jbq7kws]",
      "EditableFormat": "bbcode",
      "HTML": "I still don't really understand the stack and/or the stack frame, and its ordering/displacement/offset/address stuff completely.<br/><br/>--------------<br/><br/>I'm a bit confused on the 'mov ebp, esp' in what exactly it is for, as I think you can say I can do this:<br/><br/>mov reg, [reg]<br/>example: eax, [esi]<br/><br/>whereas, I thought I'd need to do this? :<br/><br/>mov eax, [ebp][esi]<br/><br/>or even this:<br/><br/>mov eax, [ebp+12] ; mov eax, [param1]<br/><br/>-------<br/><br/>also, do I need to do this? :<br/><br/>mov ebp, esi<br/>add [ebp], displacement<br/><br/>to get past the slots for the stack frame pointer, return address pointer, parameters (if I end up using or required to use them), and etc:<br/><br/>(if I understand this stack construction/deconstruction/ordering stuff)<br/>(assumming they're all 'byte' in size...)<br/>[ebp+0] = stack frame pointer<br/>[ebp+4] = return address<br/>[ebp+8] = param1<br/>[ebp+12] = param2<br/>etc etc etc<br/><br/>------<br/><br/>I use 'add' as I thought it was slightly more efficient than 'inc'... I keep getting opposite statements... inc is more efficient, no, add is more efficient, no, inc is more efficient... it feels like the nutrition/science &quot;surveys&quot;, one survey says this food is good for you, another survey comes out saying that food is bad for you, another survey comes out saying that food is good for you... etc etc etc<br/><br/>I wish I could get some final clarification on which is more efficient... sighs. I used 'inc' originally as I thought it was more efficient, then I'm told that it is actually 'add' that is more efficient, so I use 'add'. Then I'm told that 'inc' is more efficient. I use inc again, then I'm told 'add' is more efficient, arg<br/><br/>----------------<br/><br/>I think my 'Single_Byte_One' will check and jump it to the correct label operation (Multiple_Byte or Single_Byte_Two)<br/><br/>Single_Byte_One: this will write single bytes which don't have the upper 2 bits set, or act as a re-direct-hub to the labels to handle the other two cases (if there's multiple bytes: count &gt; 1, or if the single byte has the 2 upper bits set, which means it must write 2 bytes).<br/><br/>Single_Byte_Two: this is for writing single bytes which have the two upper bits set, thus it's actually writing 2 bytes into the output buffer.<br/><br/>Multiple_Byte: this is for writing multiple bytes (having a count &gt; 1)<br/><br/>all 3 of these label-operations, check if it's done reading/writing, jumping to Finish (I couldn't figure out a more efficient way/design, sighs)<br/><br/>I think my logic is right... as to which I have the jumps going to, but please notifify me if any are incorrect.<br/><br/>if the Outer_Loop hits ecx = 0, then I know it's only a single byte (thus it jumps to the Single_Byte_One), however, it can have its upper bits set, which means I need it to jump to Single_Byte_Two, to handle the writing of its 2 bytes: [C0 + count][value of initial slot value stored in eax, which I have the Single_Byte_One being able to handle, it'll send/jump to Single_Byte_Two if the upper bits are set]<br/><br/>if the Inner_Loop fails the comparison, it can be a single byte (which can either have its upper bits set or not) or a multiple byte, and thus it jumps to Single_Byte_One (which will check if it needs to redirect it to Multiple_Byte or Single_Byte_Two, or not).<br/><br/>if the Inner_loop doesn't fail the comparison, then it *IS* a multiple byte, and is thus jumped to that label-operation (Multiple_Byte) if it has reached the end of its available looping (3Fh, as 40h would cause C0, C0+40, to overflow into the next byte, right? 1100:0000 + 0100:0000 = 0000:0001::0000:0000) or if ecx = 0<br/><br/>---------<br/><br/>btw, is this correct bit-manipulation/arithmetic, which I used ?, will this work correctly? :<br/><br/>for writing the set upper bits single byte into its 2 bytes:<br/><br/>for Single_Byte_Two and Multiple_Byte:<br/><br/>[0xC:0 h + (count value) h] // :: [2nd byte that holds initial value stored in eax, X:X h or XXXX:XXXX y]<br/><br/>0xC:0 h to 0xF:F h<br/><br/>0xC:0 h + 3:F h = 0xF:F h<br/><br/>(0xC:0 h = 1100:0000 y)<br/>+  (3:F h = 0011:1111 y)<br/>___________________<br/><br/>[0xF:F h = 1111:1111 y] // :: [2nd byte that holds the initial value stored in eax, X:X h or XXXX:XXXX y]<br/><br/>right ???<br/><br/>do I need to use 'adc' instead, how do I handle the overflow from the low nibble (count value) into the upper nibble ??<br/><br/>or do I not use 'add/adc', and instead just mov the values into the byte's nibbles (high and low), but how would I deal with moving the overflow from the lower nibble into the upepr nibble ???<br/><br/>-----------------------------<br/><br/>here's my new code:<br/><br/>(I'm a little confused between increasing the address itself vs working with, adding/moving,  the value/s at that address, in regards to whether I enclose it within the brackets or not)<br/><br/>(for now, I'm just leaving it as the movzx 32-bit regs and byte ptr stuff usage, I'll go back later and see if I can convert it successfully over to using the 16 and 8 bit sub-division regs, and whether I need the 'byte ptrs' or not, later)<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/>; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; Credit (those who helped me)<br/>;------------------------------------------------------------------------------<br/><br/>; Online person Jay<br/>; online resources<br/>; colleagues<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to encode (compress) a data file&#46;<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/>\t\t<br/>\t\tPUBLIC RLE_Encode<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; Prototypes<br/>;------------------------------------------------------------------------------<br/><br/>DWORD\tRLE_Encode\t(char *InputBuf, DWORD InputLength, char *OutputBuf) public<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>CARRIAGE_RETURN\t\t\tEQU\t\t0Dh<br/>NEW_LINE_FEED\t\t\tEQU\t\t0Ah<br/><br/>NULL_POINTER\t\t\tEQU\t\t00h<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>heading\t\t\t\t\tbyte\t&quot;Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016&quot;,<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>history\t\t\t\t\tbyte\t&quot;Version 1&#46;0&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>credit\t\t\t\t\tbyte\t&quot;Credits (those who helped me)&#58; &quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED, \\<br/>\t\t\t\t\t\t\t\t&quot;Online person Jay&quot;, \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/>\t\t\t\t\t\t\t\t<br/>purpose\t\t\t\t\tbyte\t&quot;This program's purpose is to encode &quot;, \\<br/>\t\t\t\t\t\t\t\t&quot;(compress) a data file&#46;&quot; \\<br/>\t\t\t\t\t\t\t\tCARRIAGE_RETURN, NEW_LINE_FEED, NEW_LINE_FEED<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>Main \tProc<br/><br/>\tpush eax<br/>\tcall RLE_Encode<br/>\t<br/>\t;**********************<br/>\t; Terminating Program<br/>\t;**********************<br/>\t<br/>\tFinish&#58;<br/>\t<br/>\tinvoke\tExitProcess, NULL_POINTER<br/><br/>Main\tendp<br/><br/>;************<br/>; Procedures<br/>;************<br/><br/>DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf) proc public \\<br/>\t\tstdcall uses ebx, ecx, edx, esi, edi, ebp, esp<br/><br/>\tpush\tebp<br/>\tmovzx\tebp, esp<br/><br/>\tpush\teax<br/>\t<br/>\tmovzx\tesi, InputBuf<br/>\tmovzx\tecx, InputLength<br/>\tmovzx\tedi, OutputBuf<br/>\t<br/>\txor\t\tedx, edx\t<br/>\t<br/>\tOuter_Loop&#58;<br/>\t<br/>\tmovzx\teax, byte ptr esi<br/>\tmovzx\tebx, 01h<br/>\tadd\t\t&#91;esi&#93;, 01h<br/>\tsub\t\tecx, 01h<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tSingle_Byte_One<br/>\t<br/>\t<br/>\tInner_Loop&#58;<br/>\t<br/>\tmovzx\tedx, byte ptr esi<br/>\tcmp\t\teax, edx<br/>\tjne\t\tSingle_Byte_One<br/>\t<br/>\tadd\t\t&#91;esi&#93;, 01h<br/>\tadd\t\tebx, 01h<br/>\tsub\t\tecx, 01h<br/>\t<br/>\tcmp\t\tebx, 3Fh<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tjmp\t\tInner_Loop<br/>\t<br/>\tMultiple_Byte&#58;<br/>\t<br/>\tadd\t\tebx, 0C0h<br/>\t<br/>\tmovzx\tedi, byte ptr ebx<br/>\tadd\t\t&#91;edi&#93;, 01h<br/>\t<br/>\tmovzx\tedi, byte ptr eax<br/>\tadd\t\t&#91;edi&#93;, 01h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tSingle_Byte_Two&#58;<br/><br/>\tmovzx\tedi, byte ptr 0C1h<br/>\tadd\t\t&#91;edi&#93;, 01h<br/>\t<br/>\tmovzx\tedi, byte ptr eax<br/>\tadd\t\t&#91;edi&#93;, 01h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tSingle_Byte_One&#58;<br/>\t<br/>\tcmp\t\tebx, 01h<br/>\tjne\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tah, 0Ch<br/>\tjae\t\tSingle_Byte_Two<br/>\t<br/>\tmovzx\tedi, byte ptr eax<br/>\tadd\t\t&#91;edi&#93;, 01h<br/>\t<br/>\tcmp\t\tecx, 00h<br/>\tjne\t\tOuter_Loop<br/>\t<br/>\tFinish<br/>\t<br/>\tmov\t\teax, &#91;edi&#93;<br/>\tsub\t\teax, &#91;OutputBuf&#93;<br/>\t<br/>\tpop\t\teax<br/>\tpop\t\tebp<br/>\t\t<br/>\tret<br/><br/>RLE_Encode endp<br/><br/>;*************************<br/>; Program End/Termination<br/>;*************************<br/><br/>\t\tend Main</code></pre>",
      "PostDate": "2016-04-05T03:24:04+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42098",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "You're right - your code was handling the counts. My bad, and I apologize.\n\nAs far as the stack goes, you're mixing two different metaphors in your code. By listing arguments after your function (e.g. the &quot;char *InputBuf&quot; and all the rest, you're telling the assembler to generate the frame prolog code for you. As shown on that page I sent you before, if you use that, then it will automatically put in for you the &quot;push ebp / mov ebp,esp&quot;, etc. stuff. When you use &quot;movzx esi, InputBuf&quot; (and, again, it should just be &quot;mov&quot; - you're not extending a lower bit value to a higher bit one. You're just moving a 32-bit value around), under the covers, the assembler is turning that into &quot;mov esi, [ebp+8]&quot;. Since you indicated to me that you can't use the calling convention stuff, you don't want to be doing that anyway. If I understand it properly, you need to get rid of the arguments and return type in your proc and handle it yourself. So you would have:\n\nRLE_Encode proc public\n   push   ebp\n   mov   ebp, esp\n\n   push   eax\n   \n   mov   esi, [ebp+8]\n   mov   ecx, [ebp+12]\n   mov   edi, [ebp+16]\n   \ninstead of using the assembler-generated parameter names and the like.\n\n[quote:1thvjzkc]I use 'add' as I thought it was slightly more efficient than 'inc'[/quote:1thvjzkc]\n&quot;inc&quot; exists as a more efficient form of &quot;add 1&quot; (or it used to, at least). It takes fewer bytes (you don't need the value being added, for one thing), so it's fewer memory cycles to read, and it's microcode is dedicated to simply doing the add 1 as opposed to the more general purpose addition of an arbitrary value. Unless CPU micro architecture has changed drastically when I wasn't looking... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Consider the CPU emulation you did before - which would be easier to implement, a single byte &quot;inc&quot; instruction, or an &quot;add&quot; instruction where you have to read the opcode and then read the value to add after it? (But I do see the debate, and things are not always as they seem: <!-- m --><a class=\"postlink\" href=\"http://stackoverflow.com/questions/13383407/is-add-1-really-faster-than-inc-x86\">http://stackoverflow.com/questions/1338 ... an-inc-x86</a><!-- m -->  To be honest, go with what you want, especially if some think add is ok. It just seems odd to me, especially in cases where you're not concerned about optimization, to not use the instruction that seems clearer. Plus I have this automatic &quot;noooo&quot; when I see the add. Times may have changed.)\n\n[quote:1thvjzkc]do I need to use 'adc' instead, how do I handle the overflow from the low nibble (count value) into the upper nibble ??[/quote:1thvjzkc]\nYou can't really even address things at the nibble level as far as addition and subtraction goes. Those operations operate on a minimal unit of a byte, which is 8 bits as a unit. The thing you need the carry for with adc is propagating carry across registers or memory locations when doing multi-byte/word/whatever operations.\n\nYou're generally handling the 0xC0 fine. You can either add 0xc0 or &quot;or&quot; the bits in. I personally prefer the &quot;or&quot; since it's clearer that I'm setting too bits to those values as opposed to addition, which has other semantics to me. But as long as you know the top two bits are clear, the add *works&quot; just as well.\n\n[quote:1thvjzkc](for now, I'm just leaving it as the movzx 32-bit regs and byte ptr stuff usage, I'll go back later and see if I can convert it successfully over to using the 16 and 8 bit sub-division regs, and whether I need the 'byte ptrs' or not, later)[/quote:1thvjzkc]\nThat's fine. Just remember that you don't need to use &quot;movzx&quot; *unless* you're dealing with a byte ptr that needs to be extended to a higher-bit (16 or 32) register. You don't want/need to use it just to move 32-bit values around, and even if the compiler allows it, it's confusing to someone looking at the code, since movzx has the express purpose of moving from lower to higher bits widths, which is not the case for something like &quot;mov ebp, esp&quot;.\n\n(In fact, if you look this page, you'll see there is no supported variant of movzx for 32-bit values. If it assembles, then the assembler must be correcting it for you:  <!-- m --><a class=\"postlink\" href=\"http://x86.renejeschke.de/html/file_module_x86_id_209.html\">http://x86.renejeschke.de/html/file_mod ... d_209.html</a><!-- m -->)",
      "EditableFormat": "bbcode",
      "HTML": "You're right - your code was handling the counts. My bad, and I apologize.<br/><br/>As far as the stack goes, you're mixing two different metaphors in your code. By listing arguments after your function (e.g. the &quot;char *InputBuf&quot; and all the rest, you're telling the assembler to generate the frame prolog code for you. As shown on that page I sent you before, if you use that, then it will automatically put in for you the &quot;push ebp / mov ebp,esp&quot;, etc. stuff. When you use &quot;movzx esi, InputBuf&quot; (and, again, it should just be &quot;mov&quot; - you're not extending a lower bit value to a higher bit one. You're just moving a 32-bit value around), under the covers, the assembler is turning that into &quot;mov esi, [ebp+8]&quot;. Since you indicated to me that you can't use the calling convention stuff, you don't want to be doing that anyway. If I understand it properly, you need to get rid of the arguments and return type in your proc and handle it yourself. So you would have:<br/><br/>RLE_Encode proc public<br/>   push   ebp<br/>   mov   ebp, esp<br/><br/>   push   eax<br/>   <br/>   mov   esi, [ebp+8]<br/>   mov   ecx, [ebp+12]<br/>   mov   edi, [ebp+16]<br/>   <br/>instead of using the assembler-generated parameter names and the like.<br/><br/><blockquote><p>I use 'add' as I thought it was slightly more efficient than 'inc'</p></blockquote><br/>&quot;inc&quot; exists as a more efficient form of &quot;add 1&quot; (or it used to, at least). It takes fewer bytes (you don't need the value being added, for one thing), so it's fewer memory cycles to read, and it's microcode is dedicated to simply doing the add 1 as opposed to the more general purpose addition of an arbitrary value. Unless CPU micro architecture has changed drastically when I wasn't looking... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> Consider the CPU emulation you did before - which would be easier to implement, a single byte &quot;inc&quot; instruction, or an &quot;add&quot; instruction where you have to read the opcode and then read the value to add after it? (But I do see the debate, and things are not always as they seem: <!-- m --><a class=\"postlink\" href=\"http://stackoverflow.com/questions/13383407/is-add-1-really-faster-than-inc-x86\">http://stackoverflow.com/questions/1338 ... an-inc-x86</a><!-- m -->  To be honest, go with what you want, especially if some think add is ok. It just seems odd to me, especially in cases where you're not concerned about optimization, to not use the instruction that seems clearer. Plus I have this automatic &quot;noooo&quot; when I see the add. Times may have changed.)<br/><br/><blockquote><p>do I need to use 'adc' instead, how do I handle the overflow from the low nibble (count value) into the upper nibble ??</p></blockquote><br/>You can't really even address things at the nibble level as far as addition and subtraction goes. Those operations operate on a minimal unit of a byte, which is 8 bits as a unit. The thing you need the carry for with adc is propagating carry across registers or memory locations when doing multi-byte/word/whatever operations.<br/><br/>You're generally handling the 0xC0 fine. You can either add 0xc0 or &quot;or&quot; the bits in. I personally prefer the &quot;or&quot; since it's clearer that I'm setting too bits to those values as opposed to addition, which has other semantics to me. But as long as you know the top two bits are clear, the add *works&quot; just as well.<br/><br/><blockquote><p>(for now, I'm just leaving it as the movzx 32-bit regs and byte ptr stuff usage, I'll go back later and see if I can convert it successfully over to using the 16 and 8 bit sub-division regs, and whether I need the 'byte ptrs' or not, later)</p></blockquote><br/>That's fine. Just remember that you don't need to use &quot;movzx&quot; *unless* you're dealing with a byte ptr that needs to be extended to a higher-bit (16 or 32) register. You don't want/need to use it just to move 32-bit values around, and even if the compiler allows it, it's confusing to someone looking at the code, since movzx has the express purpose of moving from lower to higher bits widths, which is not the case for something like &quot;mov ebp, esp&quot;.<br/><br/>(In fact, if you look this page, you'll see there is no supported variant of movzx for 32-bit values. If it assembles, then the assembler must be correcting it for you:  <!-- m --><a class=\"postlink\" href=\"http://x86.renejeschke.de/html/file_module_x86_id_209.html\">http://x86.renejeschke.de/html/file_mod ... d_209.html</a><!-- m -->)",
      "PostDate": "2016-04-05T07:56:34+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42099",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "I'm really confused by and/or don't understand this stuff very well, so I have no idea what is right and what is wrong, if you could take a look at it and correct (and explain) it, I'd be appreciative:\n\nnew code:\n\n[code:f0aej8be]&#46;586\n\n&#46;MODEL flat, stdcall\n\noption casemap &#58;none\n\npublic _RLE_Encode ; Do I need this?\n\ndword _RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf) public ; Is this correct? I keep this like this, or no?\n\n&#46;STACK 4096\n\n&#46;DATA\n\n;blah stuff\n\n&#46;CODE\n\n; main proc\n\n; what do I do here, do I even need this stuff, do I just have the encode procedure ???\n; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think\n; call _RLE_Encode ; or am I too use 'invoke' instead?\n; Finish&#58;\n; invoke ExitProcess, 00h\n\n; Main endp\n\n_RLE_Encode proc public ; is this correct header?\n\n; is this stuff below correct? especially whether I use the 32 bit regs, 16 bit regs, or the 8 bit regs, whether I need to use data type pointers, whether I bracket a reg or not, and etc&#46;&#46;&#46; I'm just so confused now, I don't know what's right and what's wrong, I'm just not understanding this stuff that well&#46;\n\npush ebp\nmov ebp, esp \n\n; do I need to add/sub from esp/ebp ???\n\n; push the other regs ; does this go here?\n; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think\n; push the other regs ; does this go here?\n\n; what do I push for the 'return address' byte slot&#58; &#91;ebp+4&#93; ???\n\nmov esi, &#91;ebp+8&#93; ; will it be more than '+8' if I push the other regs?\nmov ecx, &#91;ebp+12&#93; ; will it be more than '+12' if I push the other regs?\nmov edi, &#91;ebp+16&#93; ; will it be more than '+16' if I push the other regs?\n\nOuter_Loop&#58;\n\nmov al, esi\nmov bl, 01h\ninc &#91;esi&#93;\ndec ecx\ncmp cl, 00h\nje Single_Byte_One\n\nInner_Loop&#58;\n\nmov dl, esi\ncmp al, dl\njne Single_Byte_One\ninc &#91;esi&#93;\ninc ebx\ndec ecx\ncmp bl, 3Fh\nje Multiple_Byte\ncmp cl, 00h\nje Multiple_Byte\njmp Inner_Loop\n\nMultiple_Byte&#58;\n\nor bl, 0C0h\nmov edi, bl\ninc &#91;edi&#93;\nmov edi, al\ninc &#91;edi&#93;\ncmp cl, 00h\nje Finish\njmp Outer_Loop\n\nSingle_Byte_Two&#58;\n\nmov edi, 0C1h\ninc &#91;edi&#93;\nmov edi, al\ninc &#91;edi&#93;\ncmp cl, 00h\nje Finish\njmp Outer_Loop\n\nSingle_Byte_One&#58;\n\ncmp bl, 01h\njne Multiple_Byte\ncmp ah, 0Ch\njae Single_Byte_Two\nmov edi, al\ninc &#91;edi&#93;\ncmp cl, 00h\njne Outer_Loop\n\nFinish&#58;\n\nmov al, &#91;edi&#93;\nsub al, &#91;OutputBuf&#93;\n\n; do I need to add/sub from esp/ebp ???\n\n; pop other regs ; does this go here ?\n; pop eax ; does this even get pushed/popper or not?\n; pop other regs ; does this go here ?\n; pop ebp\n\n; ret ; do I need to add/sub a value here ???\n\n_RLE_Encode endp\n\n; end Main[/code:f0aej8be]\n\n-----------------------------\n\noff-topic:\n\nabout my confusion over 'inc' vs 'add', and the differing statements I've been getting from many various sources (confusing me as to which is better):\n\nif I remember right, I think the prof said that (at least with this 32-bit build/version of MASM), that 'add' is (slightly) better/faster in terms of actual execution time efficiency, and I also think that the 'inc' requires more actual steps/operations underneath (it's basically doing the 'add' optiminally, but you got the overhead of going from the 'inc' to its own add operations), though of course for the human and the file size, 'inc' is only 2 opcodes, whereas 'add' is 3 opcodes. If I understand this stuff right, and remember correctly. So, from this I had assumed thus that 'add' was more efficient (to me actual execution is main meaning of efficiency, unless you got a big or professional program where file size and etc matters more than execution speed), so that's why I've been using 'add' over 'inc'... but it does seem to be a bit of a grey area, as efficiency seems to be a bit arbitrary, unless you've got a glaring inefficiency vs efficiency comparison.",
      "EditableFormat": "bbcode",
      "HTML": "I'm really confused by and/or don't understand this stuff very well, so I have no idea what is right and what is wrong, if you could take a look at it and correct (and explain) it, I'd be appreciative:<br/><br/>new code:<br/><br/><pre><code>&#46;586<br/><br/>&#46;MODEL flat, stdcall<br/><br/>option casemap &#58;none<br/><br/>public _RLE_Encode ; Do I need this?<br/><br/>dword _RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf) public ; Is this correct? I keep this like this, or no?<br/><br/>&#46;STACK 4096<br/><br/>&#46;DATA<br/><br/>;blah stuff<br/><br/>&#46;CODE<br/><br/>; main proc<br/><br/>; what do I do here, do I even need this stuff, do I just have the encode procedure ???<br/>; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think<br/>; call _RLE_Encode ; or am I too use 'invoke' instead?<br/>; Finish&#58;<br/>; invoke ExitProcess, 00h<br/><br/>; Main endp<br/><br/>_RLE_Encode proc public ; is this correct header?<br/><br/>; is this stuff below correct? especially whether I use the 32 bit regs, 16 bit regs, or the 8 bit regs, whether I need to use data type pointers, whether I bracket a reg or not, and etc&#46;&#46;&#46; I'm just so confused now, I don't know what's right and what's wrong, I'm just not understanding this stuff that well&#46;<br/><br/>push ebp<br/>mov ebp, esp <br/><br/>; do I need to add/sub from esp/ebp ???<br/><br/>; push the other regs ; does this go here?<br/>; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think<br/>; push the other regs ; does this go here?<br/><br/>; what do I push for the 'return address' byte slot&#58; &#91;ebp+4&#93; ???<br/><br/>mov esi, &#91;ebp+8&#93; ; will it be more than '+8' if I push the other regs?<br/>mov ecx, &#91;ebp+12&#93; ; will it be more than '+12' if I push the other regs?<br/>mov edi, &#91;ebp+16&#93; ; will it be more than '+16' if I push the other regs?<br/><br/>Outer_Loop&#58;<br/><br/>mov al, esi<br/>mov bl, 01h<br/>inc &#91;esi&#93;<br/>dec ecx<br/>cmp cl, 00h<br/>je Single_Byte_One<br/><br/>Inner_Loop&#58;<br/><br/>mov dl, esi<br/>cmp al, dl<br/>jne Single_Byte_One<br/>inc &#91;esi&#93;<br/>inc ebx<br/>dec ecx<br/>cmp bl, 3Fh<br/>je Multiple_Byte<br/>cmp cl, 00h<br/>je Multiple_Byte<br/>jmp Inner_Loop<br/><br/>Multiple_Byte&#58;<br/><br/>or bl, 0C0h<br/>mov edi, bl<br/>inc &#91;edi&#93;<br/>mov edi, al<br/>inc &#91;edi&#93;<br/>cmp cl, 00h<br/>je Finish<br/>jmp Outer_Loop<br/><br/>Single_Byte_Two&#58;<br/><br/>mov edi, 0C1h<br/>inc &#91;edi&#93;<br/>mov edi, al<br/>inc &#91;edi&#93;<br/>cmp cl, 00h<br/>je Finish<br/>jmp Outer_Loop<br/><br/>Single_Byte_One&#58;<br/><br/>cmp bl, 01h<br/>jne Multiple_Byte<br/>cmp ah, 0Ch<br/>jae Single_Byte_Two<br/>mov edi, al<br/>inc &#91;edi&#93;<br/>cmp cl, 00h<br/>jne Outer_Loop<br/><br/>Finish&#58;<br/><br/>mov al, &#91;edi&#93;<br/>sub al, &#91;OutputBuf&#93;<br/><br/>; do I need to add/sub from esp/ebp ???<br/><br/>; pop other regs ; does this go here ?<br/>; pop eax ; does this even get pushed/popper or not?<br/>; pop other regs ; does this go here ?<br/>; pop ebp<br/><br/>; ret ; do I need to add/sub a value here ???<br/><br/>_RLE_Encode endp<br/><br/>; end Main</code></pre><br/><br/>-----------------------------<br/><br/>off-topic:<br/><br/>about my confusion over 'inc' vs 'add', and the differing statements I've been getting from many various sources (confusing me as to which is better):<br/><br/>if I remember right, I think the prof said that (at least with this 32-bit build/version of MASM), that 'add' is (slightly) better/faster in terms of actual execution time efficiency, and I also think that the 'inc' requires more actual steps/operations underneath (it's basically doing the 'add' optiminally, but you got the overhead of going from the 'inc' to its own add operations), though of course for the human and the file size, 'inc' is only 2 opcodes, whereas 'add' is 3 opcodes. If I understand this stuff right, and remember correctly. So, from this I had assumed thus that 'add' was more efficient (to me actual execution is main meaning of efficiency, unless you got a big or professional program where file size and etc matters more than execution speed), so that's why I've been using 'add' over 'inc'... but it does seem to be a bit of a grey area, as efficiency seems to be a bit arbitrary, unless you've got a glaring inefficiency vs efficiency comparison.",
      "PostDate": "2016-04-05T09:54:59+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42103",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Answers and corrections inline below, preceded by &quot;----&quot;. (I haven't had time to look over all the logic, being at work. I just went for syntax, etc issues that jumped out at me.)\n\n[code:vnojtc5w]&#46;586\n\n&#46;MODEL flat, stdcall\n\noption casemap &#58;none\n\npublic _RLE_Encode ; Do I need this?\n\ndword _RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf) public ; Is this correct? I keep this like this, or no?\n---- I don't think you need this&#46; I could be wrong, but you don't need to tell the compiler params, since you're doing it yourself&#46;\n---- Having said that, when I did assembly language, we didn't have that feature&#46; I could look at it more, if you wish&#46;\n\n&#46;STACK 4096\n\n&#46;DATA\n\n;blah stuff\n\n&#46;CODE\n\n; main proc\n\n; what do I do here, do I even need this stuff, do I just have the encode procedure ???\n; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think\n; call _RLE_Encode ; or am I too use 'invoke' instead?\n; Finish&#58;\n; invoke ExitProcess, 00h\n\n---- You shouldn't need that&#46; You're not calling your function from here&#46; The &quot;main&quot; entry point will be supplied by the C code,\n---- which will be calling this as a subroutine&#46;\n\n; Main endp\n\n_RLE_Encode proc public ; is this correct header?\n\n---- I think that looks ok&#46;\n\n; is this stuff below correct? especially whether I use the 32 bit regs, 16 bit regs, or the 8 bit regs, whether I need to use data type pointers, whether I bracket a reg or not, and etc&#46;&#46;&#46; I'm just so confused now, I don't know what's right and what's wrong, I'm just not understanding this stuff that well&#46;\n\npush ebp\nmov ebp, esp \n\n; do I need to add/sub from esp/ebp ???\n\n---- You would only need to sub further from esp if you were using local (temporary/auto) variables on the stack&#46;\n---- You shouldn't need to (you should be able to get away with using registers alone), so you can skip that part&#46;\n\n; push the other regs ; does this go here?\n\n---- pushing other registers would go here&#46;\n\n; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think\n\n---- you will be returning the size in eax, so there's no point in saving it&#46; (It will be lost regardless&#46;)\n\n; push the other regs ; does this go here?\n\n---- Yes, save any other registers here&#46; Not ebp, of course, since it's already saved&#46; &#58;)\n\n; what do I push for the 'return address' byte slot&#58; &#91;ebp+4&#93; ???\n\n---- The return address is already on the stack, pushed there when the C code made the call&#46; That's what allows your ret to go home when done&#46;\n\nmov esi, &#91;ebp+8&#93; ; will it be more than '+8' if I push the other regs?\nmov ecx, &#91;ebp+12&#93; ; will it be more than '+12' if I push the other regs?\nmov edi, &#91;ebp+16&#93; ; will it be more than '+16' if I push the other regs?\n\n---- You have set ebp to be esp *before* you pushed the registers, and the stack grows downward&#46; So the +8, etc will be the values before your push&#46;\n---- So no pushing afterwards will have any effect on the offsets you use&#46;\n---- If for some reason you had set ebp *after* you pushed all the registers (not common or recommended), then you would need to change the offsets\n---- to account for that, since esp would have changed drastically - which is probably why people don't do it&#46;\n\nOuter_Loop&#58;\n\nmov al, esi    ---- mov al, &#91;esi&#93;    ; read what esi points to\nmov bl, 01h\ninc &#91;esi&#93;      ---- inc esi          ; inc the esi pointer value (not its contents)\ndec ecx\ncmp cl, 00h    ---- this is a 32-bit count, so it would be ecx&#46; However, dec sets the z flag when ecx reaches 0, so you don't even need this line&#46;\nje Single_Byte_One\n\nInner_Loop&#58;\n\nmov dl, esi     ---- mov dl,&#91;esi&#93;\ncmp al, dl\njne Single_Byte_One\ninc &#91;esi&#93;       ---- inc esi\ninc ebx\ndec ecx\ncmp bl, 3Fh\nje Multiple_Byte\ncmp cl, 00h      ---- using full 32-bits for count, so this would be ecx&#46;\nje Multiple_Byte\njmp Inner_Loop\n\nMultiple_Byte&#58;\n\nor bl, 0C0h\nmov edi, bl      ---- mov &#91;edi&#93;, bl\ninc &#91;edi&#93;        ---- inc edi\nmov edi, al      ---- ov &#91;edi&#93;, al\ninc &#91;edi&#93;        ---- inc edi\ncmp cl, 00h      ---- cmp ecx, 0\nje Finish\njmp Outer_Loop\n\nSingle_Byte_Two&#58;\n\nmov edi, 0C1h     ---- mov byte ptr &#91;edi&#93;, 0c1h\ninc &#91;edi&#93;         ---- inc edi \nmov edi, al       ---- mov &#91;edi&#93;, al\ninc &#91;edi&#93;         ---- inc edi\ncmp cl, 00h       ---- cmp ecx, 0\nje Finish\njmp Outer_Loop\n\nSingle_Byte_One&#58;\n\ncmp bl, 01h\njne Multiple_Byte\ncmp ah, 0Ch        ---- cmp al, 0c0h   (nibble confusion? If ah = 12h and al = 34h, then ax would be 1234h&#46; So c0h is just in al&#46; It doesn't touch ah)\njae Single_Byte_Two\nmov edi, al        ---- mov &#91;edi&#93;,al\ninc &#91;edi&#93;          ---- inc edi\ncmp cl, 00h        ---- cmp ecx,0\njne Outer_Loop\n\nFinish&#58;\n\nmov al, &#91;edi&#93;       ---- mov eax, edi   ; count is full 32-bit value&#46; You only would use the byte registers for the data bytes, not the counts&#46;\nsub al, &#91;OutputBuf&#93; ---- sub eax, &#91;ebp+16&#93;\n\n; do I need to add/sub from esp/ebp ???\n\n---- no adjustment needed, since you have no locals\n\n; pop other regs ; does this go here ?\n\n---- yes, pop the registers you pushed here (but not ebp yet)\n\n; pop eax ; does this even get pushed/popper or not?\n\n---- if you pushed and popped eax, you'd lose your return value&#46; So, no&#46;\n\n; pop ebp\n\n; ret ; do I need to add/sub a value here ???\n\n---- if this is C calling convention, then you would just use &quot;ret&quot;, as the caller will pop the arguments\n---- If it's stdcall, then you need to clean the stack, so it would be &quot;ret 12&quot; to remove the pushed arguments&#46;\n\n_RLE_Encode endp\n\n; end Main[/code:vnojtc5w]",
      "EditableFormat": "bbcode",
      "HTML": "Answers and corrections inline below, preceded by &quot;----&quot;. (I haven't had time to look over all the logic, being at work. I just went for syntax, etc issues that jumped out at me.)<br/><br/><pre><code>&#46;586<br/><br/>&#46;MODEL flat, stdcall<br/><br/>option casemap &#58;none<br/><br/>public _RLE_Encode ; Do I need this?<br/><br/>dword _RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf) public ; Is this correct? I keep this like this, or no?<br/>---- I don't think you need this&#46; I could be wrong, but you don't need to tell the compiler params, since you're doing it yourself&#46;<br/>---- Having said that, when I did assembly language, we didn't have that feature&#46; I could look at it more, if you wish&#46;<br/><br/>&#46;STACK 4096<br/><br/>&#46;DATA<br/><br/>;blah stuff<br/><br/>&#46;CODE<br/><br/>; main proc<br/><br/>; what do I do here, do I even need this stuff, do I just have the encode procedure ???<br/>; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think<br/>; call _RLE_Encode ; or am I too use 'invoke' instead?<br/>; Finish&#58;<br/>; invoke ExitProcess, 00h<br/><br/>---- You shouldn't need that&#46; You're not calling your function from here&#46; The &quot;main&quot; entry point will be supplied by the C code,<br/>---- which will be calling this as a subroutine&#46;<br/><br/>; Main endp<br/><br/>_RLE_Encode proc public ; is this correct header?<br/><br/>---- I think that looks ok&#46;<br/><br/>; is this stuff below correct? especially whether I use the 32 bit regs, 16 bit regs, or the 8 bit regs, whether I need to use data type pointers, whether I bracket a reg or not, and etc&#46;&#46;&#46; I'm just so confused now, I don't know what's right and what's wrong, I'm just not understanding this stuff that well&#46;<br/><br/>push ebp<br/>mov ebp, esp <br/><br/>; do I need to add/sub from esp/ebp ???<br/><br/>---- You would only need to sub further from esp if you were using local (temporary/auto) variables on the stack&#46;<br/>---- You shouldn't need to (you should be able to get away with using registers alone), so you can skip that part&#46;<br/><br/>; push the other regs ; does this go here?<br/><br/>---- pushing other registers would go here&#46;<br/><br/>; push eax ; do I need this here? do I want to push eax or not, as it's suppose to be used by the C++ to return the OutputBuf length, I think<br/><br/>---- you will be returning the size in eax, so there's no point in saving it&#46; (It will be lost regardless&#46;)<br/><br/>; push the other regs ; does this go here?<br/><br/>---- Yes, save any other registers here&#46; Not ebp, of course, since it's already saved&#46; &#58;)<br/><br/>; what do I push for the 'return address' byte slot&#58; &#91;ebp+4&#93; ???<br/><br/>---- The return address is already on the stack, pushed there when the C code made the call&#46; That's what allows your ret to go home when done&#46;<br/><br/>mov esi, &#91;ebp+8&#93; ; will it be more than '+8' if I push the other regs?<br/>mov ecx, &#91;ebp+12&#93; ; will it be more than '+12' if I push the other regs?<br/>mov edi, &#91;ebp+16&#93; ; will it be more than '+16' if I push the other regs?<br/><br/>---- You have set ebp to be esp *before* you pushed the registers, and the stack grows downward&#46; So the +8, etc will be the values before your push&#46;<br/>---- So no pushing afterwards will have any effect on the offsets you use&#46;<br/>---- If for some reason you had set ebp *after* you pushed all the registers (not common or recommended), then you would need to change the offsets<br/>---- to account for that, since esp would have changed drastically - which is probably why people don't do it&#46;<br/><br/>Outer_Loop&#58;<br/><br/>mov al, esi    ---- mov al, &#91;esi&#93;    ; read what esi points to<br/>mov bl, 01h<br/>inc &#91;esi&#93;      ---- inc esi          ; inc the esi pointer value (not its contents)<br/>dec ecx<br/>cmp cl, 00h    ---- this is a 32-bit count, so it would be ecx&#46; However, dec sets the z flag when ecx reaches 0, so you don't even need this line&#46;<br/>je Single_Byte_One<br/><br/>Inner_Loop&#58;<br/><br/>mov dl, esi     ---- mov dl,&#91;esi&#93;<br/>cmp al, dl<br/>jne Single_Byte_One<br/>inc &#91;esi&#93;       ---- inc esi<br/>inc ebx<br/>dec ecx<br/>cmp bl, 3Fh<br/>je Multiple_Byte<br/>cmp cl, 00h      ---- using full 32-bits for count, so this would be ecx&#46;<br/>je Multiple_Byte<br/>jmp Inner_Loop<br/><br/>Multiple_Byte&#58;<br/><br/>or bl, 0C0h<br/>mov edi, bl      ---- mov &#91;edi&#93;, bl<br/>inc &#91;edi&#93;        ---- inc edi<br/>mov edi, al      ---- ov &#91;edi&#93;, al<br/>inc &#91;edi&#93;        ---- inc edi<br/>cmp cl, 00h      ---- cmp ecx, 0<br/>je Finish<br/>jmp Outer_Loop<br/><br/>Single_Byte_Two&#58;<br/><br/>mov edi, 0C1h     ---- mov byte ptr &#91;edi&#93;, 0c1h<br/>inc &#91;edi&#93;         ---- inc edi <br/>mov edi, al       ---- mov &#91;edi&#93;, al<br/>inc &#91;edi&#93;         ---- inc edi<br/>cmp cl, 00h       ---- cmp ecx, 0<br/>je Finish<br/>jmp Outer_Loop<br/><br/>Single_Byte_One&#58;<br/><br/>cmp bl, 01h<br/>jne Multiple_Byte<br/>cmp ah, 0Ch        ---- cmp al, 0c0h   (nibble confusion? If ah = 12h and al = 34h, then ax would be 1234h&#46; So c0h is just in al&#46; It doesn't touch ah)<br/>jae Single_Byte_Two<br/>mov edi, al        ---- mov &#91;edi&#93;,al<br/>inc &#91;edi&#93;          ---- inc edi<br/>cmp cl, 00h        ---- cmp ecx,0<br/>jne Outer_Loop<br/><br/>Finish&#58;<br/><br/>mov al, &#91;edi&#93;       ---- mov eax, edi   ; count is full 32-bit value&#46; You only would use the byte registers for the data bytes, not the counts&#46;<br/>sub al, &#91;OutputBuf&#93; ---- sub eax, &#91;ebp+16&#93;<br/><br/>; do I need to add/sub from esp/ebp ???<br/><br/>---- no adjustment needed, since you have no locals<br/><br/>; pop other regs ; does this go here ?<br/><br/>---- yes, pop the registers you pushed here (but not ebp yet)<br/><br/>; pop eax ; does this even get pushed/popper or not?<br/><br/>---- if you pushed and popped eax, you'd lose your return value&#46; So, no&#46;<br/><br/>; pop ebp<br/><br/>; ret ; do I need to add/sub a value here ???<br/><br/>---- if this is C calling convention, then you would just use &quot;ret&quot;, as the caller will pop the arguments<br/>---- If it's stdcall, then you need to clean the stack, so it would be &quot;ret 12&quot; to remove the pushed arguments&#46;<br/><br/>_RLE_Encode endp<br/><br/>; end Main</code></pre>",
      "PostDate": "2016-04-05T12:20:49+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42104",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Looking at the calling conventions a bit (<!-- m --><a class=\"postlink\" href=\"https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions\">https://en.wikibooks.org/wiki/X86_Disas ... onventions</a><!-- m -->), it looks like you're using the cdecl (&quot;C&quot;) calling convention (based on the name of your proc just having a leading underscore). So you can ignore the part about &quot;ret 12&quot;.\n\nIf you were to use stdcall convention, you would also have to reverse the offsets you use to access the parameters relative to ebp, since stdcall pushes the parameters right-to-left instead of left-to-right. (I had a panic when I remembered this. But I think you're ok.)\n\nYes, the wonders of integrating different languages. I guess that's why Microsoft added the calling convention and parameter types to masm - to hide all the ugliness.",
      "EditableFormat": "bbcode",
      "HTML": "Looking at the calling conventions a bit (<!-- m --><a class=\"postlink\" href=\"https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions\">https://en.wikibooks.org/wiki/X86_Disas ... onventions</a><!-- m -->), it looks like you're using the cdecl (&quot;C&quot;) calling convention (based on the name of your proc just having a leading underscore). So you can ignore the part about &quot;ret 12&quot;.<br/><br/>If you were to use stdcall convention, you would also have to reverse the offsets you use to access the parameters relative to ebp, since stdcall pushes the parameters right-to-left instead of left-to-right. (I had a panic when I remembered this. But I think you're ok.)<br/><br/>Yes, the wonders of integrating different languages. I guess that's why Microsoft added the calling convention and parameter types to masm - to hide all the ugliness.",
      "PostDate": "2016-04-05T12:43:24+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42105",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Thank you so much Jay, I was really confused (I had like all the brackets/no brackets backwards, lol), also probably some of my confusion from being so tired, and now I understand it much better and not so confused as I was (I just read too much information, I didn't know whether it applied to what I was doing or not, and this also caused me to be confused with stuff I shouldn't have been confused with).\n\nSorry, about needing so much help, a lot of this stuff is new to me, so it's been confusing (too much information and not understanding it very well) and difficult for me to get this stuff on my own. Thanks for helping me learn and understand this stuff so much better! Also, being up all day and night working on it and trying to figure it out or understand it, being very tired and sleep derived, doesn't help matters.\n\n----------\n\nsome quick questions:\n\ndo I need to use the 'local' key-word/command for the labels, and if I do, does this mess up the stack (do I have to account for the displacement of them) ??? I think there's something where if you got looping/nesting/recursion with labels/procedures, you need to use the 'local', else it doesn't work right ???\n\njust want to make sure that this is correct (as I'm not sure if this is how I set it up for the or'ing to work correctly, do I use the same value of 0C0 h or do I need to use different value/binary/bit sequence to properly line it up for the or'ing?): or bl, 0C0h\n\nwere you saying that the prototype would just be this: public _RLE_Encode, ???\n\n(also does it matter if I put the key-words/commands on the left side vs the right side, such as with 'public' in the question above, ??? Can I put, using 'public' again as example, after / to the right of, 'proc', or is this right side space, reserved for the 'uses:regs' and/or the 'parameters:data type' )\n\nto go about testing if this works... I presume I'd have to make a (decoded) data file (does this have to be a specific ext or can I just use a *.txt, notepad file?), check the C++ program, figuring out how it works/gets the file (not sure if I can figure out how to get it to be able to find/get/access the file... hmm... I'll have to see if I can figure it out), and then run the C++ program, and seeing if it can link-find-access my asm file, and then if it'll work correctly or not ???\n\n----------------------------\n\nnew (corrected) code:\n\n[code:2t1cace3];------------------------------------------------------------------------------\n; HEADING\n;------------------------------------------------------------------------------\n\n; redacted\n; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016\n\n;------------------------------------------------------------------------------\n; HISTORY\n;------------------------------------------------------------------------------\n\n; Version 1&#46;0\n\n;------------------------------------------------------------------------------\n; Credit (those who helped me)\n;------------------------------------------------------------------------------\n\n; Online person Jay\n; online resources (need to get/paste them here still)\n; Colleagues in/from class\n\n;------------------------------------------------------------------------------\n; PURPOSE\n;------------------------------------------------------------------------------\n\n; The purpose of this program is to encode (compress) a data file&#46;\n\n;------------------------------------------------------------------------------\n; MASM BUILD TYPE\n;------------------------------------------------------------------------------\n\n\t\t&#46;586\n\t\t\n;------------------------------------------------------------------------------\n; MODEL, STANDARD, and Option TYPES\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;MODEL flat, stdcall\n\n\t\toption casemap &#58;none ;makes it case sensitive\n\n;------------------------------------------------------------------------------\n; LIBRARIES/MODULES\n;------------------------------------------------------------------------------\n\n;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)\n\n;********************************************************\n; Masm Include File for Windows 32-Bit API Functions\n;\n; The information contained in this file can be found at\n; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx\n;\n;********************************************************\n\n;********************************************************\n; WINDOWS API FUNCTION PROTOTYPES\n;********************************************************\n\nExitProcess PROTO &#58; DWORD\nGetStdHandle PROTO &#58; DWORD\nReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nSetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD\nSetConsoleMode PROTO &#58; DWORD, &#58; DWORD\nSetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD\nWriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nFlushConsoleInputBuffer PROTO &#58; DWORD\n\nCreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD\nCreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD\nReleaseMutex PROTO &#58;DWORD\nSleep PROTO &#58; DWORD\nWaitForSingleObject PROTO &#58;DWORD,&#58;DWORD\nWaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD\nSuspendThread PROTO &#58; DWORD\nResumeThread PROTO &#58; DWORD\nExitThread PROTO &#58; DWORD\n\nCreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD\nGetFileSize  PROTO &#58; DWORD, &#58; DWORD\nCloseHandle PROTO &#58; DWORD\n\nTIMECAPS Struct\n  wPeriodMin    DWORD     ?\n  wPeriodMax    DWORD     ?\nTIMECAPS Ends\n\ntimeGetDevCaps PROTO &#58; DWORD, &#58; DWORD\ntimeBeginPeriod PROTO &#58; DWORD\ntimeGetTime PROTO\n\nGetTickCount PROTO\n\nQueryPerformanceCounter PROTO &#58; DWORD\nQueryPerformanceFrequency PROTO &#58; DWORD\nGetLastError PROTO\n\n;********************************************************\n; EQUATES\n;********************************************************\n\nNULL                          EQU     0\n\n;*****************************************************\n; Standard Handles\n;*****************************************************\n\nSTD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle\nSTD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle\nSTD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle\n\n\nGENERIC_ALL                   EQU     10000000h\nGENERIC_READ                  EQU     80000000h\nGENERIC_WRITE                 EQU     40000000h\nGENERIC_EXECUTE               EQU     20000000h\n\nFILE_SHARE_NONE               EQU     0\nFILE_SHARE_DELETE             EQU     4\nFILE_SHARE_READ               EQU     1\nFILE_SHARE_WRITE              EQU     2\n\nCREATE_NEW                    EQU     1\nCREATE_ALWAYS                 EQU     2\nOPEN_EXISTING                 EQU     3\nOPEN_ALWAYS                   EQU     4\nTRUNCATE_EXISTING             EQU     5\n\n\nFILE_ATTRIBUTE_NORMAL         EQU     80h\n\n;*****************************************************\n; Set Console Mode Equates\n;\n; Refer to Microsoft's documentation on SetConsoleMode\n; for a complete description of these equates&#46;\n;*****************************************************\n\nENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options\nENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)\nENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location\nENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;\nENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; \nENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; \nENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  \nENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;\n\n\n;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;\nENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; \nENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;\n\n\n;********************************************************\n; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES\n;********************************************************\n\nFOREGROUND_BLACK              EQU     0\nFOREGROUND_DARK_BLUE          EQU     1\nFOREGROUND_DARK_GREEN         EQU     2\nFOREGROUND_DARK_CYAN          EQU     3\nFOREGROUND_DARK_RED           EQU     4\nFOREGROUND_DARK_MAGENTA       EQU     5\nFOREGROUND_DARK_YELLOW        EQU     6\nFOREGROUND_GRAY               EQU     7\nFOREGROUND_DARK_GRAY          EQU     8\nFOREGROUND_BLUE               EQU     9\nFOREGROUND_GREEN              EQU     10\nFOREGROUND_CYAN               EQU     11\nFOREGROUND_RED                EQU     12\nFOREGROUND_MAGENTA            EQU     13\nFOREGROUND_YELLOW             EQU     14\nFOREGROUND_WHITE              EQU     15\n\nBACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h\nBACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h\nBACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h\nBACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h\nBACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h\nBACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h\nBACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h\nBACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h\nBACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h\nBACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h\nBACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h\nBACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h\nBACKGROUND_RED                EQU     FOREGROUND_RED * 10h\nBACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h\nBACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h\nBACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h\n\n;------------------------------------------------------------------------------\n; Prototypes\n;------------------------------------------------------------------------------\n\nPUBLIC\t_RLE_Encode\n\n;------------------------------------------------------------------------------\n; STACK SIZE\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;STACK 4096\n\t\t\n;------------------------------------------------------------------------------\n; RADIX TYPE\n;------------------------------------------------------------------------------\n\t\t\n; \t\t(placeholder)\n\t\t\n;------------------------------------------------------------------------------\n; DATA SEGMENT (DS)\n;------------------------------------------------------------------------------\n\t\t\n\t\t&#46;DATA\n\t\t\n;*********************\n; EQUATES/ENUMERATORS\n;*********************\n\n; (placeholder)\n\n;***********\n; VARIABLES\n;***********\n\n; (placeholder)\n\n;------------------------------------------------------------------------------\n; CODE SEGMENT (CS)\n;------------------------------------------------------------------------------\n\n\t\t&#46;CODE\n\t\n;************\n; Procedures\n;************\n\npublic _RLE_Encode proc\n\n\tpush\tebp\n\tmov\t\tebp, esp\n\t\n\tpush\tebx\n\tpush\tecx\n\tpush\tedx\n\tpush\tesi\n\tpush\tedi\n\t\n\tmov\t\tesi, &#91;ebp+8&#93;\n\tmov\t\tecx, &#91;ebp+12&#93;\n\tmov\t\tedi, &#91;ebp+16&#93;\t\n\t\n\tlocal Outer_Loop&#58;\n\t\n\tmov\t\tal, &#91;esi&#93;\n\tmov\t\tbl, 01h\n\tinc\t\tesi\n\tdec\t\tecx\n\tcmp\t\tecx, 0\n\tje\t\tSingle_Byte_One\n\t\n\tlocal Inner_Loop&#58;\n\t\n\tmov\t\tdl, &#91;esi&#93;\n\tcmp\t\tal, dl\n\tjne\t\tSingle_Byte_One\n\t\n\tinc\t\tesi\n\tinc\t\tebx\n\tdec\t\tecx\n\t\n\tcmp\t\tbl, 3Fh\n\tje\t\tMultiple_Byte\n\t\n\tcmp\t\tecx, 0\n\tje\t\tMultiple_Byte\n\t\n\tjmp\t\tInner_Loop\n\t\n\tlocal Multiple_Byte&#58;\n\t\n\tor\t\tbl, 0C0h\n\t\n\tmov\t\t&#91;edi&#93;, bl\n\tinc\t\tedi\n\t\n\tmov\t\t&#91;edi&#93;, al\n\tinc\t\tedi\n\t\n\tcmp\t\tecx, 0\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tlocal Single_Byte_Two&#58;\n\n\tmov\t\tbyte ptr &#91;edi&#93;, 0C1h\n\tinc\t\tedi\n\t\n\tmov\t\t&#91;edi&#93;, al\n\tinc\t\tedi\n\t\n\tcmp\t\tecx, 0\n\tje\t\tFinish\n\t\n\tjmp\t\tOuter_Loop\n\t\n\tlocal Single_Byte_One&#58;\n\t\n\tcmp\t\tbl, 01h\n\tjne\t\tMultiple_Byte\n\t\n\tcmp\t\tal, 0Ch\n\tjae\t\tSingle_Byte_Two\n\t\n\tmov\t\t&#91;edi&#93;, al\n\tinc\t\tedi\n\t\n\tcmp\t\tecx, 0\n\tjne\t\tOuter_Loop\n\t\n\tlocal Finish\n\t\n\tmov\t\teax, edi\n\tsub\t\teax, &#91;ebp+16&#93;\n\t\n\tpop\t\tedi\n\tpop\t\tesi\n\tpop\t\tedx\n\tpop\t\tecx\n\tpop\t\tebx\n\t\n\tpop\t\tebp\n\t\t\n\tret\t\t12\n\n_RLE_Encode endp[/code:2t1cace3]",
      "EditableFormat": "bbcode",
      "HTML": "Thank you so much Jay, I was really confused (I had like all the brackets/no brackets backwards, lol), also probably some of my confusion from being so tired, and now I understand it much better and not so confused as I was (I just read too much information, I didn't know whether it applied to what I was doing or not, and this also caused me to be confused with stuff I shouldn't have been confused with).<br/><br/>Sorry, about needing so much help, a lot of this stuff is new to me, so it's been confusing (too much information and not understanding it very well) and difficult for me to get this stuff on my own. Thanks for helping me learn and understand this stuff so much better! Also, being up all day and night working on it and trying to figure it out or understand it, being very tired and sleep derived, doesn't help matters.<br/><br/>----------<br/><br/>some quick questions:<br/><br/>do I need to use the 'local' key-word/command for the labels, and if I do, does this mess up the stack (do I have to account for the displacement of them) ??? I think there's something where if you got looping/nesting/recursion with labels/procedures, you need to use the 'local', else it doesn't work right ???<br/><br/>just want to make sure that this is correct (as I'm not sure if this is how I set it up for the or'ing to work correctly, do I use the same value of 0C0 h or do I need to use different value/binary/bit sequence to properly line it up for the or'ing?): or bl, 0C0h<br/><br/>were you saying that the prototype would just be this: public _RLE_Encode, ???<br/><br/>(also does it matter if I put the key-words/commands on the left side vs the right side, such as with 'public' in the question above, ??? Can I put, using 'public' again as example, after / to the right of, 'proc', or is this right side space, reserved for the 'uses:regs' and/or the 'parameters:data type' )<br/><br/>to go about testing if this works... I presume I'd have to make a (decoded) data file (does this have to be a specific ext or can I just use a *.txt, notepad file?), check the C++ program, figuring out how it works/gets the file (not sure if I can figure out how to get it to be able to find/get/access the file... hmm... I'll have to see if I can figure it out), and then run the C++ program, and seeing if it can link-find-access my asm file, and then if it'll work correctly or not ???<br/><br/>----------------------------<br/><br/>new (corrected) code:<br/><br/><pre><code>;------------------------------------------------------------------------------<br/>; HEADING<br/>;------------------------------------------------------------------------------<br/><br/>; redacted<br/>; Due&#58; 5&#58;00 pm, Wed&#46;, April&#46; 6, 2016<br/><br/>;------------------------------------------------------------------------------<br/>; HISTORY<br/>;------------------------------------------------------------------------------<br/><br/>; Version 1&#46;0<br/><br/>;------------------------------------------------------------------------------<br/>; Credit (those who helped me)<br/>;------------------------------------------------------------------------------<br/><br/>; Online person Jay<br/>; online resources (need to get/paste them here still)<br/>; Colleagues in/from class<br/><br/>;------------------------------------------------------------------------------<br/>; PURPOSE<br/>;------------------------------------------------------------------------------<br/><br/>; The purpose of this program is to encode (compress) a data file&#46;<br/><br/>;------------------------------------------------------------------------------<br/>; MASM BUILD TYPE<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;586<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; MODEL, STANDARD, and Option TYPES<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;MODEL flat, stdcall<br/><br/>\t\toption casemap &#58;none ;makes it case sensitive<br/><br/>;------------------------------------------------------------------------------<br/>; LIBRARIES/MODULES<br/>;------------------------------------------------------------------------------<br/><br/>;I had issues with trying to link to the &quot;win32API&#46;asm&quot; file, (pasted it below)<br/><br/>;********************************************************<br/>; Masm Include File for Windows 32-Bit API Functions<br/>;<br/>; The information contained in this file can be found at<br/>; http&#58;//msdn&#46;microsoft&#46;com/en-us/library/default&#46;aspx<br/>;<br/>;********************************************************<br/><br/>;********************************************************<br/>; WINDOWS API FUNCTION PROTOTYPES<br/>;********************************************************<br/><br/>ExitProcess PROTO &#58; DWORD<br/>GetStdHandle PROTO &#58; DWORD<br/>ReadConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>SetConsoleCursorPosition PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleMode PROTO &#58; DWORD, &#58; DWORD<br/>SetConsoleTextAttribute PROTO &#58; DWORD, &#58; DWORD<br/>WriteConsoleA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>FlushConsoleInputBuffer PROTO &#58; DWORD<br/><br/>CreateThread PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58;  DWORD, &#58; DWORD, &#58; DWORD<br/>CreateMutexA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReleaseMutex PROTO &#58;DWORD<br/>Sleep PROTO &#58; DWORD<br/>WaitForSingleObject PROTO &#58;DWORD,&#58;DWORD<br/>WaitForMultipleObjects PROTO &#58;DWORD,&#58;DWORD, &#58;DWORD, &#58;DWORD<br/>SuspendThread PROTO &#58; DWORD<br/>ResumeThread PROTO &#58; DWORD<br/>ExitThread PROTO &#58; DWORD<br/><br/>CreateFileA PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>ReadFile  PROTO &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD, &#58; DWORD<br/>GetFileSize  PROTO &#58; DWORD, &#58; DWORD<br/>CloseHandle PROTO &#58; DWORD<br/><br/>TIMECAPS Struct<br/>  wPeriodMin    DWORD     ?<br/>  wPeriodMax    DWORD     ?<br/>TIMECAPS Ends<br/><br/>timeGetDevCaps PROTO &#58; DWORD, &#58; DWORD<br/>timeBeginPeriod PROTO &#58; DWORD<br/>timeGetTime PROTO<br/><br/>GetTickCount PROTO<br/><br/>QueryPerformanceCounter PROTO &#58; DWORD<br/>QueryPerformanceFrequency PROTO &#58; DWORD<br/>GetLastError PROTO<br/><br/>;********************************************************<br/>; EQUATES<br/>;********************************************************<br/><br/>NULL                          EQU     0<br/><br/>;*****************************************************<br/>; Standard Handles<br/>;*****************************************************<br/><br/>STD_INPUT_HANDLE              EQU     -10             ;Standard Input Handle<br/>STD_OUTPUT_HANDLE             EQU     -11             ;Standard Output Handle<br/>STD_ERROR_HANDLE              EQU     -12             ;Standard Error Handle<br/><br/><br/>GENERIC_ALL                   EQU     10000000h<br/>GENERIC_READ                  EQU     80000000h<br/>GENERIC_WRITE                 EQU     40000000h<br/>GENERIC_EXECUTE               EQU     20000000h<br/><br/>FILE_SHARE_NONE               EQU     0<br/>FILE_SHARE_DELETE             EQU     4<br/>FILE_SHARE_READ               EQU     1<br/>FILE_SHARE_WRITE              EQU     2<br/><br/>CREATE_NEW                    EQU     1<br/>CREATE_ALWAYS                 EQU     2<br/>OPEN_EXISTING                 EQU     3<br/>OPEN_ALWAYS                   EQU     4<br/>TRUNCATE_EXISTING             EQU     5<br/><br/><br/>FILE_ATTRIBUTE_NORMAL         EQU     80h<br/><br/>;*****************************************************<br/>; Set Console Mode Equates<br/>;<br/>; Refer to Microsoft's documentation on SetConsoleMode<br/>; for a complete description of these equates&#46;<br/>;*****************************************************<br/><br/>ENABLE_NOTHING_INPUT          EQU     0000h           ;Turn off all input options<br/>ENABLE_ECHO_INPUT             EQU     0004h           ;Characters read are written to the active screen buffer (can be used with ENABLE_LINE_INPUT)<br/>ENABLE_INSERT_MODE            EQU     0020h           ;When enabled, text entered in a console window will be inserted at the current cursor location<br/>ENABLE_LINE_INPUT             EQU     0002h           ;The ReadConsole function returns only when a carriage return character is read&#46;<br/>ENABLE_MOUSE_INPUT            EQU     0010h           ;If the mouse is within the borders of the console window &amp; the window has the keyboard focus, mouse events are placed in the input buffer&#46; These events are discarded by ReadFile or ReadConsole&#46; <br/>ENABLE_PROCESSED_INPUT        EQU     0001h           ;CTRL+C is processed by the system and is not placed in the input buffer&#46; <br/>ENABLE_QUICK_EDIT_MODE        EQU     0040h           ;This flag enables the user to use the mouse to select and edit text&#46; To enable this option, use the OR to combine this flag with ENABLE_EXTENDED_FLAGS&#46;  <br/>ENABLE_WINDOW_INPUT           EQU     0008h           ;User interactions that change the size of the console screen buffer are reported in the console's input buffer&#46;<br/><br/><br/>;If the hConsoleHandle parameter is a screen buffer handle, the mode can be one or more of the following values&#46; When a screen buffer is created, both output modes are enabled by default&#46;<br/>ENABLE_PROCESSED_OUTPUT       EQU     0001h           ;Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are examined for ASCII control sequences and the correct action is performed&#46; <br/>ENABLE_WRAP_AT_EOL_OUTPUT     EQU     0002h           ;When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row&#46;<br/><br/><br/>;********************************************************<br/>; CONSOLE FOREGROUND AND BACKGROUND COLOR EQUATES<br/>;********************************************************<br/><br/>FOREGROUND_BLACK              EQU     0<br/>FOREGROUND_DARK_BLUE          EQU     1<br/>FOREGROUND_DARK_GREEN         EQU     2<br/>FOREGROUND_DARK_CYAN          EQU     3<br/>FOREGROUND_DARK_RED           EQU     4<br/>FOREGROUND_DARK_MAGENTA       EQU     5<br/>FOREGROUND_DARK_YELLOW        EQU     6<br/>FOREGROUND_GRAY               EQU     7<br/>FOREGROUND_DARK_GRAY          EQU     8<br/>FOREGROUND_BLUE               EQU     9<br/>FOREGROUND_GREEN              EQU     10<br/>FOREGROUND_CYAN               EQU     11<br/>FOREGROUND_RED                EQU     12<br/>FOREGROUND_MAGENTA            EQU     13<br/>FOREGROUND_YELLOW             EQU     14<br/>FOREGROUND_WHITE              EQU     15<br/><br/>BACKGROUND_BLACK              EQU     FOREGROUND_BLACK * 10h<br/>BACKGROUND_DARK_BLUE          EQU     FOREGROUND_DARK_BLUE * 10h<br/>BACKGROUND_DARK_GREEN         EQU     FOREGROUND_DARK_GREEN * 10h<br/>BACKGROUND_DARK_CYAN          EQU     FOREGROUND_DARK_CYAN * 10h<br/>BACKGROUND_DARK_RED           EQU     FOREGROUND_DARK_RED * 10h<br/>BACKGROUND_DARK_MAGENTA       EQU     FOREGROUND_DARK_MAGENTA * 10h<br/>BACKGROUND_DARK_YELLOW        EQU     FOREGROUND_DARK_YELLOW * 10h<br/>BACKGROUND_GRAY               EQU     FOREGROUND_GRAY * 10h<br/>BACKGROUND_DARK_GRAY          EQU     FOREGROUND_DARK_GRAY * 10h<br/>BACKGROUND_BLUE               EQU     FOREGROUND_BLUE * 10h<br/>BACKGROUND_GREEN              EQU     FOREGROUND_GREEN * 10h<br/>BACKGROUND_CYAN               EQU     FOREGROUND_CYAN * 10h<br/>BACKGROUND_RED                EQU     FOREGROUND_RED * 10h<br/>BACKGROUND_MAGENTA            EQU     FOREGROUND_MAGENTA * 10h<br/>BACKGROUND_YELLOW             EQU     FOREGROUND_YELLOW * 10h<br/>BACKGROUND_WHITE              EQU     FOREGROUND_WHITE * 10h<br/><br/>;------------------------------------------------------------------------------<br/>; Prototypes<br/>;------------------------------------------------------------------------------<br/><br/>PUBLIC\t_RLE_Encode<br/><br/>;------------------------------------------------------------------------------<br/>; STACK SIZE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;STACK 4096<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; RADIX TYPE<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>; \t\t(placeholder)<br/>\t\t<br/>;------------------------------------------------------------------------------<br/>; DATA SEGMENT (DS)<br/>;------------------------------------------------------------------------------<br/>\t\t<br/>\t\t&#46;DATA<br/>\t\t<br/>;*********************<br/>; EQUATES/ENUMERATORS<br/>;*********************<br/><br/>; (placeholder)<br/><br/>;***********<br/>; VARIABLES<br/>;***********<br/><br/>; (placeholder)<br/><br/>;------------------------------------------------------------------------------<br/>; CODE SEGMENT (CS)<br/>;------------------------------------------------------------------------------<br/><br/>\t\t&#46;CODE<br/>\t<br/>;************<br/>; Procedures<br/>;************<br/><br/>public _RLE_Encode proc<br/><br/>\tpush\tebp<br/>\tmov\t\tebp, esp<br/>\t<br/>\tpush\tebx<br/>\tpush\tecx<br/>\tpush\tedx<br/>\tpush\tesi<br/>\tpush\tedi<br/>\t<br/>\tmov\t\tesi, &#91;ebp+8&#93;<br/>\tmov\t\tecx, &#91;ebp+12&#93;<br/>\tmov\t\tedi, &#91;ebp+16&#93;\t<br/>\t<br/>\tlocal Outer_Loop&#58;<br/>\t<br/>\tmov\t\tal, &#91;esi&#93;<br/>\tmov\t\tbl, 01h<br/>\tinc\t\tesi<br/>\tdec\t\tecx<br/>\tcmp\t\tecx, 0<br/>\tje\t\tSingle_Byte_One<br/>\t<br/>\tlocal Inner_Loop&#58;<br/>\t<br/>\tmov\t\tdl, &#91;esi&#93;<br/>\tcmp\t\tal, dl<br/>\tjne\t\tSingle_Byte_One<br/>\t<br/>\tinc\t\tesi<br/>\tinc\t\tebx<br/>\tdec\t\tecx<br/>\t<br/>\tcmp\t\tbl, 3Fh<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tecx, 0<br/>\tje\t\tMultiple_Byte<br/>\t<br/>\tjmp\t\tInner_Loop<br/>\t<br/>\tlocal Multiple_Byte&#58;<br/>\t<br/>\tor\t\tbl, 0C0h<br/>\t<br/>\tmov\t\t&#91;edi&#93;, bl<br/>\tinc\t\tedi<br/>\t<br/>\tmov\t\t&#91;edi&#93;, al<br/>\tinc\t\tedi<br/>\t<br/>\tcmp\t\tecx, 0<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tlocal Single_Byte_Two&#58;<br/><br/>\tmov\t\tbyte ptr &#91;edi&#93;, 0C1h<br/>\tinc\t\tedi<br/>\t<br/>\tmov\t\t&#91;edi&#93;, al<br/>\tinc\t\tedi<br/>\t<br/>\tcmp\t\tecx, 0<br/>\tje\t\tFinish<br/>\t<br/>\tjmp\t\tOuter_Loop<br/>\t<br/>\tlocal Single_Byte_One&#58;<br/>\t<br/>\tcmp\t\tbl, 01h<br/>\tjne\t\tMultiple_Byte<br/>\t<br/>\tcmp\t\tal, 0Ch<br/>\tjae\t\tSingle_Byte_Two<br/>\t<br/>\tmov\t\t&#91;edi&#93;, al<br/>\tinc\t\tedi<br/>\t<br/>\tcmp\t\tecx, 0<br/>\tjne\t\tOuter_Loop<br/>\t<br/>\tlocal Finish<br/>\t<br/>\tmov\t\teax, edi<br/>\tsub\t\teax, &#91;ebp+16&#93;<br/>\t<br/>\tpop\t\tedi<br/>\tpop\t\tesi<br/>\tpop\t\tedx<br/>\tpop\t\tecx<br/>\tpop\t\tebx<br/>\t<br/>\tpop\t\tebp<br/>\t\t<br/>\tret\t\t12<br/><br/>_RLE_Encode endp</code></pre>",
      "PostDate": "2016-04-05T15:19:10+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42106",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "also one more question:\n\nabout the 'stdcall' convention, I think this is the default (if you don't specify one), but I'm not sure if I'm using it or not with regards to this being called through C++, so I'm not sure whether I need to do:\n\npush ebp\nmov ebp, esp\nmov esi, [ebp+8]\nmov ecx, [ebp+12]\nmov edi, [ebp+16]\n\nor\n\npush ebp\nmov ebp, esp\nmov edi, [ebp+16]\nmov ecx, [ebp+12]\nmov esi, [ebp+8]\n\n(are both of these ways' order, correct? just want to make sure I understand if I'm doing them right)",
      "EditableFormat": "bbcode",
      "HTML": "also one more question:<br/><br/>about the 'stdcall' convention, I think this is the default (if you don't specify one), but I'm not sure if I'm using it or not with regards to this being called through C++, so I'm not sure whether I need to do:<br/><br/>push ebp<br/>mov ebp, esp<br/>mov esi, [ebp+8]<br/>mov ecx, [ebp+12]<br/>mov edi, [ebp+16]<br/><br/>or<br/><br/>push ebp<br/>mov ebp, esp<br/>mov edi, [ebp+16]<br/>mov ecx, [ebp+12]<br/>mov esi, [ebp+8]<br/><br/>(are both of these ways' order, correct? just want to make sure I understand if I'm doing them right)",
      "PostDate": "2016-04-05T15:43:30+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42107",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "First of all, the two code snippets are functionally the same. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You would need to load a different register from a different offset (reversed).\n\nBut if it were stdcall, then you would indeed need it to be:\n\npush ebp\nmov ebp, esp\nmov esi, [ebp+16]\nmov ecx, [ebp+12]\nmov edi, [ebp+8]\n\n(I know I haven't answered your other post yet. This was a quick one at work.)",
      "EditableFormat": "bbcode",
      "HTML": "First of all, the two code snippets are functionally the same. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> You would need to load a different register from a different offset (reversed).<br/><br/>But if it were stdcall, then you would indeed need it to be:<br/><br/>push ebp<br/>mov ebp, esp<br/>mov esi, [ebp+16]<br/>mov ecx, [ebp+12]<br/>mov edi, [ebp+8]<br/><br/>(I know I haven't answered your other post yet. This was a quick one at work.)",
      "PostDate": "2016-04-05T16:04:21+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42108",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Also, is this C++ or C?",
      "EditableFormat": "bbcode",
      "HTML": "Also, is this C++ or C?",
      "PostDate": "2016-04-05T16:04:48+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42109",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "As far as a test goes, you don't even need to get as complex as an external file. You can just set up a C array of (unsigned) char with whatever values you want and then pass that in with the size. Just be sure to allocate enough space for the encoded data to go into (the worst possible &quot;compression&quot; would be a doubling of the non-encoded data, so you should probably make your target buffer that big to be sure).",
      "EditableFormat": "bbcode",
      "HTML": "As far as a test goes, you don't even need to get as complex as an external file. You can just set up a C array of (unsigned) char with whatever values you want and then pass that in with the size. Just be sure to allocate enough space for the encoded data to go into (the worst possible &quot;compression&quot; would be a doubling of the non-encoded data, so you should probably make your target buffer that big to be sure).",
      "PostDate": "2016-04-05T16:11:05+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42110",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "C++ program, thankfully, as... I've not yet learned (nor worked with) C yet at all",
      "EditableFormat": "bbcode",
      "HTML": "C++ program, thankfully, as... I've not yet learned (nor worked with) C yet at all",
      "PostDate": "2016-04-05T18:54:54+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42111",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Then definitely put \n\nextern &quot;C&quot;\n\nwhen you declare your function in the cpp file. C++ name mangling is not something you want to have to deal with!",
      "EditableFormat": "bbcode",
      "HTML": "Then definitely put <br/><br/>extern &quot;C&quot;<br/><br/>when you declare your function in the cpp file. C++ name mangling is not something you want to have to deal with!",
      "PostDate": "2016-04-05T19:14:30+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42122",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "It's not able to link, sighs. Something is wrong in my asm file... no idea how/what to change/fix up so it works...\n\nany chance, you got any ideas ???\n\n--------------\n\ngot some more comments by my colleagues:\n\n&quot;\nSo I found out while working on the project that if you don't have any local variables in your procedure, that the assembler/compiler won't set up a stack frame for your procedure. That means that you need to access your parameters in different ways depending on if you use local variables or not. If you use local variables then you access your parameters with [ebp + 4] then adding the size of the datatype. However, if you don't have local variables then you have to access your variables from esp with some weird offsets. \n\nWhy is this? If you have parameters shouldn't a stack frame be set up so that you always access your parameters in the same way?\n(redacted)\n&quot;\n\n&quot;\nWhat an amazing discovery. Well just thinking about it, the reason why this might happen is because the compiler will allocate extra memory in the stack when you allocate for local variables. Because of this, when you call a procedure that has no local variables, ebp does not change at all! So, if you try to access ebp you are really looking at the ebp from the calling environment. Since this is so, esp is the only pointer that is close enough to touch the pushed parameters. \n\nI discovered this just by messing around on visual studio, so it might need fact checking.\n(redacted)\n&quot;\n\n---------------\n\nthe assignment brief does have this:\n\nthe function prototype for the RLE procedure is:\n\ndword RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf)\n\nshould I go and put this in, instead of:\n\npublic RLE_Encode proto\n\nwhat about for the actual procedure definition header ???",
      "EditableFormat": "bbcode",
      "HTML": "It's not able to link, sighs. Something is wrong in my asm file... no idea how/what to change/fix up so it works...<br/><br/>any chance, you got any ideas ???<br/><br/>--------------<br/><br/>got some more comments by my colleagues:<br/><br/>&quot;<br/>So I found out while working on the project that if you don't have any local variables in your procedure, that the assembler/compiler won't set up a stack frame for your procedure. That means that you need to access your parameters in different ways depending on if you use local variables or not. If you use local variables then you access your parameters with [ebp + 4] then adding the size of the datatype. However, if you don't have local variables then you have to access your variables from esp with some weird offsets. <br/><br/>Why is this? If you have parameters shouldn't a stack frame be set up so that you always access your parameters in the same way?<br/>(redacted)<br/>&quot;<br/><br/>&quot;<br/>What an amazing discovery. Well just thinking about it, the reason why this might happen is because the compiler will allocate extra memory in the stack when you allocate for local variables. Because of this, when you call a procedure that has no local variables, ebp does not change at all! So, if you try to access ebp you are really looking at the ebp from the calling environment. Since this is so, esp is the only pointer that is close enough to touch the pushed parameters. <br/><br/>I discovered this just by messing around on visual studio, so it might need fact checking.<br/>(redacted)<br/>&quot;<br/><br/>---------------<br/><br/>the assignment brief does have this:<br/><br/>the function prototype for the RLE procedure is:<br/><br/>dword RLE_Encode (char *InputBuf, dword InputLength, char *OutputBuf)<br/><br/>should I go and put this in, instead of:<br/><br/>public RLE_Encode proto<br/><br/>what about for the actual procedure definition header ???",
      "PostDate": "2016-04-06T20:19:47+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42124",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "When it doesn't link, it should tell you what it can't find. The name it can't find is the name you need your proc to be called. If you could post the actual error message, it would help.\n\nNeither of the comments by colleagues make sense to me, sadly. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> For the first one, local variables are accessed differently, and they don't impact ebp. You had a question before about adjusting esp, and that's how they come into play. So if you needed 20 bytes of local space (say, for 5 vars), then you'd do:\n\npush ebp\nmov ebp, esp\nsub esp, 20      ; set aside 20 bytes of stack space. You'd have to free it later by adding 20 back to esp (I think).\n\nBut that doesn't impact ebp or the way you access incoming parameters. It *does* mean you'd have a different way of accessing the *local*, which you can access either by going positive from esp or negative from ebp. Fortunately, you're not using any of that.\n\nFor the second comment, it doesn't make any sense. They'd have to look at the actual generated assembly code to see what it's doing. There are too many variables at play here to know definitely what's going on.\n\nThe prototype you have is the one that would be in the C++ file, I think. Except it really should be:\n\nextern &quot;C&quot; DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);\n\nGiven that you're not supposed to use the built-in inter-language stuff, I don't know why you'd need to put a prototype in the asm file. And you need the &quot;extern &quot;C&quot;&quot; so that it uses the simpler C-style name decoration, not the C++ one. Again, if you can put the link error here, I should be able to tell what's going on, as in what it's looking for.\n\nEither way, I doubt it will just be &quot;RLE_Encode&quot;. It could be _RLE_Encode for a cdecl function. It will be worse for others. (The page I linked to before shows how different calling conventions decorate the function names.)",
      "EditableFormat": "bbcode",
      "HTML": "When it doesn't link, it should tell you what it can't find. The name it can't find is the name you need your proc to be called. If you could post the actual error message, it would help.<br/><br/>Neither of the comments by colleagues make sense to me, sadly. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> For the first one, local variables are accessed differently, and they don't impact ebp. You had a question before about adjusting esp, and that's how they come into play. So if you needed 20 bytes of local space (say, for 5 vars), then you'd do:<br/><br/>push ebp<br/>mov ebp, esp<br/>sub esp, 20      ; set aside 20 bytes of stack space. You'd have to free it later by adding 20 back to esp (I think).<br/><br/>But that doesn't impact ebp or the way you access incoming parameters. It *does* mean you'd have a different way of accessing the *local*, which you can access either by going positive from esp or negative from ebp. Fortunately, you're not using any of that.<br/><br/>For the second comment, it doesn't make any sense. They'd have to look at the actual generated assembly code to see what it's doing. There are too many variables at play here to know definitely what's going on.<br/><br/>The prototype you have is the one that would be in the C++ file, I think. Except it really should be:<br/><br/>extern &quot;C&quot; DWORD RLE_Encode (char *InputBuf, DWORD InputLength, char *OutputBuf);<br/><br/>Given that you're not supposed to use the built-in inter-language stuff, I don't know why you'd need to put a prototype in the asm file. And you need the &quot;extern &quot;C&quot;&quot; so that it uses the simpler C-style name decoration, not the C++ one. Again, if you can put the link error here, I should be able to tell what's going on, as in what it's looking for.<br/><br/>Either way, I doubt it will just be &quot;RLE_Encode&quot;. It could be _RLE_Encode for a cdecl function. It will be worse for others. (The page I linked to before shows how different calling conventions decorate the function names.)",
      "PostDate": "2016-04-06T22:41:27+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42126",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "hmm.. it just says:\n\nit can't find the file 'RLE_Encode', *\nLNK 2019 unresolved external symbol _RLE_Encode referenced in function _main\nLNK 1120 1 unresolved externals\n\n*which I have the file named that (though not sure if my C++ is even set up right for it, is there any setting changes that I need to make?) and it's inside of the same VS folder as the c++ source file. If I change to the underscore in front of it, do I need to change the asm file name to using the underscore, do I need to change the 'extern' code line to using the underscore also, do I change the prototype to using the underscore, do I change the procedure definition to using the underscore?\n\ninside the given C++ file they have this:\n\nextern &quot;C&quot; int RLE_Encode (char *, int, char *);",
      "EditableFormat": "bbcode",
      "HTML": "hmm.. it just says:<br/><br/>it can't find the file 'RLE_Encode', *<br/>LNK 2019 unresolved external symbol _RLE_Encode referenced in function _main<br/>LNK 1120 1 unresolved externals<br/><br/>*which I have the file named that (though not sure if my C++ is even set up right for it, is there any setting changes that I need to make?) and it's inside of the same VS folder as the c++ source file. If I change to the underscore in front of it, do I need to change the asm file name to using the underscore, do I need to change the 'extern' code line to using the underscore also, do I change the prototype to using the underscore, do I change the procedure definition to using the underscore?<br/><br/>inside the given C++ file they have this:<br/><br/>extern &quot;C&quot; int RLE_Encode (char *, int, char *);",
      "PostDate": "2016-04-06T23:44:38+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42130",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "[quote:3c56gar8]hmm.. it just says:\n\nit can't find the file 'RLE_Encode', *\nLNK 2019 unresolved external symbol _RLE_Encode referenced in function _main\nLNK 1120 1 unresolved externals[/quote:3c56gar8]\nI don't think the linker says, &quot;it can't find the file 'RLE_Encode', *&quot; (I've never seen a linker with the word &quot;it&quot; before. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> ) Is that something you added or paraphrased? I hope I'm not seeming nit picky, but the exact error(s) you get is important.\n\nIt definitely can't find the symbol &quot;_RLE_Encode&quot;. So you need to name your proc exactly &quot;_RLE_Encode&quot; (not quote and with leading underscore).\n\nIf it also is complaining about not being to find a file, then you might not be giving the right name or path when linking, so it can find your .obj file. From the above, I can't tell if you're getting one error (unresolved symbol) or two (file not found *and* unresolved symbol). If it's the former, then you just hopefully need to name the function correctly. If it's the latter, then it can't find the symbol *because* it can't find the file, which means you need to specify how it can find the file correctly as well.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><p>hmm.. it just says:<br/><br/>it can't find the file 'RLE_Encode', *<br/>LNK 2019 unresolved external symbol _RLE_Encode referenced in function _main<br/>LNK 1120 1 unresolved externals</p></blockquote><br/>I don't think the linker says, &quot;it can't find the file 'RLE_Encode', *&quot; (I've never seen a linker with the word &quot;it&quot; before. <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) --> ) Is that something you added or paraphrased? I hope I'm not seeming nit picky, but the exact error(s) you get is important.<br/><br/>It definitely can't find the symbol &quot;_RLE_Encode&quot;. So you need to name your proc exactly &quot;_RLE_Encode&quot; (not quote and with leading underscore).<br/><br/>If it also is complaining about not being to find a file, then you might not be giving the right name or path when linking, so it can find your .obj file. From the above, I can't tell if you're getting one error (unresolved symbol) or two (file not found *and* unresolved symbol). If it's the former, then you just hopefully need to name the function correctly. If it's the latter, then it can't find the symbol *because* it can't find the file, which means you need to specify how it can find the file correctly as well.",
      "PostDate": "2016-04-07T07:07:09+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42133",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "ah, so it is dependant also upon me setting up VS correctly too... I wasn't able to figure this out yet... hopefully my code works, and it's just not having the VS set up to be able to find/link my asm file, but maybe there's still an issue with my asm file code too.\n\nI matched it's name correctly (underscore), and yes, that was me paraphrasing, though it does say &quot;file not found&quot; (error message upon trying to run the C++ file), so that part is not paraphrasing, but my use of &quot;it&quot;, was definately part of my paraphrasing, lol.",
      "EditableFormat": "bbcode",
      "HTML": "ah, so it is dependant also upon me setting up VS correctly too... I wasn't able to figure this out yet... hopefully my code works, and it's just not having the VS set up to be able to find/link my asm file, but maybe there's still an issue with my asm file code too.<br/><br/>I matched it's name correctly (underscore), and yes, that was me paraphrasing, though it does say &quot;file not found&quot; (error message upon trying to run the C++ file), so that part is not paraphrasing, but my use of &quot;it&quot;, was definately part of my paraphrasing, lol.",
      "PostDate": "2016-04-07T09:18:07+01:00",
      "LastEditDate": null
    },
    {
      "PostId": "42134",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "Can you give the exact error message? It might have a clue.",
      "EditableFormat": "bbcode",
      "HTML": "Can you give the exact error message? It might have a clue.",
      "PostDate": "2016-04-07T10:59:57+01:00",
      "LastEditDate": null
    }
  ]
}
