{
  "Topic": {
    "TopicId": "5749",
    "ForumId": "10",
    "Title": "Do, Invoke, While vs Recursion",
    "LastUpdated": "2015-12-25T07:11:30+00:00",
    "ReplyCount": 5
  },
  "Posts": [
    {
      "PostId": "39796",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "(Since I'm currently between school symesters, I'm trying to get back into quest and progressing towards making a game)\n\nIn trying to avoid using recursion (as it piles up memory usage), and the issues with the 'while' Function's looping not waiting for its scripts to finish first, and thus the conflict with the 'get input ~ show menu', is the 'do~invoke' Scripts~Functions, an alternative?\n\nHow does the 'do~invoke' work in terms of memory usage? Are they Functions, and thus use recursion, being no different than all other Functions? Or, are they Method (Script Attribute) calls, which don't use recursion, and are like the looping programming, which doesn't use as much memory as recursion?\n\nOtherwise, it seems that Pixie's roundabout method of using a second 'if' check is the only way to avoid recursive Functions? (or, are there any other alternative methods?)\n\n------------------\n\noff-topic (question on deeper understanding~knowledge in programming on memory and operation efficiencies):\n\nI wasn't able to get around to asking my programming professors~teachers, on how~why looping (do, do-while, for, foreach, etc) works in not wasting up (at least as much) memory, as recursion does. Don't loops have to store~save~preserve data like recursive Functions, thus piling up memory in the stack?\n\nAlso, in terms of operation efficiency (more ambigious ~ situational question, I know), is recursion better or are loops better? How much extra operations are occuring in terms of looping vs recursion vs how many variables and other assignment~whatever etc operations you're doing, if it's possible to give a generalized repsonse~answer on this type of stuff, of course.\n\nI will hopefully be learning more about all of this stuff in my continuing programming classes, but I'd like to get a bit of a head-start of a basic understanding in memory and operation efficiencies and their workings, so I can start to begin to program much better.",
      "EditableFormat": "bbcode",
      "HTML": "(Since I'm currently between school symesters, I'm trying to get back into quest and progressing towards making a game)<br/><br/>In trying to avoid using recursion (as it piles up memory usage), and the issues with the 'while' Function's looping not waiting for its scripts to finish first, and thus the conflict with the 'get input ~ show menu', is the 'do~invoke' Scripts~Functions, an alternative?<br/><br/>How does the 'do~invoke' work in terms of memory usage? Are they Functions, and thus use recursion, being no different than all other Functions? Or, are they Method (Script Attribute) calls, which don't use recursion, and are like the looping programming, which doesn't use as much memory as recursion?<br/><br/>Otherwise, it seems that Pixie's roundabout method of using a second 'if' check is the only way to avoid recursive Functions? (or, are there any other alternative methods?)<br/><br/>------------------<br/><br/>off-topic (question on deeper understanding~knowledge in programming on memory and operation efficiencies):<br/><br/>I wasn't able to get around to asking my programming professors~teachers, on how~why looping (do, do-while, for, foreach, etc) works in not wasting up (at least as much) memory, as recursion does. Don't loops have to store~save~preserve data like recursive Functions, thus piling up memory in the stack?<br/><br/>Also, in terms of operation efficiency (more ambigious ~ situational question, I know), is recursion better or are loops better? How much extra operations are occuring in terms of looping vs recursion vs how many variables and other assignment~whatever etc operations you're doing, if it's possible to give a generalized repsonse~answer on this type of stuff, of course.<br/><br/>I will hopefully be learning more about all of this stuff in my continuing programming classes, but I'd like to get a bit of a head-start of a basic understanding in memory and operation efficiencies and their workings, so I can start to begin to program much better.",
      "PostDate": "2015-12-20T03:36:06+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "39797",
      "UserId": 0,
      "Username": "george",
      "UserAvatar": null,
      "UserGravatar": "dc6fe8e6172303d85249a13c9a49c1ff",
      "EditableText": "HK, I don't know the answer to the first part of your question but for your off-topic question, this may help:\n\n<!-- m --><a class=\"postlink\" href=\"http://stackoverflow.com/questions/310974/what-is-tail-call-optimization\">http://stackoverflow.com/questions/3109 ... timization</a><!-- m -->\n\nThe top answer explains it well. \n\nIf you don't have tail-call optimization in your language of choice or a similar solution recursion can be very inefficient.",
      "EditableFormat": "bbcode",
      "HTML": "HK, I don't know the answer to the first part of your question but for your off-topic question, this may help:<br/><br/><!-- m --><a class=\"postlink\" href=\"http://stackoverflow.com/questions/310974/what-is-tail-call-optimization\">http://stackoverflow.com/questions/3109 ... timization</a><!-- m --><br/><br/>The top answer explains it well. <br/><br/>If you don't have tail-call optimization in your language of choice or a similar solution recursion can be very inefficient.",
      "PostDate": "2015-12-20T03:44:53+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "39798",
      "UserId": 0,
      "Username": "The Pixie",
      "UserAvatar": null,
      "UserGravatar": "cfa37e927f96177bcf6053ae8f108f77",
      "EditableText": "[quote=&quot;HegemonKhan&quot;:2as4l7lr](Since I'm currently between school symesters, I'm trying to get back into quest and progressing towards making a game)\n\nIn trying to avoid using recursion (as it piles up memory usage), and the issues with the 'while' Function's looping not waiting for its scripts to finish first, and thus the conflict with the 'get input ~ show menu', is the 'do~invoke' Scripts~Functions, an alternative?[/quote:2as4l7lr]\nDo you have any evidence that you are running out of memory? How many layers of recursion do you anticipate?\n\nI have helped Neonayon with the same thing and he (she?) has about twenty questions, and that seems to work fine as far as I can tell. A general solution is here:\n<!-- l --><a class=\"postlink-local\" href=\"http://forum.textadventures.co.uk/viewtopic.php?f=18&amp;t=5492\">viewtopic.php?f=18&amp;t=5492</a><!-- l -->\n\nAn alternative would be to use the &quot;on ready&quot; script command - as long as you are not using ShowMenu (it does not wait for ShowMenu).\n[quote:2as4l7lr]How does the 'do~invoke' work in terms of memory usage? Are they Functions, and thus use recursion, being no different than all other Functions? Or, are they Method (Script Attribute) calls, which don't use recursion, and are like the looping programming, which doesn't use as much memory as recursion?[/quote:2as4l7lr]\nI guess &quot;do&quot; uses more memory than &quot;invoke&quot; as it also has &quot;this&quot; stored somewhere. Functions possibly use more as they have parameters (assuming you are not using delegates or dictionaries with the script). If you are having memory problems, try them and test it. Otherwise, I would not worry about it.\n[quote:2as4l7lr]I wasn't able to get around to asking my programming professors~teachers, on how~why looping (do, do-while, for, foreach, etc) works in not wasting up (at least as much) memory, as recursion does. Don't loops have to store~save~preserve data like recursive Functions, thus piling up memory in the stack?[/quote:2as4l7lr]\nEach time you call a function it gets added to the stack (Quest has to know what called the function so it can jump back there after it terminates). Recursion is calling the function from itself, so each time you do that the stack will get bigger.\n\nLoops also add to the stack, again Quest needs to know where the loop started. But that is a one off. If you loop a million times you still only get that one-off addition to the stack. Call a function recursively a million times and the stack will increase a million times.\n\nThe amount the stack increases each time should only be a few bytes (I guess), so even a hundred calls of your recursive function would only add about 1kb to the stack. I doubt that would impact on modern computers, with typically a few million kb of RAM (i.e. 1-8 Gb), \n[quote:2as4l7lr]Also, in terms of operation efficiency (more ambigious ~ situational question, I know), is recursion better or are loops better? How much extra operations are occuring in terms of looping vs recursion vs how many variables and other assignment~whatever etc operations you're doing, if it's possible to give a generalized repsonse~answer on this type of stuff, of course.[/quote:2as4l7lr]\nRecursion gives you a shorter code, which is generally a good thing.\n\nIf you have a few thousand iterations you might possibly see a diference, but I doubt it. If you are asking a question at each step, it will take longer for the question to get sent to the player than for the code to run that step. There is no way the player will notice any difference, even playing off-line.",
      "EditableFormat": "bbcode",
      "HTML": "<blockquote><cite>HegemonKhan wrote:</cite>(Since I'm currently between school symesters, I'm trying to get back into quest and progressing towards making a game)<br/><br/>In trying to avoid using recursion (as it piles up memory usage), and the issues with the 'while' Function's looping not waiting for its scripts to finish first, and thus the conflict with the 'get input ~ show menu', is the 'do~invoke' Scripts~Functions, an alternative?</blockquote><br/>Do you have any evidence that you are running out of memory? How many layers of recursion do you anticipate?<br/><br/>I have helped Neonayon with the same thing and he (she?) has about twenty questions, and that seems to work fine as far as I can tell. A general solution is here:<br/><!-- l --><a class=\"postlink-local\" href=\"http://forum.textadventures.co.uk/viewtopic.php?f=18&amp;t=5492\">viewtopic.php?f=18&amp;t=5492</a><!-- l --><br/><br/>An alternative would be to use the &quot;on ready&quot; script command - as long as you are not using ShowMenu (it does not wait for ShowMenu).<br/><blockquote><p>How does the 'do~invoke' work in terms of memory usage? Are they Functions, and thus use recursion, being no different than all other Functions? Or, are they Method (Script Attribute) calls, which don't use recursion, and are like the looping programming, which doesn't use as much memory as recursion?</p></blockquote><br/>I guess &quot;do&quot; uses more memory than &quot;invoke&quot; as it also has &quot;this&quot; stored somewhere. Functions possibly use more as they have parameters (assuming you are not using delegates or dictionaries with the script). If you are having memory problems, try them and test it. Otherwise, I would not worry about it.<br/><blockquote><p>I wasn't able to get around to asking my programming professors~teachers, on how~why looping (do, do-while, for, foreach, etc) works in not wasting up (at least as much) memory, as recursion does. Don't loops have to store~save~preserve data like recursive Functions, thus piling up memory in the stack?</p></blockquote><br/>Each time you call a function it gets added to the stack (Quest has to know what called the function so it can jump back there after it terminates). Recursion is calling the function from itself, so each time you do that the stack will get bigger.<br/><br/>Loops also add to the stack, again Quest needs to know where the loop started. But that is a one off. If you loop a million times you still only get that one-off addition to the stack. Call a function recursively a million times and the stack will increase a million times.<br/><br/>The amount the stack increases each time should only be a few bytes (I guess), so even a hundred calls of your recursive function would only add about 1kb to the stack. I doubt that would impact on modern computers, with typically a few million kb of RAM (i.e. 1-8 Gb), <br/><blockquote><p>Also, in terms of operation efficiency (more ambigious ~ situational question, I know), is recursion better or are loops better? How much extra operations are occuring in terms of looping vs recursion vs how many variables and other assignment~whatever etc operations you're doing, if it's possible to give a generalized repsonse~answer on this type of stuff, of course.</p></blockquote><br/>Recursion gives you a shorter code, which is generally a good thing.<br/><br/>If you have a few thousand iterations you might possibly see a diference, but I doubt it. If you are asking a question at each step, it will take longer for the question to get sent to the player than for the code to run that step. There is no way the player will notice any difference, even playing off-line.",
      "PostDate": "2015-12-20T08:58:47+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "39803",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "a BIG THANK YOU to George and Pixie! A ton of wealth of information.. albiet I really jumped into a can of worms... SOOOO MUUUUCH INFORMATION that I know nothing about in regards to programming, I've got a lot of stuff to try to learn, laughs...\n\n(if only I could understand all of it easily, laughs. I'm still struggling with basic recursion and thus I'm struggling to make sense of &quot;tail-recursion&quot; and I'm not familiar with this 'Scheme' syntax, as I get what recursion is doing in it &quot;drilling down&quot; to the base case and then it has to &quot;drill back up&quot; to finish off each stack-layer of the called functions, but my brain just still has trouble with actually doing~using~applying~implementing it successfully, sighs)\n\nI failed to solve how to do this on my Java final (had to use recursion to solve it):\n\n[code:3qtwqxfg]    * \n   * * \n  * * * \n * * * * \n  * * * \n   * * \n    * [/code:3qtwqxfg]\n\nwe had code to study for this:\n\n[code:3qtwqxfg] * * * * \n  * * * \n   * * \n    * \n   * * \n  * * * \n * * * * [/code:3qtwqxfg]\n\nbut, that didn't help me at all, in solving the other pattern, sighs. My brain just isn't trained in recursion's &quot;drilling down to base case and then drilling back up to each function call layer to finish each of them off&quot;.\n\n-------------------------------------------------------------------------\n\n@ Pixie:\n\n--\n\nOh, this isn't about any specific issues in terms of memory or performance that have been issues with a game (I've not made any significant progress on a game of my own, lol), just asking about this stuff for in-general better code design, since now I'm at least aware of all of this stuff of programming, lol.\n\n----\n\nyes, I've been reading every post of~between neonayon and you, hehe. As she's making a RPG, as I'm interested in doing too, so her questions, are my questions, and your answers help me, as they do her. I've just not had the time to post due to school, but I've been lurking~reading both of your posts.\n\n----\n\nI actually was trying~testing to see if 'on ready' would work... I found out that you don't want to do:\n\nwhile -&gt; on ready -&gt; get input\n\nI haven't tried doing though:\n\nwhile -&gt; if ~ firsttime -&gt; get input\nwhile -&gt; else ~ otherwise -&gt; on ready -&gt; get input\n\nalso, found out with the 'while', that it ends (totally nullifies the looping of) the while loop (as the while loop indeed doesn't wait for other actions at all ~ which makes it very hard to work with), via trying this:\n\nflag = true -&gt; while (flag) -&gt; flag = false -&gt; get input -&gt; else (flag = true)\n\n---\n\nah, so data gets piled up in the stack regardless of iteration~looping (do, do-while, for, foreach, etc) vs recursion, but since recursion (unless able to use 'tail-end' recursion) multiplies these layers of data due to having to &quot;drill back up&quot; (finishing off all of the layers of function calls), whereas iteration doesn't do this as its always only &quot;one off&quot; as you used.\n\n---\n\nhmm, how about in general with the programming languages, how do Method calls (Object.Method) work? do they use iteration or recursion?\n\nfurther (fake and uber poor) psuedocode example:\n\n(wow, I've already forgotten everything I know in C++, Java, and Python, laughs. I've only been done with finals for 3-4 days now!)\n\n[code:3qtwqxfg]class Math {\n  addition (a, b) {\n    sum = a + b\n    math&#46;addition ( (sum + a), (sum+b) )\n    // ignore its infinite looping issue\n    msg (sum)\n  }\n}[/code:3qtwqxfg]",
      "EditableFormat": "bbcode",
      "HTML": "a BIG THANK YOU to George and Pixie! A ton of wealth of information.. albiet I really jumped into a can of worms... SOOOO MUUUUCH INFORMATION that I know nothing about in regards to programming, I've got a lot of stuff to try to learn, laughs...<br/><br/>(if only I could understand all of it easily, laughs. I'm still struggling with basic recursion and thus I'm struggling to make sense of &quot;tail-recursion&quot; and I'm not familiar with this 'Scheme' syntax, as I get what recursion is doing in it &quot;drilling down&quot; to the base case and then it has to &quot;drill back up&quot; to finish off each stack-layer of the called functions, but my brain just still has trouble with actually doing~using~applying~implementing it successfully, sighs)<br/><br/>I failed to solve how to do this on my Java final (had to use recursion to solve it):<br/><br/><pre><code>    * <br/>   * * <br/>  * * * <br/> * * * * <br/>  * * * <br/>   * * <br/>    * </code></pre><br/><br/>we had code to study for this:<br/><br/><pre><code> * * * * <br/>  * * * <br/>   * * <br/>    * <br/>   * * <br/>  * * * <br/> * * * * </code></pre><br/><br/>but, that didn't help me at all, in solving the other pattern, sighs. My brain just isn't trained in recursion's &quot;drilling down to base case and then drilling back up to each function call layer to finish each of them off&quot;.<br/><br/>-------------------------------------------------------------------------<br/><br/>@ Pixie:<br/><br/>--<br/><br/>Oh, this isn't about any specific issues in terms of memory or performance that have been issues with a game (I've not made any significant progress on a game of my own, lol), just asking about this stuff for in-general better code design, since now I'm at least aware of all of this stuff of programming, lol.<br/><br/>----<br/><br/>yes, I've been reading every post of~between neonayon and you, hehe. As she's making a RPG, as I'm interested in doing too, so her questions, are my questions, and your answers help me, as they do her. I've just not had the time to post due to school, but I've been lurking~reading both of your posts.<br/><br/>----<br/><br/>I actually was trying~testing to see if 'on ready' would work... I found out that you don't want to do:<br/><br/>while -&gt; on ready -&gt; get input<br/><br/>I haven't tried doing though:<br/><br/>while -&gt; if ~ firsttime -&gt; get input<br/>while -&gt; else ~ otherwise -&gt; on ready -&gt; get input<br/><br/>also, found out with the 'while', that it ends (totally nullifies the looping of) the while loop (as the while loop indeed doesn't wait for other actions at all ~ which makes it very hard to work with), via trying this:<br/><br/>flag = true -&gt; while (flag) -&gt; flag = false -&gt; get input -&gt; else (flag = true)<br/><br/>---<br/><br/>ah, so data gets piled up in the stack regardless of iteration~looping (do, do-while, for, foreach, etc) vs recursion, but since recursion (unless able to use 'tail-end' recursion) multiplies these layers of data due to having to &quot;drill back up&quot; (finishing off all of the layers of function calls), whereas iteration doesn't do this as its always only &quot;one off&quot; as you used.<br/><br/>---<br/><br/>hmm, how about in general with the programming languages, how do Method calls (Object.Method) work? do they use iteration or recursion?<br/><br/>further (fake and uber poor) psuedocode example:<br/><br/>(wow, I've already forgotten everything I know in C++, Java, and Python, laughs. I've only been done with finals for 3-4 days now!)<br/><br/><pre><code>class Math {<br/>  addition (a, b) {<br/>    sum = a + b<br/>    math&#46;addition ( (sum + a), (sum+b) )<br/>    // ignore its infinite looping issue<br/>    msg (sum)<br/>  }<br/>}</code></pre>",
      "PostDate": "2015-12-20T12:28:50+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40008",
      "UserId": 0,
      "Username": "jaynabonne",
      "UserAvatar": "6579_1344778256.jpg",
      "UserGravatar": "379859a7f1952a65399fc63997e68f0b",
      "EditableText": "There shouldn't be much difference between &quot;do&quot; and &quot;invoke&quot; in Quest, resources-wise. There is just the injection of the one extra &quot;this&quot; variable into a &quot;do&quot;, which shouldn't take much. You can actually simulate a &quot;do&quot; with an &quot;invoke&quot; by passing a parameter dictionary and adding a &quot;this&quot; entry pointing to the desired object. \n\nAs far as Object.Method calls, they use neither iteration nor recursion. A single method call is neither. You get recursion if the function you call ends up calling back into itself (or somewhere in the chain) either directly or indirectly. And iteration and function/method calls are different things entirely. Iteration is a way to &quot;loop back&quot; within the same function. A method call invokes a completely separate bit of code, in a new, nested context. In your example, the first method call (to enter &quot;addition&quot;) is neither recursion nor iteration. The call to &quot;addition&quot; within &quot;addition&quot; is a recursive call. Recursion is a higher-level concept based on *how* you make your function calls.\n\nRegarding how much memory is taken for recursion, it all depends. In normal machine code, a subroutine call only pushes the return address, which will be something like 32- or 64 bits, depending on your machine architecture. Higher-level languages typically need more stack space per call, as certain registers typically need to be preserved. Also, each function call pushes whatever parameters you're passing and establishes a new call frame (a chunk of memory on the stack) to hold local variables. That's how each function call gets its own values for parameters and local variables. So if you had a C function with an automatic local 4K byte array, if you invoked it recursively, you'd eat at least 4K of stack space per call. Not good. Of course, that's not typical, and I don't how &quot;managed&quot; languages like Java handle stack. There must be some sort of storage from which to allocate local variables (a virtual stack?), so the concept would be similar in terms of memory usage and growth even if the actual processor stack isn't used.\n\nModern machines will typically grow the stack as needed. They all have hard limits though, either programmatically set or defined by the amount of available memory. You really don't want to push your memory usage into a paging situation, though, as the system will slow to a crawl, which will make your users very unhappy!\n\nKeep in mind that a &quot;get input&quot;-calling-function situation (even calling itself) is not recursive, as the &quot;get input&quot; does not nest - it merely sets up the script as a completion callback when the input is done. It might look recursive, but it's not. Quest will invoke the script at a later time, but there is never more than one instance of the script running at a given time.\n\nAnd it makes no sense to put &quot;get input&quot; inside a direct loop, as &quot;get input&quot; doesn't block. It just sets up the input &quot;state&quot;, which it doesn't make sense to do repeatedly. As I'm sure you've discovered... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "EditableFormat": "bbcode",
      "HTML": "There shouldn't be much difference between &quot;do&quot; and &quot;invoke&quot; in Quest, resources-wise. There is just the injection of the one extra &quot;this&quot; variable into a &quot;do&quot;, which shouldn't take much. You can actually simulate a &quot;do&quot; with an &quot;invoke&quot; by passing a parameter dictionary and adding a &quot;this&quot; entry pointing to the desired object. <br/><br/>As far as Object.Method calls, they use neither iteration nor recursion. A single method call is neither. You get recursion if the function you call ends up calling back into itself (or somewhere in the chain) either directly or indirectly. And iteration and function/method calls are different things entirely. Iteration is a way to &quot;loop back&quot; within the same function. A method call invokes a completely separate bit of code, in a new, nested context. In your example, the first method call (to enter &quot;addition&quot;) is neither recursion nor iteration. The call to &quot;addition&quot; within &quot;addition&quot; is a recursive call. Recursion is a higher-level concept based on *how* you make your function calls.<br/><br/>Regarding how much memory is taken for recursion, it all depends. In normal machine code, a subroutine call only pushes the return address, which will be something like 32- or 64 bits, depending on your machine architecture. Higher-level languages typically need more stack space per call, as certain registers typically need to be preserved. Also, each function call pushes whatever parameters you're passing and establishes a new call frame (a chunk of memory on the stack) to hold local variables. That's how each function call gets its own values for parameters and local variables. So if you had a C function with an automatic local 4K byte array, if you invoked it recursively, you'd eat at least 4K of stack space per call. Not good. Of course, that's not typical, and I don't how &quot;managed&quot; languages like Java handle stack. There must be some sort of storage from which to allocate local variables (a virtual stack?), so the concept would be similar in terms of memory usage and growth even if the actual processor stack isn't used.<br/><br/>Modern machines will typically grow the stack as needed. They all have hard limits though, either programmatically set or defined by the amount of available memory. You really don't want to push your memory usage into a paging situation, though, as the system will slow to a crawl, which will make your users very unhappy!<br/><br/>Keep in mind that a &quot;get input&quot;-calling-function situation (even calling itself) is not recursive, as the &quot;get input&quot; does not nest - it merely sets up the script as a completion callback when the input is done. It might look recursive, but it's not. Quest will invoke the script at a later time, but there is never more than one instance of the script running at a given time.<br/><br/>And it makes no sense to put &quot;get input&quot; inside a direct loop, as &quot;get input&quot; doesn't block. It just sets up the input &quot;state&quot;, which it doesn't make sense to do repeatedly. As I'm sure you've discovered... <!-- s:) --><img src=\"{SMILIES_PATH}/icon_smile.gif\" alt=\":)\" title=\"Smile\" /><!-- s:) -->",
      "PostDate": "2015-12-24T23:26:20+00:00",
      "LastEditDate": null
    },
    {
      "PostId": "40028",
      "UserId": 0,
      "Username": "HegemonKhan",
      "UserAvatar": null,
      "UserGravatar": "a96cf34d8d97c57de38f54ee22b1759b",
      "EditableText": "Thank you, Jay!, I'll be reading and trying to digest all of this (a bit beyond my learning as I've not done-learned any of the low level stuff yet), laughs! Any information on trying to understand programming better, I'm so very greatly appreciative of to all!\n\n----\n\n[quote=&quot;jay&quot;:2apiohxg]You really don't want to push your memory usage into a paging situation, though, as the system will slow to a crawl, which will make your users very unhappy![/quote:2apiohxg]\n\nYa, I think in general, if I remember reading it right (when I was learning software, hardware, and networking about 2-3 years ago), you always want to leave at least a minimum of 15% of free-unused memory on your computer (out of your total memory).",
      "EditableFormat": "bbcode",
      "HTML": "Thank you, Jay!, I'll be reading and trying to digest all of this (a bit beyond my learning as I've not done-learned any of the low level stuff yet), laughs! Any information on trying to understand programming better, I'm so very greatly appreciative of to all!<br/><br/>----<br/><br/><blockquote><cite>jay wrote:</cite>You really don't want to push your memory usage into a paging situation, though, as the system will slow to a crawl, which will make your users very unhappy!</blockquote><br/><br/>Ya, I think in general, if I remember reading it right (when I was learning software, hardware, and networking about 2-3 years ago), you always want to leave at least a minimum of 15% of free-unused memory on your computer (out of your total memory).",
      "PostDate": "2015-12-25T07:11:30+00:00",
      "LastEditDate": null
    }
  ]
}
